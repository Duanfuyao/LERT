[{"func": "static void c_can_do_tx ( struct net_device * dev ) { struct c_can_priv * priv = netdev_priv ( dev ) ; struct c_can_tx_ring * tx_ring = & priv -> tx ; struct net_device_stats * stats = & dev -> stats ; u32 idx , obj , pkts = 0 , bytes = 0 , pend ; u8 tail ; if ( priv -> msg_obj_tx_last > 32 ) { pend = priv -> read_reg32 ( priv , C_CAN_INTPND3_REG ) ; } else { pend = priv -> read_reg ( priv , C_CAN_INTPND2_REG ) ; } while ( ( idx = ffs ( pend ) ) ) { idx -- ; pend &= ~ BIT ( idx ) ; obj = idx + priv -> msg_obj_tx_first ; c_can_inval_tx_object ( dev , IF_NAPI , obj ) ; bytes += can_get_echo_skb ( dev , idx , NULL ) ; pkts ++ ; } if ( ! pkts ) { return ; } tx_ring -> tail += pkts ; if ( c_can_get_tx_free ( priv , tx_ring ) ) { smp_mb ( ) ; netif_wake_queue ( priv -> dev , NULL ) ; } stats -> tx_bytes += bytes ; stats -> tx_packets += pkts ; tail = c_can_get_tx_tail ( tx_ring ) ; if ( priv -> type == BOSCH_D_CAN && tail == 0 ) { u8 head = c_can_get_tx_head ( tx_ring ) ; for ( idx = tail ; idx < head ; idx ++ ) { obj = idx + priv -> msg_obj_tx_first ; c_can_object_put ( dev , IF_NAPI , obj , IF_COMM_TXRQST ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void pvr2_dvb_destroy ( struct pvr2_dvb_adapter * adap ) { pvr2_dvb_stream_end ( adap ) ; pvr2_dvb_frontend_exit ( adap ) ; pvr2_dvb_adapter_exit ( adap ) ; pvr2_channel_done ( & adap -> channel ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static u8 ali_udma_filter ( ide_drive_t * drive ) { if ( m5229_revision > 0x20 && m5229_revision < 0xC2 ) { if ( chip_is_1543c_e && strstr ( ( char * ) & drive -> id [ ATA_ID_PROD ] , \"WDC \" ) ) { return 0 ; } } return drive -> hwif -> ultra_mask ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ul_register_watch_db ( int id ) { ul_db_watch_list_t * new_id = NULL , * tmp ; if ( ! list_lock ) { if ( init_watch_db_list ( ) < 0 ) { return - 1 ; } } lock_get ( list_lock ) ; tmp = * list ; while ( tmp ) { if ( tmp -> id == id ) { tmp -> active = 1 ; return 0 ; } tmp = tmp -> next ; } if ( ( new_id = shm_malloc ( sizeof ( ul_db_watch_list_t ) ) ) == NULL ) { LM_ERR ( \"couldn't allocate shared memory\\n\" ) ; lock_release ( list_lock ) ; return - 1 ; } memset ( new_id , 0 , sizeof ( ul_db_watch_list_t ) ) ; new_id -> active = 1 ; new_id -> next = * list ; new_id -> id = id ; * list = new_id ; lock_release ( list_lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void empty_recycle_bin ( void ) { struct erl_rpc_garbage * p ; while ( recycle_bin ) { p = recycle_bin ; recycle_bin = recycle_bin -> next ; switch ( p -> type ) { case JUNK_EI_X_BUFF : if ( p -> ptr ) { ei_x_free ( ( ei_x_buff * ) p -> ptr ) ; } break ; case JUNK_PKGCHAR : if ( p -> ptr ) { pkg_free ( p -> ptr ) ; } break ; default : ERR ( \"BUG: Unsupported junk type\\n\" ) ; } pkg_free ( p ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static TEE_Result mbed_hash_init ( struct crypto_hash_ctx * ctx ) { return TEE_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void i82443bxgx_edacmc_remove_one ( struct pci_dev * pdev ) { struct mem_ctl_info * mci ; edac_dbg ( 0 , \"\\n\" ) ; if ( i82443bxgx_pci ) { edac_pci_release_generic_ctl ( i82443bxgx_pci ) ; } edac_mc_free ( mci ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "uint16_t stoeplitz_hash_ip6 ( const struct stoeplitz_cache * scache , const struct in6_addr * faddr6 , const struct in6_addr * laddr6 ) { uint32_t n32 = 0 ; int i ; for ( i = 0 ; i < nitems ( faddr6 -> s6_addr32 ) ; i ++ ) { n32 ^= faddr6 -> s6_addr32 [ i ] ^ laddr6 -> s6_addr32 [ i ] ; } return ( stoeplitz_hash_n32 ( scache , n32 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "uc_graphemeclusterbreak_property ( ) { int index1 = uc >> gbrkprop_header_0 ; if ( index1 < gbrkprop_header_1 ) { int lookup1 = unigbrkprop . level1 [ index1 ] ; if ( lookup1 >= 0 ) { unsigned int index2 = ( uc >> gbrkprop_header_2 ) & gbrkprop_header_3 ; int lookup2 = unigbrkprop . level2 [ lookup1 + index2 ] ; if ( lookup2 >= 0 ) { unsigned int index3 = uc & gbrkprop_header_4 ; return unigbrkprop . level3 [ lookup2 + index3 ] ; } } } return GBP_OTHER ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "size_t HIST_countFast_wksp ( unsigned * count , unsigned * maxSymbolValuePtr , const void * source , size_t sourceSize , void * workSpace , size_t workSpaceSize ) { if ( ( size_t ) workSpace & 3 ) { return ERROR ( GENERIC ) ; } if ( workSpaceSize < HIST_WKSP_SIZE ) { return ERROR ( workSpace_tooSmall ) ; } return HIST_count_parallel_wksp ( count , maxSymbolValuePtr , source , sourceSize , trustInput , ( U32 * ) workSpace ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void do_announce ( CTL_MSG * mp , CTL_RESPONSE * rp ) { struct hostent * hp ; CTL_MSG * ptr ; int result ; result = find_user ( mp -> r_name , mp -> r_tty , sizeof ( mp -> r_tty ) ) ; if ( result != SUCCESS ) { rp -> answer = result ; return ; } hp = gethostbyaddr ( ( char * ) & satosin ( & mp -> ctl_addr ) -> sin_addr , sizeof ( in_addr ) , AF_INET ) ; if ( hp == NULL ) { rp -> answer = MACHINE_UNKNOWN ; return ; } ptr = find_request ( mp ) ; if ( ptr == ( CTL_MSG * ) 0 ) { insert_table ( mp , rp ) ; rp -> answer = announce ( mp , hp -> h_name ) ; return ; } if ( mp -> id_num > ptr -> id_num ) { ptr -> id_num = new_id ( ) ; rp -> id_num = htonl ( ptr -> id_num , NULL ) ; rp -> answer = announce ( mp , hp -> h_name ) ; } else { rp -> id_num = htonl ( ptr -> id_num ) ; rp -> answer = SUCCESS ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static u32 read_div ( struct gk104_clk * , int , u32 , u32 ) static u32 read_pll ( struct gk104_clk * , u32 ) static u32 read_vco ( struct gk104_clk * clk , u32 dsrc ) { struct nvkm_device * device = clk -> base . subdev . device ; u32 ssrc = nvkm_rd32 ( device , dsrc ) ; return read_pll ( clk , 0x00e820 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static acpi_status acpi_ns_repair_PSS ( struct acpi_evaluate_info * info , union acpi_operand_object * * return_object_ptr ) { union acpi_operand_object * return_object = * return_object_ptr ; union acpi_operand_object * * outer_elements ; u32 outer_element_count ; union acpi_operand_object * * elements ; union acpi_operand_object * obj_desc ; u32 previous_value ; acpi_status status ; u32 i ; status = acpi_ns_check_sorted_list ( info , return_object , 0 , 6 , 0 , ACPI_SORT_DESCENDING , \"CpuFrequency\" ) ; previous_value = ACPI_UINT32_MAX ; outer_elements = return_object -> package . elements ; outer_element_count = return_object -> package . count ; for ( i = 0 ; i < outer_element_count ; i ++ ) { elements = ( * outer_elements ) -> package . elements ; obj_desc = elements [ 1 ] ; if ( ( u32 ) obj_desc -> integer . value > previous_value ) { ACPI_WARN_PREDEFINED ( ( AE_INFO , info -> full_pathname , info -> node_flags , \"SubPackage[%u,%u] - suspicious power dissipation values\" , i - 1 , i ) ) ; } previous_value = ( u32 ) obj_desc -> integer . value ; outer_elements ++ ; } return ( AE_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void check_basics ( const char * filename ) { cups_file_t * fp ; int ch ; int col , whitespace ; int eol ; int linenum ; int mixed ; if ( ( fp = cupsFileOpen ( filename , \"r\" ) ) == NULL ) { return ; } linenum = 1 ; col = 0 ; eol = EOL_NONE ; whitespace = 1 ; while ( ( ch = cupsFileGetChar ( fp ) ) != EOF ) { if ( ch == '\\r' || ch == '\\n' ) { if ( ch == '\\n' ) { if ( eol == EOL_NONE ) { eol = EOL_LF ; } if ( eol != EOL_LF ) { mixed = 1 ; } } if ( ch == '\\r' ) { if ( cupsFilePeekChar ( fp ) == '\\n' ) { cupsFileGetChar ( fp ) ; if ( eol == EOL_NONE ) { eol = EOL_CRLF ; } if ( eol != EOL_CRLF ) { mixed = 1 ; } } if ( eol == EOL_NONE ) { eol = EOL_CR ; } if ( eol != EOL_CR ) { mixed = 1 ; } } if ( col > 0 && whitespace ) { _cupsLangPrintf ( stdout , _ ( \"        WARN    Line %d only contains whitespace.\" ) , linenum ) ; } linenum ++ ; col = 0 ; whitespace = 1 ; } else { if ( ch != ' ' && ch != '\\t' ) { whitespace = 0 ; } col ++ ; } } if ( mixed ) { _cupsLangPuts ( stdout , _ ( \"        WARN    File contains a mix of CR, LF, and \" \"CR LF line endings.\" ) ) ; } if ( eol == EOL_CRLF ) { _cupsLangPuts ( stdout , _ ( \"        WARN    Non-Windows PPD files should use lines \" \"ending with only LF, not CR LF.\" ) ) ; } cupsFileClose ( fp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "START_TEST ( ) { pr_jot_ctx_t * ctx ; pr_json_object_t * json ; double num ; int res , truth ; const char * text ; mark_point ( ) ; res = pr_jot_on_json ( NULL , NULL , 0 , NULL , NULL ) ; ck_assert_msg ( res < 0 , \"Failed to handle null pool\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; mark_point ( ) ; res = pr_jot_on_json ( p , NULL , 0 , NULL , NULL ) ; ck_assert_msg ( res < 0 , \"Failed to handle null ctx\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; ctx = pcalloc ( p , sizeof ( pr_jot_ctx_t ) ) ; mark_point ( ) ; res = pr_jot_on_json ( p , ctx , 0 , NULL , NULL ) ; ck_assert_msg ( res < 0 , \"Failed to handle null val\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; mark_point ( ) ; res = pr_jot_on_json ( p , ctx , 0 , NULL , & num ) ; ck_assert_msg ( res < 0 , \"Failed to handle null ctx->log\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; json = pr_json_object_alloc ( p ) ; ctx -> log = json ; mark_point ( ) ; res = pr_jot_on_json ( p , ctx , 0 , NULL , & num ) ; ck_assert_msg ( res < 0 , \"Failed to handle null ctx->user_data\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; ctx -> user_data = pr_table_alloc ( p , 0 ) ; mark_point ( ) ; res = pr_jot_on_json ( p , ctx , 0 , NULL , & num ) ; ck_assert_msg ( res < 0 , \"Failed to handle null JSON info\" ) ; ck_assert_msg ( errno == EINVAL , \"Expected EINVAL (%d), got %s (%d)\" , EINVAL , strerror ( errno ) , errno ) ; ctx -> user_data = pr_jot_get_logfmt2json ( p , NULL ) ; mark_point ( ) ; truth = FALSE ; res = pr_jot_on_json ( p , ctx , LOGFMT_META_CONNECT , NULL , & truth ) ; ck_assert_msg ( res == 0 , \"Failed to handle LOGFMT_META_CONNECT: %s\" , strerror ( errno ) ) ; mark_point ( ) ; num = 2476 ; res = pr_jot_on_json ( p , ctx , LOGFMT_META_PID , NULL , & num ) ; ck_assert_msg ( res == 0 , \"Failed to handle LOGFMT_META_PID: %s\" , strerror ( errno ) ) ; mark_point ( ) ; text = \"lorem ipsum\" ; res = pr_jot_on_json ( p , ctx , LOGFMT_META_IDENT_USER , NULL , text ) ; ck_assert_msg ( res == 0 , \"Failed to handle LOGFMT_META_IDENT_USER: %s\" , strerror ( errno ) ) ; mark_point ( ) ; text = \"alef bet vet\" ; res = pr_jot_on_json ( p , ctx , LOGFMT_META_USER , \"USER_KEY\" , text ) ; ck_assert_msg ( res == 0 , \"Failed to handle LOGFMT_META_USER: %s\" , strerror ( errno ) ) ; ( void ) pr_json_object_free ( json ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct wusb_dev * wusbhc_cack_add ( struct wusbhc * wusbhc , struct wusb_dn_connect * dnc , const char * pr_cdid , u8 port_idx ) { struct device * dev = wusbhc -> dev ; struct wusb_dev * wusb_dev ; int new_connection = wusb_dn_connect_new_connection ( dnc ) ; u8 dev_addr ; int result ; list_for_each_entry ( , , ) if ( ! memcmp ( & wusb_dev -> cdid , & dnc -> CDID , sizeof ( wusb_dev -> cdid ) ) ) { return wusb_dev ; } wusb_dev = wusb_dev_alloc ( wusbhc ) ; wusb_dev_init ( wusb_dev ) ; wusb_dev -> cdid = dnc -> CDID ; wusb_dev -> port_idx = port_idx ; bitmap_fill ( wusb_dev -> availability . bm , UWB_NUM_MAS ) ; if ( 1 && new_connection == 0 ) { new_connection = 1 ; } if ( new_connection ) { dev_addr = ( port_idx + 2 ) | WUSB_DEV_ADDR_UNAUTH ; dev_info ( dev , \"Connecting new WUSB device to address %u, \" \"port %u\\n\" , dev_addr , port_idx ) ; result = wusb_set_dev_addr ( wusbhc , wusb_dev , dev_addr ) ; if ( result < 0 ) { return NULL ; } } wusb_dev -> entry_ts = jiffies ; list_add_tail ( & wusb_dev -> cack_node , & wusbhc -> cack_list ) ; wusbhc -> cack_count ++ ; wusbhc_fill_cack_ie ( wusbhc ) ; return wusb_dev ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static M_uint64 read_hid_field_le ( const M_uint8 * data , size_t data_len ) { M_uint64 ret ; size_t i ; if ( data_len == 1 ) { return * data ; } ret = 0 ; for ( i = 0 ; i < data_len ; i ++ ) { size_t val = data [ i ] ; val <<= ( 8 * i ) ; ret |= val ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static acpi_status intel_pmic_power_handler ( u32 function , acpi_physical_address address , u32 bits , u64 * value64 , void * handler_context , void * region_context ) { struct intel_pmic_opregion * opregion = region_context ; struct regmap * regmap = opregion -> regmap ; const struct intel_pmic_opregion_data * d = opregion -> data ; int reg , bit , result ; if ( bits != 32 || ! value64 ) { return AE_BAD_PARAMETER ; } result = pmic_get_reg_bit ( address , d -> power_table , d -> power_table_count , & reg , & bit ) ; if ( result == - ENOENT ) { return AE_BAD_PARAMETER ; } mutex_lock ( & opregion -> lock ) ; result = function == ACPI_READ ?d -> get_power ( regmap , reg , bit , value64 ) : d -> update_power ( regmap , reg , bit , * value64 == 1 ) ; mutex_unlock ( & opregion -> lock ) ; return result ?AE_ERROR : AE_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s6d16d0_unprepare ( struct drm_panel * panel ) { struct s6d16d0 * s6 = panel_to_s6d16d0 ( panel ) ; struct mipi_dsi_device * dsi = to_mipi_dsi_device ( s6 -> dev ) ; int ret ; ret = mipi_dsi_dcs_enter_sleep_mode ( dsi ) ; if ( ret ) { dev_err ( s6 -> dev , \"failed to enter sleep mode (%d)\\n\" , ret ) ; return ret ; } gpiod_set_value_cansleep ( s6 -> reset_gpio , 1 ) ; regulator_disable ( s6 -> supply , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void fsg_common_remove_lun ( struct fsg_lun * lun ) { if ( device_is_registered ( & lun -> dev ) ) { device_unregister ( & lun -> dev ) ; } fsg_lun_close ( lun ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pnv_tce_build ( struct iommu_table * tbl , long index , long npages , unsigned long uaddr , enum dma_data_direction direction , unsigned long attrs ) { u64 proto_tce = iommu_direction_to_tce_perm ( direction ) ; u64 rpn = __pa ( uaddr ) >> tbl -> it_page_shift ; long i ; if ( proto_tce & TCE_PCI_WRITE ) { proto_tce |= TCE_PCI_READ ; } for ( i = 0 ; i < npages ; i ++ ) { cfs_time_t newtce = proto_tce | ( ( rpn + i ) << tbl -> it_page_shift ) ; unsigned long idx = index - tbl -> it_offset + i ; * ( pnv_tce ( tbl , idx ) ) = cpu_to_be64 ( newtce ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int handle__auth ( struct mosquitto * mosq ) { int rc = 0 ; uint8_t reason_code ; mosquitto_property * properties = NULL ; log__printf ( mosq , MOSQ_LOG_DEBUG , \"Client %s received AUTH\" , SAFE_PRINT ( mosq -> id ) ) ; if ( mosq -> protocol != mosq_p_mqtt5 ) { return MOSQ_ERR_PROTOCOL ; } if ( mosq -> in_packet . command != CMD_AUTH ) { return MOSQ_ERR_MALFORMED_PACKET ; } if ( packet__read_byte ( & mosq -> in_packet , & reason_code ) ) { return 1 ; } rc = property__read_all ( CMD_AUTH , & mosq -> in_packet , & properties ) ; if ( rc ) { return rc ; } mosquitto_property_free_all ( & properties ) ; return MOSQ_ERR_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mlx5_fc_pool_free_bulk ( struct mlx5_fc_pool * fc_pool , struct mlx5_fc_bulk * bulk ) { struct mlx5_core_dev * dev = fc_pool -> dev ; fc_pool -> available_fcs -= bulk -> bulk_len ; mlx5_fc_bulk_destroy ( dev , bulk ) ; mlx5_fc_pool_update_threshold ( fc_pool , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ld9040_remove ( struct spi_device * spi ) { struct ld9040 * ctx = spi_get_drvdata ( spi ) ; ld9040_power_off ( ctx , NULL ) ; drm_panel_remove ( & ctx -> panel ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct usb_rx * alloc_rx_struct ( void ) { struct usb_rx * r = NULL ; int ret ; r = kmalloc ( sizeof ( * r ) , GFP_KERNEL ) ; if ( ! r ) { ret = - ENOMEM ; out } r -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; r -> buf = kmalloc ( RX_BUF_SIZE , GFP_KERNEL ) ; if ( ! r -> urb || ! r -> buf ) { ret = - ENOMEM ; out } out if ( ret < 0 ) { if ( r ) { usb_free_urb ( r -> urb ) ; kfree ( r -> buf ) ; kfree ( r ) ; } return NULL ; } return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sort_pacl ( struct posix_acl * pacl ) { int i , j ; i = 1 ; while ( pacl -> a_entries [ i ] . e_tag == ACL_USER ) { i ++ ; } sort_pacl_range ( pacl , 1 , i - 1 ) ; BUG_ON ( pacl -> a_entries [ i ] . e_tag != ACL_GROUP_OBJ ) ; j = ++ i ; while ( pacl -> a_entries [ j ] . e_tag == ACL_GROUP ) { j ++ ; } sort_pacl_range ( pacl , i , j - 1 ) ; return ; } posix_ace_state { u32 allow ; u32 deny ; } posix_user_ace_state { { kuid_t uid ; kgid_t gid ; } struct posix_ace_state perms ; } posix_ace_state_array { int n ; struct posix_user_ace_state aces [ ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ufs_qcom_device_reset_ctrl ( struct ufs_hba * hba , bool asserted ) { struct ufs_qcom_host * host = ufshcd_get_variant ( hba ) ; gpiod_set_value_cansleep ( host -> device_reset , asserted ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mc417_register_read ( struct cx231xx * dev , u16 address , u32 * value ) { u32 temp ; u32 return_value = 0 ; int ret ; temp = 0x82 | MCI_REGISTER_ADDRESS_BYTE0 | ( ( address & 0x00FF ) << 8 ) ; temp = temp << 10 ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; temp = temp | ( ( 0x05 ) << 10 ) ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; temp = 0x82 | MCI_REGISTER_ADDRESS_BYTE1 | ( address & 0xFF00 ) ; temp = temp << 10 ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; temp = temp | ( ( 0x05 ) << 10 ) ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; temp = 0x82 | MCI_REGISTER_MODE | MCI_MODE_REGISTER_READ ; temp = temp << 10 ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; temp = temp | ( ( 0x05 ) << 10 ) ; set_itvc_reg ( dev , ITVC_WRITE_DIR , temp ) ; ret = wait_for_mci_complete ( dev ) ; temp = ( 0x82 | MCI_REGISTER_DATA_BYTE0 ) << 10 ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; temp = ( ( 0x81 | MCI_REGISTER_DATA_BYTE0 ) << 10 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; get_itvc_reg ( dev , ITVC_READ_DIR , & temp ) ; return_value |= ( ( temp & 0x03FC0000 ) >> 18 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , ( 0x87 << 10 ) ) ; temp = ( 0x82 | MCI_REGISTER_DATA_BYTE1 ) << 10 ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; temp = ( ( 0x81 | MCI_REGISTER_DATA_BYTE1 ) << 10 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; get_itvc_reg ( dev , ITVC_READ_DIR , & temp ) ; return_value |= ( ( temp & 0x03FC0000 ) >> 10 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , ( 0x87 << 10 ) ) ; temp = ( 0x82 | MCI_REGISTER_DATA_BYTE2 ) << 10 ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; temp = ( ( 0x81 | MCI_REGISTER_DATA_BYTE2 ) << 10 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; get_itvc_reg ( dev , ITVC_READ_DIR , & temp ) ; return_value |= ( ( temp & 0x03FC0000 ) >> 2 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , ( 0x87 << 10 ) ) ; temp = ( 0x82 | MCI_REGISTER_DATA_BYTE3 ) << 10 ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; temp = ( ( 0x81 | MCI_REGISTER_DATA_BYTE3 ) << 10 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , temp ) ; get_itvc_reg ( dev , ITVC_READ_DIR , & temp ) ; return_value |= ( ( temp & 0x03FC0000 ) << 6 ) ; set_itvc_reg ( dev , ITVC_READ_DIR , ( 0x87 << 10 ) ) ; * value = return_value ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void set_rx_mode ( void ) { unsigned char mc_filter [ 8 ] ; int i ; outl ( 0x0C , rxcon ) ; for ( i = 0 ; i < 4 ; i ++ ) { outw ( ( ( unsigned short * ) mc_filter ) [ i ] , mc0 + i * 4 ) ; } return ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int spectre_v2_test ( void ) { enum spectre_v2_state state ; struct event events [ 4 ] ; s64 miss_percent ; bool is_p9 ; SKIP_IF ( ! have_hwcap2 ( PPC_FEATURE2_ARCH_2_07 ) ) ; state = get_sysfs_state ( ) ; if ( state == UNKNOWN ) { printf ( \"Error: couldn't determine spectre_v2 mitigation state?\\n\" ) ; return - 1 ; } setup_event ( & events [ 0 ] , PM_BR_PRED_CCACHE , \"PM_BR_PRED_CCACHE\" ) ; setup_event ( & events [ 1 ] , PM_BR_MPRED_CCACHE , \"PM_BR_MPRED_CCACHE\" ) ; FAIL_IF ( event_open ( & events [ 0 ] ) ) ; FAIL_IF ( event_open_with_group ( & events [ 1 ] , events [ 0 ] . fd ) == - 1 ) ; is_p9 = ( ( mfspr ( SPRN_PVR ) >> 16 ) & 0xFFFF ) == 0x4e ; if ( is_p9 ) { setup_event ( & events [ 2 ] , PM_BR_PRED_PCACHE , \"PM_BR_PRED_PCACHE\" ) ; setup_event ( & events [ 3 ] , PM_BR_MPRED_PCACHE , \"PM_BR_MPRED_PCACHE\" ) ; FAIL_IF ( event_open_with_group ( & events [ 2 ] , events [ 0 ] . fd ) == - 1 ) ; FAIL_IF ( event_open_with_group ( & events [ 3 ] , events [ 0 ] . fd ) == - 1 ) ; } FAIL_IF ( do_count_loop ( events , is_p9 , & miss_percent ) ) ; event_report_justified ( & events [ 0 ] , 18 , 10 ) ; event_report_justified ( & events [ 1 ] , 18 , 10 ) ; event_close ( & events [ 0 ] ) ; event_close ( & events [ 1 ] ) ; if ( is_p9 ) { event_report_justified ( & events [ 2 ] , 18 , 10 ) ; event_report_justified ( & events [ 3 ] , 18 , 10 ) ; event_close ( & events [ 2 ] ) ; event_close ( & events [ 3 ] ) ; } printf ( \"Miss percent %lld %%\\n\" , miss_percent ) ; switch ( state ) { case VULNERABLE : case NOT_AFFECTED : case COUNT_CACHE_FLUSH_SW : case COUNT_CACHE_FLUSH_HW : if ( miss_percent > 15 ) { if ( miss_percent > 95 ) { printf ( \"Branch misses>95%% unexpected in this configuration.\\n\" ) ; printf ( \"Count cache likely disabled without Linux knowing.\\n\" ) ; if ( state == COUNT_CACHE_FLUSH_SW ) { printf ( \"WARNING: Kernel performing unnecessary flushes.\\n\" ) ; } return 4 ; } printf ( \"Branch misses>15%% unexpected in this configuration!\\n\" ) ; printf ( \"Possible mismatch between reported&actual mitigation\\n\" ) ; return 1 ; } break ; case BRANCH_SERIALISATION : if ( miss_percent > 25 ) { printf ( \"Branch misses>25%% unexpected in this configuration!\\n\" ) ; printf ( \"Possible mismatch between reported&actual mitigation\\n\" ) ; return 1 ; } break ; case COUNT_CACHE_DISABLED : if ( miss_percent < 95 ) { printf ( \"Branch misses<95%% unexpected in this configuration!\\n\" ) ; printf ( \"Possible mismatch between reported&actual mitigation\\n\" ) ; return 1 ; } break ; case UNKNOWN : case BTB_FLUSH : printf ( \"Not sure!\\n\" ) ; return 1 ; } printf ( \"OK - Measured branch prediction rates match reported spectre v2 mitigation.\\n\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( iwl_write_direct64 ) ; int iwl_poll_direct_bit ( struct iwl_trans * trans , u32 addr , u32 mask , int timeout ) { int t = 0 ; { udelay ( IWL_POLL_INTERVAL ) ; t += IWL_POLL_INTERVAL ; } t < timeout ; return - ETIMEDOUT ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void node_remove ( struct fw_unit * unit ) { struct firedtv * fdtv = dev_get_drvdata ( & unit -> device ) ; fdtv_dvb_unregister ( fdtv ) ; spin_lock_irq ( & node_list_lock ) ; list_del ( & fdtv -> list ) ; spin_unlock_irq ( & node_list_lock ) ; fdtv_unregister_rc ( fdtv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void musb_host_finish_resume ( struct work_struct * work ) { struct musb * musb ; unsigned long flags ; u8 power ; musb = container_of ( work , musb , finish_resume_work . work ) ; spin_lock_irqsave ( & musb -> lock , flags ) ; power = musb_readb ( musb -> mregs , MUSB_POWER ) ; power &= ~ MUSB_POWER_RESUME ; musb_dbg ( musb , \"root port resume stopped, power %02x\" , power ) ; musb_writeb ( musb -> mregs , MUSB_POWER , power ) ; musb -> is_active = 1 ; musb -> port1_status &= ~ ( USB_PORT_STAT_SUSPEND | MUSB_PORT_STAT_RESUME ) ; musb -> port1_status |= USB_PORT_STAT_C_SUSPEND << 16 ; usb_hcd_poll_rh_status ( musb -> hcd , NULL ) ; musb_set_state ( musb , OTG_STATE_A_HOST ) ; spin_unlock_irqrestore ( & musb -> lock , flags ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void memb_merge_detect_transmit ( struct totemsrp_instance * instance ) { struct memb_merge_detect memb_merge_detect ; memb_merge_detect . header . magic = TOTEM_MH_MAGIC ; memb_merge_detect . header . version = TOTEM_MH_VERSION ; memb_merge_detect . header . type = MESSAGE_TYPE_MEMB_MERGE_DETECT ; memb_merge_detect . header . encapsulated = 0 ; memb_merge_detect . header . nodeid = instance -> my_id . nodeid ; memb_merge_detect . system_from = instance -> my_id ; memcpy ( & memb_merge_detect . ring_id , & instance -> my_ring_id , sizeof ( memb_ring_id ) ) ; instance -> stats . memb_merge_detect_tx ++ ; totemnet_mcast_flush_send ( instance -> totemnet_context , & memb_merge_detect , sizeof ( memb_merge_detect ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void free_note_info ( struct elf_note_info * info ) { struct elf_thread_status * ets ; while ( ! QTAILQ_EMPTY ( & info -> thread_list ) ) { ets = QTAILQ_FIRST ( & info -> thread_list ) ; QTAILQ_REMOVE ( & info -> thread_list , ets , ets_link ) ; g_free ( ets ) ; } g_free ( info -> prstatus ) ; g_free ( info -> psinfo ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void tsig_init_record ( tsig_record_type * tsig , tsig_algorithm_type * algorithm , tsig_key_type * key ) { tsig -> status = TSIG_NOT_PRESENT ; tsig -> error_code = TSIG_ERROR_NOERROR ; tsig -> position = 0 ; tsig -> response_count = 0 ; tsig -> context = NULL ; tsig -> algorithm = algorithm ; tsig -> key = key ; tsig -> prior_mac_size = 0 ; region_free_all ( tsig -> context_region ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void pstops ( int modulo , int pps , int nobind , PageSpec * specs , double draw ) { scanpages ( NULL ) ; pstops_write ( modulo , pps , nobind , specs , draw ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rtllib_tkip_get_key ( void * key , int len , u8 * seq , void * priv ) { struct rtllib_tkip_data * tkey = priv ; if ( ! tkey -> key_set ) { return 0 ; } memcpy ( key , tkey -> key , TKIP_KEY_LEN ) ; if ( seq ) { u16 iv16 = tkey -> tx_iv16 ; u32 iv32 = tkey -> tx_iv32 ; if ( iv16 == 0 ) { iv32 -- ; } iv16 -- ; seq [ 0 ] = tkey -> tx_iv16 ; seq [ 1 ] = tkey -> tx_iv16 >> 8 ; seq [ 2 ] = tkey -> tx_iv32 ; seq [ 3 ] = tkey -> tx_iv32 >> 8 ; seq [ 4 ] = tkey -> tx_iv32 >> 16 ; seq [ 5 ] = tkey -> tx_iv32 >> 24 ; } return TKIP_KEY_LEN ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * trim_me ( char * str_ptr ) { char * str_end ; while ( isspace ( * str_ptr ) ) { str_ptr ++ ; } if ( * str_ptr == '\\0' ) { return ( NULL ) ; } str_end = str_ptr + strlen ( str_ptr ) ; while ( str_end > str_ptr && isspace ( str_end [ - 1 ] ) ) { str_end -- ; } * str_end = '\\0' ; return ( str_ptr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct prestera_acl_rule_entry * prestera_acl_rule_entry_create ( struct prestera_acl * acl , struct prestera_acl_rule_entry_key * key , struct prestera_acl_rule_entry_arg * arg ) { struct prestera_acl_rule_entry * e ; int err ; e = kmalloc ( sizeof ( * e ) , GFP_KERNEL ) ; if ( ! e ) { err_kzalloc } memcpy ( & e -> key , key , sizeof ( * key ) ) ; e -> vtcam_id = arg -> vtcam_id ; err = __prestera_acl_rule_entry_act_construct ( acl -> sw , e , arg ) ; if ( err ) { err_act_construct } err = __prestera_acl_rule_entry2hw_add ( acl -> sw , e ) ; if ( err ) { err_hw_add } err = rhashtable_insert_fast ( & acl -> acl_rule_entry_ht , & e -> ht_node , __prestera_acl_rule_entry_ht_params ) ; if ( err ) { err_ht_insert } return e ; err_ht_insert WARN_ON ( __prestera_acl_rule_entry2hw_del ( acl -> sw , e ) ) ; err_hw_add __prestera_acl_rule_entry_act_destruct ( acl -> sw , e ) ; err_act_construct kfree ( e ) ; err_kzalloc return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * argv [ ] ) { puts ( \"Creating root node\" ) ; node_t * root = node_create ( NULL , NULL ) ; puts ( \"Creating child 1 node\" ) ; node_t * one = node_create ( root , NULL ) ; puts ( \"Creating child 2 node\" ) ; node_t * two = node_create ( root , NULL ) ; puts ( \"Creating child 3 node\" ) ; node_t * three = node_create ( one , NULL ) ; puts ( \"Debugging root node\" ) ; node_debug ( root ) ; puts ( \"Destroying root node\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sb_register_oss ( struct sb_card_config * scc , struct sb_module_options * sbmo ) { if ( ! request_region ( scc -> conf . io_base , 16 , \"soundblaster\" ) ) { printk ( KERN_ERR \"sb: ports busy.\\n\" ) ; return - EBUSY ; } if ( ! sb_dsp_detect ( & scc -> conf , 0 , 0 , sbmo ) ) { release_region ( scc -> conf . io_base , 16 ) ; printk ( KERN_ERR \"sb: Failed DSP Detect.\\n\" ) ; kfree ( scc ) ; return - ENODEV ; } if ( ! sb_dsp_init ( & scc -> conf , THIS_MODULE ) ) { printk ( KERN_ERR \"sb: Failed DSP init.\\n\" ) ; kfree ( scc ) ; return - ENODEV ; } if ( scc -> mpucnf . io_base > 0 ) { scc -> mpu = 1 ; printk ( KERN_INFO \"sb: Turning on MPU\\n\" ) ; if ( ! probe_sbmpu ( & scc -> mpucnf , THIS_MODULE ) ) { scc -> mpu = 0 ; } } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pcm1789_hw_params ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * params , struct snd_soc_dai * codec_dai ) { struct snd_soc_component * component = codec_dai -> component ; struct pcm1789_private * priv = snd_soc_component_get_drvdata ( component ) ; int val = 0 , ret ; priv -> rate = params_rate ( params ) ; switch ( priv -> format & SND_SOC_DAIFMT_FORMAT_MASK ) { case SND_SOC_DAIFMT_RIGHT_J : switch ( params_width ( params ) ) { case 24 : val = 2 ; break ; case 16 : val = 3 ; break ; default : return - EINVAL ; } break ; case SND_SOC_DAIFMT_I2S : switch ( params_width ( params ) ) { case 16 : case 24 : case 32 : val = 0 ; break ; default : return - EINVAL ; } break ; case SND_SOC_DAIFMT_LEFT_J : switch ( params_width ( params ) ) { case 16 : case 24 : case 32 : val = 1 ; break ; default : return - EINVAL ; } break ; default : dev_err ( component -> dev , \"Invalid DAI format\\n\" ) ; return - EINVAL ; } ret = regmap_update_bits ( priv -> regmap , PCM1789_FMT_CONTROL , PCM1789_FMT_MASK , val ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pic32_clk_probe ( struct udevice * dev ) { struct pic32_clk_priv * priv = dev_get_priv ( dev ) ; fdt_addr_t addr ; fdt_size_t size ; addr = fdtdec_get_addr_size ( gd -> fdt_blob , dev_of_offset ( dev ) , \"reg\" , & size ) ; priv -> iobase = ioremap ( addr , size ) ; if ( ! priv -> iobase ) { return - EINVAL ; } priv -> syscfg_base = pic32_get_syscfg_base ( ) ; pic32_clk_init ( dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xdl_init_classifier ( xdlclassifier_t * cf , long size , long flags ) { cf -> flags = flags ; cf -> hbits = xdl_hashbits ( ( unsigned int ) size ) ; cf -> hsize = 1 << cf -> hbits ; if ( xdl_cha_init ( & cf -> ncha , sizeof ( xdlclass_t ) , size / 4 + 1 ) < 0 ) { return - 1 ; } if ( ! ( cf -> rchash = ( xdlclass_t * * ) xdl_malloc ( cf -> hsize * sizeof ( xdlclass_t * ) ) ) ) { xdl_cha_free ( & cf -> ncha ) ; return - 1 ; } cf -> alloc = size ; if ( ! ( cf -> rcrecs = ( xdlclass_t * * ) xdl_malloc ( cf -> alloc * sizeof ( xdlclass_t * ) ) ) ) { xdl_free ( cf -> rchash ) ; xdl_cha_free ( & cf -> ncha ) ; return - 1 ; } cf -> count = 0 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void debug_rt_mutex_init_waiter ( struct rt_mutex_waiter * waiter ) { memset ( waiter , 0x11 , sizeof ( * waiter ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( ath9k_hw_resume_interrupts ) ; void ath9k_hw_enable_interrupts ( struct ath_hw * ah ) { struct ath_common * common = ath9k_hw_common ( ah ) ; if ( ! ( ah -> imask & ATH9K_INT_GLOBAL ) ) { return ; } if ( ! atomic_inc_and_test ( & ah -> intr_ref_cnt ) ) { ath_dbg ( common , INTERRUPT , \"Do not enable IER ref count %d\\n\" , atomic_read ( & ah -> intr_ref_cnt ) ) ; return ; } __ath9k_hw_enable_interrupts ( ah , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pk_group_from_specified ( const mbedtls_asn1_buf * params , mbedtls_ecp_group * grp ) { int ret ; unsigned char * p = params -> p ; const unsigned char * const end = params -> p + params -> len ; const unsigned char * end_field , * end_curve ; size_t len ; int ver ; if ( ( ret = mbedtls_asn1_get_int ( & p , end , & ver ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } if ( ( ret = mbedtls_asn1_get_tag ( & p , end , & len , MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 ) { return ( ret ) ; } end_field = p + len ; if ( ( ret = mbedtls_asn1_get_tag ( & p , end_field , & len , MBEDTLS_ASN1_OID ) ) != 0 ) { return ( ret ) ; } if ( len != MBEDTLS_OID_SIZE ( MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD ) || memcmp ( p , MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD , len ) != 0 ) { return ( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE ) ; } p += len ; if ( ( ret = mbedtls_asn1_get_mpi ( & p , end_field , & grp -> P ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } grp -> pbits = mbedtls_mpi_bitlen ( & grp -> P ) ; if ( p != end_field ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ) ; } if ( ( ret = mbedtls_asn1_get_tag ( & p , end , & len , MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 ) { return ( ret ) ; } end_curve = p + len ; if ( ( ret = mbedtls_asn1_get_tag ( & p , end_curve , & len , MBEDTLS_ASN1_OCTET_STRING ) ) != 0 || ( ret = mbedtls_mpi_read_binary ( & grp -> A , p , len ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } p += len ; if ( ( ret = mbedtls_asn1_get_tag ( & p , end_curve , & len , MBEDTLS_ASN1_OCTET_STRING ) ) != 0 || ( ret = mbedtls_mpi_read_binary ( & grp -> B , p , len ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } p += len ; if ( ( ret = mbedtls_asn1_get_tag ( & p , end_curve , & len , MBEDTLS_ASN1_BIT_STRING ) ) == 0 ) { p += len ; } if ( p != end_curve ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ) ; } if ( ( ret = mbedtls_asn1_get_tag ( & p , end , & len , MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } if ( ( ret = mbedtls_ecp_point_read_binary ( grp , & grp -> G , ( const unsigned char * ) p , len ) ) != 0 ) { if ( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE || ( p [ 0 ] != 0x02 && p [ 0 ] != 0x03 ) || len != mbedtls_mpi_size ( & grp -> P ) + 1 || mbedtls_mpi_read_binary ( & grp -> G . X , p + 1 , len - 1 ) != 0 || mbedtls_mpi_lset ( & grp -> G . Y , p [ 0 ] - 2 ) != 0 || mbedtls_mpi_lset ( & grp -> G . Z , 1 ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT ) ; } } p += len ; if ( ( ret = mbedtls_asn1_get_mpi ( & p , end , & grp -> N ) ) != 0 ) { return ( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret ) ; } grp -> nbits = mbedtls_mpi_bitlen ( & grp -> N ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static pci_ers_result_t e1000_io_slot_reset ( struct pci_dev * pdev ) { struct net_device * netdev = pci_get_drvdata ( pdev ) ; struct e1000_adapter * adapter = netdev_priv ( netdev ) ; struct e1000_hw * hw = & adapter -> hw ; u16 aspm_disable_flag = 0 ; int err ; pci_ers_result_t result ; if ( adapter -> flags2 & FLAG2_DISABLE_ASPM_L0S ) { aspm_disable_flag = PCIE_LINK_STATE_L0S ; } if ( adapter -> flags2 & FLAG2_DISABLE_ASPM_L1 ) { aspm_disable_flag |= PCIE_LINK_STATE_L1 ; } if ( aspm_disable_flag ) { e1000e_disable_aspm_locked ( pdev , aspm_disable_flag ) ; } err = pci_enable_device_mem ( pdev ) ; if ( err ) { dev_err ( & pdev -> dev , \"Cannot re-enable PCI device after reset.\\n\" ) ; result = PCI_ERS_RESULT_DISCONNECT ; } else { pdev -> state_saved = true ; pci_restore_state ( pdev ) ; pci_set_master ( pdev ) ; pci_enable_wake ( pdev , PCI_D3hot , 0 ) ; pci_enable_wake ( pdev , PCI_D3cold , 0 ) ; e1000e_reset ( adapter ) ; ew32 ( WUS , ~ 0 ) ; result = PCI_ERS_RESULT_RECOVERED ; } pci_cleanup_aer_uncorrect_error_status ( pdev , NULL ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pidff_erase_effect ( struct input_dev * dev , int effect_id ) { struct pidff_device * pidff = dev -> ff -> private ; int pid_id = pidff -> pid_id [ effect_id ] ; hid_dbg ( pidff -> hid , \"starting to erase %d/%d\\n\" , effect_id , pidff -> pid_id [ effect_id ] ) ; hid_hw_wait ( pidff -> hid , NULL ) ; pidff_playback_pid ( pidff , pid_id , 0 ) ; pidff_erase_pid ( pidff , pid_id ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void vboxsf_free_fc ( struct fs_context * fc ) { struct vboxsf_fs_context * ctx = fc -> fs_private ; kfree ( ctx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static acpi_status acpi_ns_dump_one_device ( acpi_handle obj_handle , u32 level , void * context , void * * return_value ) { struct acpi_buffer buffer ; struct acpi_device_info * info ; acpi_status status ; u32 i ; ACPI_FUNCTION_NAME ( ns_dump_one_device ) ; status = acpi_ns_dump_one_object ( obj_handle , level , context , return_value ) ; buffer . length = ACPI_ALLOCATE_LOCAL_BUFFER ; status = acpi_get_object_info ( obj_handle , & buffer ) ; if ( ACPI_SUCCESS ( status ) ) { info = buffer . pointer ; for ( i = 0 ; i < level ; i ++ ) { ACPI_DEBUG_PRINT_RAW ( ( ACPI_DB_TABLES , \" \" ) ) ; } ACPI_DEBUG_PRINT_RAW ( ( ACPI_DB_TABLES , \"    HID: %s, ADR: %8.8X%8.8X\\n\" , info -> hardware_id . value , ACPI_FORMAT_UINT64 ( info -> address ) ) ) ; ACPI_FREE ( info , NULL ) ; } return ( status ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int realloc_mv_buffers ( struct vpe_ctx * ctx , size_t size ) { struct device * dev = ctx -> dev -> v4l2_dev . dev ; if ( ctx -> mv_buf [ 0 ] ) { dma_free_coherent ( dev , ctx -> mv_buf_size , ctx -> mv_buf [ 0 ] , ctx -> mv_buf_dma [ 0 ] ) ; } if ( ctx -> mv_buf [ 1 ] ) { dma_free_coherent ( dev , ctx -> mv_buf_size , ctx -> mv_buf [ 1 ] , ctx -> mv_buf_dma [ 1 ] ) ; } if ( size == 0 ) { return 0 ; } ctx -> mv_buf [ 0 ] = dma_alloc_coherent ( dev , size , & ctx -> mv_buf_dma [ 0 ] , GFP_KERNEL ) ; if ( ! ctx -> mv_buf [ 0 ] ) { vpe_err ( ctx -> dev , \"failed to allocate motion vector buffer\\n\" ) ; return - ENOMEM ; } ctx -> mv_buf [ 1 ] = dma_alloc_coherent ( dev , size , & ctx -> mv_buf_dma [ 1 ] , GFP_KERNEL ) ; if ( ! ctx -> mv_buf [ 1 ] ) { vpe_err ( ctx -> dev , \"failed to allocate motion vector buffer\\n\" ) ; dma_free_coherent ( dev , size , ctx -> mv_buf [ 0 ] , ctx -> mv_buf_dma [ 0 ] ) ; return - ENOMEM ; } ctx -> mv_buf_size = size ; ctx -> src_mv_buf_selector = 0 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool is_sp_stage ( struct ia_css_pipeline_stage * stage ) { return stage -> sp_func != IA_CSS_PIPELINE_NO_FUNC ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct microcode_intel * __load_ucode_intel ( struct ucode_cpu_info * uci ) { static const char * path ; struct cpio_data cp ; bool use_pa ; if ( IS_ENABLED ( CONFIG_X86_32 ) ) { path = ( const char * ) __pa_nodebug ( ucode_path ) ; use_pa = true ; } else { path = ucode_path ; use_pa = false ; } if ( ! load_builtin_intel_microcode ( & cp ) ) { cp = find_microcode_in_initrd ( path , use_pa ) ; } if ( ! ( cp . data && cp . size ) ) { return NULL ; } intel_cpu_collect_info ( uci , NULL ) ; return scan_microcode ( cp . data , cp . size , uci , false ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cmi_mce_response ( struct regs * rp , uint64_t disp ) { int panicrsp = cmi_panic_on_uncorrectable_error ?CMI_RESPONSE_PANIC : CMI_RESPONSE_NONE ; on_trap_data_t * otp ; if ( disp == 0 ) { return ( CMI_RESPONSE_NONE ) ; } if ( disp & CMI_ERRDISP_UC_UNCONSTRAINED ) { return ( panicrsp ) ; } if ( ( otp = curthread -> t_ontrap ) != NULL && otp -> ot_prot & OT_DATA_EC ) { return ( CMI_RESPONSE_ONTRAP_PROT ) ; } if ( curthread -> t_lofault ) { return ( CMI_RESPONSE_LOFAULT_PROT ) ; } if ( disp & CMI_ERRDISP_FORCEFATAL ) { return ( panicrsp ) ; } if ( disp & ( CMI_ERRDISP_CURCTXBAD | CMI_ERRDISP_RIPV_INVALID ) ) { return ( USERMODE ( rp -> r_cs ) ?CMI_RESPONSE_CKILL : panicrsp ) ; } return ( CMI_RESPONSE_NONE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int hinic_hwdev_ifup ( struct hinic_hwdev * hwdev , u16 sq_depth , u16 rq_depth ) { struct hinic_func_to_io * func_to_io = & hwdev -> func_to_io ; struct hinic_cap * nic_cap = & hwdev -> nic_cap ; struct hinic_hwif * hwif = hwdev -> hwif ; int err , num_aeqs , num_ceqs , num_qps ; struct msix_entry * ceq_msix_entries ; struct msix_entry * sq_msix_entries ; struct msix_entry * rq_msix_entries ; struct pci_dev * pdev = hwif -> pdev ; u16 base_qpn ; err = get_base_qpn ( hwdev , & base_qpn ) ; if ( err ) { dev_err ( & pdev -> dev , \"Failed to get global base qp number\\n\" ) ; return err ; } num_aeqs = HINIC_HWIF_NUM_AEQS ( hwif ) ; num_ceqs = HINIC_HWIF_NUM_CEQS ( hwif , NULL ) ; ceq_msix_entries = & hwdev -> msix_entries [ num_aeqs ] ; func_to_io -> hwdev = hwdev ; func_to_io -> sq_depth = sq_depth ; func_to_io -> rq_depth = rq_depth ; func_to_io -> global_qpn = base_qpn ; err = hinic_io_init ( func_to_io , hwif , nic_cap -> max_qps , num_ceqs , ceq_msix_entries ) ; if ( err ) { dev_err ( & pdev -> dev , \"Failed to init IO channel\\n\" ) ; return err ; } num_qps = nic_cap -> num_qps ; sq_msix_entries = & hwdev -> msix_entries [ num_aeqs + num_ceqs ] ; rq_msix_entries = & hwdev -> msix_entries [ num_aeqs + num_ceqs + num_qps ] ; err = hinic_io_create_qps ( func_to_io , base_qpn , num_qps , sq_msix_entries , rq_msix_entries ) ; if ( err ) { dev_err ( & pdev -> dev , \"Failed to create QPs\\n\" ) ; err_create_qps } err = wait_for_db_state ( hwdev ) ; if ( err ) { dev_warn ( & pdev -> dev , \"db - disabled, try again\\n\" ) ; hinic_db_state_set ( hwif , HINIC_DB_ENABLE ) ; } err = set_hw_ioctxt ( hwdev , sq_depth , rq_depth ) ; if ( err ) { dev_err ( & pdev -> dev , \"Failed to set HW IO ctxt\\n\" ) ; err_hw_ioctxt } return 0 ; err_hw_ioctxt hinic_io_destroy_qps ( func_to_io , num_qps ) ; err_create_qps hinic_io_free ( func_to_io ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void line_out_enable ( HWVoiceOut * hw , bool enable ) { SpiceVoiceOut * out = container_of ( hw , SpiceVoiceOut , hw ) ; if ( enable ) { if ( out -> active ) { return ; } out -> active = 1 ; audio_rate_start ( & out -> rate ) ; spice_server_playback_start ( & out -> sin ) ; } else { if ( ! out -> active ) { return ; } out -> active = 0 ; if ( out -> frame ) { spice_server_playback_put_samples ( & out -> sin , out -> frame ) ; out -> frame = NULL ; } spice_server_playback_stop ( & out -> sin ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int board_early_init_f ( void ) { at91_periph_clk_enable ( ATMEL_ID_UHP , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pelican_memory ( const unsigned char * key , unsigned long keylen , const unsigned char * in , unsigned long inlen , unsigned char * out ) { pelican_state * pel ; int err ; pel = XMALLOC ( sizeof ( * pel ) ) ; if ( pel == NULL ) { return CRYPT_MEM ; } if ( ( err = pelican_init ( pel , key , keylen ) ) != CRYPT_OK ) { XFREE ( pel , NULL ) ; return err ; } if ( ( err = pelican_process ( pel , in , inlen ) ) != CRYPT_OK ) { XFREE ( pel ) ; return err ; } err = pelican_done ( pel , out ) ; XFREE ( pel ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void s3c2412_iotiming_getbank ( struct s3c_cpufreq_config * cfg , struct s3c2412_iobank_timing * bt , unsigned int bank ) { cfs_time_t clk = cfg -> freq . hclk_tns ; void __iomem * regs = S3C2412_SSMC_BANK ( bank ) ; bt -> idcy = s3c2412_decode_timing ( clk , __raw_readl ( regs + SMBIDCYR ) ) ; bt -> wstrd = s3c2412_decode_timing ( clk , __raw_readl ( regs + SMBWSTRDR ) ) ; bt -> wstoen = s3c2412_decode_timing ( clk , __raw_readl ( regs + SMBWSTOENR ) ) ; bt -> wstwen = s3c2412_decode_timing ( clk , __raw_readl ( regs + SMBWSTWENR ) ) ; bt -> wstbrd = s3c2412_decode_timing ( clk , __raw_readl ( regs + SMBWSTBRDR ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int reftable_stack_clean ( struct reftable_stack * st ) { struct reftable_addition * add = NULL ; int err = reftable_stack_new_addition ( & add , st ) ; if ( err < 0 ) { done } err = reftable_stack_reload ( st ) ; if ( err < 0 ) { done } err = reftable_stack_clean_locked ( st ) ; done return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _fini ( void ) { int err ; if ( xendev_nounload ) { return ( EBUSY ) ; } impl_bus_delete_probe ( xendev_enumerate ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void mbedtls_test_info_reset ( void ) { mbedtls_test_info . result = MBEDTLS_TEST_RESULT_SUCCESS ; mbedtls_test_info . step = ( unsigned long ) ( - 1 ) ; mbedtls_test_info . test = 0 ; mbedtls_test_info . line_no = 0 ; mbedtls_test_info . filename = 0 ; memset ( mbedtls_test_info . line2 , 0 , sizeof ( mbedtls_test_info . line2 ) ) ; mbedtls_test_case_uses_negative_0 = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ntfs_read_folio ( struct file * file , struct folio * folio ) { struct page * page = & folio -> page ; int err ; struct address_space * mapping = page -> mapping ; struct inode * inode = mapping -> host ; struct ntfs_inode * ni = ntfs_i ( inode ) ; if ( is_resident ( ni ) ) { ni_lock ( ni , NULL ) ; err = attr_data_read_resident ( ni , page ) ; ni_unlock ( ni ) ; if ( err != E_NTFS_NONRESIDENT ) { unlock_page ( page ) ; return err ; } } if ( is_compressed ( ni ) ) { ni_lock ( ni ) ; err = ni_readpage_cmpr ( ni , page ) ; ni_unlock ( ni ) ; return err ; } return mpage_read_folio ( folio , ntfs_get_block ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "s32 e1000_acquire_swfw_sync_i210 ( struct e1000_hw * hw , u16 mask ) { u32 swfw_sync ; u32 swmask = mask ; u32 fwmask = mask << 16 ; s32 ret_val = E1000_SUCCESS ; s32 i = 0 , timeout = 200 ; DEBUGFUNC ( \"e1000_acquire_swfw_sync_i210\" ) ; while ( i < timeout ) { if ( e1000_get_hw_semaphore_i210 ( hw ) ) { ret_val = - E1000_ERR_SWFW_SYNC ; out } swfw_sync = E1000_READ_REG ( hw , E1000_SW_FW_SYNC ) ; if ( ! ( swfw_sync & ( fwmask | swmask ) ) ) { break ; } e1000_put_hw_semaphore_generic ( hw , NULL ) ; msec_delay_irq ( 5 ) ; i ++ ; } if ( i == timeout ) { DEBUGOUT ( \"Driver can't access resource, SW_FW_SYNC timeout.\\n\" ) ; ret_val = - E1000_ERR_SWFW_SYNC ; out } swfw_sync |= swmask ; E1000_WRITE_REG ( hw , E1000_SW_FW_SYNC , swfw_sync ) ; e1000_put_hw_semaphore_generic ( hw ) ; out return ret_val ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _init ( void ) { uint16_t w16 ; int rval = 0 ; for ( w16 = 0 ; w16 < sizeof ( utsname . release ) ; w16 ++ ) { if ( utsname . release [ w16 ] == '.' ) { w16 ++ ; break ; } } if ( w16 < sizeof ( utsname . release ) ) { ( void ) ql_bstr_to_dec ( & utsname . release [ w16 ] , & ql_os_release_level , 0 ) ; } else { ql_os_release_level = 0 ; } if ( ql_os_release_level < 6 ) { cmn_err ( CE_WARN , \"%s Unsupported OS release level = %d\" , QL_NAME , ql_os_release_level ) ; rval = EINVAL ; } if ( ql_os_release_level == 6 ) { ql_32bit_io_dma_attr . dma_attr_count_max = 0x00ffffff ; ql_64bit_io_dma_attr . dma_attr_count_max = 0x00ffffff ; } if ( rval == 0 ) { rval = ddi_soft_state_init ( & ql_state , sizeof ( ql_adapter_state_t ) , 0 ) ; } if ( rval == 0 ) { fc_fca_init ( & ql_devops ) ; mutex_init ( & ql_global_mutex , MUTEX_DRIVER , NULL ) ; mutex_init ( & ql_global_hw_mutex , NULL , MUTEX_DRIVER , NULL ) ; mutex_init ( & ql_global_el_mutex , NULL , MUTEX_DRIVER , NULL ) ; rval = mod_install ( & modlinkage ) ; if ( rval != 0 ) { mutex_destroy ( & ql_global_hw_mutex ) ; mutex_destroy ( & ql_global_mutex ) ; mutex_destroy ( & ql_global_el_mutex ) ; ddi_soft_state_fini ( & ql_state ) ; } else { ql_32fcsm_cmd_dma_attr = ql_32bit_io_dma_attr ; ql_64fcsm_cmd_dma_attr = ql_64bit_io_dma_attr ; ql_32fcsm_rsp_dma_attr = ql_32bit_io_dma_attr ; ql_64fcsm_rsp_dma_attr = ql_64bit_io_dma_attr ; ql_32fcip_cmd_dma_attr = ql_32bit_io_dma_attr ; ql_64fcip_cmd_dma_attr = ql_64bit_io_dma_attr ; ql_32fcip_rsp_dma_attr = ql_32bit_io_dma_attr ; ql_64fcip_rsp_dma_attr = ql_64bit_io_dma_attr ; ql_32fcp_cmd_dma_attr = ql_32bit_io_dma_attr ; ql_64fcp_cmd_dma_attr = ql_64bit_io_dma_attr ; ql_32fcp_rsp_dma_attr = ql_32bit_io_dma_attr ; ql_64fcp_rsp_dma_attr = ql_64bit_io_dma_attr ; ql_32fcp_data_dma_attr = ql_32bit_io_dma_attr ; ql_64fcp_data_dma_attr = ql_64bit_io_dma_attr ; ql_32fcsm_cmd_dma_attr . dma_attr_sgllen = ql_64fcsm_cmd_dma_attr . dma_attr_sgllen = QL_FCSM_CMD_SGLLEN ; ql_32fcsm_rsp_dma_attr . dma_attr_sgllen = ql_64fcsm_rsp_dma_attr . dma_attr_sgllen = QL_FCSM_RSP_SGLLEN ; ql_32fcip_cmd_dma_attr . dma_attr_sgllen = ql_64fcip_cmd_dma_attr . dma_attr_sgllen = QL_FCIP_CMD_SGLLEN ; ql_32fcip_rsp_dma_attr . dma_attr_sgllen = ql_64fcip_rsp_dma_attr . dma_attr_sgllen = QL_FCIP_RSP_SGLLEN ; ql_32fcp_cmd_dma_attr . dma_attr_sgllen = ql_64fcp_cmd_dma_attr . dma_attr_sgllen = QL_FCP_CMD_SGLLEN ; ql_32fcp_rsp_dma_attr . dma_attr_sgllen = ql_64fcp_rsp_dma_attr . dma_attr_sgllen = QL_FCP_RSP_SGLLEN ; } } if ( rval != 0 ) { cmn_err ( CE_CONT , \"?Unable to install/attach driver '%s'\" , QL_NAME ) ; } return ( rval ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "seg6_end_dt_mode seg6_end_dt6_parse_mode ( struct seg6_local_lwt * slwt ) { unsigned long parsed_optattrs = slwt -> parsed_optattrs ; bool legacy , vrfmode ; legacy = ! ! ( parsed_optattrs & SEG6_F_ATTR ( SEG6_LOCAL_TABLE ) ) ; vrfmode = ! ! ( parsed_optattrs & SEG6_F_ATTR ( SEG6_LOCAL_VRFTABLE ) ) ; return legacy ?DT_LEGACY_MODE : DT_VRF_MODE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline int is_rm300_revd ( void ) { int csmsr = * ( volatile unsigned char * ) PCIMT_CSMSR ; return ( csmsr & 0xa0 ) == 0x20 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ulong_t dtrace_getreg ( struct regs * rp , uint_t reg ) { if ( reg <= SS ) { if ( reg >= sizeof ( dtrace_regmap ) / sizeof ( int ) ) { DTRACE_CPUFLAG_SET ( CPU_DTRACE_ILLOP , NULL ) ; return ( 0 ) ; } reg = dtrace_regmap [ reg ] ; } else { reg -= SS + 1 ; } switch ( reg ) { case REG_RDI : return ( rp -> r_rdi ) ; case REG_RSI : return ( rp -> r_rsi ) ; case REG_RDX : return ( rp -> r_rdx ) ; case REG_RCX : return ( rp -> r_rcx ) ; case REG_R8 : return ( rp -> r_r8 ) ; case REG_R9 : return ( rp -> r_r9 ) ; case REG_RAX : return ( rp -> r_rax ) ; case REG_RBX : return ( rp -> r_rbx ) ; case REG_RBP : return ( rp -> r_rbp ) ; case REG_R10 : return ( rp -> r_r10 ) ; case REG_R11 : return ( rp -> r_r11 ) ; case REG_R12 : return ( rp -> r_r12 ) ; case REG_R13 : return ( rp -> r_r13 ) ; case REG_R14 : return ( rp -> r_r14 ) ; case REG_R15 : return ( rp -> r_r15 ) ; case REG_DS : return ( rp -> r_ds ) ; case REG_ES : return ( rp -> r_es ) ; case REG_FS : return ( rp -> r_fs ) ; case REG_GS : return ( rp -> r_gs ) ; case REG_TRAPNO : return ( rp -> r_trapno ) ; case REG_ERR : return ( rp -> r_err ) ; case REG_RIP : return ( rp -> r_rip ) ; case REG_CS : return ( rp -> r_cs ) ; case REG_SS : return ( rp -> r_ss ) ; case REG_RFL : return ( rp -> r_rfl ) ; case REG_RSP : return ( rp -> r_rsp ) ; default : DTRACE_CPUFLAG_SET ( CPU_DTRACE_ILLOP ) ; return ( 0 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int zynqmp_disp_layer_update ( struct zynqmp_disp_layer * layer , struct drm_plane_state * state ) { const struct drm_format_info * info = layer -> drm_fmt ; unsigned int i ; if ( ! layer -> disp -> dpsub -> dma_enabled ) { return 0 ; } for ( i = 0 ; i < info -> num_planes ; i ++ ) { int width = state -> crtc_w / ( i ?info -> hsub : 1 ) ; unsigned int height = state -> crtc_h / ( i ?info -> vsub : 1 ) ; struct zynqmp_disp_layer_dma * dma = & layer -> dmas [ i ] ; struct dma_async_tx_descriptor * desc ; dma_addr_t dma_addr ; dma_addr = drm_fb_dma_get_gem_addr ( state -> fb , state , i ) ; dma -> xt . numf = height ; dma -> sgl . size = width * info -> cpp [ i ] ; dma -> sgl . icg = state -> fb -> pitches [ i ] - dma -> sgl . size ; dma -> xt . src_start = dma_addr ; dma -> xt . frame_size = 1 ; dma -> xt . dir = DMA_MEM_TO_DEV ; dma -> xt . src_sgl = true ; dma -> xt . dst_sgl = false ; desc = dmaengine_prep_interleaved_dma ( dma -> chan , & dma -> xt , DMA_CTRL_ACK | DMA_PREP_REPEAT | DMA_PREP_LOAD_EOT ) ; if ( ! desc ) { dev_err ( layer -> disp -> dev , \"failed to prepare DMA descriptor\\n\" ) ; return - ENOMEM ; } dmaengine_submit ( desc ) ; dma_async_issue_pending ( dma -> chan ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int qlcnic_pci_mem_read_2M ( struct qlcnic_adapter * adapter , u64 off , u64 * data ) { int j , ret ; u32 temp , off8 ; u64 val ; struct qlcnic_ms_reg_ctrl ms ; if ( off & 7 ) { return - EIO ; } memset ( & ms , 0 , sizeof ( qlcnic_ms_reg_ctrl ) ) ; qlcnic_set_ms_controls ( adapter , off , & ms ) ; if ( ADDR_IN_RANGE ( off , QLCNIC_ADDR_OCM0 , QLCNIC_ADDR_OCM0_MAX ) ) { return qlcnic_pci_mem_access_direct ( adapter , ms . ocm_window , ms . off , data , 0 ) ; } mutex_lock ( & adapter -> ahw -> mem_lock ) ; off8 = off & ~ 0xf ; qlcnic_ind_wr ( adapter , ms . low , off8 ) ; qlcnic_ind_wr ( adapter , ms . hi , 0 ) ; qlcnic_ind_wr ( adapter , ms . control , TA_CTL_ENABLE ) ; qlcnic_ind_wr ( adapter , ms . control , QLCNIC_TA_START_ENABLE ) ; for ( j = 0 ; j < MAX_CTL_CHECK ; j ++ ) { temp = qlcnic_ind_rd ( adapter , ms . control ) ; if ( ( temp & TA_CTL_BUSY ) == 0 ) { break ; } } if ( j >= MAX_CTL_CHECK ) { if ( printk_ratelimit ( ) ) { dev_err ( & adapter -> pdev -> dev , \"failed to read through agent\\n\" ) ; } ret = - EIO ; } else { temp = qlcnic_ind_rd ( adapter , ms . rd [ 3 ] ) ; val = ( u64 ) temp << 32 ; val |= qlcnic_ind_rd ( adapter , ms . rd [ 2 ] ) ; * data = val ; ret = 0 ; } mutex_unlock ( & adapter -> ahw -> mem_lock ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test ( ) { int a [ ] { 1 } ; ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( iommufd_device_unbind , IOMMUFD ) ; static int iommufd_device_setup_msi ( struct iommufd_device * idev , struct iommufd_hw_pagetable * hwpt , phys_addr_t sw_msi_start ) { int rc ; if ( sw_msi_start != PHYS_ADDR_MAX && ! hwpt -> msi_cookie ) { rc = iommu_get_msi_cookie ( hwpt -> domain , sw_msi_start ) ; if ( rc ) { return rc ; } hwpt -> msi_cookie = true ; } if ( ! iommu_group_has_isolated_msi ( idev -> group ) ) { dev_warn ( idev -> dev , \"MSI interrupts are not secure, they cannot be isolated by the platform. \" \"Check that platform features like interrupt remapping are enabled. \" \"Use the \\\"allow_unsafe_interrupts\\\" module parameter to override\\n\" ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int axi_dmac_remove ( struct platform_device * pdev ) { struct axi_dmac * dmac = platform_get_drvdata ( pdev ) ; of_dma_controller_free ( pdev -> dev . of_node ) ; free_irq ( dmac -> irq , dmac ) ; tasklet_kill ( & dmac -> chan . vchan . task ) ; dma_async_device_unregister ( & dmac -> dma_dev ) ; clk_disable_unprepare ( dmac -> clk , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct charset_cache * nfscmd_findmap ( struct exportinfo * exi , struct sockaddr * sp ) { struct charset_cache * charset ; ASSERT ( exi != NULL ) ; ASSERT ( sp != NULL ) ; mutex_enter ( & exi -> exi_lock ) ; if ( ! ( exi -> exi_export . ex_flags & EX_CHARMAP ) ) { mutex_exit ( & exi -> exi_lock ) ; return ( NULL ) ; } for ( charset = exi -> exi_charset ; charset != NULL ; charset = charset -> next ) { if ( bcmp ( sp , & charset -> client_addr , sizeof ( sockaddr ) ) == 0 ) { break ; } } mutex_exit ( & exi -> exi_lock ) ; if ( charset == NULL ) { charset = nfscmd_charmap ( exi , sp ) ; } return ( charset ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int process_prometheus_remote_write_response ( BUFFER * buffer , struct instance * instance ) { const char * s = buffer_tostring ( buffer ) ; int len = buffer_strlen ( buffer ) ; while ( ! isspace ( * s ) && len ) { s ++ ; len -- ; } s ++ ; len -- ; if ( likely ( len > 4 && ( ! strncmp ( s , \"200 \" , 4 ) || ! strncmp ( s , \"204 \" , 4 ) ) ) ) { return 0 ; } else { return exporting_discard_response ( buffer , instance ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dac_volume_put ( struct snd_kcontrol * ctl , struct snd_ctl_elem_value * value ) { struct oxygen * chip = ctl -> private_data ; unsigned int i ; int changed ; changed = 0 ; for ( i = 0 ; i < chip -> model . dac_channels_mixer ; ++ i ) { if ( value -> value . integer . value [ i ] != chip -> dac_volume [ i ] ) { chip -> dac_volume [ i ] = value -> value . integer . value [ i ] ; changed = 1 ; } } if ( changed ) { chip -> model . update_dac_volume ( chip ) ; } mutex_unlock ( & chip -> mutex ) ; return changed ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int bcmdog_activate ( struct device * self , int act ) { switch ( act ) { case DVACT_POWERDOWN : wdog_shutdown ( self , NULL ) ; break ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ud_clear_margins ( struct vc_data * vc , struct fb_info * info , int color , int bottom_only ) { int cw = vc -> vc_font . width ; unsigned int ch = vc -> vc_font . height ; unsigned int rw = info -> var . xres - ( vc -> vc_cols * cw ) ; unsigned int bh = info -> var . yres - ( vc -> vc_rows * ch ) ; struct fb_fillrect region ; region . color = color ; region . rop = ROP_COPY ; if ( ( int ) rw > 0 && ! bottom_only ) { region . dy = 0 ; region . dx = info -> var . xoffset ; region . width = rw ; region . height = info -> var . yres_virtual ; info -> fbops -> fb_fillrect ( info , & region ) ; } if ( ( int ) bh > 0 ) { region . dy = info -> var . yoffset ; region . dx = info -> var . xoffset ; region . height = bh ; region . width = info -> var . xres ; info -> fbops -> fb_fillrect ( info , & region ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { __u32 mode_flags = XDP_FLAGS_DRV_MODE | XDP_FLAGS_SKB_MODE ; struct addrinfo * a , hints = { . ai_family = AF_INET } ; __u16 count = XDPING_DEFAULT_COUNT ; struct pinginfo pinginfo = { 0 } ; const char * optstr = \"c:I:NsS\" ; struct bpf_program * main_prog ; int prog_fd = - 1 , map_fd = - 1 ; struct sockaddr_in rin ; struct bpf_object * obj ; struct bpf_map * map ; char * ifname = NULL ; char filename [ 256 ] ; int opt , ret = 1 ; __u32 raddr = 0 ; int server = 0 ; char cmd [ 256 ] ; while ( ( opt = getopt ( argc , argv , optstr ) ) != - 1 ) { switch ( opt ) { case 'c' : count = atoi ( optarg ) ; if ( count ( 1 || count ) XDPING_MAX_COUNT ) { fprintf ( stderr , \"min count is 1, max count is %d\\n\" , XDPING_MAX_COUNT ) ; return 1 ; } break ; case 'I' : ifname = optarg ; ifindex = if_nametoindex ( ifname ) ; if ( ! ifindex ) { fprintf ( stderr , \"Could not get interface %s\\n\" , ifname ) ; return 1 ; } break ; case 'N' : xdp_flags |= XDP_FLAGS_DRV_MODE ; break ; case 's' : server = 1 ; break ; case 'S' : xdp_flags |= XDP_FLAGS_SKB_MODE ; break ; default : show_usage ( basename ( argv [ 0 ] ) ) ; return 1 ; } } if ( ! ifname ) { show_usage ( basename ( argv [ 0 ] ) ) ; return 1 ; } if ( ! server && optind == argc ) { show_usage ( basename ( argv [ 0 ] ) ) ; return 1 ; } if ( ( xdp_flags & mode_flags ) == mode_flags ) { fprintf ( stderr , \"-N or -S can be specified, not both.\\n\" ) ; show_usage ( basename ( argv [ 0 ] ) ) ; return 1 ; } if ( ! server ) { if ( getaddrinfo ( argv [ optind ] , NULL , & hints , & a ) || ! a ) { fprintf ( stderr , \"Could not resolve %s\\n\" , argv [ optind ] ) ; return 1 ; } memcpy ( & rin , a -> ai_addr , sizeof ( rin ) ) ; raddr = rin . sin_addr . s_addr ; freeaddrinfo ( a ) ; } libbpf_set_strict_mode ( LIBBPF_STRICT_ALL ) ; sprintf ( filename , \"%s_kern.bpf.o\" , argv [ 0 ] ) ; if ( bpf_prog_test_load ( filename , BPF_PROG_TYPE_XDP , & obj , & prog_fd ) ) { fprintf ( stderr , \"load of %s failed\\n\" , filename ) ; return 1 ; } main_prog = bpf_object__find_program_by_name ( obj , server ?\"xdping_server\" : \"xdping_client\" ) ; if ( main_prog ) { prog_fd = bpf_program__fd ( main_prog ) ; } if ( ! main_prog || prog_fd < 0 ) { fprintf ( stderr , \"could not find xdping program\" ) ; return 1 ; } map = bpf_object__next_map ( obj , NULL ) ; if ( map ) { map_fd = bpf_map__fd ( map ) ; } if ( ! map || map_fd < 0 ) { fprintf ( stderr , \"Could not find ping map\" ) ; done } signal ( SIGINT , cleanup ) ; signal ( SIGTERM , cleanup ) ; printf ( \"Setting up XDP for %s, please wait...\\n\" , ifname ) ; printf ( \"XDP setup disrupts network connectivity, hit Ctrl+C to quit\\n\" ) ; if ( bpf_xdp_attach ( ifindex , prog_fd , xdp_flags , NULL ) < 0 ) { fprintf ( stderr , \"Link set xdp fd failed for %s\\n\" , ifname ) ; done } if ( server ) { close ( prog_fd ) ; close ( map_fd ) ; printf ( \"Running server on %s; press Ctrl+C to exit...\\n\" , ifname ) ; { } 1 ; } pinginfo . seq = htons ( count ) ; pinginfo . count = count ; if ( bpf_map_update_elem ( map_fd , & raddr , & pinginfo , BPF_ANY ) ) { fprintf ( stderr , \"could not communicate with BPF map: %s\\n\" , strerror ( errno ) ) ; cleanup ( 0 ) ; done } sleep ( 10 ) ; snprintf ( cmd , sizeof ( cmd ) , \"ping -c %d -I %s %s\" , count , ifname , argv [ optind ] ) ; printf ( \"\\nNormal ping RTT data\\n\" ) ; printf ( \"[Ignore final RTT; it is distorted by XDP using the reply]\\n\" ) ; ret = system ( cmd ) ; if ( ! ret ) { ret = get_stats ( map_fd , count , raddr ) ; } cleanup ( 0 ) ; done if ( prog_fd > 0 ) { close ( prog_fd ) ; } if ( map_fd > 0 ) { close ( map_fd ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void ieee80211_monitor_rx ( struct ieee80211_device * ieee , struct sk_buff * skb , struct ieee80211_rx_stats * rx_stats ) { struct rtl_80211_hdr_4addr * hdr = ( rtl_80211_hdr_4addr * ) skb -> data ; u16 fc = le16_to_cpu ( hdr -> frame_ctl ) ; skb -> dev = ieee -> dev ; skb_reset_mac_header ( skb ) ; skb_pull ( skb , ieee80211_get_hdrlen ( fc ) ) ; skb -> pkt_type = PACKET_OTHERHOST ; skb -> protocol = htons ( ETH_P_80211_RAW ) ; netif_rx ( skb ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void mt8186_adsp_clock_off ( struct snd_sof_dev * sdev ) { snd_sof_dsp_write ( sdev , DSP_REG_BAR , ADSP_CK_EN , 0 ) ; snd_sof_dsp_write ( sdev , DSP_REG_BAR , ADSP_UART_CTRL , 0 ) ; adsp_disable_all_clock ( sdev , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int libxlMakeNetworkDiskSrc ( virStorageSource * src , char * * srcstr ) { g_autoptr ( ) conn = NULL ; g_autofree char * base64secret = NULL ; char * username = NULL ; * srcstr = NULL ; if ( src -> auth && src -> protocol == VIR_STORAGE_NET_PROTOCOL_RBD ) { g_autofree uint8_t * secret = NULL ; int secretlen = 0 ; VIR_IDENTITY_AUTORESTORE virIdentity * oldident = virIdentityElevateCurrent ( ) ; if ( ! oldident ) { return - 1 ; } username = src -> auth -> username ; if ( ! ( conn = virConnectOpen ( \" ) ) } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mt9m001_init_sensor ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( sd * ) gspca_dev ; u16 id ; i2c_r2 ( gspca_dev , 0x00 , & id ) ; if ( gspca_dev -> usb_err < 0 ) { return ; } switch ( id ) { case 0x8411 : case 0x8421 : pr_info ( \"MT9M001 color sensor detected\\n\" ) ; break ; case 0x8431 : pr_info ( \"MT9M001 mono sensor detected\\n\" ) ; break ; default : pr_err ( \"No MT9M001 chip detected, ID = %x\\n\\n\" , id ) ; gspca_dev -> usb_err = - ENODEV ; return ; } i2c_w2_buf ( gspca_dev , mt9m001_init , ARRAY_SIZE ( mt9m001_init ) ) ; if ( gspca_dev -> usb_err < 0 ) { pr_err ( \"MT9M001 sensor initialization failed\\n\" ) ; } sd -> vstart = 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pmu_send_request ( struct adb_request * req , int sync ) { int i , ret ; if ( pmu_state == uninitialized || ! pmu_fully_inited ) { return - ENXIO ; } ret = - EINVAL ; switch ( req -> data [ 0 ] ) { case PMU_PACKET : for ( i = 0 ; i < req -> nbytes - 1 ; ++ i ) { req -> data [ i ] = req -> data [ i + 1 ] ; } -- req -> nbytes ; if ( pmu_data_len [ req -> data [ 0 ] ] [ 1 ] != 0 ) { req -> reply [ 0 ] = ADB_RET_OK ; req -> reply_len = 1 ; } else { req -> reply_len = 0 ; } ret = pmu_queue_request ( req ) ; break ; case CUDA_PACKET : switch ( req -> data [ 1 ] ) { case CUDA_GET_TIME : if ( req -> nbytes != 2 ) { break ; } req -> data [ 0 ] = PMU_READ_RTC ; req -> nbytes = 1 ; req -> reply_len = 3 ; req -> reply [ 0 ] = CUDA_PACKET ; req -> reply [ 1 ] = 0 ; req -> reply [ 2 ] = CUDA_GET_TIME ; ret = pmu_queue_request ( req ) ; break ; case CUDA_SET_TIME : if ( req -> nbytes != 6 ) { break ; } req -> data [ 0 ] = PMU_SET_RTC ; req -> nbytes = 5 ; for ( i = 1 ; i <= 4 ; ++ i ) { req -> data [ i ] = req -> data [ i + 1 ] ; } req -> reply_len = 3 ; req -> reply [ 0 ] = CUDA_PACKET ; req -> reply [ 1 ] = 0 ; req -> reply [ 2 ] = CUDA_SET_TIME ; ret = pmu_queue_request ( req ) ; break ; } break ; case ADB_PACKET : if ( ! pmu_has_adb ) { return - ENXIO ; } for ( i = req -> nbytes - 1 ; i > 1 ; -- i ) { req -> data [ i + 2 ] = req -> data [ i ] ; } req -> data [ 3 ] = req -> nbytes - 2 ; req -> data [ 2 ] = pmu_adb_flags ; req -> data [ 0 ] = PMU_ADB_CMD ; req -> nbytes += 2 ; req -> reply_expected = 1 ; req -> reply_len = 0 ; ret = pmu_queue_request ( req ) ; break ; } if ( ret ) { req -> complete = 1 ; return ret ; } if ( sync ) { while ( ! req -> complete ) { pmu_poll ( ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int qcom_hfpll_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; void __iomem * base ; struct regmap * regmap ; struct clk_hfpll * h ; struct clk_init_data init = { . num_parents = 1 . ops = & clk_ops_hfpll . flags = CLK_IGNORE_UNUSED } ; int ret ; struct clk_parent_data pdata = { . index = 0 } ; h = devm_kzalloc ( dev , sizeof ( * h ) , GFP_KERNEL ) ; base = devm_platform_get_and_ioremap_resource ( pdev , 0 , NULL ) ; if ( IS_ERR ( base ) ) { return PTR_ERR ( base ) ; } regmap = devm_regmap_init_mmio ( & pdev -> dev , base , & hfpll_regmap_config ) ; if ( IS_ERR ( regmap ) ) { return PTR_ERR ( regmap ) ; } if ( of_property_read_string_index ( dev -> of_node , \"clock-output-names\" , 0 , & init . name ) ) { return - ENODEV ; } init . parent_data = & pdata ; h -> d = & hdata ; h -> clkr . hw . init = & init ; spin_lock_init ( & h -> lock ) ; ret = devm_clk_register_regmap ( dev , & h -> clkr ) ; if ( ret ) { dev_err ( dev , \"failed to register regmap clock: %d\\n\" , ret ) ; return ret ; } return devm_of_clk_add_hw_provider ( dev , of_clk_hw_simple_get , & h -> clkr . hw ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void credential_free ( Credential * cred ) { assert ( cred ) ; cred -> id = mfree ( cred -> id ) ; cred -> size = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static enum drm_mode_status sun4i_hdmi_mode_valid ( struct drm_encoder * encoder , const struct drm_display_mode * mode ) { struct sun4i_hdmi * hdmi = drm_encoder_to_sun4i_hdmi ( encoder ) ; unsigned long rate = mode -> clock * 1000 ; unsigned long diff = rate / 200 ; long rounded_rate ; rounded_rate = clk_round_rate ( hdmi -> tmds_clk , rate ) ; if ( rounded_rate > 0 && max_t ( , , ) - min_t ( , , ) < diff ) { return MODE_OK ; } return MODE_NOCLOCK ; } static const struct drm_encoder_helper_funcs sun4i_hdmi_helper_funcs = { . atomic_check = sun4i_hdmi_atomic_check . disable = sun4i_hdmi_disable . enable = sun4i_hdmi_enable . mode_set = sun4i_hdmi_mode_set . mode_valid = sun4i_hdmi_mode_valid } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int qe_uec_set_uec_info ( struct udevice * dev ) { struct qe_uec_priv * priv = dev_get_priv ( dev ) ; struct eth_pdata * pdata = dev_get_plat ( dev ) ; struct uec_priv * uec = priv -> uec ; struct uec_inf * uec_info ; struct ucc_fast_inf * uf_info ; const char * s ; int ret ; u32 val ; uec_info = ( uec_inf * ) malloc ( sizeof ( uec_inf ) ) ; if ( ! uec_info ) { return - ENOMEM ; } uf_info = & uec_info -> uf_info ; ret = dev_read_u32 ( dev , \"cell-index\" , & val ) ; if ( ret ) { ret = dev_read_u32 ( dev , \"device-id\" , & val ) ; if ( ret ) { pr_err ( \"no cell-index nor device-id found!\" ) ; out } } uf_info -> ucc_num = val - 1 ; if ( uf_info -> ucc_num ( 0 || uf_info -> ucc_num ) 7 ) { ret = - ENODEV ; out } ret = dev_read_string_index ( dev , \"rx-clock-name\" , 0 , & s ) ; if ( ! ret ) { uf_info -> rx_clock = qe_clock_source ( s ) ; if ( uf_info -> rx_clock ( QE_CLK_NONE || uf_info -> rx_clock ) QE_CLK24 ) { pr_err ( \"invalid rx-clock-name property\\n\" ) ; ret = - EINVAL ; out } } else { ret = dev_read_u32 ( dev , \"rx-clock\" , & val ) ; if ( ret ) { pr_err ( \"missing rx-clock-name property\\n\" ) ; out } if ( val ( QE_CLK_NONE || val ) QE_CLK24 ) { pr_err ( \"invalid rx-clock property\\n\" ) ; ret = - EINVAL ; out } uf_info -> rx_clock = val ; } ret = dev_read_string_index ( dev , \"tx-clock-name\" , 0 , & s ) ; if ( ! ret ) { uf_info -> tx_clock = qe_clock_source ( s ) ; if ( uf_info -> tx_clock ( QE_CLK_NONE || uf_info -> tx_clock ) QE_CLK24 ) { pr_err ( \"invalid tx-clock-name property\\n\" ) ; ret = - EINVAL ; out } } else { ret = dev_read_u32 ( dev , \"tx-clock\" , & val ) ; if ( ret ) { pr_err ( \"missing tx-clock-name property\\n\" ) ; out } if ( val ( QE_CLK_NONE || val ) QE_CLK24 ) { pr_err ( \"invalid tx-clock property\\n\" ) ; ret = - EINVAL ; out } uf_info -> tx_clock = val ; } uec_info -> num_threads_tx = UEC_NUM_OF_THREADS_1 ; uec_info -> num_threads_rx = UEC_NUM_OF_THREADS_1 ; uec_info -> risc_tx = QE_RISC_ALLOCATION_RISC1_AND_RISC2 ; uec_info -> risc_rx = QE_RISC_ALLOCATION_RISC1_AND_RISC2 ; uec_info -> tx_bd_ring_len = 16 ; uec_info -> rx_bd_ring_len = 16 ; uec_info -> risc_tx = QE_RISC_ALLOCATION_FOUR_RISCS ; uec_info -> risc_rx = QE_RISC_ALLOCATION_FOUR_RISCS ; uec_info -> enet_interface_type = pdata -> phy_interface ; uec -> uec_info = uec_info ; qe_uec_set_eth_type ( dev ) ; return 0 ; out return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sm_cwa_securize_apdu ( struct sc_context * ctx , struct sm_info * sm_info , struct sc_remote_apdu * rapdu ) { struct sm_cwa_session * session_data = & sm_info -> session . cwa ; struct sc_apdu * apdu = & rapdu -> apdu ; unsigned char sbuf [ 0x400 ] ; sm_des_cblock cblock , icv ; unsigned char * encrypted = NULL , edfb_data [ 0x200 ] , mac_data [ 0x200 ] ; size_t encrypted_len , edfb_len = 0 , mac_len = 0 , offs ; int rv ; LOG_FUNC_CALLED ( ctx ) ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"securize APDU (cla:%X,ins:%X,p1:%X,p2:%X,data(%\" SC_FORMAT_LEN_SIZE_T \"u):%p)\" , apdu -> cla , apdu -> ins , apdu -> p1 , apdu -> p2 , apdu -> datalen , apdu -> data ) ; sm_incr_ssc ( session_data -> ssc , sizeof ( session_data -> ssc ) ) ; rv = sm_encrypt_des_cbc3 ( ctx , session_data -> session_enc , apdu -> data , apdu -> datalen , & encrypted , & encrypted_len , 0 ) ; LOG_TEST_RET ( ctx , rv , \"securize APDU: DES CBC3 encryption failed\" ) ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"encrypted data (len:%\" SC_FORMAT_LEN_SIZE_T \"u, %s)\" , encrypted_len , sc_dump_hex ( encrypted , encrypted_len ) ) ; offs = 0 ; if ( apdu -> ins & 0x01 ) { edfb_data [ offs ++ ] = IASECC_SM_DO_TAG_TCG_ODD_INS ; if ( encrypted_len + 1 > 0x7F ) { edfb_data [ offs ++ ] = 0x81 ; } edfb_data [ offs ++ ] = encrypted_len ; } else { edfb_data [ offs ++ ] = IASECC_SM_DO_TAG_TCG_EVEN_INS ; if ( encrypted_len + 1 > 0x7F ) { edfb_data [ offs ++ ] = 0x81 ; } edfb_data [ offs ++ ] = encrypted_len + 1 ; edfb_data [ offs ++ ] = 0x01 ; } memcpy ( edfb_data + offs , encrypted , encrypted_len ) ; offs += encrypted_len ; edfb_len = offs ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"securize APDU: EDFB(len:%\" SC_FORMAT_LEN_SIZE_T \"u,%s)\" , edfb_len , sc_dump_hex ( edfb_data , edfb_len ) ) ; encrypted = NULL ; offs = 0 ; memcpy ( mac_data + offs , session_data -> ssc , 8 ) ; offs += 8 ; mac_data [ offs ++ ] = apdu -> cla | 0x0C ; mac_data [ offs ++ ] = apdu -> ins ; mac_data [ offs ++ ] = apdu -> p1 ; mac_data [ offs ++ ] = apdu -> p2 ; mac_data [ offs ++ ] = 0x80 ; mac_data [ offs ++ ] = 0x00 ; mac_data [ offs ++ ] = 0x00 ; mac_data [ offs ++ ] = 0x00 ; memcpy ( mac_data + offs , edfb_data , edfb_len ) ; offs += edfb_len ; mac_data [ offs ++ ] = IASECC_SM_DO_TAG_TLE ; mac_data [ offs ++ ] = 1 ; mac_data [ offs ++ ] = apdu -> le ; mac_len = offs ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"securize APDU: MAC data(len:%\" SC_FORMAT_LEN_SIZE_T \"u,%s)\" , mac_len , sc_dump_hex ( mac_data , mac_len ) ) ; memset ( icv , 0 , sizeof ( icv ) ) ; rv = sm_cwa_get_mac ( ctx , session_data -> session_mac , & icv , mac_data , mac_len , & cblock , 0 ) ; LOG_TEST_RET ( ctx , rv , \"securize APDU: MAC calculation error\" ) ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"securize APDU: MAC:%s\" , sc_dump_hex ( cblock , sizeof ( cblock ) ) ) ; offs = 0 ; if ( edfb_len ) { memcpy ( sbuf + offs , edfb_data , edfb_len ) ; offs += edfb_len ; } sbuf [ offs ++ ] = IASECC_SM_DO_TAG_TLE ; sbuf [ offs ++ ] = 1 ; sbuf [ offs ++ ] = apdu -> le ; sbuf [ offs ++ ] = IASECC_SM_DO_TAG_TCC ; sbuf [ offs ++ ] = 8 ; memcpy ( sbuf + offs , cblock , 8 ) ; offs += 8 ; sc_debug ( ctx , SC_LOG_DEBUG_SM , \"securize APDU: SM data(len:%\" SC_FORMAT_LEN_SIZE_T \"u,%s)\" , offs , sc_dump_hex ( sbuf , offs ) ) ; if ( offs > sizeof ( rapdu -> sbuf ) ) { LOG_TEST_RET ( ctx , SC_ERROR_BUFFER_TOO_SMALL , \"securize APDU: buffer too small for encrypted data\" ) ; } apdu -> cse = SC_APDU_CASE_4_SHORT ; apdu -> cla |= 0x0C ; apdu -> lc = offs ; apdu -> datalen = offs ; memcpy ( ( unsigned char * ) apdu -> data , sbuf , offs ) ; sm_incr_ssc ( session_data -> ssc , sizeof ( session_data -> ssc ) ) ; LOG_FUNC_RETURN ( ctx , SC_SUCCESS ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void board_boot_order ( u32 * spl_boot_list ) { int i ; u32 boot_devices [ ] { BOOT_DEVICE_MMC1 } ; ; for ( i = 0 ; i < ARRAY_SIZE ( boot_devices ) ; i ++ ) { spl_boot_list [ i ] = boot_devices [ i ] ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int smu_v13_0_5_od_edit_dpm_table ( struct smu_context * smu , enum PP_OD_DPM_TABLE_COMMAND type , long input [ ] , uint32_t size ) { struct smu_dpm_context * smu_dpm = & ( smu -> smu_dpm ) ; int ret = 0 ; switch ( type ) { case PP_OD_EDIT_SCLK_VDDC_TABLE : if ( size != 2 ) { dev_err ( smu -> adev -> dev , \"Input parameter number not correct\\n\" ) ; return - EINVAL ; } if ( input [ 0 ] == 0 ) { if ( input [ 1 ] < smu -> gfx_default_hard_min_freq ) { dev_warn ( smu -> adev -> dev , \"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\" , input [ 1 ] , smu -> gfx_default_hard_min_freq ) ; return - EINVAL ; } smu -> gfx_actual_hard_min_freq = input [ 1 ] ; } if ( input [ 0 ] == 1 ) { if ( input [ 1 ] > smu -> gfx_default_soft_max_freq ) { dev_warn ( smu -> adev -> dev , \"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\" , input [ 1 ] , smu -> gfx_default_soft_max_freq ) ; return - EINVAL ; } smu -> gfx_actual_soft_max_freq = input [ 1 ] ; } else { return - EINVAL ; } break ; case PP_OD_RESTORE_DEFAULT_TABLE : if ( size != 0 ) { dev_err ( smu -> adev -> dev , \"Input parameter number not correct\\n\" ) ; return - EINVAL ; } else { smu -> gfx_actual_hard_min_freq = smu -> gfx_default_hard_min_freq ; smu -> gfx_actual_soft_max_freq = smu -> gfx_default_soft_max_freq ; } break ; case PP_OD_COMMIT_DPM_TABLE : if ( size != 0 ) { dev_err ( smu -> adev -> dev , \"Input parameter number not correct\\n\" ) ; return - EINVAL ; } else { if ( smu -> gfx_actual_hard_min_freq > smu -> gfx_actual_soft_max_freq ) { dev_err ( smu -> adev -> dev , \"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\" , smu -> gfx_actual_hard_min_freq , smu -> gfx_actual_soft_max_freq ) ; return - EINVAL ; } ret = smu_cmn_send_smc_msg_with_param ( smu , SMU_MSG_SetHardMinGfxClk , smu -> gfx_actual_hard_min_freq , NULL ) ; if ( ret ) { dev_err ( smu -> adev -> dev , \"Set hard min sclk failed!\" ) ; return ret ; } ret = smu_cmn_send_smc_msg_with_param ( smu , SMU_MSG_SetSoftMaxGfxClk , smu -> gfx_actual_soft_max_freq , NULL ) ; if ( ret ) { dev_err ( smu -> adev -> dev , \"Set soft max sclk failed!\" ) ; return ret ; } } break ; default : return - ENOSYS ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void wait_running ( const struct varnish * v ) { char * r = NULL ; enum VCLI_status_e st ; while ( 1 ) { vtc_log ( v -> vl , 3 , \"wait-running\" ) ; st = varnish_ask_cli ( v , \"status\" , & r ) ; if ( st != CLIS_OK ) { vtc_fatal ( v -> vl , \"CLI status command failed: %u %s\" , st , r ) ; } if ( ! strcmp ( r , \"Child in state stopped\" ) ) { vtc_fatal ( v -> vl , \"Child stopped before running: %u %s\" , st , r ) ; } if ( ! strcmp ( r , \"Child in state running\" ) ) { r = NULL ; st = varnish_ask_cli ( v , \"debug.listen_address\" , & r ) ; if ( st != CLIS_OK ) { vtc_fatal ( v -> vl , \"CLI status command failed: %u %s\" , st , r ) ; } free ( r ) ; break ; } free ( r ) ; r = NULL ; ( void ) usleep ( 200000 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cxgbit_ofld_send ( struct cxgbit_device * cdev , struct sk_buff * skb ) { int ret = 0 ; if ( ! test_bit ( CDEV_STATE_UP , & cdev -> flags ) ) { pr_err ( \"%s - device not up - dropping\\n\" , __func__ ) ; return - EIO ; } ret = cxgb4_ofld_send ( cdev -> lldi . ports [ 0 ] , skb ) ; if ( ret < 0 ) { kfree_skb ( skb ) ; } return ret < 0 ?ret : 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int parse_table ( char * line , command_t * command ) { char * tok = NULL ; char * tnametok = NULL ; char * last = NULL ; tok = strtok_r ( line , WHITESPACE , & last ) ; tnametok = strtok_r ( last , WHITESPACE , & last ) ; if ( tnametok == NULL ) { return ( EC_INSUFFICIENT_TOKEN ) ; } command -> tablecmd_tname = strdup ( tnametok ) ; if ( command -> tablecmd_tname == NULL ) { return ( EC_FAILURE ) ; } command -> tablecmd_newtbl = 0 ; command -> tablecmd_tblh = 0 ; return ( EC_SYNTAX_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tegra210_bpmp_ring_doorbell ( struct tegra_bpmp * bpmp ) { struct tegra210_bpmp * priv = bpmp -> priv ; struct irq_data * irq_data = priv -> tx_irq_data ; return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void class_compat_unregister ( struct class_compat * cls ) { kobject_put ( cls -> kobj ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int soc_tplg_dmixer_create ( struct soc_tplg * tplg , unsigned int count , size_t size ) { struct snd_soc_tplg_mixer_control * mc ; struct soc_mixer_control * sm ; struct snd_kcontrol_new kc ; int i , err ; if ( soc_tplg_check_elem_count ( tplg , sizeof ( snd_soc_tplg_mixer_control ) , count , size , \"mixers\" ) ) { dev_err ( tplg -> dev , \"ASoC: invalid count %d for controls\\n\" , count ) ; return - EINVAL ; } for ( i = 0 ; i < count ; i ++ ) { mc = ( snd_soc_tplg_mixer_control * ) tplg -> pos ; if ( strnlen ( mc -> hdr . name , SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) == SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) { return - EINVAL ; } sm = kzalloc ( sizeof ( * sm ) , GFP_KERNEL ) ; if ( sm == NULL ) { return - ENOMEM ; } tplg -> pos += ( sizeof ( snd_soc_tplg_mixer_control ) + mc -> priv . size ) ; dev_dbg ( tplg -> dev , \"ASoC: adding mixer kcontrol %s with access 0x%x\\n\" , mc -> hdr . name , mc -> hdr . access ) ; kc . name = mc -> hdr . name ; kc . private_value = ( long ) sm ; kc . iface = SNDRV_CTL_ELEM_IFACE_MIXER ; kc . access = mc -> hdr . access ; sm -> reg = tplc_chan_get_reg ( tplg , mc -> channel , SNDRV_CHMAP_FL ) ; sm -> rreg = tplc_chan_get_reg ( tplg , mc -> channel , SNDRV_CHMAP_FR ) ; sm -> shift = tplc_chan_get_shift ( tplg , mc -> channel , SNDRV_CHMAP_FL ) ; sm -> rshift = tplc_chan_get_shift ( tplg , mc -> channel , SNDRV_CHMAP_FR ) ; sm -> max = mc -> max ; sm -> min = mc -> min ; sm -> invert = mc -> invert ; sm -> platform_max = mc -> platform_max ; sm -> dobj . index = tplg -> index ; sm -> dobj . ops = tplg -> ops ; sm -> dobj . type = SND_SOC_DOBJ_MIXER ; INIT_LIST_HEAD ( & sm -> dobj . list ) ; err = soc_tplg_kcontrol_bind_io ( & mc -> hdr , & kc , tplg ) ; if ( err ) { soc_control_err ( tplg , & mc -> hdr , mc -> hdr . name ) ; kfree ( sm ) ; continue ; } err = soc_tplg_init_kcontrol ( tplg , & kc , ( snd_soc_tplg_ctl_hdr * ) mc ) ; if ( err < 0 ) { dev_err ( tplg -> dev , \"ASoC: failed to init %s\\n\" , mc -> hdr . name ) ; kfree ( sm ) ; continue ; } soc_tplg_create_tlv ( tplg , & kc , & mc -> hdr ) ; err = soc_tplg_add_kcontrol ( tplg , & kc , & sm -> dobj . control . kcontrol ) ; if ( err < 0 ) { dev_err ( tplg -> dev , \"ASoC: failed to add %s\\n\" , mc -> hdr . name ) ; soc_tplg_free_tlv ( tplg , & kc ) ; kfree ( sm ) ; continue ; } list_add ( & sm -> dobj . list , & tplg -> comp -> dobj_list ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "test_rotate ( ) { const gchar * filename = data ; const gchar * path ; GError * error = NULL ; GdkPixbuf * ref ; GdkPixbuf * pixbuf ; if ( ! format_supported ( filename ) ) { g_test_skip ( \"format not supported\" ) ; return ; } path = g_test_get_filename ( G_TEST_DIST , filename , NULL ) ; ref = gdk_pixbuf_new_from_file ( path , & error ) ; if ( skip_if_insufficient_memory ( & error ) ) { return ; } g_assert_no_error ( error ) ; pixbuf = gdk_pixbuf_rotate_simple ( ref , GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE ) ; if ( pixbuf == NULL ) { g_test_skip ( \"Couldn't rotate the image - your system probably lacks sufficient memory.\" ) ; } else { g_object_unref ( pixbuf ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct dentry * debugfs_create_devm_seqfile ( struct device * dev , const char * name , struct dentry * parent , int * read_fn ( struct seq_file * s , void * data ) ) { struct debugfs_devm_entry * entry ; if ( IS_ERR ( parent ) ) { return ERR_PTR ( - ENOENT ) ; } entry = devm_kzalloc ( dev , sizeof ( * entry ) , GFP_KERNEL ) ; entry -> read = read_fn ; entry -> dev = dev ; return debugfs_create_file ( name , S_IRUGO , parent , entry , & debugfs_devm_entry_ops ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void run_rec_bench ( void ) { char * * impl_name ; LOG ( D_INFO , DBLSEP \"\\nBenchmarking data reconstruction...\\n\\n\" ) ; LOG ( D_ALL , \"impl, math, dcols, iosize, disk_bw, total_bw, iter\\n\" ) ; for ( impl_name = ( char * * ) raidz_impl_names ; * impl_name != NULL ; impl_name ++ ) { run_rec_bench_impl ( * impl_name ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sppp_kstat_update ( kstat_t * ksp , int rw ) { register sppa_t * ppa ; register sppp_kstats_t * pppkp ; register struct pppstat64 * sp ; ppa = ( sppa_t * ) ksp -> ks_private ; ASSERT ( ppa != NULL ) ; pppkp = ( sppp_kstats_t * ) ksp -> ks_data ; sp = & ppa -> ppa_stats . p ; mutex_enter ( & ppa -> ppa_sta_lock ) ; pppkp -> allocbfail . value . ui32 = ppa -> ppa_allocbfail ; pppkp -> mctlsfwd . value . ui32 = ppa -> ppa_mctlsfwd ; pppkp -> mctlsfwderr . value . ui32 = ppa -> ppa_mctlsfwderr ; pppkp -> rbytes . value . ui32 = sp -> ppp_ibytes ; pppkp -> rbytes64 . value . ui64 = sp -> ppp_ibytes ; pppkp -> ierrors . value . ui32 = sp -> ppp_ierrors ; pppkp -> ierrors_lower . value . ui32 = ppa -> ppa_ierr_low ; pppkp -> ioctlsfwd . value . ui32 = ppa -> ppa_ioctlsfwd ; pppkp -> ioctlsfwdok . value . ui32 = ppa -> ppa_ioctlsfwdok ; pppkp -> ioctlsfwderr . value . ui32 = ppa -> ppa_ioctlsfwderr ; pppkp -> ipackets . value . ui32 = sp -> ppp_ipackets ; pppkp -> ipackets64 . value . ui64 = sp -> ppp_ipackets ; pppkp -> ipackets_ctl . value . ui32 = ppa -> ppa_ipkt_ctl ; pppkp -> iqdropped . value . ui32 = ppa -> ppa_iqdropped ; pppkp -> irunts . value . ui32 = ppa -> ppa_irunts ; pppkp -> itoolongs . value . ui32 = ppa -> ppa_itoolongs ; pppkp -> lsneedup . value . ui32 = ppa -> ppa_lsneedup ; pppkp -> lsdown . value . ui32 = ppa -> ppa_lsdown ; pppkp -> mctlsknown . value . ui32 = ppa -> ppa_mctlsknown ; pppkp -> mctlsunknown . value . ui32 = ppa -> ppa_mctlsunknown ; pppkp -> obytes . value . ui32 = sp -> ppp_obytes ; pppkp -> obytes64 . value . ui64 = sp -> ppp_obytes ; pppkp -> oerrors . value . ui32 = sp -> ppp_oerrors ; pppkp -> oerrors_lower . value . ui32 = ppa -> ppa_oerr_low ; pppkp -> opackets . value . ui32 = sp -> ppp_opackets ; pppkp -> opackets64 . value . ui64 = sp -> ppp_opackets ; pppkp -> opackets_ctl . value . ui32 = ppa -> ppa_opkt_ctl ; pppkp -> oqdropped . value . ui32 = ppa -> ppa_oqdropped ; pppkp -> otoolongs . value . ui32 = ppa -> ppa_otoolongs ; pppkp -> orunts . value . ui32 = ppa -> ppa_orunts ; mutex_exit ( & ppa -> ppa_sta_lock ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xhci_mtk_host_enable ( struct xhci_hcd_mtk * mtk ) { struct mu3c_ippc_regs __iomem * ippc = mtk -> ippc_regs ; u32 value , check_val ; int u3_ports_disabled = 0 ; int ret ; int i ; value = readl ( & ippc -> ip_pw_ctr1 ) ; value &= ~ CTRL1_IP_HOST_PDN ; writel ( value , & ippc -> ip_pw_ctr1 ) ; for ( i = 0 ; i < mtk -> num_u3_ports ; i ++ ) { if ( ( 0x1 << i ) & mtk -> u3p_dis_msk ) { u3_ports_disabled ++ ; continue ; } value = readl ( & ippc -> u3_ctrl_p [ i ] ) ; value &= ~ ( CTRL_U3_PORT_PDN | CTRL_U3_PORT_DIS ) ; value |= CTRL_U3_PORT_HOST_SEL ; writel ( value , & ippc -> u3_ctrl_p [ i ] ) ; } for ( i = 0 ; i < mtk -> num_u2_ports ; i ++ ) { if ( BIT ( i ) & mtk -> u2p_dis_msk ) { continue ; } value = readl ( & ippc -> u2_ctrl_p [ i ] ) ; value &= ~ ( CTRL_U2_PORT_PDN | CTRL_U2_PORT_DIS ) ; value |= CTRL_U2_PORT_HOST_SEL ; writel ( value , & ippc -> u2_ctrl_p [ i ] ) ; } check_val = STS1_SYSPLL_STABLE | STS1_REF_RST | STS1_SYS125_RST | STS1_XHCI_RST ; if ( mtk -> num_u3_ports > u3_ports_disabled ) { check_val |= STS1_U3_MAC_RST ; } ret = readl_poll_timeout ( & ippc -> ip_pw_sts1 , value , ( check_val == ( value & check_val ) ) , 100 , 20000 ) ; if ( ret ) { dev_err ( mtk -> dev , \"clocks are not stable (0x%x)\\n\" , value ) ; return ret ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void prism2_info_commtallies32 ( local_info_t * local , unsigned char * buf , int left ) { struct hfa384x_comm_tallies32 * tallies ; if ( left < sizeof ( hfa384x_comm_tallies32 ) ) { printk ( KERN_DEBUG \"%s: too short (len=%d) commtallies32 \" \"info frame\\n\" , local -> dev -> name , left ) ; return ; } tallies = ( hfa384x_comm_tallies32 * ) buf ; local -> comm_tallies . name += le32_to_cpu ( ) ADD_COMM_TALLIES ( tx_unicast_frames ) ; ADD_COMM_TALLIES ( tx_multicast_frames ) ; ADD_COMM_TALLIES ( tx_fragments ) ; ADD_COMM_TALLIES ( tx_unicast_octets ) ; ADD_COMM_TALLIES ( tx_multicast_octets ) ; ADD_COMM_TALLIES ( tx_deferred_transmissions ) ; ADD_COMM_TALLIES ( tx_single_retry_frames ) ; ADD_COMM_TALLIES ( tx_multiple_retry_frames ) ; ADD_COMM_TALLIES ( tx_retry_limit_exceeded ) ; ADD_COMM_TALLIES ( tx_discards ) ; ADD_COMM_TALLIES ( rx_unicast_frames ) ; ADD_COMM_TALLIES ( rx_multicast_frames ) ; ADD_COMM_TALLIES ( rx_fragments ) ; ADD_COMM_TALLIES ( rx_unicast_octets ) ; ADD_COMM_TALLIES ( rx_multicast_octets ) ; ADD_COMM_TALLIES ( rx_fcs_errors ) ; ADD_COMM_TALLIES ( rx_discards_no_buffer ) ; ADD_COMM_TALLIES ( tx_discards_wrong_sa ) ; ADD_COMM_TALLIES ( rx_discards_wep_undecryptable ) ; ADD_COMM_TALLIES ( rx_message_in_msg_fragments , NULL ) ; ADD_COMM_TALLIES ( rx_message_in_bad_msg_fragments ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int omap_rproc_get_boot_data ( struct platform_device * pdev , struct rproc * rproc ) { struct device_node * np = pdev -> dev . of_node ; struct omap_rproc * oproc = rproc -> priv ; const struct omap_rproc_dev_data * data ; int ret ; data = of_device_get_match_data ( & pdev -> dev ) ; if ( ! data ) { return - ENODEV ; } if ( ! of_property_read_bool ( np , \"ti,bootreg\" ) ) { return 0 ; } oproc -> boot_data = devm_kzalloc ( & pdev -> dev , sizeof ( * oproc -> boot_data ) , GFP_KERNEL ) ; oproc -> boot_data -> syscon = syscon_regmap_lookup_by_phandle ( np , \"ti,bootreg\" ) ; if ( IS_ERR ( oproc -> boot_data -> syscon ) ) { ret = PTR_ERR ( oproc -> boot_data -> syscon ) ; return ret ; } if ( of_property_read_u32_index ( np , \"ti,bootreg\" , 1 , & oproc -> boot_data -> boot_reg ) ) { dev_err ( & pdev -> dev , \"couldn't get the boot register\\n\" ) ; return - EINVAL ; } of_property_read_u32_index ( np , \"ti,bootreg\" , 2 , & oproc -> boot_data -> boot_reg_shift ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void kprobe_flush_task ( struct task_struct * tk ) { struct kretprobe_instance * ri ; struct llist_node * node ; kprobe_busy_begin ( ) ; node = __llist_del_all ( & tk -> kretprobe_instances ) ; while ( node ) { ri = container_of ( node , kretprobe_instance , llist ) ; node = node -> next ; recycle_rp_inst ( ri ) ; } kprobe_busy_end ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mpl2_read_header ( AVFormatContext * s ) { MPL2Context * mpl2 = s -> priv_data ; AVStream * st = avformat_new_stream ( s , NULL ) ; avpriv_set_pts_info ( st , 64 , 1 , 10 ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_SUBTITLE ; st -> codecpar -> codec_id = AV_CODEC_ID_MPL2 ; if ( avio_rb24 ( s -> pb ) != 0xefbbbf ) { avio_seek ( s -> pb , - 3 , SEEK_CUR ) ; } while ( ! avio_feof ( s -> pb ) ) { char line [ 4096 ] ; char * p = line ; const int64_t pos = avio_tell ( s -> pb ) ; int len = ff_get_line ( s -> pb , line , sizeof ( line ) ) ; int64_t pts_start ; int64_t duration ; if ( ! len ) { break ; } line [ strcspn ( line , \"\\r\\n\" ) ] = 0 ; if ( ! read_ts ( & p , & pts_start , & duration ) ) { AVPacket * sub ; sub = ff_subtitles_queue_insert ( & mpl2 -> q , p , strlen ( p ) , 0 ) ; if ( ! sub ) { return AVERROR ( ENOMEM ) ; } sub -> pos = pos ; sub -> pts = pts_start ; sub -> duration = duration ; } } ff_subtitles_queue_finalize ( s , & mpl2 -> q ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * expand_filename_append_dvi ( const char * filename , expandPathTypeT type , Boolean must_exist ) { char canonical_path [ MAXPATHLEN + 1 ] ; char * normalized_fname = filename_append_dvi ( filename ) ; char * expanded_fname = expand_filename ( normalized_fname , type ) ; if ( must_exist ) { char * canonical_name = REALPATH ( expanded_fname , canonical_path ) ; free ( normalized_fname ) ; return xstrdup ( canonical_name ) ; } else { free ( normalized_fname ) ; return expanded_fname ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void xor_path ( potrace_bitmap_t * bm , path_t * p ) { int xa , x , y , k , y1 ; y1 = p -> priv -> pt [ p -> priv -> len - 1 ] . y ; xa = p -> priv -> pt [ 0 ] . x & - BM_WORDBITS ; for ( k = 0 ; k < p -> priv -> len ; k ++ ) { x = p -> priv -> pt [ k ] . x ; y = p -> priv -> pt [ k ] . y ; if ( y != y1 ) { xor_to_ref ( bm , x , min ( y , y1 ) , xa ) ; y1 = y ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int adm9240_probe ( struct i2c_client * new_client , const struct i2c_device_id * id ) { struct device * dev = & new_client -> dev ; struct device * hwmon_dev ; struct adm9240_data * data ; data = devm_kzalloc ( dev , sizeof ( * data ) , GFP_KERNEL ) ; i2c_set_clientdata ( new_client , data ) ; data -> client = new_client ; mutex_init ( & data -> update_lock ) ; adm9240_init_client ( new_client ) ; hwmon_dev = devm_hwmon_device_register_with_groups ( dev , new_client -> name , data , adm9240_groups ) ; return PTR_ERR_OR_ZERO ( hwmon_dev ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static gboolean lte_rlc_pseudo_hdr ( char * option_str , packet_info * pinfo , guint16 length , packet_direction_t direction ) { struct rlc_lte_info * p_rlc_lte_info ; char * par_opt_field ; char option [ 30 ] ; static int proto_rlc_lte = 0 ; if ( proto_rlc_lte == 0 ) { proto_rlc_lte = proto_get_id_by_filter_name ( \"rlc-lte\" ) ; } ( void ) g_strlcpy ( option , option_str , 30 ) ; p_rlc_lte_info = ( rlc_lte_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc_lte , 0 ) ; if ( p_rlc_lte_info != NULL ) { return 1 ; } p_rlc_lte_info = ( rlc_lte_info * ) wmem_new0 ( pinfo -> pool , rlc_lte_info ) ; par_opt_field = strtok ( option , \" \" ) ; if ( strcmp ( par_opt_field , \"SRB\" ) == 0 ) { p_rlc_lte_info -> channelType = CHANNEL_TYPE_SRB ; } if ( strcmp ( par_opt_field , \"DRB\" ) == 0 ) { p_rlc_lte_info -> channelType = CHANNEL_TYPE_DRB ; } else { return 0 ; } par_opt_field = strtok ( NULL , \" \" ) ; if ( par_opt_field == NULL ) { return 0 ; } ws_strtou16 ( par_opt_field , NULL , & p_rlc_lte_info -> channelId ) ; par_opt_field = strtok ( NULL , \" \" ) ; if ( par_opt_field == NULL ) { return 0 ; } if ( strcmp ( par_opt_field , \"TM\" ) == 0 ) { p_rlc_lte_info -> rlcMode = RLC_TM_MODE ; } if ( strcmp ( par_opt_field , \"UM\" ) == 0 ) { p_rlc_lte_info -> rlcMode = RLC_UM_MODE ; } if ( strcmp ( par_opt_field , \"AM\" ) == 0 ) { p_rlc_lte_info -> rlcMode = RLC_AM_MODE ; } if ( strcmp ( par_opt_field , \"NA\" ) == 0 ) { p_rlc_lte_info -> rlcMode = RLC_PREDEF ; } else { return 0 ; } par_opt_field = strtok ( NULL , \" \" ) ; if ( par_opt_field != NULL ) { if ( strcmp ( par_opt_field , \"SN_5b\" ) == 0 ) { p_rlc_lte_info -> sequenceNumberLength = UM_SN_LENGTH_5_BITS ; } if ( strcmp ( par_opt_field , \"SN_10b\" ) == 0 ) { p_rlc_lte_info -> sequenceNumberLength = UM_SN_LENGTH_10_BITS ; } } p_rlc_lte_info -> direction = ( direction == UPLINK ) ?DIRECTION_UPLINK : DIRECTION_DOWNLINK ; p_rlc_lte_info -> priority = 0 ; p_rlc_lte_info -> ueid = 0 ; p_rlc_lte_info -> pduLength = length ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc_lte , 0 , p_rlc_lte_info ) ; return ( 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rafind_open_dir ( RafindOptions * ro , const char * dir ) { RListIter * iter ; char * fullpath ; char * fname = NULL ; RList * files = r_sys_dir ( dir ) ; if ( files ) { r_list_foreach ( , , ) { if ( * fname == '.' ) { continue ; } fullpath = r_str_newf ( \"%s\" R_SYS_DIR \"%s\" , dir , fname ) ; ( void ) rafind_open ( ro , fullpath ) ; } r_list_free ( files ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int fsl_asrc_set_ideal_ratio ( struct fsl_asrc_pair * pair , int inrate , int outrate ) { struct fsl_asrc * asrc_priv = pair -> asrc_priv ; enum asrc_pair_index index = pair -> index ; cfs_time_t ratio ; int i ; if ( ! outrate ) { pair_err ( \"output rate should not be zero\\n\" ) ; return - EINVAL ; } ratio = ( inrate / outrate ) << IDEAL_RATIO_DECIMAL_DEPTH ; inrate %= outrate ; for ( i = 1 ; i <= IDEAL_RATIO_DECIMAL_DEPTH ; i ++ ) { inrate <<= 1 ; if ( inrate < outrate ) { continue ; } ratio |= 1 << ( IDEAL_RATIO_DECIMAL_DEPTH - i ) ; inrate -= outrate ; if ( ! inrate ) { break ; } } regmap_write ( asrc_priv -> regmap , REG_ASRIDRL ( index ) , ratio ) ; regmap_write ( asrc_priv -> regmap , REG_ASRIDRH ( index ) , ratio >> 24 ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int at91_rtc_settime ( struct device * dev , struct rtc_time * tm ) { struct sam9_rtc * rtc = dev_get_drvdata ( dev ) ; int err ; u32 offset , alarm , mr ; unsigned long secs ; dev_dbg ( dev , \"%s: %4d-%02d-%02d %02d:%02d:%02d\\n\" , \"settime\" , 1900 + tm -> tm_year , tm -> tm_mon , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ; err = rtc_tm_to_time ( tm , & secs ) ; mr = rtt_readl ( rtc , MR ) ; rtt_writel ( rtc , MR , mr & ~ ( AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN ) ) ; offset = gpbr_readl ( rtc ) ; secs += 1 ; gpbr_writel ( rtc , secs ) ; alarm = rtt_readl ( rtc , AR ) ; if ( alarm != ALARM_DISABLED ) { if ( offset > secs ) { alarm += ( offset - secs ) ; } if ( ( alarm + offset ) > secs ) { alarm -= ( secs - offset ) ; } else { alarm = ALARM_DISABLED ; mr &= ~ AT91_RTT_ALMIEN ; } rtt_writel ( rtc , AR , alarm ) ; } rtt_writel ( rtc , MR , mr | AT91_RTT_RTTRST ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int objfs_unmount ( vfs_t * vfsp , int flag , struct cred * cr ) { objfs_vfs_t * data ; if ( secpolicy_fs_unmount ( cr , vfsp ) != 0 ) { return ( EPERM ) ; } ASSERT ( vfsp -> vfs_count >= 2 ) ; data = vfsp -> vfs_data ; if ( data -> objfs_vfs_root -> v_count > 1 ) { return ( EBUSY ) ; } VN_RELE ( data -> objfs_vfs_root ) ; kmem_free ( data , sizeof ( objfs_vfs_t ) ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ac_file_set ( ac_info_t * info , void * ubuf , size_t bufsz ) { int error = 0 ; void * kbuf ; void * namebuf ; int namelen ; vnode_t * vp ; void * hdr ; size_t hdrsize ; vattr_t va ; if ( ubuf == NULL ) { mutex_enter ( & info -> ac_lock ) ; if ( info -> ac_vnode != NULL ) { error = VOP_CLOSE ( info -> ac_vnode , FWRITE , 1 , 0 , CRED ( ) , NULL ) ; if ( error ) { mutex_exit ( & info -> ac_lock ) ; return ( error ) ; } VN_RELE ( info -> ac_vnode , NULL ) ; info -> ac_vnode = NULL ; } if ( info -> ac_file != NULL ) { kmem_free ( info -> ac_file , strlen ( info -> ac_file ) + 1 ) ; info -> ac_file = NULL ; } mutex_exit ( & info -> ac_lock ) ; return ( error ) ; } if ( bufsz ( 2 || bufsz ) MAXPATHLEN ) { return ( EINVAL ) ; } kbuf = kmem_zalloc ( bufsz , KM_SLEEP ) ; if ( ( error = copyinstr ( ( char * ) ubuf , ( char * ) kbuf , bufsz , NULL ) ) != 0 ) { kmem_free ( kbuf , bufsz ) ; return ( error ) ; } if ( * ( ( char * ) kbuf ) != '/' ) { kmem_free ( kbuf , bufsz ) ; return ( EINVAL ) ; } namelen = strlen ( kbuf ) + 1 ; namebuf = kmem_alloc ( namelen , KM_SLEEP ) ; ( void ) strcpy ( namebuf , kbuf ) ; kmem_free ( kbuf , bufsz ) ; error = lookupname ( namebuf , UIO_SYSSPACE , FOLLOW , NULLVPP , & vp ) ; if ( ! error ) { if ( ac_file_in_use ( vp ) ) { kmem_free ( namebuf , namelen ) ; VN_RELE ( vp ) ; return ( EBUSY ) ; } VN_RELE ( vp ) ; } hdr = exacct_create_header ( & hdrsize ) ; mutex_enter ( & info -> ac_lock ) ; if ( ( error = vn_open ( namebuf , UIO_SYSSPACE , FCREAT | FWRITE | FOFFMAX , 0600 , & vp , CRCREAT , 0 ) ) != 0 ) { mutex_exit ( & info -> ac_lock ) ; kmem_free ( namebuf , namelen ) ; kmem_free ( hdr , hdrsize ) ; return ( error ) ; } if ( vp -> v_type != VREG ) { VN_RELE ( vp ) ; mutex_exit ( & info -> ac_lock ) ; kmem_free ( namebuf , namelen ) ; kmem_free ( hdr , hdrsize ) ; return ( EACCES ) ; } if ( info -> ac_vnode != NULL ) { vnode_t * oldvp ; oldvp = info -> ac_vnode ; info -> ac_vnode = vp ; vp = oldvp ; } else { info -> ac_vnode = vp ; vp = NULL ; } if ( vp ) { if ( ( error = VOP_CLOSE ( vp , FWRITE , 1 , 0 , CRED ( ) , NULL ) ) != 0 ) { VN_RELE ( vp ) ; mutex_exit ( & info -> ac_lock ) ; kmem_free ( namebuf , namelen ) ; kmem_free ( hdr , hdrsize ) ; return ( error ) ; } VN_RELE ( vp ) ; if ( info -> ac_file != NULL ) { kmem_free ( info -> ac_file , strlen ( info -> ac_file ) + 1 ) ; info -> ac_file = NULL ; } } info -> ac_file = namebuf ; error = VOP_GETATTR ( info -> ac_vnode , & va , AT_SIZE , CRED ( ) , NULL ) ; if ( error == 0 && va . va_size == 0 ) { error = exacct_write_header ( info , hdr , hdrsize ) ; } mutex_exit ( & info -> ac_lock ) ; kmem_free ( hdr , hdrsize ) ; return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int decode_mon_info ( void * * p , void * end , bool msgr2 , struct ceph_entity_addr * addr ) { void * mon_info_end ; u32 struct_len ; u8 struct_v ; int ret ; ret = ceph_start_decoding ( p , end , 1 , \"mon_info_t\" , & struct_v , & struct_len ) ; mon_info_end = * p + struct_len ; ceph_decode_skip_string ( p , end , e_inval ) ; ret = ceph_decode_entity_addrvec ( p , end , msgr2 , addr ) ; if ( ret ) { return ret ; } * p = mon_info_end ; return 0 ; e_inval return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mmhub_v2_3_gart_enable ( struct amdgpu_device * adev ) { if ( amdgpu_sriov_vf ( adev ) ) { WREG32_SOC15 ( MMHUB , 0 , mmMMMC_VM_FB_LOCATION_BASE , adev -> gmc . vram_start >> 24 ) ; WREG32_SOC15 ( MMHUB , 0 , mmMMMC_VM_FB_LOCATION_TOP , adev -> gmc . vram_end >> 24 ) ; } mmhub_v2_3_init_gart_aperture_regs ( adev ) ; mmhub_v2_3_init_system_aperture_regs ( adev ) ; mmhub_v2_3_init_tlb_regs ( adev ) ; mmhub_v2_3_init_cache_regs ( adev ) ; mmhub_v2_3_enable_system_domain ( adev ) ; mmhub_v2_3_disable_identity_aperture ( adev ) ; mmhub_v2_3_setup_vmid_config ( adev ) ; mmhub_v2_3_program_invalidation ( adev , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void cqspi_chipselect ( struct spi_nor * nor ) { struct cqspi_flash_pdata * f_pdata = nor -> priv ; struct cqspi_st * cqspi = f_pdata -> cqspi ; void __iomem * reg_base = cqspi -> iobase ; int chip_select = f_pdata -> cs ; unsigned int reg ; reg = readl ( reg_base + CQSPI_REG_CONFIG ) ; if ( cqspi -> is_decoded_cs ) { reg |= CQSPI_REG_CONFIG_DECODE_MASK ; } else { reg &= ~ CQSPI_REG_CONFIG_DECODE_MASK ; chip_select = 0xF & ~ ( 1 << chip_select ) ; } reg &= ~ ( CQSPI_REG_CONFIG_CHIPSELECT_MASK << CQSPI_REG_CONFIG_CHIPSELECT_LSB ) ; reg |= ( chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK ) << CQSPI_REG_CONFIG_CHIPSELECT_LSB ; writel ( reg , reg_base + CQSPI_REG_CONFIG ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ps3disk_identify ( struct ps3_storage_device * dev ) { struct ps3disk_private * priv = ps3_system_bus_get_drvdata ( & dev -> sbd ) ; struct lv1_ata_cmnd_block ata_cmnd ; u16 * id = dev -> bounce_buf ; u64 res ; dev_dbg ( & dev -> sbd . core , \"%s:%u: identify disk\\n\" , __func__ , __LINE__ ) ; memset ( & ata_cmnd , 0 , sizeof ( lv1_ata_cmnd_block ) ) ; ata_cmnd . command = ATA_CMD_ID_ATA ; ata_cmnd . size = ata_cmnd . arglen = ATA_ID_WORDS * 2 ; ata_cmnd . buffer = dev -> bounce_lpar ; ata_cmnd . proto = PIO_DATA_IN_PROTO ; ata_cmnd . in_out = DIR_READ ; res = ps3stor_send_command ( dev , LV1_STORAGE_SEND_ATA_COMMAND , ps3_mm_phys_to_lpar ( __pa ( & ata_cmnd ) ) , sizeof ( ata_cmnd ) , ata_cmnd . buffer , ata_cmnd . arglen ) ; if ( res ) { dev_err ( & dev -> sbd . core , \"%s:%u: identify disk failed 0x%llx\\n\" , __func__ , __LINE__ , res ) ; return - EIO ; } swap_buf_le16 ( id , ATA_ID_WORDS ) ; priv -> raw_capacity = ata_id_n_sectors ( id ) ; ata_id_c_string ( id , priv -> model , ATA_ID_PROD , sizeof ( priv -> model ) ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct bpf_map * trie_alloc ( union bpf_attr * attr ) { struct lpm_trie * trie ; u64 cost = sizeof ( * trie ) , cost_per_node ; int ret ; if ( attr -> max_entries == 0 || attr -> map_flags != BPF_F_NO_PREALLOC || attr -> key_size ( LPM_KEY_SIZE_MIN || attr -> key_size ) LPM_KEY_SIZE_MAX || attr -> value_size ( LPM_VAL_SIZE_MIN || attr -> value_size ) LPM_VAL_SIZE_MAX ) { return ERR_PTR ( - EINVAL ) ; } trie = kzalloc ( sizeof ( * trie ) , GFP_USER | __GFP_NOWARN ) ; if ( ! trie ) { return ERR_PTR ( - ENOMEM ) ; } trie -> map . map_type = attr -> map_type ; trie -> map . key_size = attr -> key_size ; trie -> map . value_size = attr -> value_size ; trie -> map . max_entries = attr -> max_entries ; trie -> data_size = attr -> key_size - offsetof ( bpf_lpm_trie_key , data ) ; trie -> max_prefixlen = trie -> data_size * 8 ; cost_per_node = sizeof ( lpm_trie_node ) + attr -> value_size + trie -> data_size ; cost += ( u64 ) attr -> max_entries * cost_per_node ; if ( cost >= U32_MAX - PAGE_SIZE ) { ret = - E2BIG ; out_err } trie -> map . pages = round_up ( cost , PAGE_SIZE ) >> PAGE_SHIFT ; ret = bpf_map_precharge_memlock ( trie -> map . pages ) ; if ( ret ) { out_err } raw_spin_lock_init ( & trie -> lock ) ; return & trie -> map ; out_err kfree ( trie ) ; return ERR_PTR ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void qedr_free_pbl ( struct qedr_dev * dev , struct qedr_pbl_info * pbl_info , struct qedr_pbl * pbl ) { struct pci_dev * pdev = dev -> pdev ; int i ; for ( i = 0 ; i < pbl_info -> num_pbls ; i ++ ) { if ( ! pbl [ i ] . va ) { continue ; } dma_free_coherent ( & pdev -> dev , pbl_info -> pbl_size , pbl [ i ] . va , pbl [ i ] . pa ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t nvmet_addr_portid_store ( struct config_item * item , const char * page , size_t count ) { struct nvmet_port * port = to_nvmet_port ( item ) ; u16 portid = 0 ; if ( kstrtou16 ( page , 0 , & portid ) ) { pr_err ( \"Invalid value '%s' for portid\\n\" , page ) ; return - EINVAL ; } port -> disc_addr . portid = cpu_to_le16 ( portid ) ; return count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * Lst_DeQueue ( Lst l ) { void * rd ; LstNode tln ; tln = l -> firstPtr ; rd = tln -> datum ; l -> firstPtr = tln -> nextPtr ; if ( l -> firstPtr ) { l -> firstPtr -> prevPtr = NULL ; } else { l -> lastPtr = NULL ; } free ( tln ) ; return rd ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void match_statement ( struct statement * stmt ) { int cnt ; cnt = get_stmt_cnt ( ) ; cnt ++ ; set_state ( my_id , \"stmts\" , alloc_state_num ( cnt ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bnx2x_nvram_write ( struct bnx2x * bp , u32 offset , u8 * data_buf , int buf_size ) { int rc ; u32 cmd_flags ; u32 val ; u32 written_so_far ; if ( ( offset & 0x03 ) || ( buf_size & 0x03 ) || ( buf_size == 0 ) ) { DP ( BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM , \"Invalid parameter: offset 0x%x  buf_size 0x%x\\n\" , offset , buf_size ) ; return - EINVAL ; } if ( offset + buf_size > bp -> common . flash_size ) { DP ( BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM , \"Invalid parameter: offset (0x%x) + buf_size (0x%x)>flash_size (0x%x)\\n\" , offset , buf_size , bp -> common . flash_size ) ; return - EINVAL ; } rc = bnx2x_acquire_nvram_lock ( bp ) ; if ( rc ) { return rc ; } bnx2x_enable_nvram_access ( bp ) ; written_so_far = 0 ; cmd_flags = MCPR_NVM_COMMAND_FIRST ; while ( ( written_so_far < buf_size ) && ( rc == 0 ) ) { if ( written_so_far == ( buf_size - sizeof ( u32 ) ) ) { cmd_flags |= MCPR_NVM_COMMAND_LAST ; } if ( ( ( offset + 4 ) % BNX2X_NVRAM_PAGE_SIZE ) == 0 ) { cmd_flags |= MCPR_NVM_COMMAND_LAST ; } if ( ( offset % BNX2X_NVRAM_PAGE_SIZE ) == 0 ) { cmd_flags |= MCPR_NVM_COMMAND_FIRST ; } memcpy ( & val , data_buf , 4 ) ; rc = bnx2x_nvram_write_dword ( bp , offset , val , cmd_flags ) ; offset += sizeof ( u32 ) ; data_buf += sizeof ( u32 ) ; written_so_far += sizeof ( u32 ) ; if ( ( cmd_flags & MCPR_NVM_COMMAND_LAST ) && ( written_so_far < buf_size ) ) { DP ( BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM , \"Releasing NVM lock after offset 0x%x\\n\" , ( u32 ) ( offset - sizeof ( u32 ) ) ) ; bnx2x_release_nvram_lock ( bp ) ; usleep_range ( 1000 , 2000 ) ; rc = bnx2x_acquire_nvram_lock ( bp ) ; if ( rc ) { return rc ; } } cmd_flags = 0 ; } bnx2x_disable_nvram_access ( bp ) ; bnx2x_release_nvram_lock ( bp ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dbg_check_lprops ( struct ubifs_info * c ) { int i , err ; struct ubifs_lp_stats lst ; if ( ! dbg_is_chk_lprops ( c ) ) { return 0 ; } for ( i = 0 ; i < c -> jhead_cnt ; i ++ ) { err = ubifs_wbuf_sync ( & c -> jheads [ i ] . wbuf ) ; if ( err ) { return err ; } } err = ubifs_lpt_scan_nolock ( c , c -> main_first , c -> leb_cnt - 1 , ( ubifs_lpt_scan_callback ) scan_check_cb , & lst ) ; if ( err && err != - ENOSPC ) { out } if ( lst . empty_lebs != c -> lst . empty_lebs || lst . idx_lebs != c -> lst . idx_lebs || lst . total_free != c -> lst . total_free || lst . total_dirty != c -> lst . total_dirty || lst . total_used != c -> lst . total_used ) { ubifs_err ( c , \"bad overall accounting\" ) ; ubifs_err ( c , \"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\" , lst . empty_lebs , lst . idx_lebs , lst . total_free , lst . total_dirty , lst . total_used ) ; ubifs_err ( c , \"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\" , c -> lst . empty_lebs , c -> lst . idx_lebs , c -> lst . total_free , c -> lst . total_dirty , c -> lst . total_used ) ; err = - EINVAL ; out } if ( lst . total_dead != c -> lst . total_dead || lst . total_dark != c -> lst . total_dark ) { ubifs_err ( c , \"bad dead/dark space accounting\" ) ; ubifs_err ( c , \"calculated: total_dead %lld, total_dark %lld\" , lst . total_dead , lst . total_dark ) ; ubifs_err ( c , \"read from lprops: total_dead %lld, total_dark %lld\" , c -> lst . total_dead , c -> lst . total_dark ) ; err = - EINVAL ; out } err = dbg_check_cats ( c ) ; out return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hal2_gain_info ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_info * uinfo ) { uinfo -> type = SNDRV_CTL_ELEM_TYPE_INTEGER ; uinfo -> count = 2 ; switch ( ( int ) kcontrol -> private_value ) { case H2_MIX_OUTPUT_ATT : uinfo -> value . integer . max = 31 ; break ; case H2_MIX_INPUT_GAIN : uinfo -> value . integer . max = 15 ; break ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rm_padding ( u8 padding_indicator , const u8 * data , size_t datalen ) { size_t len ; switch ( padding_indicator ) { case SM_NO_PADDING : len = datalen ; break ; case SM_ISO_PADDING : len = datalen ; while ( len ) { len -- ; if ( data [ len ] ) { break ; } } if ( data [ len ] != 0x80 ) { return SC_ERROR_INVALID_DATA ; } break ; default : return SC_ERROR_NOT_SUPPORTED ; } return len ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int crl_cb ( int operation , ASN1_VALUE * * pval , const ASN1_ITEM * it , void * exarg ) { X509_CRL * crl = ( X509_CRL * ) * pval ; STACK_OF ( X509_EXTENSION ) * exts ; X509_EXTENSION * ext ; int idx ; int rc = 1 ; switch ( operation ) { case ASN1_OP_NEW_POST : crl -> idp = NULL ; crl -> akid = NULL ; crl -> flags = 0 ; crl -> idp_flags = 0 ; crl -> idp_reasons = CRLDP_ALL_REASONS ; crl -> meth = default_crl_method ; crl -> meth_data = NULL ; crl -> issuers = NULL ; crl -> crl_number = NULL ; crl -> base_crl_number = NULL ; break ; case ASN1_OP_D2I_POST : X509_CRL_digest ( crl , X509_CRL_HASH_EVP , crl -> hash , NULL ) ; crl -> idp = X509_CRL_get_ext_d2i ( crl , NID_issuing_distribution_point , NULL , NULL ) ; if ( crl -> idp ) { setup_idp ( crl , crl -> idp ) ; } crl -> akid = X509_CRL_get_ext_d2i ( crl , NID_authority_key_identifier , NULL , NULL ) ; crl -> crl_number = X509_CRL_get_ext_d2i ( crl , NID_crl_number , NULL , NULL ) ; crl -> base_crl_number = X509_CRL_get_ext_d2i ( crl , NID_delta_crl , NULL , NULL ) ; if ( crl -> base_crl_number && ! crl -> crl_number ) { crl -> flags |= EXFLAG_INVALID ; } exts = crl -> crl -> extensions ; for ( idx = 0 ; idx < sk_X509_EXTENSION_num ( exts ) ; idx ++ ) { int nid ; ext = sk_X509_EXTENSION_value ( exts , idx ) ; nid = OBJ_obj2nid ( ext -> object ) ; if ( nid == NID_freshest_crl ) { crl -> flags |= EXFLAG_FRESHEST ; } if ( ext -> critical > 0 ) { if ( nid == NID_issuing_distribution_point || nid == NID_authority_key_identifier || nid == NID_delta_crl ) { break ; } crl -> flags |= EXFLAG_CRITICAL ; break ; } } if ( crl -> meth -> crl_init ) { if ( crl -> meth -> crl_init ( crl ) == 0 ) { return 0 ; } } break ; case ASN1_OP_FREE_POST : if ( crl -> meth -> crl_free ) { if ( ! crl -> meth -> crl_free ( crl ) ) { rc = 0 ; } } if ( crl -> akid ) { AUTHORITY_KEYID_free ( crl -> akid ) ; } if ( crl -> idp ) { ISSUING_DIST_POINT_free ( crl -> idp ) ; } ASN1_INTEGER_free ( crl -> crl_number ) ; ASN1_INTEGER_free ( crl -> base_crl_number ) ; sk_GENERAL_NAMES_pop_free ( crl -> issuers , GENERAL_NAMES_free ) ; break ; } return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool _bt_bottomupdel_pass ( Relation rel , Buffer buf , Relation heapRel , Size newitemsz ) { OffsetNumber offnum , minoff , maxoff ; Page page = BufferGetPage ( buf ) ; BTPageOpaque opaque = BTPageGetOpaque ( page ) ; BTDedupState state ; TM_IndexDeleteOp delstate ; bool neverdedup ; int nkeyatts = IndexRelationGetNumberOfKeyAttributes ( rel ) ; newitemsz += sizeof ( ItemIdData ) ; state = ( BTDedupState ) palloc ( sizeof ( BTDedupStateData ) ) ; state -> deduplicate = true ; state -> nmaxitems = 0 ; state -> maxpostingsize = BLCKSZ ; state -> base = NULL ; state -> baseoff = InvalidOffsetNumber ; state -> basetupsize = 0 ; state -> htids = palloc ( state -> maxpostingsize ) ; state -> nhtids = 0 ; state -> nitems = 0 ; state -> phystupsize = 0 ; state -> nintervals = 0 ; delstate . irel = rel ; delstate . iblknum = BufferGetBlockNumber ( buf ) ; delstate . bottomup = true ; delstate . bottomupfreespace = Max ( BLCKSZ / 16 , newitemsz ) ; delstate . ndeltids = 0 ; delstate . deltids = palloc ( MaxTIDsPerBTreePage * sizeof ( TM_IndexDelete ) ) ; delstate . status = palloc ( MaxTIDsPerBTreePage * sizeof ( TM_IndexStatus ) ) ; minoff = P_FIRSTDATAKEY ( opaque ) ; maxoff = PageGetMaxOffsetNumber ( page ) ; for ( offnum = minoff ; offnum <= maxoff ; offnum = OffsetNumberNext ( offnum ) ) { ItemId itemid = PageGetItemId ( page , offnum ) ; IndexTuple itup = ( IndexTuple ) PageGetItem ( page , itemid ) ; Assert ( ! ItemIdIsDead ( itemid ) ) ; if ( offnum == minoff ) { _bt_dedup_start_pending ( state , itup , offnum ) ; } if ( _bt_keep_natts_fast ( rel , state -> base , itup ) > nkeyatts && _bt_dedup_save_htid ( state , itup ) ) { } else { _bt_bottomupdel_finish_pending ( page , state , & delstate ) ; _bt_dedup_start_pending ( state , itup , offnum ) ; } } _bt_bottomupdel_finish_pending ( page , state , & delstate ) ; neverdedup = false ; if ( state -> nintervals == 0 ) { neverdedup = true ; } pfree ( state -> htids ) ; pfree ( state ) ; _bt_delitems_delete_check ( rel , buf , heapRel , & delstate ) ; pfree ( delstate . deltids ) ; pfree ( delstate . status ) ; return PageGetExactFreeSpace ( page ) >= Max ( BLCKSZ / 24 , newitemsz ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void pfctl_kill_src_nodes ( int dev , int opts ) { struct pfioc_src_node_kill psnk ; struct addrinfo * res [ 2 ] , * resp [ 2 ] ; struct sockaddr last_src , last_dst ; int killed , sources , dests ; killed = sources = dests = 0 ; memset ( & psnk . psnk_src . addr . v . a . mask , 0xff , sizeof ( psnk . psnk_src . addr . v . a . mask ) ) ; memset ( & last_src , 0xff , sizeof ( last_src ) ) ; memset ( & last_dst , 0xff , sizeof ( last_dst ) ) ; res [ 0 ] = pfctl_addrprefix ( src_node_kill [ 0 ] , & psnk . psnk_src . addr . v . a . mask , ( opts & PF_OPT_NODNS ) ) ; for ( resp [ 0 ] = res [ 0 ] ; resp [ 0 ] ; resp [ 0 ] = resp [ 0 ] -> ai_next ) { if ( resp [ 0 ] -> ai_addr == NULL ) { continue ; } if ( memcmp ( & last_src , resp [ 0 ] -> ai_addr , sizeof ( last_src ) ) == 0 ) { continue ; } last_src = * ( sockaddr * ) resp [ 0 ] -> ai_addr ; psnk . psnk_af = resp [ 0 ] -> ai_family ; sources ++ ; copy_satopfaddr ( & psnk . psnk_src . addr . v . a . addr , resp [ 0 ] -> ai_addr ) ; if ( src_node_killers > 1 ) { dests = 0 ; memset ( & psnk . psnk_dst . addr . v . a . mask , 0xff , sizeof ( psnk . psnk_dst . addr . v . a . mask ) ) ; memset ( & last_dst , 0xff , sizeof ( last_dst ) ) ; res [ 1 ] = pfctl_addrprefix ( src_node_kill [ 1 ] , & psnk . psnk_dst . addr . v . a . mask , ( opts & PF_OPT_NODNS ) ) ; for ( resp [ 1 ] = res [ 1 ] ; resp [ 1 ] ; resp [ 1 ] = resp [ 1 ] -> ai_next ) { if ( resp [ 1 ] -> ai_addr == NULL ) { continue ; } if ( psnk . psnk_af != resp [ 1 ] -> ai_family ) { continue ; } if ( memcmp ( & last_dst , resp [ 1 ] -> ai_addr , sizeof ( last_dst ) ) == 0 ) { continue ; } last_dst = * ( sockaddr * ) resp [ 1 ] -> ai_addr ; dests ++ ; copy_satopfaddr ( & psnk . psnk_src . addr . v . a . addr , resp [ 1 ] -> ai_addr ) ; if ( ioctl ( dev , DIOCKILLSRCNODES , & psnk ) == - 1 ) { err ( 1 , \"DIOCKILLSRCNODES\" ) ; } killed += psnk . psnk_killed ; } freeaddrinfo ( res [ 1 ] ) ; } else { if ( ioctl ( dev , DIOCKILLSRCNODES , & psnk ) == - 1 ) { err ( 1 , \"DIOCKILLSRCNODES\" ) ; } killed += psnk . psnk_killed ; } } freeaddrinfo ( res [ 0 ] ) ; if ( ( opts & PF_OPT_QUIET ) == 0 ) { fprintf ( stderr , \"killed %d src nodes from %d sources and %d \" \"destinations\\n\" , killed , sources , dests ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "server_rec * main_server = NULL ; pool * auth_otp_pool ; int auth_otp_logfd = - 1 ; config_rec * find_config ( xaset_t * set , int type , const char * name , int recurse ) { return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mdio_mux_multiplexer_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct mdio_mux_multiplexer_state * s ; int ret = 0 ; s = devm_kzalloc ( & pdev -> dev , sizeof ( * s ) , GFP_KERNEL ) ; s -> muxc = devm_mux_control_get ( dev , NULL ) ; if ( IS_ERR ( s -> muxc ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( s -> muxc ) , \"Failed to get mux\\n\" ) ; } platform_set_drvdata ( pdev , s ) ; ret = mdio_mux_init ( & pdev -> dev , pdev -> dev . of_node , mdio_mux_multiplexer_switch_fn , & s -> mux_handle , pdev , NULL ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hfa384x_usbctlx_complete_sync ( struct hfa384x * hw , struct hfa384x_usbctlx * ctlx , struct usbctlx_completor * completor ) { unsigned long flags ; int result ; result = wait_for_completion_interruptible ( & ctlx -> done ) ; spin_lock_irqsave ( & hw -> ctlxq . lock , flags ) ; cleanup if ( hw -> wlandev -> hwremoved ) { spin_unlock_irqrestore ( & hw -> ctlxq . lock , flags ) ; result = - ENODEV ; } if ( result != 0 ) { int runqueue = 0 ; if ( ctlx == get_active_ctlx ( hw ) ) { spin_unlock_irqrestore ( & hw -> ctlxq . lock , flags ) ; del_timer_sync ( & hw -> reqtimer ) ; del_timer_sync ( & hw -> resptimer ) ; hw -> req_timer_done = 1 ; hw -> resp_timer_done = 1 ; usb_kill_urb ( & hw -> ctlx_urb ) ; spin_lock_irqsave ( & hw -> ctlxq . lock , flags ) ; runqueue = 1 ; if ( hw -> wlandev -> hwremoved ) { cleanup } } ctlx -> reapable = 1 ; ctlx -> state = CTLX_REQ_FAILED ; list_move_tail ( & ctlx -> list , & hw -> ctlxq . completing ) ; spin_unlock_irqrestore ( & hw -> ctlxq . lock , flags ) ; if ( runqueue ) { hfa384x_usbctlxq_run ( hw ) ; } } else { if ( ctlx -> state == CTLX_COMPLETE ) { result = completor -> complete ( completor ) ; } else { netdev_warn ( hw -> wlandev -> netdev , \"CTLX[%d] error: state(%s)\\n\" , le16_to_cpu ( ctlx -> outbuf . type ) , ctlxstr ( ctlx -> state ) ) ; result = - EIO ; } list_del ( & ctlx -> list ) ; spin_unlock_irqrestore ( & hw -> ctlxq . lock , flags ) ; } return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "OM_uint32 gss_krb5int_set_allowable_enctypes ( OM_uint32 * minor_status , gss_cred_id_t * cred_handle , const gss_OID desired_oid , const gss_buffer_t value ) { unsigned int i , j ; krb5_enctype * new_ktypes ; OM_uint32 major_status ; krb5_gss_cred_id_t cred ; krb5_error_code kerr = 0 ; struct krb5_gss_set_allowable_enctypes_req * req ; * minor_status = 0 ; major_status = GSS_S_FAILURE ; assert ( value -> length == sizeof ( * req ) ) ; req = ( krb5_gss_set_allowable_enctypes_req * ) value -> value ; cred = ( krb5_gss_cred_id_t ) * cred_handle ; if ( req -> ktypes == NULL ) { k5_mutex_lock ( & cred -> lock ) ; if ( cred -> req_enctypes ) { free ( cred -> req_enctypes ) ; } cred -> req_enctypes = NULL ; k5_mutex_unlock ( & cred -> lock ) ; return GSS_S_COMPLETE ; } new_ktypes = k5calloc ( req -> num_ktypes + 1 , sizeof ( * new_ktypes ) , & kerr ) ; if ( new_ktypes == NULL ) { error_out } for ( i = 0 , j = 0 ; i < req -> num_ktypes && req -> ktypes [ i ] ; i ++ ) { if ( krb5_c_valid_enctype ( req -> ktypes [ i ] ) ) { new_ktypes [ j ++ ] = req -> ktypes [ i ] ; } } new_ktypes [ j ] = 0 ; if ( j == 0 ) { kerr = KRB5_PROG_ETYPE_NOSUPP ; error_out } k5_mutex_lock ( & cred -> lock ) ; if ( cred -> req_enctypes ) { free ( cred -> req_enctypes ) ; } cred -> req_enctypes = new_ktypes ; k5_mutex_unlock ( & cred -> lock ) ; return GSS_S_COMPLETE ; error_out * minor_status = kerr ; return ( major_status ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void purge_node ( struct addrtree * tree , struct addrnode * node ) { struct addredge * parent_edge , * child_edge = NULL ; int index ; int keep = node -> edge [ 0 ] && node -> edge [ 1 ] ; clean_node ( tree , node ) ; parent_edge = node -> parent_edge ; if ( keep || ! parent_edge ) { return ; } tree -> node_count -- ; index = parent_edge -> parent_index ; child_edge = node -> edge [ ! node -> edge [ 0 ] ] ; if ( child_edge ) { child_edge -> parent_node = parent_edge -> parent_node ; child_edge -> parent_index = index ; } parent_edge -> parent_node -> edge [ index ] = child_edge ; tree -> size_bytes -= node_size ( tree , node ) ; free ( parent_edge -> str ) ; free ( parent_edge ) ; lru_pop ( tree , node ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "cxx_get_alias_set ( ) { if ( IS_FAKE_BASE_TYPE ( t ) ) { return get_alias_set ( TYPE_CONTEXT ( t ) ) ; } return c_common_get_alias_set ( t ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xgene_slimpro_i2c_remove ( struct platform_device * pdev ) { struct slimpro_i2c_dev * ctx = platform_get_drvdata ( pdev ) ; i2c_del_adapter ( & ctx -> adapter ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "avl_t * avl_search_lock ( avl_tree_lock * tree , avl_t * item ) { avl_read_lock ( tree ) ; avl_t * ret = avl_search ( & tree -> avl_tree , item ) ; avl_unlock ( tree , NULL ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FlangerContext * s = ctx -> priv ; AVFrame * out_frame ; int chan , i ; if ( av_frame_is_writable ( frame ) ) { out_frame = frame ; } else { out_frame = ff_get_audio_buffer ( ctx -> outputs [ 0 ] , frame -> nb_samples ) ; if ( ! out_frame ) { return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out_frame , frame ) ; } for ( i = 0 ; i < frame -> nb_samples ; i ++ ) { s -> delay_buf_pos = ( s -> delay_buf_pos + s -> max_samples - 1 ) % s -> max_samples ; for ( chan = 0 ; chan < inlink -> ch_layout . nb_channels ; chan ++ ) { double * src = ( double * ) frame -> extended_data [ chan ] ; double * dst = ( double * ) out_frame -> extended_data [ chan ] ; double delayed_0 , delayed_1 ; double delayed ; double in , out ; int channel_phase = chan * s -> lfo_length * s -> channel_phase + .5 ; double delay = s -> lfo [ ( s -> lfo_pos + channel_phase ) % s -> lfo_length ] ; int int_delay = ( int ) delay ; double frac_delay = modf ( delay , & delay ) ; double * delay_buffer = ( double * ) s -> delay_buffer [ chan ] ; in = src [ i ] ; delay_buffer [ s -> delay_buf_pos ] = in + s -> delay_last [ chan ] * s -> feedback_gain ; delayed_0 = delay_buffer [ ( s -> delay_buf_pos + int_delay ++ ) % s -> max_samples ] ; delayed_1 = delay_buffer [ ( s -> delay_buf_pos + int_delay ++ ) % s -> max_samples ] ; if ( s -> interpolation == INTERPOLATION_LINEAR ) { delayed = delayed_0 + ( delayed_1 - delayed_0 ) * frac_delay ; } else { double a , b ; double delayed_2 = delay_buffer [ ( s -> delay_buf_pos + int_delay ++ ) % s -> max_samples ] ; delayed_2 -= delayed_0 ; delayed_1 -= delayed_0 ; a = delayed_2 * .5 - delayed_1 ; b = delayed_1 * 2 - delayed_2 * .5 ; delayed = delayed_0 + ( a * frac_delay + b ) * frac_delay ; } s -> delay_last [ chan ] = delayed ; out = in * s -> in_gain + delayed * s -> delay_gain ; dst [ i ] = out ; } s -> lfo_pos = ( s -> lfo_pos + 1 ) % s -> lfo_length ; } if ( frame != out_frame ) { av_frame_free ( & frame ) ; } return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "usbd_status urtw_8225_rf_set_sens ( struct urtw_rf * rf ) { struct urtw_softc * sc = rf -> rf_sc ; usbd_status error ; if ( rf -> sens > 4 ) { urtw_8225_write ( sc , 0x0c , 0x850 ) ; } else { urtw_8225_write ( sc , 0x0c , 0x50 ) ; } rf -> sens = 6 - rf -> sens ; error = urtw_8225_setgain ( sc , rf -> sens ) ; if ( error ) { fail } urtw_8187_write_phy_cck ( sc , 0x41 , urtw_8225_threshold [ rf -> sens ] ) ; fail return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cpu_create ( topo_mod_t * mod , tnode_t * rnode , const char * name , topo_instance_t min , topo_instance_t max , cpu_node_t * cpuip ) { int i ; processorid_t cpu_id ; char * s , sbuf [ 21 ] ; kstat_named_t * ks ; nvlist_t * fmri ; for ( i = 0 ; i <= cpuip -> cn_ncpustats ; i ++ ) { if ( ( ks = kstat_data_lookup ( cpuip -> cn_cpustats [ i ] , \"device_ID\" ) ) != NULL ) { ( void ) snprintf ( sbuf , 21 , \"%llX\" , ks -> value . ui64 ) ; s = sbuf ; } else { s = NULL ; } if ( ( fmri = fmri_create ( mod , cpu_id , 0 , s ) ) == NULL ) { continue ; } ( void ) topo_node_bind ( mod , rnode , name , cpu_id , fmri ) ; nvlist_free ( fmri ) ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int phm_copy_clock_limits_array ( struct pp_hwmgr * hwmgr , uint32_t * * pptable_info_array , const uint32_t * pptable_array , uint32_t power_saving_clock_count ) { uint32_t array_size , i ; uint32_t * table ; array_size = sizeof ( uint32_t ) * power_saving_clock_count ; table = kzalloc ( array_size , GFP_KERNEL ) ; for ( i = 0 ; i < power_saving_clock_count ; i ++ ) { table [ i ] = le32_to_cpu ( pptable_array [ i ] ) ; } * pptable_info_array = table ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "const char * tor_tls_get_last_error_msg ( const tor_tls_t * tls ) { IF_BUG_ONCE ( ) { return NULL ; } if ( tls -> last_error == 0 ) { return in ; } return ( const char * ) ERR_reason_error_string ( tls -> last_error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ibmphp_init_devno ( struct slot * * cur_slot ) { struct irq_routing_table * rtable ; int len ; int loop ; int i ; rtable = pcibios_get_irq_routing_table ( ) ; if ( ! rtable ) { err ( \"no BIOS routing table...\\n\" ) ; return - ENOMEM ; } len = ( rtable -> size - sizeof ( irq_routing_table ) ) / sizeof ( irq_info ) ; if ( ! len ) { return - 1 ; } for ( loop = 0 ; loop < len ; loop ++ ) { if ( ( * cur_slot ) -> number == rtable -> slots [ loop ] . slot && ( * cur_slot ) -> bus == rtable -> slots [ loop ] . bus ) { ( * cur_slot ) -> device = PCI_SLOT ( rtable -> slots [ loop ] . devfn ) ; for ( i = 0 ; i < 4 ; i ++ ) { ( * cur_slot ) -> irq [ i ] = IO_APIC_get_PCI_irq_vector ( ( int ) ( * cur_slot ) -> bus , ( int ) ( * cur_slot ) -> device , i ) ; } debug ( \"(*cur_slot)->irq[0] = %x\\n\" , ( * cur_slot ) -> irq [ 0 ] ) ; debug ( \"(*cur_slot)->irq[1] = %x\\n\" , ( * cur_slot ) -> irq [ 1 ] ) ; debug ( \"(*cur_slot)->irq[2] = %x\\n\" , ( * cur_slot ) -> irq [ 2 ] ) ; debug ( \"(*cur_slot)->irq[3] = %x\\n\" , ( * cur_slot ) -> irq [ 3 ] ) ; debug ( \"rtable->exclusive_irqs = %x\\n\" , rtable -> exclusive_irqs ) ; debug ( \"rtable->slots[loop].irq[0].bitmap = %x\\n\" , rtable -> slots [ loop ] . irq [ 0 ] . bitmap ) ; debug ( \"rtable->slots[loop].irq[1].bitmap = %x\\n\" , rtable -> slots [ loop ] . irq [ 1 ] . bitmap ) ; debug ( \"rtable->slots[loop].irq[2].bitmap = %x\\n\" , rtable -> slots [ loop ] . irq [ 2 ] . bitmap ) ; debug ( \"rtable->slots[loop].irq[3].bitmap = %x\\n\" , rtable -> slots [ loop ] . irq [ 3 ] . bitmap ) ; debug ( \"rtable->slots[loop].irq[0].link = %x\\n\" , rtable -> slots [ loop ] . irq [ 0 ] . link ) ; debug ( \"rtable->slots[loop].irq[1].link = %x\\n\" , rtable -> slots [ loop ] . irq [ 1 ] . link ) ; debug ( \"rtable->slots[loop].irq[2].link = %x\\n\" , rtable -> slots [ loop ] . irq [ 2 ] . link ) ; debug ( \"rtable->slots[loop].irq[3].link = %x\\n\" , rtable -> slots [ loop ] . irq [ 3 ] . link ) ; debug ( \"end of init_devno\\n\" ) ; kfree ( rtable ) ; return 0 ; } } kfree ( rtable ) ; return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int adin1110_switchdev_event ( struct notifier_block * unused , unsigned long event , void * ptr ) { struct net_device * netdev = switchdev_notifier_info_to_dev ( ptr ) ; struct adin1110_port_priv * port_priv = netdev_priv ( netdev ) ; struct adin1110_switchdev_event_work * switchdev_work ; struct switchdev_notifier_fdb_info * fdb_info = ptr ; if ( ! adin1110_port_dev_check ( netdev ) ) { return NOTIFY_DONE ; } switchdev_work = kzalloc ( sizeof ( * switchdev_work ) , GFP_ATOMIC ) ; if ( WARN_ON ( ! switchdev_work ) ) { return NOTIFY_BAD ; } INIT_WORK ( & switchdev_work -> work , adin1110_switchdev_event_work ) ; switchdev_work -> port_priv = port_priv ; switchdev_work -> event = event ; switch ( event ) { case SWITCHDEV_FDB_ADD_TO_DEVICE : case SWITCHDEV_FDB_DEL_TO_DEVICE : memcpy ( & switchdev_work -> fdb_info , ptr , sizeof ( switchdev_work -> fdb_info ) ) ; switchdev_work -> fdb_info . addr = kzalloc ( ETH_ALEN , GFP_ATOMIC ) ; if ( ! switchdev_work -> fdb_info . addr ) { err_addr_alloc } ether_addr_copy ( ( u8 * ) switchdev_work -> fdb_info . addr , fdb_info -> addr ) ; dev_hold ( netdev ) ; break ; default : return NOTIFY_DONE ; } queue_work ( system_long_wq , & switchdev_work -> work ) ; return NOTIFY_DONE ; err_addr_alloc kfree ( switchdev_work ) ; return NOTIFY_BAD ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void brcmf_detach ( struct device * dev ) { s32 i ; struct brcmf_bus * bus_if = dev_get_drvdata ( dev ) ; struct brcmf_pub * drvr = bus_if -> drvr ; brcmf_dbg ( TRACE , \"Enter\\n\" ) ; if ( drvr == NULL ) { return ; } unregister_inetaddr_notifier ( & drvr -> inetaddr_notifier ) ; unregister_inet6addr_notifier ( & drvr -> inet6addr_notifier ) ; brcmf_fweh_detach ( drvr ) ; if ( drvr -> config ) { brcmf_p2p_detach ( & drvr -> config -> p2p ) ; } brcmf_bus_change_state ( bus_if , BRCMF_BUS_DOWN ) ; for ( i = BRCMF_MAX_IFS - 1 ; i > - 1 ; i -- ) { brcmf_remove_interface ( drvr -> iflist [ i ] , false ) ; } brcmf_cfg80211_detach ( drvr -> config ) ; brcmf_bus_stop ( drvr -> bus_if , NULL ) ; brcmf_proto_detach ( drvr ) ; brcmf_debug_detach ( drvr ) ; bus_if -> drvr = NULL ; kfree ( drvr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int test_eof ( lua_State * L , gzFile f ) { lua_pushlstring ( L , 0 ) ; return ( gzeof ( f ) != 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int db__message_store ( const struct mosquitto * source , struct mosquitto_msg_store * stored , uint32_t message_expiry_interval , dbid_t store_id , enum mosquitto_msg_origin origin ) { UNUSED ( source ) ; UNUSED ( stored ) ; UNUSED ( message_expiry_interval ) ; UNUSED ( store_id ) ; UNUSED ( origin , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "kadm5_ret_t kadm5_rename_principal ( void * server_handle , krb5_principal source , krb5_principal target ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_error_code ret ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( source == NULL || target == NULL ) { return EINVAL ; } if ( ( ret = kdb_get_entry ( handle , target , & kdb , & adb ) ) == 0 ) { kdb_free_entry ( handle , kdb , & adb ) ; return ( KADM5_DUP ) ; } ret = k5_kadm5_hook_rename ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , source , target ) ; ret = krb5_db_rename_principal ( handle -> context , source , target ) ; if ( ret ) { return ret ; } ret = kdb_get_entry ( handle , target , & kdb , & adb ) ; if ( ret ) { return ret ; } kdb -> mask = 0 ; ret = kdb_put_entry ( handle , kdb , & adb ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( ret ) { return ret ; } ( void ) k5_kadm5_hook_rename ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , source , target ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ubi_refill_pools ( struct ubi_device * ubi ) { struct ubi_fm_pool * wl_pool = & ubi -> fm_wl_pool ; struct ubi_fm_pool * pool = & ubi -> fm_pool ; struct ubi_wl_entry * e ; int enough ; spin_lock ( & ubi -> wl_lock ) ; return_unused_pool_pebs ( ubi , wl_pool ) ; return_unused_pool_pebs ( ubi , pool ) ; pool -> size = 0 ; for ( ; ; ) { enough = 0 ; if ( pool -> size < pool -> max_size ) { if ( ! ubi -> free . rb_node ) { break ; } e = wl_get_wle ( ubi ) ; if ( ! e ) { break ; } pool -> pebs [ pool -> size ] = e -> pnum ; pool -> size ++ ; } else { enough ++ ; } if ( wl_pool -> size < wl_pool -> max_size ) { if ( ! ubi -> free . rb_node || ( ubi -> free_count - ubi -> beb_rsvd_pebs < 5 ) ) { break ; } e = find_wl_entry ( ubi , & ubi -> free , WL_FREE_MAX_DIFF ) ; self_check_in_wl_tree ( ubi , e , & ubi -> free ) ; rb_erase ( & e -> u . rb , & ubi -> free ) ; ubi -> free_count -- ; wl_pool -> pebs [ wl_pool -> size ] = e -> pnum ; wl_pool -> size ++ ; } else { enough ++ ; } if ( enough == 2 ) { break ; } } wl_pool -> used = 0 ; pool -> used = 0 ; spin_unlock ( & ubi -> wl_lock ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void print_header ( mrb_state * mrb , const mrb_irep * irep , ptrdiff_t i , FILE * out ) { int line ; mrb_assert ( i <= UINT32_MAX ) ; line = mrb_debug_get_line ( mrb , irep , ( uint32_t ) i ) ; if ( line < 0 ) { fprintf ( out , \"      \" ) ; } else { fprintf ( out , \"%5d \" , line ) ; } fprintf ( out , \"%03d \" , ( int ) i ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void wait_wfifo_ready ( struct sh_flctl * flctl ) { uint32_t len , timeout = LOOP_TIMEOUT_MAX ; while ( timeout -- ) { len = ( readl ( FLDTCNTR ( flctl ) ) >> 16 ) & 0xFF ; if ( len >= 4 ) { return ; } udelay ( 1 ) ; } timeout_error ( flctl , __func__ ) ; } static enum flctl_ecc_res_t wait_recfifo_ready ( struct sh_flctl * flctl , int sector_number ) { uint32_t timeout = LOOP_TIMEOUT_MAX ; void __iomem * ecc_reg [ 4 ] ; int i ; int state = FL_SUCCESS ; uint32_t data , size ; while ( timeout -- ) { size = readl ( FLDTCNTR ( flctl ) ) >> 24 ; if ( ( size & 0xFF ) == 4 ) { return state ; } if ( ! ( readl ( FL4ECCCR ( flctl ) ) & _4ECCEND ) ) { udelay ( 1 ) ; continue ; } if ( readl ( FL4ECCCR ( flctl ) ) & _4ECCFA ) { for ( i = 0 ; i < 512 ; i ++ ) { if ( flctl -> done_buff [ i ] != 0xff ) { state = FL_ERROR ; break ; } } if ( state == FL_SUCCESS ) { dev_dbg ( & flctl -> pdev -> dev , \"reading empty sector %d, ecc error ignored\\n\" , sector_number ) ; } writel ( 0 , FL4ECCCR ( flctl ) ) ; continue ; } ecc_reg [ 0 ] = FL4ECCRESULT0 ( flctl ) ; ecc_reg [ 1 ] = FL4ECCRESULT1 ( flctl ) ; ecc_reg [ 2 ] = FL4ECCRESULT2 ( flctl ) ; ecc_reg [ 3 ] = FL4ECCRESULT3 ( flctl ) ; for ( i = 0 ; i < 3 ; i ++ ) { uint8_t org ; int index ; data = readl ( ecc_reg [ i ] ) ; if ( flctl -> page_size ) { index = ( 512 * sector_number ) + ( data >> 16 ) ; } else { index = data >> 16 ; } org = flctl -> done_buff [ index ] ; flctl -> done_buff [ index ] = org ^ ( data & 0xFF ) ; } state = FL_REPAIRABLE ; writel ( 0 , FL4ECCCR ( flctl ) ) ; } timeout_error ( flctl , __func__ ) ; return FL_TIMEOUT ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int inet6_netconf_get_devconf ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct nlattr * tb [ NETCONFA_MAX + 1 ] ; struct netconfmsg * ncm ; struct sk_buff * skb ; struct ipv6_devconf * devconf ; struct inet6_dev * in6_dev ; struct net_device * dev ; int ifindex ; int err ; err = nlmsg_parse ( nlh , sizeof ( * ncm ) , tb , NETCONFA_MAX , devconf_ipv6_policy , extack ) ; if ( err < 0 ) { errout } err = - EINVAL ; if ( ! tb [ NETCONFA_IFINDEX ] ) { errout } ifindex = nla_get_s32 ( tb [ NETCONFA_IFINDEX ] , NULL ) ; switch ( ifindex ) { case NETCONFA_IFINDEX_ALL : devconf = net -> ipv6 . devconf_all ; break ; case NETCONFA_IFINDEX_DEFAULT : devconf = net -> ipv6 . devconf_dflt ; break ; default : dev = __dev_get_by_index ( net , ifindex ) ; if ( ! dev ) { errout } in6_dev = __in6_dev_get ( dev ) ; if ( ! in6_dev ) { errout } devconf = & in6_dev -> cnf ; break ; } err = - ENOBUFS ; skb = nlmsg_new ( inet6_netconf_msgsize_devconf ( NETCONFA_ALL ) , GFP_ATOMIC ) ; if ( ! skb ) { errout } err = inet6_netconf_fill_devconf ( skb , ifindex , devconf , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWNETCONF , 0 , NETCONFA_ALL ) ; if ( err < 0 ) { WARN_ON ( err == - EMSGSIZE ) ; kfree_skb ( skb ) ; errout } err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; errout return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int emac_sgmii_link_up ( struct emac_adapter * adpt ) { struct emac_sgmii * sgmii = & adpt -> phy ; int ret ; ret = emac_sgmii_irq_clear ( adpt , 0xff ) ; writel ( SGMII_ISR_MASK , sgmii -> base + EMAC_SGMII_PHY_INTERRUPT_MASK ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nfsd4_init_cb ( struct nfsd4_callback * cb , struct nfs4_client * clp , const struct nfsd4_callback_ops * ops , enum nfsd4_cb_op op ) { cb -> cb_clp = clp ; cb -> cb_msg . rpc_proc = & nfs4_cb_procedures [ op ] ; cb -> cb_msg . rpc_argp = cb ; cb -> cb_msg . rpc_resp = cb ; cb -> cb_ops = ops ; INIT_WORK ( & cb -> cb_work , nfsd4_run_cb_work ) ; cb -> cb_seq_status = 1 ; cb -> cb_need_restart = false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cbuf_find_replay_line ( cbuf_t * cb , int chars , int * nlines , int * nl ) { int i , n , m , l ; int lines ; assert ( cb != NULL ) ; assert ( nlines != NULL ) ; assert ( * nlines >= - 1 ) ; assert ( _cbuf_mutex_is_locked ( cb ) ) ; n = m = l = 0 ; lines = * nlines ; * nlines = 0 ; if ( nl ) { * nl = 0 ; } if ( ( lines == 0 ) || ( ( lines <= - 1 ) && ( chars <= 0 ) ) ) { return ( 0 ) ; } if ( lines > 0 ) { chars = - 1 ; } else { ++ chars ; } if ( cb -> data [ ( cb -> i_out + cb -> size ) % ( cb -> size + 1 ) ] != '\\n' ) { if ( nl ) { * nl = 1 ; } -- chars ; } else { if ( lines > 0 ) { ++ lines ; } -- l ; } i = cb -> i_out ; while ( i != cb -> i_rep ) { i = ( i + cb -> size ) % ( cb -> size + 1 ) ; ++ n ; if ( chars > 0 ) { -- chars ; } if ( cb -> data [ i ] == '\\n' ) { if ( lines > 0 ) { -- lines ; } m = n - 1 ; ++ l ; } if ( ( chars == 0 ) || ( lines == 0 ) ) { break ; } } if ( ( ! cb -> got_wrap ) && ( ( chars > 0 ) || ( lines > 0 ) ) ) { if ( lines > 0 ) { -- lines ; } m = n ; ++ l ; } if ( lines > 0 ) { return ( 0 ) ; } * nlines = l ; return ( m ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void hid_irq_out ( struct urb * urb ) { struct hid_device * hid = urb -> context ; struct usbhid_device * usbhid = hid -> driver_data ; cfs_time_t flags ; int unplug = 0 ; switch ( urb -> status ) { case 0 : break ; case - ESHUTDOWN : unplug = 1 ; break ; case - EILSEQ : case - EPROTO : case - ECONNRESET : case - ENOENT : break ; default : hid_warn ( urb -> dev , \"output irq status %d received\\n\" , urb -> status ) ; } spin_lock_irqsave ( & usbhid -> lock , flags ) ; if ( unplug ) { usbhid -> outtail = usbhid -> outhead ; } else { usbhid -> outtail = ( usbhid -> outtail + 1 ) & ( HID_OUTPUT_FIFO_SIZE - 1 ) ; if ( usbhid -> outhead != usbhid -> outtail && hid_submit_out ( hid ) == 0 ) { spin_unlock_irqrestore ( & usbhid -> lock , flags ) ; return ; } } clear_bit ( HID_OUT_RUNNING , & usbhid -> iofl ) ; spin_unlock_irqrestore ( & usbhid -> lock , flags ) ; usb_autopm_put_interface_async ( usbhid -> intf ) ; wake_up ( & usbhid -> wait ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * sfgetr ( Sfio_t * sp , int c , int z ) { register char * s ; register char * e ; static char * buf ; static unsigned long siz ; if ( ! buf ) { siz = CHUNK ; if ( ! ( buf = newof ( 0 , char , siz , 0 ) ) ) { return 0 ; } } s = buf ; e = s + siz ; for ( ; ; ) { if ( s >= e ) { siz += CHUNK ; if ( ! ( buf = newof ( buf , char , siz , 0 ) ) ) { return 0 ; } s = buf + ( siz - CHUNK ) ; e = s + siz ; } if ( ( c = sfgetc ( sp ) ) == EOF ) { * s = 0 ; return 0 ; } if ( c == '\\n' ) { * s = z ?0 : c ; break ; } * s ++ = c ; } return buf ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool dcn20_set_input_transfer_func ( struct dc * dc , struct pipe_ctx * pipe_ctx , const struct dc_plane_state * plane_state ) { struct dce_hwseq * hws = dc -> hwseq ; struct dpp * dpp_base = pipe_ctx -> plane_res . dpp ; const struct dc_transfer_func * tf = NULL ; bool result = true ; bool use_degamma_ram = false ; hws -> funcs . set_shaper_3dlut ( pipe_ctx , plane_state ) ; hws -> funcs . set_blend_lut ( pipe_ctx , plane_state ) ; if ( plane_state -> in_transfer_func ) { tf = plane_state -> in_transfer_func ; } if ( tf == NULL ) { dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_BYPASS ) ; return true ; } if ( tf -> type == TF_TYPE_HWPWL || tf -> type == TF_TYPE_DISTRIBUTED_POINTS ) { use_degamma_ram = true ; } if ( use_degamma_ram == true ) { if ( tf -> type == TF_TYPE_HWPWL ) { dpp_base -> funcs -> dpp_program_degamma_pwl ( dpp_base , & tf -> pwl ) ; } if ( tf -> type == TF_TYPE_DISTRIBUTED_POINTS ) { cm_helper_translate_curve_to_degamma_hw_format ( tf , & dpp_base -> degamma_params ) ; dpp_base -> funcs -> dpp_program_degamma_pwl ( dpp_base , & dpp_base -> degamma_params ) ; } return true ; } if ( tf -> type == TF_TYPE_PREDEFINED ) { switch ( tf -> tf ) { case TRANSFER_FUNCTION_SRGB : dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_HW_sRGB ) ; break ; case TRANSFER_FUNCTION_BT709 : dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_HW_xvYCC ) ; break ; case TRANSFER_FUNCTION_LINEAR : dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_BYPASS ) ; break ; case TRANSFER_FUNCTION_PQ : dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_USER_PWL ) ; cm_helper_translate_curve_to_degamma_hw_format ( tf , & dpp_base -> degamma_params ) ; dpp_base -> funcs -> dpp_program_degamma_pwl ( dpp_base , & dpp_base -> degamma_params ) ; result = true ; break ; default : result = false ; break ; } } if ( tf -> type == TF_TYPE_BYPASS ) { dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_BYPASS ) ; } else { BREAK_TO_DEBUGGER ( ) ; dpp_base -> funcs -> dpp_set_degamma ( dpp_base , IPP_DEGAMMA_MODE_BYPASS ) ; } return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int for_each_subchannel ( int * fn ( struct subchannel_id , void * ) , void * data ) { struct subchannel_id schid ; int ret ; init_subchannel_id ( & schid ) ; { { ret = fn ( schid , data ) ; } schid . sch_no ++ < __MAX_SUBCHANNEL ; schid . sch_no = 0 ; } schid . ssid ++ < max_ssid ; return ret ; } cb_data { void * data ; struct idset * set ; int * fn_known_sch ( struct subchannel * , void * ) int * fn_unknown_sch ( struct subchannel_id , void * ) } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int spi_flash_mtd_read ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , u_char * buf ) { struct spi_flash * flash = mtd -> priv ; int err ; if ( ! flash ) { return - ENODEV ; } err = spi_flash_read ( flash , from , len , buf ) ; if ( ! err ) { * retlen = len ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct cachekey_header * cache_insert_ch ( struct cachekey_header * ch , uid_t uid , deskeyarray common , des_block key , keybuf3 * public , keybuf3 * secret ) { struct cachekey_disklist * cd ; struct cachekey_header * newch ; int i , err ; struct skck * skck ; des_block ivec ; struct dhkey * pk ; struct dhkey * sk ; if ( ch == 0 || uid == ( uid_t ) - 1 ) { return ( 0 ) ; } if ( common . deskeyarray_len > sizeof ( skck -> common ) / sizeof ( des_block ) || ( pk = keybuf3_2_dhkey ( public ) ) == 0 || ( sk = keybuf3_2_dhkey ( secret ) ) == 0 ) { return ( 0 ) ; } newch = ch ; if ( ( cd = find_cache_item ( & newch , uid , pk ) ) == 0 ) { free ( sk ) ; return ( newch ) ; } cd -> uid = uid ; memcpy ( & ( cd -> public ) , pk , DHKEYSIZE ( pk ) ) ; skck = MOVE_ADDR ( & ( cd -> public ) , DHKEYSIZE ( pk ) ) ; for ( i = 0 ; i < common . deskeyarray_len ; i ++ ) { skck -> common [ i ] = common . deskeyarray_val [ i ] ; } skck -> verifier = key ; memcpy ( & ( skck -> secret ) , sk , DHKEYSIZE ( sk ) ) ; free ( pk ) ; free ( sk ) ; memcpy ( ivec . c , key . c , sizeof ( key . c ) ) ; err = cbc_crypt ( key . c , ( char * ) skck , SKCK_LEN ( newch -> keylen ) , DES_ENCRYPT | DES_HW , ivec . c ) ; if ( DES_FAILED ( err ) ) { list_insert ( cd , & ( newch -> free ) , 0 , & ( newch -> free_count ) ) ; return ( newch ) ; } list_insert_hash ( cd , & ( newch -> bucket [ hashval ( cd -> uid ) ] ) , 0 , 0 ) ; list_insert ( cd , & ( newch -> inuse ) , & ( newch -> inuse_end ) , & ( newch -> inuse_count ) ) ; ( void ) msync ( ( caddr_t ) newch , newch -> length , MS_SYNC ) ; return ( newch ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "AVCodec * avcodec_find_encoder_by_name ( const char * name ) { AVCodec * p ; if ( ! name ) { return in ; } p = first_avcodec ; while ( p ) { if ( av_codec_is_encoder ( p ) && strcmp ( name , p -> name ) == 0 ) { return p ; } p = p -> next ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rxe_create_ah ( struct ib_ah * ibah , struct rdma_ah_init_attr * init_attr , struct ib_udata * udata ) { struct rxe_dev * rxe = to_rdev ( ibah -> device ) ; struct rxe_ah * ah = to_rah ( ibah ) ; struct rxe_create_ah_resp __user * uresp = NULL ; int err ; if ( udata ) { if ( udata -> outlen >= sizeof ( * uresp ) ) { uresp = udata -> outbuf ; } ah -> is_user = true ; } else { ah -> is_user = false ; } err = rxe_add_to_pool_ah ( & rxe -> ah_pool , ah , init_attr -> flags & RDMA_CREATE_AH_SLEEPABLE ) ; if ( err ) { return err ; } ah -> ah_num = ah -> elem . index ; err = rxe_ah_chk_attr ( ah , init_attr -> ah_attr ) ; if ( err ) { rxe_cleanup ( ah , NULL ) ; return err ; } if ( uresp ) { err = copy_to_user ( & uresp -> ah_num , & ah -> ah_num , sizeof ( uresp -> ah_num ) ) ; if ( err ) { rxe_cleanup ( ah ) ; return - EFAULT ; } } if ( ah -> is_user ) { ah -> ah_num = 0 ; } rxe_init_av ( init_attr -> ah_attr , & ah -> av ) ; rxe_finalize ( ah ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int drm_connector_init ( struct drm_device * dev , struct drm_connector * connector , const struct drm_connector_funcs * funcs , int connector_type ) { struct drm_mode_config * config = & dev -> mode_config ; int ret ; struct ida * connector_ida = & drm_connector_enum_list [ connector_type ] . ida ; ret = __drm_mode_object_add ( dev , & connector -> base , DRM_MODE_OBJECT_CONNECTOR , false , drm_connector_free ) ; if ( ret ) { return ret ; } connector -> base . properties = & connector -> properties ; connector -> dev = dev ; connector -> funcs = funcs ; ret = ida_simple_get ( & config -> connector_ida , 0 , 0 , GFP_KERNEL ) ; if ( ret < 0 ) { out_put } connector -> index = ret ; ret = 0 ; connector -> connector_type = connector_type ; connector -> connector_type_id = ida_simple_get ( connector_ida , 1 , 0 , GFP_KERNEL ) ; if ( connector -> connector_type_id < 0 ) { ret = connector -> connector_type_id ; out_put_id } connector -> name = kasprintf ( GFP_KERNEL , \"%s-%d\" , drm_connector_enum_list [ connector_type ] . name , connector -> connector_type_id ) ; if ( ! connector -> name ) { ret = - ENOMEM ; out_put_type_id } INIT_LIST_HEAD ( & connector -> probed_modes ) ; INIT_LIST_HEAD ( & connector -> modes ) ; connector -> edid_blob_ptr = NULL ; connector -> status = connector_status_unknown ; drm_connector_get_cmdline_mode ( connector ) ; spin_lock_irq ( & config -> connector_list_lock ) ; list_add_tail ( & connector -> head , & config -> connector_list ) ; config -> num_connector ++ ; spin_unlock_irq ( & config -> connector_list_lock ) ; if ( connector_type != DRM_MODE_CONNECTOR_VIRTUAL ) { drm_object_attach_property ( & connector -> base , config -> edid_property , 0 ) ; } drm_object_attach_property ( & connector -> base , config -> dpms_property , 0 ) ; drm_object_attach_property ( & connector -> base , config -> link_status_property , 0 ) ; if ( drm_core_check_feature ( dev , DRIVER_ATOMIC ) ) { drm_object_attach_property ( & connector -> base , config -> prop_crtc_id , 0 ) ; } connector -> debugfs_entry = NULL ; out_put_type_id if ( ret ) { ida_simple_remove ( connector_ida , connector -> connector_type_id ) ; } out_put_id if ( ret ) { ida_simple_remove ( & config -> connector_ida , connector -> index ) ; } out_put if ( ret ) { drm_mode_object_unregister ( dev , & connector -> base ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mcp320x_adc_conversion ( struct mcp320x * adc , u8 channel , bool differential , int device_index , int * val ) { int ret ; if ( adc -> chip_info -> conv_time ) { ret = spi_sync ( adc -> spi , & adc -> start_conv_msg ) ; usleep_range ( adc -> chip_info -> conv_time , adc -> chip_info -> conv_time + 100 ) ; } memset ( & adc -> rx_buf , 0 , sizeof ( adc -> rx_buf ) ) ; if ( adc -> chip_info -> num_channels > 1 ) { adc -> tx_buf = mcp320x_channel_to_tx_data ( device_index , channel , differential ) ; } ret = spi_sync ( adc -> spi , & adc -> msg ) ; if ( ret < 0 ) { return ret ; } switch ( device_index ) { case mcp3001 : * val = ( adc -> rx_buf [ 0 ] << 5 | adc -> rx_buf [ 1 ] >> 3 ) ; return 0 ; case mcp3002 : case mcp3004 : case mcp3008 : * val = ( adc -> rx_buf [ 0 ] << 2 | adc -> rx_buf [ 1 ] >> 6 ) ; return 0 ; case mcp3201 : * val = ( adc -> rx_buf [ 0 ] << 7 | adc -> rx_buf [ 1 ] >> 1 ) ; return 0 ; case mcp3202 : case mcp3204 : case mcp3208 : * val = ( adc -> rx_buf [ 0 ] << 4 | adc -> rx_buf [ 1 ] >> 4 ) ; return 0 ; case mcp3301 : * val = sign_extend32 ( ( adc -> rx_buf [ 0 ] & 0x1f ) << 8 | adc -> rx_buf [ 1 ] , 12 ) ; return 0 ; case mcp3550_50 : case mcp3550_60 : case mcp3551 : case mcp3553 : { u32 raw = be32_to_cpup ( ( __be32 * ) adc -> rx_buf ) ; if ( ! ( adc -> spi -> mode & SPI_CPOL ) ) { raw <<= 1 ; } raw >>= 8 ; if ( raw & BIT ( 22 ) && raw & BIT ( 23 ) ) { return - EIO ; } if ( raw & BIT ( 22 ) ) { raw &= ~ BIT ( 22 ) ; } if ( raw & BIT ( 23 ) || raw & BIT ( 21 ) ) { raw |= GENMASK ( 31 , 22 ) ; } * val = ( s32 ) raw ; return 0 ; } default : return - EINVAL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static krb5_error_code kcm_op_set_kdc_offset ( krb5_context context , kcm_client * client , kcm_operation opcode , krb5_storage * request , krb5_storage * response ) { krb5_error_code ret ; kcm_ccache ccache ; int32_t offset ; char * name ; ret = krb5_ret_stringz ( request , & name ) ; if ( ret ) { return ret ; } KCM_LOG_REQUEST_NAME ( context , client , opcode , name ) ; ret = krb5_ret_int32 ( request , & offset ) ; if ( ret ) { return ret ; } ret = kcm_ccache_resolve_client ( context , client , opcode , name , & ccache ) ; free ( name ) ; if ( ret ) { return ret ; } HEIMDAL_MUTEX_lock ( & ccache -> mutex ) ; ccache -> kdc_offset = offset ; HEIMDAL_MUTEX_unlock ( & ccache -> mutex ) ; kcm_release_ccache ( context , ccache ) ; return ret ; } kcm_ntlm_cred { kcmuuid_t uuid ; char * user ; char * domain ; krb5_data nthash ; uid_t uid ; pid_t session ; struct kcm_ntlm_cred * next ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void pppdump_close ( wtap * wth ) { pppdump_t * state ; state = ( pppdump_t * ) wth -> priv ; if ( state -> seek_state ) { g_free ( state -> seek_state ) ; } if ( state -> pids ) { int i ; for ( i = 0 ; i < g_ptr_array_len ( state -> pids ) ; i ++ ) { g_free ( g_ptr_array_index ( state -> pids , i ) ) ; } g_ptr_array_free ( state -> pids , TRUE ) ; } } static const struct supported_block_type pppdump_blocks_supported [ ] { { WTAP_BLOCK_PACKET MULTIPLE_BLOCKS_SUPPORTED NO_OPTIONS_SUPPORTED } } ; ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mlxsw_linecard_ini_erase ( struct mlxsw_core * mlxsw_core , struct mlxsw_linecard * linecard , struct netlink_ext_ack * extack ) { enum mlxsw_reg_mbct_fsm_state fsm_state ; enum mlxsw_reg_mbct_status status ; int err ; mlxsw_reg_mbct_pack ( linecard -> mbct_pl , linecard -> slot_index , MLXSW_REG_MBCT_OP_ERASE_INI_IMAGE , false ) ; err = mlxsw_reg_write ( mlxsw_core , MLXSW_REG ( mbct ) , linecard -> mbct_pl ) ; if ( err ) { NL_SET_ERR_MSG_MOD ( extack , \"Failed to issue linecard INI erase\" ) ; return err ; } mlxsw_reg_mbct_unpack ( linecard -> mbct_pl , & status , & fsm_state ) ; switch ( status ) { case MLXSW_REG_MBCT_STATUS_ERASE_COMPLETE : break ; default : fallthrough ; case MLXSW_REG_MBCT_STATUS_ERASE_FAILED : NL_SET_ERR_MSG_MOD ( extack , \"Failed to erase linecard INI\" ) ; fix_fsm_err_out case MLXSW_REG_MBCT_STATUS_ERROR_INI_IN_USE : NL_SET_ERR_MSG_MOD ( extack , \"Failed to erase linecard INI while being used\" ) ; fix_fsm_err_out } return 0 ; fix_fsm_err_out mlxsw_linecard_fix_fsm_state ( linecard , fsm_state ) ; return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ieee802154_llsec_add_seclevel ( struct sk_buff * skb , struct genl_info * info ) { return ieee802154_nl_llsec_change ( skb , info , llsec_add_seclevel ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int vroute_getdns ( struct iked * env , struct imsg * imsg ) { struct sockaddr * dns ; uint8_t * ptr ; int left ; int add ; unsigned int ifidx ; ptr = imsg -> data ; left = IMSG_DATA_SIZE ( imsg ) ; if ( left < sizeof ( * dns ) ) { fatalx ( \"bad length imsg received\" ) ; } dns = ( sockaddr * ) ptr ; if ( left < dns -> sa_len ) { fatalx ( \"bad length imsg received\" ) ; } ptr += dns -> sa_len ; left -= dns -> sa_len ; if ( left != sizeof ( ifidx ) ) { fatalx ( \"bad length imsg received\" ) ; } memcpy ( & ifidx , ptr , sizeof ( ifidx ) ) ; ptr += sizeof ( ifidx ) ; left -= sizeof ( ifidx ) ; add = ( imsg -> hdr . type == IMSG_VDNS_ADD ) ; if ( add ) { vroute_insertdns ( env , ifidx , dns ) ; } else { vroute_removedns ( env , ifidx , dns ) ; } return ( vroute_dodns ( env , dns , add , ifidx ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "mpd_t * balance_freeze ( uint32_t user_id , const char * asset , mpd_t * amount ) { struct asset_type * at = get_asset_type ( asset ) ; if ( mpd_cmp ( amount , mpd_zero , & mpd_ctx ) < 0 ) { return NULL ; } mpd_t * available = balance_get ( user_id , BALANCE_TYPE_AVAILABLE , asset ) ; if ( available == NULL ) { return NULL ; } if ( mpd_cmp ( available , amount , & mpd_ctx ) < 0 ) { return NULL ; } if ( balance_add ( user_id , BALANCE_TYPE_FREEZE , asset , amount ) == 0 ) { return NULL ; } mpd_sub ( available , available , amount , & mpd_ctx ) ; if ( mpd_cmp ( available , mpd_zero , & mpd_ctx ) == 0 ) { balance_del ( user_id , BALANCE_TYPE_AVAILABLE , asset ) ; return mpd_zero ; } mpd_rescale ( available , available , - at -> prec_save , & mpd_ctx ) ; return available ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cosm_create_reference_data ( struct sc_profile * profile , struct sc_pkcs15_card * p15card , struct sc_pkcs15_auth_info * ainfo , const unsigned char * pin , size_t pin_len , const unsigned char * puk , size_t puk_len ) { struct sc_context * ctx = p15card -> card -> ctx ; struct sc_card * card = p15card -> card ; struct sc_pkcs15_auth_info profile_auth_pin , profile_auth_puk ; struct sc_cardctl_oberthur_createpin_info args ; int rv ; unsigned char oberthur_puk [ 16 ] { 0x6F 0x47 0xD9 0x88 0x4B 0x6F 0x9D 0xC5 0x78 0x33 0x79 0x8F 0x5B 0x7D 0xE1 0xA5 } ; ; SC_FUNC_CALLED ( ctx , SC_LOG_DEBUG_VERBOSE ) ; sc_log ( ctx , \"pin lens %\" SC_FORMAT_LEN_SIZE_T \"u/%\" SC_FORMAT_LEN_SIZE_T \"u\" , pin_len , puk_len ) ; if ( ! pin || pin_len > 0x40 ) { return SC_ERROR_INVALID_ARGUMENTS ; } if ( puk && ! puk_len ) { return SC_ERROR_INVALID_ARGUMENTS ; } if ( ainfo -> auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN ) { return SC_ERROR_OBJECT_NOT_VALID ; } rv = sc_select_file ( card , & ainfo -> path , NULL ) ; LOG_TEST_RET ( ctx , rv , \"Cannot select file\" ) ; sc_profile_get_pin_info ( profile , SC_PKCS15INIT_USER_PIN , & profile_auth_pin ) ; sc_profile_get_pin_info ( profile , SC_PKCS15INIT_USER_PUK , & profile_auth_puk ) ; args . type = SC_AC_CHV ; args . ref = ainfo -> attrs . pin . reference ; args . pin = pin ; args . pin_len = pin_len ; if ( ! ( ainfo -> attrs . pin . flags & SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN ) ) { args . pin_tries = profile_auth_pin . tries_left ; if ( profile_auth_puk . tries_left > 0 ) { args . puk = oberthur_puk ; args . puk_len = sizeof ( oberthur_puk ) ; args . puk_tries = 5 ; } } else { args . pin_tries = profile_auth_puk . tries_left ; } rv = sc_card_ctl ( card , SC_CARDCTL_OBERTHUR_CREATE_PIN , & args ) ; LOG_TEST_RET ( ctx , rv , \"'CREATE_PIN' card specific command failed\" ) ; if ( ! ( ainfo -> attrs . pin . flags & SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN ) && ( profile_auth_puk . tries_left > 0 ) ) { struct sc_file * file = NULL ; if ( sc_profile_get_file ( profile , COSM_TITLE \"-puk-file\" , & file ) ) { LOG_TEST_RET ( ctx , SC_ERROR_INCONSISTENT_PROFILE , \"Cannot find PUKFILE\" ) ; } rv = sc_pkcs15init_update_file ( profile , p15card , file , oberthur_puk , sizeof ( oberthur_puk ) ) ; LOG_TEST_RET ( ctx , rv , \"Failed to update pukfile\" ) ; sc_file_free ( file ) ; } LOG_FUNC_RETURN ( ctx , rv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int get_signed_sha1 ( tpm_sha1_data_t * dgst , const fido_blob_t * authdata , const fido_blob_t * clientdata ) { const EVP_MD * md = NULL ; EVP_MD_CTX * ctx = NULL ; int ok = - 1 ; if ( ( dgst -> size = sizeof ( dgst -> body ) ) != SHA_DIGEST_LENGTH || ( md = EVP_sha1 ( ) ) == NULL || ( ctx = EVP_MD_CTX_new ( ) ) == NULL || EVP_DigestInit_ex ( ctx , md , NULL ) != 1 || EVP_DigestUpdate ( ctx , authdata -> ptr , authdata -> len ) != 1 || EVP_DigestUpdate ( ctx , clientdata -> ptr , clientdata -> len ) != 1 || EVP_DigestFinal_ex ( ctx , dgst -> body , NULL ) != 1 ) { fido_log_debug ( \"%s: sha1\" , __func__ ) ; fail } ok = 0 ; fail return ( ok ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ret_code_t ble_ln_db_record_get ( uint8_t rec_ndx , ble_lns_route_t * p_rec ) { * p_rec = m_database [ m_database_crossref [ rec_ndx ] ] . record ; return NRF_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ssize_t vfio_pci_bar_rw ( struct vfio_pci_core_device * vdev , char __user * buf , size_t count , loff_t * ppos , bool iswrite ) { struct pci_dev * pdev = vdev -> pdev ; loff_t pos = * ppos & VFIO_PCI_OFFSET_MASK ; int bar = VFIO_PCI_OFFSET_TO_INDEX ( * ppos ) ; size_t x_start = 0 , x_end = 0 ; resource_size_t end ; void __iomem * io ; struct resource * res = & vdev -> pdev -> resource [ bar ] ; ssize_t done ; if ( pci_resource_start ( pdev , bar ) ) { end = pci_resource_len ( pdev , bar ) ; } if ( bar == PCI_ROM_RESOURCE && pdev -> resource [ bar ] . flags & IORESOURCE_ROM_SHADOW ) { end = 0x20000 ; } else { return - EINVAL ; } count = min ( count , ( size_t ) ( end - pos ) ) ; if ( bar == PCI_ROM_RESOURCE ) { io = pci_map_rom ( pdev , & x_start ) ; if ( ! io ) { done = - ENOMEM ; out } x_end = end ; } else { int ret = vfio_pci_setup_barmap ( vdev , bar ) ; if ( ret ) { done = ret ; out } io = vdev -> barmap [ bar ] ; } if ( bar == vdev -> msix_bar ) { x_start = vdev -> msix_offset ; x_end = vdev -> msix_offset + vdev -> msix_size ; } done = do_io_rw ( vdev , res -> flags & IORESOURCE_MEM , io , buf , pos , count , x_start , x_end , iswrite ) ; if ( done >= 0 ) { * ppos += done ; } if ( bar == PCI_ROM_RESOURCE ) { pci_unmap_rom ( pdev , io ) ; } out return done ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t show_sas_rphy_bay_identifier ( struct device * dev , struct device_attribute * attr , char * buf ) { struct sas_rphy * rphy = transport_class_to_rphy ( dev ) ; struct sas_phy * phy = dev_to_phy ( rphy -> dev . parent ) ; struct Scsi_Host * shost = dev_to_shost ( phy -> dev . parent ) ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; int val ; val = i -> f -> get_bay_identifier ( rphy ) ; return sprintf ( buf , \"%d\\n\" , val ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mlx5_ib_destroy_counters ( struct ib_counters * counters ) { struct mlx5_ib_mcounters * mcounters = to_mcounters ( counters ) ; if ( mcounters -> hw_cntrs_hndl ) { mlx5_fc_destroy ( to_mdev ( counters -> device ) -> mdev , mcounters -> hw_cntrs_hndl ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "krb5_error_code krb5_rc_file_close_no_free ( krb5_context context , krb5_rcache id ) { struct file_data * t = ( file_data * ) id -> data ; struct authlist * q ; if ( t -> h ) { FREE_RC ( t -> h ) ; } if ( t -> name ) { FREE_RC ( t -> name ) ; } while ( ( q = t -> a ) ) { t -> a = q -> na ; FREE_RC ( q -> rep . client ) ; FREE_RC ( q -> rep . server , NULL ) ; FREE_RC ( q ) ; } if ( t -> d . fd >= 0 ) { ( void ) krb5_rc_io_close ( context , & t -> d ) ; } FREE_RC ( t ) ; id -> data = NULL ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int DetectNocaseSetup ( DetectEngineCtx * de_ctx , Signature * s , const char * nullstr ) { SCEnter ( ) ; SigMatch * pm = NULL ; int ret = - 1 ; if ( nullstr != NULL ) { SCLogError ( \"nocase has value\" ) ; end } pm = DetectGetLastSMFromLists ( s , DETECT_CONTENT , - 1 ) ; if ( pm == NULL ) { SCLogError ( \"nocase needs \" \"preceding content option\" ) ; end } DetectContentData * cd = ( DetectContentData * ) pm -> ctx ; if ( cd -> flags & DETECT_CONTENT_NOCASE ) { SCLogError ( \"can't use multiple nocase modifiers with the same content\" ) ; end } for ( uint8_t * c = cd -> content ; c < cd -> content + cd -> content_len ; c ++ ) { * c = u8_tolower ( * c ) ; } cd -> flags |= DETECT_CONTENT_NOCASE ; SpmDestroyCtx ( cd -> spm_ctx ) ; cd -> spm_ctx = SpmInitCtx ( cd -> content , cd -> content_len , 1 , de_ctx -> spm_global_thread_ctx ) ; if ( cd -> spm_ctx == NULL ) { end } end SCReturnInt ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void __multiorder_split3 ( int old_order , int new_order ) { RADIX_TREE ( tree , GFP_KERNEL ) ; void * * slot ; struct radix_tree_iter iter ; struct radix_tree_node * node ; void * item ; __radix_tree_insert ( & tree , 0 , old_order , ( void * ) 0x12 ) ; item = __radix_tree_lookup ( & tree , 0 , & node , NULL ) ; assert ( item == ( void * ) 0x12 ) ; assert ( node -> exceptional > 0 ) ; radix_tree_split ( & tree , 0 , new_order ) ; radix_tree_for_each_slot ( , , , 0 ) { radix_tree_iter_replace ( & tree , & iter , slot , ( void * ) 0x16 ) ; } item = __radix_tree_lookup ( & tree , 0 , & node , NULL ) ; assert ( item == ( void * ) 0x16 ) ; assert ( node -> exceptional > 0 ) ; item_kill_tree ( & tree ) ; __radix_tree_insert ( & tree , 0 , old_order , ( void * ) 0x12 ) ; item = __radix_tree_lookup ( & tree , 0 , & node , NULL ) ; assert ( item == ( void * ) 0x12 ) ; assert ( node -> exceptional > 0 ) ; radix_tree_split ( & tree , 0 , new_order ) ; radix_tree_for_each_slot ( , , , 0 ) { if ( iter . index == ( 1 << new_order ) ) { radix_tree_iter_replace ( & tree , & iter , slot , ( void * ) 0x16 ) ; } else { radix_tree_iter_replace ( & tree , & iter , slot , NULL ) ; } } item = __radix_tree_lookup ( & tree , 1 << new_order , & node , NULL ) ; assert ( item == ( void * ) 0x16 ) ; assert ( node -> count == node -> exceptional ) ; { node = node -> parent ; assert ( node -> count == 1 ) ; assert ( node -> exceptional == 0 ) ; } 1 ; item_kill_tree ( & tree ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vidioc_s_fmt_overlay ( struct file * file , void * priv , struct v4l2_format * f ) { struct viu_fh * fh = priv ; struct viu_dev * dev = ( viu_dev * ) fh -> dev ; cfs_time_t flags ; int err ; err = verify_preview ( dev , & f -> fmt . win ) ; if ( err ) { return err ; } fh -> win = f -> fmt . win ; spin_lock_irqsave ( & dev -> slock , flags ) ; viu_setup_preview ( dev , fh ) ; spin_unlock_irqrestore ( & dev -> slock , flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void foo ( ) { if ( uc == 10000 ) { return ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "extern int skip_utf8 ( const symbol * p , int c , int limit , int n ) { int b ; for ( ; n > 0 ; n -- ) { if ( c >= limit ) { return - 1 ; } b = p [ c ++ ] ; if ( b >= 0xC0 ) { while ( c < limit ) { b = p [ c ] ; if ( b >= 0xC0 || b < 0x80 ) { break ; } c ++ ; } } } return c ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "update_status_progress_and_estimating ( ) { GString * buf ; guint64 total = 0 ; guint64 elapsed_time ; guint new_progress = 0 ; gboolean estimating = FALSE ; guint64 total_transferred ; gboolean last_was_metadata = self -> last_was_metadata ; g_autofree gchar * formatted_bytes_total_transferred = NULL ; if ( self -> requested == 0 ) { return ; } buf = g_string_new ( \"\" ) ; elapsed_time = ( g_get_monotonic_time ( ) - self -> start_time ) / G_USEC_PER_SEC ; if ( * self -> ostree_status && self -> total_extra_data_bytes == 0 ) { g_string_append ( buf , self -> ostree_status ) ; new_progress = 100 ; out } total_transferred = self -> bytes_transferred + self -> transferred_extra_data_bytes ; formatted_bytes_total_transferred = g_format_size_full ( total_transferred , 0 ) ; self -> last_was_metadata = FALSE ; if ( self -> total_delta_parts == 0 && ( self -> outstanding_metadata_fetches > 0 || last_was_metadata ) && self -> metadata_fetched < 20 ) { if ( self -> outstanding_metadata_fetches > 0 ) { self -> last_was_metadata = TRUE ; } estimating = TRUE ; g_string_append_printf ( buf , _ ( \"Downloading metadata: %u/(estimating) %s\" ) , self -> fetched , formatted_bytes_total_transferred ) ; new_progress = 0 ; if ( self -> requested > 0 ) { new_progress = self -> fetched * 5 / self -> requested ; } } else { if ( self -> total_delta_parts > 0 ) { g_autofree gchar * formatted_bytes_total = NULL ; total = self -> total_delta_part_size - self -> fetched_delta_part_size + self -> total_extra_data_bytes ; formatted_bytes_total = g_format_size_full ( total , 0 ) ; g_string_append_printf ( buf , _ ( \"Downloading: %s/%s\" ) , formatted_bytes_total_transferred , formatted_bytes_total ) ; } else { double average_object_size = 1 ; if ( self -> fetched > 0 ) { average_object_size = self -> bytes_transferred / ( double ) self -> fetched ; } total = average_object_size * self -> requested + self -> total_extra_data_bytes ; if ( self -> downloading_extra_data ) { g_autofree gchar * formatted_bytes_total = g_format_size_full ( total , 0 ) ; g_string_append_printf ( buf , _ ( \"Downloading extra data: %s/%s\" ) , formatted_bytes_total_transferred , formatted_bytes_total ) ; } else { g_string_append_printf ( buf , _ ( \"Downloading files: %d/%d %s\" ) , self -> fetched , self -> requested , formatted_bytes_total_transferred ) ; } } if ( total > 0 ) { new_progress = 5 + ( ( total_transferred / ( gdouble ) total ) * 92 ) ; } else { new_progress = 97 ; } new_progress += get_write_progress ( self -> outstanding_writes ) ; } if ( elapsed_time > 0 ) { g_autofree gchar * formatted_bytes_sec = g_format_size ( total_transferred / elapsed_time ) ; g_string_append_printf ( buf , \" (%s/s)\" , formatted_bytes_sec ) ; } out if ( new_progress < self -> progress && self -> last_total == total ) { new_progress = self -> progress ; } self -> last_total = total ; if ( new_progress > 100 ) { if ( ! self -> reported_overflow ) { g_info ( \"Unexpectedly got>100%% progress, limiting\" ) ; } self -> reported_overflow = TRUE ; new_progress = 100 ; } self -> status = g_string_free ( buf , FALSE ) ; self -> progress = new_progress ; self -> estimating = estimating ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dce_v8_0_afmt_init ( struct amdgpu_device * adev ) { int i ; for ( i = 0 ; i < adev -> mode_info . num_dig ; i ++ ) { adev -> mode_info . afmt [ i ] = NULL ; } for ( i = 0 ; i < adev -> mode_info . num_dig ; i ++ ) { adev -> mode_info . afmt [ i ] = kmalloc ( sizeof ( amdgpu_afmt ) , GFP_KERNEL ) ; if ( adev -> mode_info . afmt [ i ] ) { adev -> mode_info . afmt [ i ] -> offset = dig_offsets [ i ] ; adev -> mode_info . afmt [ i ] -> id = i ; } else { int j ; for ( j = 0 ; j < i ; j ++ ) { kfree ( adev -> mode_info . afmt [ j ] ) ; adev -> mode_info . afmt [ j ] = NULL ; } return - ENOMEM ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void intel_menlow_memory_remove ( struct acpi_device * device ) { struct thermal_cooling_device * cdev ; if ( ! device ) { return ; } cdev = acpi_driver_data ( device ) ; if ( ! cdev ) { return ; } sysfs_remove_link ( & device -> dev . kobj , \"thermal_cooling\" ) ; sysfs_remove_link ( & cdev -> device . kobj , \"device\" ) ; thermal_cooling_device_unregister ( cdev , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void stv0297_release ( struct dvb_frontend * fe ) { struct stv0297_state * state = fe -> demodulator_priv ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pl330_fifo_get ( PL330Fifo * s , uint8_t * buf , int len , uint8_t tag ) { int i ; for ( i = 0 ; i < len ; i ++ ) { if ( s -> tag [ s -> head ] == tag ) { int get_idx = ( s -> head + i ) % s -> buf_size ; buf [ i ] = s -> buf [ get_idx ] ; } else { return PL330_FIFO_ERR ; } } s -> head = ( s -> head + len ) % s -> buf_size ; s -> num -= len ; return PL330_FIFO_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void send_update ( struct eigrp_iface * ei , struct nbr * nbr , uint32_t flags , struct rinfo_head * rinfo_list ) { struct eigrp * eigrp = ei -> eigrp ; struct ibuf * buf ; struct rinfo_entry * re ; int size ; int route_len ; { if ( ( buf = ibuf_dynamic ( PKG_DEF_SIZE , IP_MAXPACKET - sizeof ( ip ) ) ) == NULL ) { fatal ( \"send_update\" ) ; } if ( gen_eigrp_hdr ( buf , EIGRP_OPC_UPDATE , flags , eigrp -> seq_num , eigrp -> as ) ) { fail } if ( rinfo_list == NULL ) { break ; } switch ( eigrp -> af ) { case AF_INET : size = sizeof ( ip ) ; break ; case AF_INET6 : size = sizeof ( ip6_hdr ) ; break ; default : fatalx ( \"send_update: unknown af\" ) ; } size += sizeof ( eigrp_hdr ) ; while ( ( re = TAILQ_FIRST ( rinfo_list ) ) != NULL ) { route_len = len_route_tlv ( & re -> rinfo ) ; if ( size + route_len > ei -> iface -> mtu ) { rtp_send ( ei , nbr , buf ) ; break ; } size += route_len ; if ( gen_route_tlv ( buf , & re -> rinfo ) ) { fail } TAILQ_REMOVE ( rinfo_list , re , entry ) ; } } ! TAILQ_EMPTY ( rinfo_list ) ; rtp_send ( ei , nbr , buf ) ; return ; fail log_warnx ( \"%s: failed to send message\" , __func__ ) ; if ( rinfo_list ) { message_list_clr ( rinfo_list ) ; } ibuf_free ( buf ) ; return ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void prefetch256 ( const void * table ) { volatile unsigned long * t = ( void * ) table , ret ; cfs_time_t sum ; int i ; for ( sum = 0 , i = 0 ; i < 256 / sizeof ( t [ 0 ] ) ; i += 32 / sizeof ( t [ 0 ] ) ) { sum ^= t [ i ] ; } ret = sum ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int benchmark ( void * fn ( void ) ) { unsigned n , i , t , t0 ; for ( n = 1000 ; ; n *= 2 ) { t0 = sched_clock ( ) ; for ( i = n ; i > 0 ; -- i ) { fn ( ) ; } t = sched_clock ( ) - t0 ; } return t / n ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int jffs2_fsync ( struct file * filp , loff_t start , loff_t end , int datasync ) { struct inode * inode = filp -> f_mapping -> host ; struct jffs2_sb_info * c = JFFS2_SB_INFO ( inode -> i_sb ) ; int ret ; ret = filemap_write_and_wait_range ( inode -> i_mapping , start , end ) ; if ( ret ) { return ret ; } inode_lock ( inode , NULL ) ; jffs2_flush_wbuf_gc ( c , inode -> i_ino ) ; inode_unlock ( inode ) ; return 0 ; } const struct file_operations jffs2_file_operations = { . llseek = generic_file_llseek . open = generic_file_open . read_iter = generic_file_read_iter . write_iter = generic_file_write_iter . unlocked_ioctl = jffs2_ioctl . mmap = generic_file_readonly_mmap . fsync = jffs2_fsync . splice_read = generic_file_splice_read } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sk_enroll ( uint32_t alg , const uint8_t * challenge , size_t challenge_len , const char * application , uint8_t flags , const char * pin , struct sk_option * * options , struct sk_enroll_response * * enroll_response ) { fido_cred_t * cred = NULL ; const uint8_t * ptr ; uint8_t user_id [ 32 ] ; struct sk_usbhid * sk = NULL ; struct sk_enroll_response * response = NULL ; size_t len ; int credprot ; int cose_alg ; int ret = SSH_SK_ERR_GENERAL ; int r ; char * device = NULL ; fido_init ( SSH_FIDO_INIT_ARG ) ; if ( enroll_response == NULL ) { skdebug ( __func__ , \"enroll_response == NULL\" ) ; out } * enroll_response = NULL ; if ( check_enroll_options ( options , & device , user_id , sizeof ( user_id ) ) != 0 ) { out } switch ( alg ) { case SSH_SK_ECDSA : cose_alg = COSE_ES256 ; break ; case SSH_SK_ED25519 : cose_alg = COSE_EDDSA ; break ; default : skdebug ( __func__ , \"unsupported key type %d\" , alg ) ; out } if ( device != NULL ) { sk = sk_open ( device ) ; } else { sk = sk_probe ( NULL , NULL , 0 , 0 ) ; } if ( sk == NULL ) { ret = SSH_SK_ERR_DEVICE_NOT_FOUND ; skdebug ( __func__ , \"failed to find sk\" ) ; out } skdebug ( __func__ , \"using device %s\" , sk -> path ) ; if ( ( flags & SSH_SK_RESIDENT_KEY ) != 0 && ( flags & SSH_SK_FORCE_OPERATION ) == 0 && ( r = key_lookup ( sk -> dev , application , user_id , sizeof ( user_id ) , pin ) ) != FIDO_ERR_NO_CREDENTIALS ) { if ( r != FIDO_OK ) { ret = fidoerr_to_skerr ( r ) ; skdebug ( __func__ , \"key_lookup failed\" ) ; } else { ret = SSH_SK_ERR_CREDENTIAL_EXISTS ; skdebug ( __func__ , \"key exists\" ) ; } out } if ( ( cred = fido_cred_new ( ) ) == NULL ) { skdebug ( __func__ , \"fido_cred_new failed\" ) ; out } if ( ( r = fido_cred_set_type ( cred , cose_alg ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_type: %s\" , fido_strerr ( r ) ) ; out } if ( ( r = fido_cred_set_clientdata ( cred , challenge , challenge_len ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_clientdata: %s\" , fido_strerr ( r ) ) ; out } if ( ( r = fido_cred_set_rk ( cred , ( flags & SSH_SK_RESIDENT_KEY ) != 0 ?FIDO_OPT_TRUE : FIDO_OPT_OMIT ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_rk: %s\" , fido_strerr ( r ) ) ; out } if ( ( r = fido_cred_set_user ( cred , user_id , sizeof ( user_id ) , \"openssh\" , \"openssh\" , NULL ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_user: %s\" , fido_strerr ( r ) ) ; out } if ( ( r = fido_cred_set_rp ( cred , application , NULL ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_rp: %s\" , fido_strerr ( r ) ) ; out } if ( ( flags & ( SSH_SK_RESIDENT_KEY | SSH_SK_USER_VERIFICATION_REQD ) ) != 0 ) { if ( ! fido_dev_supports_cred_prot ( sk -> dev ) ) { skdebug ( __func__ , \"%s does not support credprot, \" \"refusing to create unprotected \" \"resident/verify-required key\" , sk -> path ) ; ret = SSH_SK_ERR_UNSUPPORTED ; out } if ( ( flags & SSH_SK_USER_VERIFICATION_REQD ) ) { credprot = FIDO_CRED_PROT_UV_REQUIRED ; } else { credprot = FIDO_CRED_PROT_UV_OPTIONAL_WITH_ID ; } if ( ( r = fido_cred_set_prot ( cred , credprot ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_set_prot: %s\" , fido_strerr ( r ) ) ; ret = fidoerr_to_skerr ( r ) ; out } } if ( ( r = fido_dev_make_cred ( sk -> dev , cred , pin ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_dev_make_cred: %s\" , fido_strerr ( r ) ) ; ret = fidoerr_to_skerr ( r ) ; out } if ( fido_cred_x5c_ptr ( cred ) != NULL ) { if ( ( r = fido_cred_verify ( cred ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_verify: %s\" , fido_strerr ( r ) ) ; out } } else { skdebug ( __func__ , \"self-attested credential\" ) ; if ( ( r = fido_cred_verify_self ( cred ) ) != FIDO_OK ) { skdebug ( __func__ , \"fido_cred_verify_self: %s\" , fido_strerr ( r ) ) ; out } } if ( ( response = calloc ( 1 , sizeof ( * response ) ) ) == NULL ) { skdebug ( __func__ , \"calloc response failed\" ) ; out } response -> flags = flags ; if ( pack_public_key ( alg , cred , response ) != 0 ) { skdebug ( __func__ , \"pack_public_key failed\" ) ; out } if ( ( ptr = fido_cred_id_ptr ( cred ) ) != NULL ) { len = fido_cred_id_len ( cred ) ; if ( ( response -> key_handle = calloc ( 1 , len ) ) == NULL ) { skdebug ( __func__ , \"calloc key handle failed\" ) ; out } memcpy ( response -> key_handle , ptr , len ) ; response -> key_handle_len = len ; } if ( ( ptr = fido_cred_sig_ptr ( cred ) ) != NULL ) { len = fido_cred_sig_len ( cred ) ; if ( ( response -> signature = calloc ( 1 , len ) ) == NULL ) { skdebug ( __func__ , \"calloc signature failed\" ) ; out } memcpy ( response -> signature , ptr , len ) ; response -> signature_len = len ; } if ( ( ptr = fido_cred_x5c_ptr ( cred ) ) != NULL ) { len = fido_cred_x5c_len ( cred ) ; skdebug ( __func__ , \"attestation cert len=%zu\" , len ) ; if ( ( response -> attestation_cert = calloc ( 1 , len ) ) == NULL ) { skdebug ( __func__ , \"calloc attestation cert failed\" ) ; out } memcpy ( response -> attestation_cert , ptr , len ) ; response -> attestation_cert_len = len ; } if ( ( ptr = fido_cred_authdata_ptr ( cred ) ) != NULL ) { len = fido_cred_authdata_len ( cred ) ; skdebug ( __func__ , \"authdata len=%zu\" , len ) ; if ( ( response -> authdata = calloc ( 1 , len ) ) == NULL ) { skdebug ( __func__ , \"calloc authdata failed\" ) ; out } memcpy ( response -> authdata , ptr , len ) ; response -> authdata_len = len ; } * enroll_response = response ; response = NULL ; ret = 0 ; out free ( device ) ; if ( response != NULL ) { free ( response -> public_key ) ; free ( response -> key_handle ) ; free ( response -> signature ) ; free ( response -> attestation_cert ) ; free ( response -> authdata ) ; free ( response ) ; } sk_close ( sk ) ; fido_cred_free ( & cred ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int fastboot_set_reboot_flag ( enum fastboot_reboot_reason reason ) { return omap_reboot_mode_store ( \"b\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int isight_probe ( struct fw_unit * unit , const struct ieee1394_device_id * id ) { struct fw_device * fw_dev = fw_parent_device ( unit ) ; struct snd_card * card ; struct isight * isight ; int err ; err = snd_card_new ( & unit -> device , - 1 , NULL , THIS_MODULE , sizeof ( * isight ) , & card ) ; if ( err < 0 ) { return err ; } isight = card -> private_data ; isight -> card = card ; mutex_init ( & isight -> mutex ) ; isight -> unit = fw_unit_get ( unit ) ; isight -> device = fw_dev ; isight -> audio_base = get_unit_base ( unit ) ; if ( ! isight -> audio_base ) { dev_err ( & unit -> device , \"audio unit base not found\\n\" ) ; err = - ENXIO ; err_unit } fw_iso_resources_init ( & isight -> resources , unit ) ; card -> private_free = isight_card_free ; strcpy ( card -> driver , \"iSight\" ) ; strcpy ( card -> shortname , \"Apple iSight\" ) ; snprintf ( card -> longname , sizeof ( card -> longname ) , \"Apple iSight (GUID %08x%08x) at %s, S%d\" , fw_dev -> config_rom [ 3 ] , fw_dev -> config_rom [ 4 ] , dev_name ( & unit -> device ) , 100 << fw_dev -> max_speed ) ; strcpy ( card -> mixername , \"iSight\" ) ; err = isight_create_pcm ( isight ) ; err = isight_create_mixer ( isight ) ; if ( err < 0 ) { error } err = snd_card_register ( card ) ; if ( err < 0 ) { error } dev_set_drvdata ( & unit -> device , isight ) ; return 0 ; err_unit fw_unit_put ( isight -> unit ) ; mutex_destroy ( & isight -> mutex ) ; error snd_card_free ( card ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int surface_kbd_probe ( struct platform_device * pdev ) { struct ssam_controller * ctrl ; struct surface_hid_device * shid ; ctrl = ssam_client_bind ( & pdev -> dev ) ; if ( IS_ERR ( ctrl ) ) { return PTR_ERR ( ctrl ) == - ENODEV ?- EPROBE_DEFER : PTR_ERR ( ctrl ) ; } shid = devm_kzalloc ( & pdev -> dev , sizeof ( * shid ) , GFP_KERNEL ) ; if ( ! shid ) { return - ENOMEM ; } shid -> dev = & pdev -> dev ; shid -> ctrl = ctrl ; shid -> uid . domain = SSAM_DOMAIN_SERIALHUB ; shid -> uid . category = SSAM_SSH_TC_KBD ; shid -> uid . target = SSAM_SSH_TID_KIP ; shid -> uid . instance = 0 ; shid -> uid . function = 0 ; shid -> notif . base . priority = 1 ; shid -> notif . base . fn = ssam_kbd_event_fn ; shid -> notif . event . reg = SSAM_EVENT_REGISTRY_SAM ; shid -> notif . event . id . target_category = shid -> uid . category ; shid -> notif . event . id . instance = shid -> uid . instance ; shid -> notif . event . flags = 0 ; shid -> ops . get_descriptor = ssam_kbd_get_descriptor ; shid -> ops . output_report = skbd_output_report ; shid -> ops . get_feature_report = skbd_get_feature_report ; shid -> ops . set_feature_report = skbd_set_feature_report ; platform_set_drvdata ( pdev , shid ) ; return surface_hid_device_add ( shid ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int smb3_query_mf_symlink ( unsigned int xid , struct cifs_tcon * tcon , struct cifs_sb_info * cifs_sb , const unsigned char * path , char * pbuf , unsigned int * pbytes_read ) { int rc ; struct cifs_fid fid ; struct cifs_open_parms oparms ; struct cifs_io_parms io_parms = { 0 } ; int buf_type = CIFS_NO_BUFFER ; __le16 * utf16_path ; __u8 oplock = SMB2_OPLOCK_LEVEL_NONE ; struct smb2_file_all_info * pfile_info = NULL ; oparms = ( cifs_open_parms ) { . tcon = tcon . cifs_sb = cifs_sb . desired_access = GENERIC_READ . create_options = cifs_create_options ( cifs_sb , CREATE_NOT_DIR ) . disposition = FILE_OPEN . fid = & fid } ; utf16_path = cifs_convert_path_to_utf16 ( path , cifs_sb ) ; if ( utf16_path == NULL ) { return - ENOMEM ; } pfile_info = kzalloc ( sizeof ( smb2_file_all_info ) + PATH_MAX * 2 , GFP_KERNEL ) ; if ( pfile_info == NULL ) { return - ENOMEM ; } rc = SMB2_open ( xid , & oparms , utf16_path , & oplock , pfile_info , NULL , NULL , NULL ) ; if ( rc ) { qmf_out_open_fail } if ( pfile_info -> EndOfFile != cpu_to_le64 ( CIFS_MF_SYMLINK_FILE_SIZE ) ) { rc = - ENOENT ; qmf_out } io_parms . netfid = fid . netfid ; io_parms . pid = current -> tgid ; io_parms . tcon = tcon ; io_parms . offset = 0 ; io_parms . length = CIFS_MF_SYMLINK_FILE_SIZE ; io_parms . persistent_fid = fid . persistent_fid ; io_parms . volatile_fid = fid . volatile_fid ; rc = SMB2_read ( xid , & io_parms , pbytes_read , & pbuf , & buf_type ) ; qmf_out SMB2_close ( xid , tcon , fid . persistent_fid , fid . volatile_fid ) ; qmf_out_open_fail kfree ( utf16_path ) ; kfree ( pfile_info ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vc4_get_param_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct vc4_dev * vc4 = to_vc4_dev ( dev ) ; struct drm_vc4_get_param * args = data ; int ret ; if ( args -> pad != 0 ) { return - EINVAL ; } if ( WARN_ON_ONCE ( vc4 -> is_vc5 ) ) { return - ENODEV ; } if ( ! vc4 -> v3d ) { return - ENODEV ; } switch ( args -> param ) { case DRM_VC4_PARAM_V3D_IDENT0 : ret = vc4_v3d_pm_get ( vc4 , NULL ) ; if ( ret ) { return ret ; } args -> value = V3D_READ ( V3D_IDENT0 ) ; vc4_v3d_pm_put ( vc4 ) ; break ; case DRM_VC4_PARAM_V3D_IDENT1 : ret = vc4_v3d_pm_get ( vc4 ) ; if ( ret ) { return ret ; } args -> value = V3D_READ ( V3D_IDENT1 ) ; vc4_v3d_pm_put ( vc4 ) ; break ; case DRM_VC4_PARAM_V3D_IDENT2 : ret = vc4_v3d_pm_get ( vc4 ) ; if ( ret ) { return ret ; } args -> value = V3D_READ ( V3D_IDENT2 ) ; vc4_v3d_pm_put ( vc4 ) ; break ; case DRM_VC4_PARAM_SUPPORTS_BRANCHES : case DRM_VC4_PARAM_SUPPORTS_ETC1 : case DRM_VC4_PARAM_SUPPORTS_THREADED_FS : case DRM_VC4_PARAM_SUPPORTS_FIXED_RCL_ORDER : case DRM_VC4_PARAM_SUPPORTS_MADVISE : case DRM_VC4_PARAM_SUPPORTS_PERFMON : args -> value = true ; break ; default : DRM_DEBUG ( \"Unknown parameter %d\\n\" , args -> param ) ; return - EINVAL ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gboolean inf_name_resolver_start ( InfNameResolver * resolver , GError * * error ) { InfNameResolverPrivate * priv ; gboolean success ; g_return_val_if_fail ( INF_IS_NAME_RESOLVER ( resolver ) , FALSE ) ; g_return_val_if_fail ( error == NULL || * error == NULL , FALSE ) ; priv = INF_NAME_RESOLVER_PRIVATE ( resolver ) ; g_return_val_if_fail ( priv -> operation == NULL , FALSE ) ; inf_name_resolver_result_cleanup ( & priv -> result ) ; inf_name_resolver_result_nullify ( & priv -> result ) ; priv -> operation = inf_async_operation_new ( priv -> io , inf_name_resolver_run_func , inf_name_resolver_done_func , resolver ) ; g_object_ref ( resolver ) ; success = inf_async_operation_start ( priv -> operation , error ) ; if ( success == FALSE ) { g_object_unref ( resolver ) ; return FALSE ; } return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { int number_failed = 0 ; SRunner * sr ; rundebug ( ) ; sr = srunner_create ( attr_fn_tokens_suite ( ) ) ; srunner_set_log ( sr , \"attr_fn_tokens_suite.log\" ) ; srunner_run_all ( sr , CK_NORMAL ) ; number_failed = srunner_ntests_failed ( sr ) ; srunner_free ( sr ) ; return number_failed ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s6d16d0_get_modes ( struct drm_panel * panel , struct drm_connector * connector ) { struct drm_display_mode * mode ; mode = drm_mode_duplicate ( connector -> dev , & samsung_s6d16d0_mode ) ; if ( ! mode ) { dev_err ( panel -> dev , \"bad mode or failed to add mode\\n\" ) ; return - EINVAL ; } drm_mode_set_name ( mode , NULL ) ; mode -> type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED ; connector -> display_info . width_mm = mode -> width_mm ; connector -> display_info . height_mm = mode -> height_mm ; drm_mode_probed_add ( connector , mode ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void add_node ( Sys_tree * root , Prom_node * pnode ) { int board = - 1 ; int portid = - 1 ; void * value = NULL ; Board_node * bnode = NULL ; Prom_node * p = NULL ; value = get_prop_val ( find_prop ( pnode , \"portid\" ) ) ; if ( value != NULL ) { portid = * ( int * ) value ; } board = DAK_PORTID_TO_BOARD_NUM ( portid , NULL ) ; if ( ( bnode = daktari_find_board ( root , board ) ) == NULL ) { bnode = daktari_insert_board ( root , board ) ; } pnode -> sibling = NULL ; if ( bnode -> nodes == NULL ) { bnode -> nodes = pnode ; } else { p = bnode -> nodes ; while ( p -> sibling != NULL ) { p = p -> sibling ; } p -> sibling = pnode ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int intel_get_crtc_scanline ( struct intel_crtc * crtc ) { struct drm_i915_private * dev_priv = to_i915 ( crtc -> base . dev ) ; cfs_time_t irqflags ; int position ; spin_lock_irqsave ( & dev_priv -> uncore . lock , irqflags ) ; position = __intel_get_crtc_scanline ( crtc ) ; spin_unlock_irqrestore ( & dev_priv -> uncore . lock , irqflags ) ; return position ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vpx3220_write_block ( struct v4l2_subdev * sd , const u8 * data , unsigned int len ) { u8 reg ; int ret = - 1 ; while ( len >= 2 ) { reg = * data ++ ; ret = vpx3220_write ( sd , reg , * data ++ ) ; len -= 2 ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rtsx_resume ( struct pci_dev * pci ) { struct rtsx_dev * dev = pci_get_drvdata ( pci ) ; struct rtsx_chip * chip ; chip = dev -> chip ; mutex_lock ( & dev -> dev_mutex ) ; pci_set_power_state ( pci , PCI_D0 ) ; pci_restore_state ( pci ) ; if ( pci_enable_device ( pci ) < 0 ) { dev_err ( & dev -> pci -> dev , \"%s: pci_enable_device failed, disabling device\\n\" , CR_DRIVER_NAME ) ; mutex_unlock ( & dev -> dev_mutex ) ; return - EIO ; } pci_set_master ( pci ) ; if ( chip -> msi_en ) { if ( pci_enable_msi ( pci ) < 0 ) { chip -> msi_en = 0 ; } } if ( rtsx_acquire_irq ( dev ) < 0 ) { mutex_unlock ( & dev -> dev_mutex ) ; return - EIO ; } rtsx_write_register ( chip , HOST_SLEEP_STATE , 0x03 , 0x00 ) ; rtsx_init_chip ( chip ) ; mutex_unlock ( & dev -> dev_mutex ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gimp_environ_table_clear_vars ( ) { if ( environ_table -> vars ) { g_hash_table_destroy ( environ_table -> vars ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int parse_caps ( sd_bus_creds * c , unsigned offset , const char * p ) { size_t sz , max ; unsigned i , j ; assert ( c ) ; assert ( p ) ; max = DIV_ROUND_UP ( cap_last_cap ( ) + 1 , 32U ) ; p += strspn ( p , WHITESPACE ) ; sz = strlen ( p ) ; if ( sz % 8 != 0 ) { return - EINVAL ; } sz /= 8 ; if ( ! c -> capability ) { c -> capability = new0 ( uint32_t , max * 4 ) ; if ( ! c -> capability ) { return - ENOMEM ; } } for ( i = 0 ; i < sz ; i ++ ) { uint32_t v = 0 ; for ( j = 0 ; j < 8 ; ++ j ) { int t ; t = unhexchar ( * p ++ ) ; if ( t < 0 ) { return - EINVAL ; } v = ( v << 4 ) | t ; } c -> capability [ offset * max + ( sz - i - 1 ) ] = v ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int valid_format ( const char * fmt ) { int conversions = 0 ; while ( * fmt != '\\0' ) { if ( * fmt != '%' ) { fmt ++ ; continue ; } fmt ++ ; if ( * fmt == '%' ) { fmt ++ ; continue ; } while ( * fmt != '\\0' && strchr ( \"#0- +'\" , * fmt ) ) { fmt ++ ; } while ( * fmt != '\\0' && strchr ( \"0123456789\" , * fmt ) ) { fmt ++ ; } if ( * fmt == '.' ) { fmt ++ ; while ( * fmt != '\\0' && strchr ( \"0123456789\" , * fmt ) ) { fmt ++ ; } } switch ( * fmt ) { case 'A' : case 'a' : case 'E' : case 'e' : case 'F' : case 'f' : case 'G' : case 'g' : conversions ++ ; break ; default : return 0 ; } } return conversions == 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int iso_mountfs ( struct vnode * devvp , struct mount * mp , struct proc * p , struct iso_args * argp ) { struct iso_mnt * isomp = NULL ; struct buf * bp = NULL ; struct buf * pribp = NULL , * supbp = NULL ; dev_t dev = devvp -> v_rdev ; int error = EINVAL ; int ronly = ( mp -> mnt_flag & MNT_RDONLY ) != 0 ; extern struct vnode * rootvp ; int iso_bsize ; int iso_blknum ; int joliet_level ; struct iso_volume_descriptor * vdp ; struct iso_primary_descriptor * pri = NULL ; struct iso_supplementary_descriptor * sup = NULL ; struct iso_directory_record * rootp ; int logical_block_size ; int sess ; if ( ! ronly ) { return ( EROFS ) ; } if ( ( error = vfs_mountedon ( devvp ) ) != 0 ) { return ( error ) ; } if ( vcount ( devvp ) > 1 && devvp != rootvp ) { return ( EBUSY ) ; } vn_lock ( devvp , LK_EXCLUSIVE | LK_RETRY ) ; error = vinvalbuf ( devvp , V_SAVE , p -> p_ucred , p , 0 , INFSLP ) ; VOP_UNLOCK ( devvp ) ; error = VOP_OPEN ( devvp , ronly ?FREAD : FREAD | FWRITE , FSCRED , p ) ; if ( error ) { return ( error ) ; } iso_bsize = ISO_DEFAULT_BLOCK_SIZE ; if ( argp -> flags & ISOFSMNT_SESS ) { sess = argp -> sess ; if ( sess < 0 ) { sess = 0 ; } } else { sess = 0 ; error = VOP_IOCTL ( devvp , CDIOREADMSADDR , ( caddr_t ) & sess , 0 , FSCRED , p ) ; if ( error ) { sess = 0 ; } } joliet_level = 0 ; for ( iso_blknum = 16 ; iso_blknum < 100 ; iso_blknum ++ ) { if ( ( error = bread ( devvp , ( iso_blknum + sess ) * btodb ( iso_bsize ) , iso_bsize , & bp ) ) != 0 ) { out } vdp = ( iso_volume_descriptor * ) bp -> b_data ; if ( bcmp ( vdp -> id , ISO_STANDARD_ID , sizeof vdp -> id ) != 0 ) { error = EINVAL ; out } switch ( isonum_711 ( vdp -> type ) ) { case ISO_VD_PRIMARY : if ( pribp == NULL ) { pribp = bp ; bp = NULL ; pri = ( iso_primary_descriptor * ) vdp ; } break ; case ISO_VD_SUPPLEMENTARY : if ( supbp == NULL ) { supbp = bp ; bp = NULL ; sup = ( iso_supplementary_descriptor * ) vdp ; if ( ! ( argp -> flags & ISOFSMNT_NOJOLIET ) ) { if ( bcmp ( sup -> escape , \"%/@\" , 3 ) == 0 ) { joliet_level = 1 ; } if ( bcmp ( sup -> escape , \"%/C\" , 3 ) == 0 ) { joliet_level = 2 ; } if ( bcmp ( sup -> escape , \"%/E\" , 3 ) == 0 ) { joliet_level = 3 ; } if ( isonum_711 ( sup -> flags ) & 1 ) { joliet_level = 0 ; } } } break ; case ISO_VD_END : vd_end default : break ; } if ( bp ) { brelse ( bp ) ; bp = NULL ; } } vd_end if ( bp ) { brelse ( bp ) ; bp = NULL ; } if ( pri == NULL ) { error = EINVAL ; out } logical_block_size = isonum_723 ( pri -> logical_block_size ) ; if ( logical_block_size ( DEV_BSIZE || logical_block_size ) MAXBSIZE || ( logical_block_size & ( logical_block_size - 1 ) ) != 0 ) { error = EINVAL ; out } rootp = ( iso_directory_record * ) pri -> root_directory_record ; isomp = malloc ( sizeof isomp , M_ISOFSMNT , M_WAITOK ) ; bzero ( ( caddr_t ) isomp , sizeof isomp ) ; isomp -> logical_block_size = logical_block_size ; isomp -> volume_space_size = isonum_733 ( pri -> volume_space_size ) ; bcopy ( rootp , isomp -> root , sizeof isomp -> root ) ; isomp -> root_extent = isonum_733 ( rootp -> extent ) ; isomp -> root_size = isonum_733 ( rootp -> size ) ; isomp -> joliet_level = 0 ; isomp -> volume_space_size += sess ; isomp -> im_bmask = logical_block_size - 1 ; isomp -> im_bshift = ffs ( logical_block_size ) - 1 ; brelse ( pribp ) ; pribp = NULL ; mp -> mnt_data = isomp ; mp -> mnt_stat . f_fsid . val [ 0 ] = ( long ) dev ; mp -> mnt_stat . f_fsid . val [ 1 ] = mp -> mnt_vfc -> vfc_typenum ; mp -> mnt_stat . f_namemax = NAME_MAX ; mp -> mnt_flag |= MNT_LOCAL ; isomp -> im_mountp = mp ; isomp -> im_dev = dev ; isomp -> im_devvp = devvp ; if ( ! ( argp -> flags & ISOFSMNT_NORRIP ) ) { if ( ( error = bread ( isomp -> im_devvp , ( isomp -> root_extent + isonum_711 ( rootp -> ext_attr_length ) ) << ( isomp -> im_bshift - DEV_BSHIFT ) , isomp -> logical_block_size , & bp ) ) != 0 ) { out } rootp = ( iso_directory_record * ) bp -> b_data ; if ( ( isomp -> rr_skip = cd9660_rrip_offset ( rootp , isomp ) ) < 0 ) { argp -> flags |= ISOFSMNT_NORRIP ; } else { argp -> flags &= ~ ISOFSMNT_GENS ; } brelse ( bp ) ; bp = NULL ; } isomp -> im_flags = argp -> flags & ( ISOFSMNT_NORRIP | ISOFSMNT_GENS | ISOFSMNT_EXTATT | ISOFSMNT_NOJOLIET ) ; switch ( isomp -> im_flags & ( ISOFSMNT_NORRIP | ISOFSMNT_GENS ) ) { default : isomp -> iso_ftype = ISO_FTYPE_DEFAULT ; break ; case ISOFSMNT_GENS | ISOFSMNT_NORRIP : isomp -> iso_ftype = ISO_FTYPE_9660 ; break ; case 0 : isomp -> iso_ftype = ISO_FTYPE_RRIP ; break ; } if ( isomp -> iso_ftype != ISO_FTYPE_RRIP && joliet_level ) { rootp = ( iso_directory_record * ) sup -> root_directory_record ; bcopy ( rootp , isomp -> root , sizeof isomp -> root ) ; isomp -> root_extent = isonum_733 ( rootp -> extent ) ; isomp -> root_size = isonum_733 ( rootp -> size ) ; isomp -> joliet_level = joliet_level ; } if ( supbp ) { brelse ( supbp ) ; supbp = NULL ; } devvp -> v_specmountpoint = mp ; return ( 0 ) ; out if ( devvp -> v_specinfo ) { devvp -> v_specmountpoint = NULL ; } if ( bp ) { brelse ( bp ) ; } if ( supbp ) { brelse ( supbp ) ; } vn_lock ( devvp , LK_EXCLUSIVE | LK_RETRY ) ; VOP_CLOSE ( devvp , ronly ?FREAD : FREAD | FWRITE , NOCRED , p ) ; VOP_UNLOCK ( devvp ) ; if ( isomp ) { free ( ( caddr_t ) isomp , M_ISOFSMNT , 0 ) ; mp -> mnt_data = NULL ; } return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * parse_filepath ( unsigned int repoid , const char * path , const char * file , enum location loc ) { struct parse_repo * rp ; char * fn , * repopath ; rp = repo_get ( repoid ) ; if ( rp == NULL ) { errx ( 1 , \"build file path: repository %u missing\" , repoid ) ; } if ( loc == DIR_VALID ) { repopath = rp -> validpath ; } else { repopath = rp -> path ; } if ( path == NULL ) { if ( asprintf ( & fn , \"%s/%s\" , repopath , file ) == - 1 ) { err ( 1 , NULL ) ; } } else { if ( asprintf ( & fn , \"%s/%s/%s\" , repopath , path , file ) == - 1 ) { err ( 1 , NULL ) ; } } return fn ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int measure_cache_vals ( struct resctrl_val_param * param , int bm_pid ) { unsigned long llc_perf_miss = 0 , llc_occu_resc = 0 , llc_value = 0 ; int ret ; if ( ! strncmp ( param -> resctrl_val , CAT_STR , sizeof ( CAT_STR ) ) ) { ret = get_llc_perf ( & llc_perf_miss ) ; llc_value = llc_perf_miss ; } if ( ! strncmp ( param -> resctrl_val , CMT_STR , sizeof ( CMT_STR ) ) ) { ret = get_llc_occu_resctrl ( & llc_occu_resc ) ; if ( ret < 0 ) { return ret ; } llc_value = llc_occu_resc ; } ret = print_results_cache ( param -> filename , bm_pid , llc_value ) ; if ( ret ) { return ret ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int altera_get_act_info ( u8 * p , s32 program_size , int index , char * * name , char * * description , struct altera_procinfo * * proc_list ) { int status = - EIO ; struct altera_procinfo * procptr = NULL ; struct altera_procinfo * tmpptr = NULL ; u32 first_word = 0L ; u32 action_table = 0L ; u32 proc_table = 0L ; u32 str_table = 0L ; u32 note_strings = 0L ; u32 action_count = 0L ; u32 proc_count = 0L ; u32 act_name_id = 0L ; u32 act_desc_id = 0L ; u32 act_proc_id = 0L ; u32 act_proc_name = 0L ; u8 act_proc_attribute = 0 ; if ( program_size <= 52L ) { return status ; } first_word = get_unaligned_be32 ( & p [ 0 ] ) ; action_table = get_unaligned_be32 ( & p [ 4 ] ) ; proc_table = get_unaligned_be32 ( & p [ 8 ] ) ; str_table = get_unaligned_be32 ( & p [ 12 ] ) ; note_strings = get_unaligned_be32 ( & p [ 16 ] ) ; action_count = get_unaligned_be32 ( & p [ 48 ] ) ; proc_count = get_unaligned_be32 ( & p [ 52 ] ) ; if ( index >= action_count ) { return status ; } act_name_id = get_unaligned_be32 ( & p [ action_table + ( 12 * index ) ] ) ; act_desc_id = get_unaligned_be32 ( & p [ action_table + ( 12 * index ) + 4 ] ) ; act_proc_id = get_unaligned_be32 ( & p [ action_table + ( 12 * index ) + 8 ] ) ; * name = & p [ str_table + act_name_id ] ; if ( act_desc_id < ( note_strings - str_table ) ) { * description = & p [ str_table + act_desc_id ] ; } { act_proc_name = get_unaligned_be32 ( & p [ proc_table + ( 13 * act_proc_id ) ] ) ; act_proc_attribute = ( p [ proc_table + ( 13 * act_proc_id ) + 8 ] & 0x03 ) ; procptr = kzalloc ( sizeof ( altera_procinfo ) , GFP_KERNEL ) ; if ( procptr == NULL ) { status = - ENOMEM ; } else { procptr -> name = & p [ str_table + act_proc_name ] ; procptr -> attrs = act_proc_attribute ; procptr -> next = NULL ; if ( * proc_list == NULL ) { * proc_list = procptr ; } else { tmpptr = * proc_list ; while ( tmpptr -> next != NULL ) { tmpptr = tmpptr -> next ; } tmpptr -> next = procptr ; } } act_proc_id = get_unaligned_be32 ( & p [ proc_table + ( 13 * act_proc_id ) + 4 ] ) ; } ( act_proc_id != 0 ) && ( act_proc_id < proc_count ) ; return status ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned int do_IRQ ( int irq , struct uml_pt_regs * regs ) { struct pt_regs * old_regs = set_irq_regs ( ( pt_regs * ) regs ) ; irq_enter ( ) ; generic_handle_irq ( irq , NULL ) ; irq_exit ( ) ; set_irq_regs ( old_regs ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dpu_encoder_helper_reset_mixers ( struct dpu_encoder_phys * phys_enc ) { struct dpu_hw_mixer_cfg mixer ; int i , num_lm ; struct dpu_global_state * global_state ; struct dpu_hw_blk * hw_lm [ 2 ] ; struct dpu_hw_mixer * hw_mixer [ 2 ] ; struct dpu_hw_ctl * ctl = phys_enc -> hw_ctl ; if ( phys_enc -> hw_ctl -> ops . clear_all_blendstages ) { phys_enc -> hw_ctl -> ops . clear_all_blendstages ( phys_enc -> hw_ctl ) ; } global_state = dpu_kms_get_existing_global_state ( phys_enc -> dpu_kms ) ; num_lm = dpu_rm_get_assigned_resources ( & phys_enc -> dpu_kms -> rm , global_state , phys_enc -> parent -> base . id , DPU_HW_BLK_LM , hw_lm , ARRAY_SIZE ( hw_lm ) ) ; for ( i = 0 ; i < num_lm ; i ++ ) { hw_mixer [ i ] = to_dpu_hw_mixer ( hw_lm [ i ] ) ; if ( phys_enc -> hw_ctl -> ops . update_pending_flush_mixer ) { phys_enc -> hw_ctl -> ops . update_pending_flush_mixer ( ctl , hw_mixer [ i ] -> idx ) ; } if ( phys_enc -> hw_ctl -> ops . setup_blendstage ) { phys_enc -> hw_ctl -> ops . setup_blendstage ( ctl , hw_mixer [ i ] -> idx , NULL ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dib0070_write_reg ( struct dib0070_state * state , u8 reg , u16 val ) { int ret ; if ( mutex_lock_interruptible ( & state -> i2c_buffer_lock ) < 0 ) { dprintk ( \"could not acquire lock\\n\" ) ; return - EINVAL ; } state -> i2c_write_buffer [ 0 ] = reg ; state -> i2c_write_buffer [ 1 ] = val >> 8 ; state -> i2c_write_buffer [ 2 ] = val & 0xff ; state -> msg [ 0 ] . addr = state -> cfg -> i2c_address ; state -> msg [ 0 ] . flags = 0 ; state -> msg [ 0 ] . buf = state -> i2c_write_buffer ; state -> msg [ 0 ] . len = 3 ; if ( i2c_transfer ( state -> i2c , state -> msg , 1 ) != 1 ) { pr_warn ( \"DiB0070 I2C write failed\\n\" ) ; ret = - EREMOTEIO ; } else { ret = 0 ; } mutex_unlock ( & state -> i2c_buffer_lock ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nforce2_set_fsb ( unsigned int fsb ) { int temp = 0 ; unsigned int tfsb ; int diff ; int pll = 0 ; if ( ( fsb > max_fsb ) || ( fsb < NFORCE2_MIN_FSB ) ) { pr_err ( \"FSB %d is out of range!\\n\" , fsb ) ; return - EINVAL ; } tfsb = nforce2_fsb_read ( 0 ) ; if ( ! tfsb ) { pr_err ( \"Error while reading the FSB\\n\" ) ; return - EINVAL ; } pci_read_config_byte ( nforce2_dev , NFORCE2_PLLENABLE , ( u8 * ) & temp ) ; if ( ! temp ) { pll = nforce2_calc_pll ( tfsb ) ; if ( pll < 0 ) { return - EINVAL ; } nforce2_write_pll ( pll ) ; } temp = 0x01 ; pci_write_config_byte ( nforce2_dev , NFORCE2_PLLENABLE , ( u8 ) temp ) ; diff = tfsb - fsb ; if ( ! diff ) { return 0 ; } while ( ( tfsb != fsb ) && ( tfsb <= max_fsb ) && ( tfsb >= min_fsb ) ) { if ( diff < 0 ) { tfsb ++ ; } else { tfsb -- ; } pll = nforce2_calc_pll ( tfsb ) ; if ( pll == - 1 ) { return - EINVAL ; } nforce2_write_pll ( pll ) ; mdelay ( NFORCE2_DELAY ) ; } temp = 0x40 ; pci_write_config_byte ( nforce2_dev , NFORCE2_PLLADR , ( u8 ) temp ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "make_ref_file ( ) { char * uri , * ref_uri ; GFile * result ; uri = g_file_get_uri ( file ) ; ref_uri = g_strconcat ( uri , \".ref.png\" , NULL ) ; result = g_file_new_for_uri ( ref_uri ) ; g_free ( ref_uri ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int epoll_close ( HANDLE ephnd ) { ts_tree_node_t * tree_node ; port_state_t * port_state ; if ( init ( ) < 0 ) { return - 1 ; } tree_node = ts_tree_del_and_ref ( & epoll__handle_tree , ( uintptr_t ) ephnd ) ; if ( tree_node == NULL ) { err_set_win_error ( ERROR_INVALID_PARAMETER ) ; err } port_state = port_state_from_handle_tree_node ( tree_node , NULL ) ; port_close ( port_state ) ; ts_tree_node_unref_and_destroy ( tree_node ) ; return port_delete ( port_state ) ; err err_check_handle ( ephnd ) ; return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cs_hex_decode ( const char * s , int len , unsigned char * dst , int * dst_len ) { int i ; unsigned char * p = dst ; while ( i < len ) { int c1 , c2 ; c1 = hextoi ( tolower ( ( int ) s [ i ++ ] ) ) ; if ( c1 ( 0 || c1 ) 15 || i == len ) { i -- ; break ; } c2 = hextoi ( tolower ( ( int ) s [ i ++ ] ) ) ; if ( c2 ( 0 || c2 ) 15 ) { i -= 2 ; break ; } * p ++ = ( unsigned char ) ( ( c1 << 4 ) | c2 ) ; } * dst_len = ( int ) ( p - dst ) ; return i ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void stm_port_disable_hw ( struct stm_drvdata * drvdata ) { CS_UNLOCK ( drvdata -> base , NULL ) ; writel_relaxed ( 0x0 , drvdata -> base + STMSPER ) ; writel_relaxed ( 0x0 , drvdata -> base + STMSPTRIGCSR ) ; CS_LOCK ( drvdata -> base ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void matrix_db_close ( void ) { if ( matrix_dbh ) { matrix_dbf . close ( matrix_dbh , NULL ) ; matrix_dbh = NULL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct object * sml_getobj ( struct worker * wrk , struct objcore * oc ) { const struct stevedore * stv ; struct object * o ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( oc , OBJCORE_MAGIC ) ; stv = oc -> stobj -> stevedore ; CHECK_OBJ_NOTNULL ( stv , STEVEDORE_MAGIC ) ; if ( oc -> stobj -> priv == NULL ) { return ( NULL ) ; } CAST_OBJ_NOTNULL ( o , oc -> stobj -> priv , OBJECT_MAGIC ) ; return ( o ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void opj_tcd_free_tile ( opj_tcd_t * p_tcd ) { OPJ_UINT32 compno , resno , bandno , precno ; opj_tcd_tile_t * l_tile = 00 ; opj_tcd_tilecomp_t * l_tile_comp = 00 ; opj_tcd_resolution_t * l_res = 00 ; opj_tcd_band_t * l_band = 00 ; opj_tcd_precinct_t * l_precinct = 00 ; OPJ_UINT32 l_nb_resolutions , l_nb_precincts ; void * l_tcd_code_block_deallocate ( opj_tcd_precinct_t * ) 00 if ( ! p_tcd -> tcd_image ) { return ; } if ( p_tcd -> m_is_decoder ) { l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate ; } else { l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate ; } l_tile = p_tcd -> tcd_image -> tiles ; if ( ! l_tile ) { return ; } l_tile_comp = l_tile -> comps ; for ( compno = 0 ; compno < l_tile -> numcomps ; ++ compno ) { l_res = l_tile_comp -> resolutions ; if ( l_res ) { l_nb_resolutions = l_tile_comp -> resolutions_size / ( OPJ_UINT32 ) sizeof ( opj_tcd_resolution_t ) ; for ( resno = 0 ; resno < l_nb_resolutions ; ++ resno ) { l_band = l_res -> bands ; for ( bandno = 0 ; bandno < 3 ; ++ bandno ) { l_precinct = l_band -> precincts ; if ( l_precinct ) { l_nb_precincts = l_band -> precincts_data_size / ( OPJ_UINT32 ) sizeof ( opj_tcd_precinct_t ) ; for ( precno = 0 ; precno < l_nb_precincts ; ++ precno ) { opj_tgt_destroy ( l_precinct -> incltree ) ; l_precinct -> incltree = 00 ; opj_tgt_destroy ( l_precinct -> imsbtree ) ; l_precinct -> imsbtree = 00 ; * l_tcd_code_block_deallocate ( l_precinct ) ; ++ l_precinct ; } opj_free ( l_band -> precincts ) ; l_band -> precincts = 00 ; } ++ l_band ; } ++ l_res ; } opj_free ( l_tile_comp -> resolutions ) ; l_tile_comp -> resolutions = 00 ; } if ( l_tile_comp -> ownsData && l_tile_comp -> data ) { opj_image_data_free ( l_tile_comp -> data ) ; l_tile_comp -> data = 00 ; l_tile_comp -> ownsData = 0 ; l_tile_comp -> data_size = 0 ; l_tile_comp -> data_size_needed = 0 ; } opj_image_data_free ( l_tile_comp -> data_win ) ; ++ l_tile_comp ; } opj_free ( l_tile -> comps ) ; l_tile -> comps = 00 ; opj_free ( p_tcd -> tcd_image -> tiles ) ; p_tcd -> tcd_image -> tiles = 00 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static apr_status_t public_key_cleanup ( void * data ) { EVP_PKEY * pubkey = data ; return APR_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MINT * mp_xtom ( char * key ) { short digit ; MINT * m = mp_itom ( 0 ) ; MINT * d ; MINT * sixteen ; sixteen = mp_itom ( 16 ) ; for ( ; * key ; key ++ ) { digit = xtoi ( * key ) ; if ( digit < 0 ) { return ( NULL ) ; } d = mp_itom ( digit ) ; mp_mult ( m , sixteen , m ) ; mp_madd ( m , d , m ) ; } mp_mfree ( sixteen ) ; return ( m ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void b43_sdio_remove ( struct sdio_func * func ) { struct b43_sdio * sdio = sdio_get_drvdata ( func ) ; ssb_bus_unregister ( & sdio -> ssb ) ; sdio_claim_host ( func ) ; sdio_disable_func ( func ) ; sdio_release_host ( func ) ; sdio_set_drvdata ( func , NULL ) ; } static const struct sdio_device_id b43_sdio_ids [ ] { { SDIO_DEVICE ( 0x02d0 , 0x044b ) } { SDIO_DEVICE ( 0x0092 , 0x0004 ) } { } } ; ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ssh_dss_serialize_public ( const struct sshkey * key , struct sshbuf * b , enum sshkey_serialize_rep opts ) { int r ; const BIGNUM * dsa_p , * dsa_q , * dsa_g , * dsa_pub_key ; DSA_get0_pqg ( key -> dsa , & dsa_p , & dsa_q , & dsa_g ) ; DSA_get0_key ( key -> dsa , & dsa_pub_key , NULL ) ; if ( dsa_p == NULL || dsa_q == NULL || dsa_g == NULL || dsa_pub_key == NULL ) { return SSH_ERR_INTERNAL_ERROR ; } if ( ( r = sshbuf_put_bignum2 ( b , dsa_p ) ) != 0 || ( r = sshbuf_put_bignum2 ( b , dsa_q ) ) != 0 || ( r = sshbuf_put_bignum2 ( b , dsa_g ) ) != 0 || ( r = sshbuf_put_bignum2 ( b , dsa_pub_key ) ) != 0 ) { return r ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sirfsoc_wdt_settimeout ( struct watchdog_device * wdd , unsigned int to ) { wdd -> timeout = to ; sirfsoc_wdt_updatetimeout ( wdd , NULL ) ; return 0 ; } static const struct watchdog_info sirfsoc_wdt_ident = { . options = OPTIONS . firmware_version = 0 . identity = \"SiRFSOC Watchdog\" } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hvc_iucv_filter_connreq ( u8 ipvmid [ 8 ] ) { const char * wildcard , * filter_entry ; size_t i , len ; for ( i = 0 ; i < hvc_iucv_filter_size ; i ++ ) { filter_entry = hvc_iucv_filter + ( 8 * i ) ; wildcard = strnchr ( filter_entry , 8 , FILTER_WILDCARD_CHAR ) ; len = ( wildcard ) ?wildcard - filter_entry : 8 ; if ( 0 == memcmp ( ipvmid , filter_entry , len ) ) { return 0 ; } } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void table_fill_string ( char * dest , const char * src , size_t n , char pad ) { int start , len ; int i ; strncpy ( dest , src , n ) ; len = strlen ( src , NULL ) ; start = len < n ?len : n ; for ( i = start ; i < n ; i ++ ) { dest [ i ] = pad ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void crypt_free_tfms_skcipher ( struct crypt_config * cc ) { unsigned i ; if ( ! cc -> cipher_tfm . tfms ) { return ; } for ( i = 0 ; i < cc -> tfms_count ; i ++ ) { if ( cc -> cipher_tfm . tfms [ i ] && ! IS_ERR ( cc -> cipher_tfm . tfms [ i ] ) ) { crypto_free_skcipher ( cc -> cipher_tfm . tfms [ i ] ) ; } } kfree ( cc -> cipher_tfm . tfms ) ; cc -> cipher_tfm . tfms = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void svc_i3c_master_start_xfer_locked ( struct svc_i3c_master * master ) { struct svc_i3c_xfer * xfer = master -> xferqueue . cur ; int ret , i ; ret = pm_runtime_resume_and_get ( master -> dev ) ; if ( ret < 0 ) { dev_err ( master -> dev , \"<%s>Cannot get runtime PM.\\n\" , __func__ ) ; return ; } svc_i3c_master_clear_merrwarn ( master ) ; svc_i3c_master_flush_fifo ( master ) ; for ( i = 0 ; i < xfer -> ncmds ; i ++ ) { struct svc_i3c_cmd * cmd = & xfer -> cmds [ i ] ; ret = svc_i3c_master_xfer ( master , cmd -> rnw , xfer -> type , cmd -> addr , cmd -> in , cmd -> out , cmd -> len , & cmd -> read_len , cmd -> continued ) ; if ( ret ) { break ; } } pm_runtime_mark_last_busy ( master -> dev ) ; pm_runtime_put_autosuspend ( master -> dev ) ; xfer -> ret = ret ; complete ( & xfer -> comp ) ; if ( ret < 0 ) { svc_i3c_master_dequeue_xfer_locked ( master , xfer ) ; } xfer = list_first_entry_or_null ( & master -> xferqueue . list , svc_i3c_xfer , node ) ; if ( xfer ) { list_del_init ( & xfer -> node ) ; } master -> xferqueue . cur = xfer ; svc_i3c_master_start_xfer_locked ( master ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void tls13_alert_received_cb ( uint8_t alert_desc , void * arg ) { struct tls13_ctx * ctx = arg ; if ( alert_desc == TLS13_ALERT_CLOSE_NOTIFY ) { ctx -> ssl -> shutdown |= SSL_RECEIVED_SHUTDOWN ; ctx -> ssl -> s3 -> warn_alert = alert_desc ; return ; } if ( alert_desc == TLS13_ALERT_USER_CANCELED ) { return ; } ctx -> ssl -> s3 -> fatal_alert = alert_desc ; SSLerror ( ctx -> ssl , SSL_AD_REASON_OFFSET + alert_desc ) ; ERR_asprintf_error_data ( \"SSL alert number %d\" , alert_desc ) ; SSL_CTX_remove_session ( ctx -> ssl -> ctx , ctx -> ssl -> session ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int init_initiator_rw_fcoe_task ( struct fcoe_task_params * task_params , struct scsi_sgl_task_params * sgl_task_params , struct regpair sense_data_buffer_phys_addr , u32 task_retry_id , u8 fcp_cmd_payload [ 32 ] ) { struct fcoe_task_context * ctx = task_params -> context ; struct ystorm_fcoe_task_st_ctx * y_st_ctx ; struct tstorm_fcoe_task_st_ctx * t_st_ctx ; struct ustorm_fcoe_task_ag_ctx * u_ag_ctx ; struct mstorm_fcoe_task_st_ctx * m_st_ctx ; u32 io_size , val ; bool slow_sgl ; memset ( ctx , 0 , sizeof ( * ( ctx ) ) ) ; slow_sgl = scsi_is_slow_sgl ( sgl_task_params -> num_sges , sgl_task_params -> small_mid_sge ) ; io_size = ( task_params -> task_type == FCOE_TASK_TYPE_WRITE_INITIATOR ?task_params -> tx_io_size : task_params -> rx_io_size ) ; y_st_ctx = & ctx -> ystorm_st_context ; y_st_ctx -> data_2_trns_rem = cpu_to_le32 ( io_size ) ; y_st_ctx -> task_rety_identifier = cpu_to_le32 ( task_retry_id ) ; y_st_ctx -> task_type = task_params -> task_type ; memcpy ( & y_st_ctx -> tx_info_union . fcp_cmd_payload , fcp_cmd_payload , sizeof ( fcoe_fcp_cmd_payload ) ) ; t_st_ctx = & ctx -> tstorm_st_context ; t_st_ctx -> read_only . dev_type = ( task_params -> is_tape_device == 1 ?FCOE_TASK_DEV_TYPE_TAPE : FCOE_TASK_DEV_TYPE_DISK ) ; t_st_ctx -> read_only . cid = cpu_to_le32 ( task_params -> conn_cid ) ; val = cpu_to_le32 ( task_params -> cq_rss_number ) ; t_st_ctx -> read_only . glbl_q_num = val ; t_st_ctx -> read_only . fcp_cmd_trns_size = cpu_to_le32 ( io_size ) ; t_st_ctx -> read_only . task_type = task_params -> task_type ; SET_FIELD ( t_st_ctx -> read_write . flags , FCOE_TSTORM_FCOE_TASK_ST_CTX_READ_WRITE_EXP_FIRST_FRAME , 1 ) ; t_st_ctx -> read_write . rx_id = cpu_to_le16 ( FCOE_RX_ID ) ; u_ag_ctx = & ctx -> ustorm_ag_context ; u_ag_ctx -> global_cq_num = cpu_to_le32 ( task_params -> cq_rss_number ) ; m_st_ctx = & ctx -> mstorm_st_context ; val = cpu_to_le32 ( sense_data_buffer_phys_addr . hi ) ; m_st_ctx -> rsp_buf_addr . hi = val ; val = cpu_to_le32 ( sense_data_buffer_phys_addr . lo ) ; m_st_ctx -> rsp_buf_addr . lo = val ; if ( task_params -> task_type == FCOE_TASK_TYPE_WRITE_INITIATOR ) { SET_FIELD ( y_st_ctx -> sgl_mode , YSTORM_FCOE_TASK_ST_CTX_TX_SGL_MODE , ( slow_sgl ?SCSI_TX_SLOW_SGL : SCSI_FAST_SGL ) ) ; init_scsi_sgl_context ( & y_st_ctx -> sgl_params , & y_st_ctx -> data_desc , sgl_task_params ) ; SET_FIELD ( m_st_ctx -> flags , MSTORM_FCOE_TASK_ST_CTX_TX_SGL_MODE , ( slow_sgl ?SCSI_TX_SLOW_SGL : SCSI_FAST_SGL ) ) ; } else { SET_FIELD ( t_st_ctx -> read_write . flags , FCOE_TSTORM_FCOE_TASK_ST_CTX_READ_WRITE_RX_SGL_MODE , ( slow_sgl ?SCSI_TX_SLOW_SGL : SCSI_FAST_SGL ) ) ; m_st_ctx -> data_2_trns_rem = cpu_to_le32 ( io_size ) ; init_scsi_sgl_context ( & m_st_ctx -> sgl_params , & m_st_ctx -> data_desc , sgl_task_params ) ; } init_common_sqe ( task_params , SEND_FCOE_CMD ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int noexternalmsgs_can_send_to_channel ( Client * client , Channel * channel , Membership * lp , const char * * msg , const char * * errmsg , SendType sendtype ) { if ( IsNoExternalMessages ( channel ) && ! IsMember ( client , channel ) ) { Hook * h ; int i ; for ( h = Hooks [ HOOKTYPE_CAN_BYPASS_CHANNEL_MESSAGE_RESTRICTION ] ; h ; h = h -> next ) { i = ( * ( h -> func . intfunc ) ) ( client , channel , BYPASS_CHANMSG_EXTERNAL ) ; if ( i != HOOK_CONTINUE ) { break ; } } * errmsg = \"No external channel messages\" ; return HOOK_DENY ; } return HOOK_CONTINUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ki_goes_to_gw_type ( struct sip_msg * msg , int type ) { pgw_addr_t * pgwa = NULL ; struct sip_uri puri ; struct ip_addr * ip ; str * uri ; uri = GET_NEXT_HOP ( msg ) ; if ( parse_uri ( uri -> s , uri -> len , & puri ) < 0 ) { LM_ERR ( \"bad uri<%.*s>\\n\" , uri -> len , uri -> s ) ; return - 1 ; } if ( ( ( ip = str2ip ( & puri . host ) ) != 0 ) || ( ( ip = str2ip6 ( & puri . host ) ) != 0 ) ) { pgwa = ( * rdata ) -> pgw_addr_l ; while ( pgwa ) { if ( ( type < 0 || type == pgwa -> type ) && ip_addr_cmp ( & pgwa -> ip , ip ) ) { return 1 ; } pgwa = pgwa -> next ; } } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _dwarf_load_debug_info ( Dwarf_Debug dbg , Dwarf_Error * error ) { int res = DW_DLV_ERROR ; if ( dbg -> de_debug_info . dss_data ) { return DW_DLV_OK ; } res = _dwarf_load_section ( dbg , & dbg -> de_debug_abbrev , error ) ; res = _dwarf_load_section ( dbg , & dbg -> de_debug_info , error ) ; if ( res != DW_DLV_OK ) { return res ; } res = dwarf_load_rnglists ( dbg , 0 , error ) ; if ( res == DW_DLV_ERROR ) { return res ; } res = dwarf_load_loclists ( dbg , 0 , error ) ; if ( res == DW_DLV_ERROR ) { return res ; } return DW_DLV_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int vbe_simple_read_state ( struct udevice * dev , struct simple_state * state ) { ALLOC_CACHE_ALIGN_BUFFER ( u8 , buf , MMC_MAX_BLOCK_LEN ) ; struct simple_priv * priv = dev_get_priv ( dev ) ; struct blk_desc * desc ; char devname [ 16 ] ; const char * end ; int devnum ; int ret ; log_debug ( \"storage=%s\\n\" , priv -> storage ) ; devnum = trailing_strtoln_end ( priv -> storage , NULL , & end ) ; if ( devnum == - 1 ) { return log_msg_ret ( \"num\" , - ENODEV ) ; } strlcpy ( devname , priv -> storage , end - priv -> storage + 1 ) ; log_debug ( \"dev=%s, %x\\n\" , devname , devnum ) ; desc = blk_get_dev ( devname , devnum ) ; if ( ! desc ) { return log_msg_ret ( \"get\" , - ENXIO ) ; } ret = simple_read_version ( dev , desc , buf , state ) ; if ( ret ) { return log_msg_ret ( \"ver\" , ret ) ; } ret = simple_read_nvdata ( dev , desc , buf , state ) ; if ( ret ) { return log_msg_ret ( \"nvd\" , ret ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void btrfs_apply_pending_changes ( struct btrfs_fs_info * fs_info ) { unsigned long prev ; unsigned long bit ; prev = xchg ( & fs_info -> pending_changes , 0 ) ; bit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE ; if ( prev & bit ) { btrfs_set_opt ( fs_info -> mount_opt , INODE_MAP_CACHE ) ; } prev &= ~ bit ; bit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE ; if ( prev & bit ) { btrfs_clear_opt ( fs_info -> mount_opt , INODE_MAP_CACHE ) ; } prev &= ~ bit ; bit = 1 << BTRFS_PENDING_COMMIT ; if ( prev & bit ) { btrfs_debug ( fs_info , \"pending commit done\" ) ; } prev &= ~ bit ; if ( prev ) { btrfs_warn ( fs_info , \"unknown pending changes left 0x%lx, ignoring\" , prev ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool smc_pnetid_valid ( const char * pnet_name , char * pnetid ) { char * bf = skip_spaces ( pnet_name ) ; size_t len = strlen ( bf ) ; char * end = bf + len ; if ( ! len ) { return false ; } while ( -- end >= bf && isspace ( * end ) ) { } while ( bf <= end ) { if ( ! isalnum ( * bf ) ) { return false ; } * pnetid ++ = islower ( * bf ) ?toupper ( * bf ) : * bf ; bf ++ ; } * pnetid = '\\0' ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int adf_dev_aer_schedule_reset ( struct adf_accel_dev * accel_dev , enum adf_dev_reset_mode mode ) { struct adf_reset_dev_data * reset_data ; if ( ! adf_dev_started ( accel_dev ) || test_bit ( ADF_STATUS_RESTARTING , & accel_dev -> status ) ) { return 0 ; } set_bit ( ADF_STATUS_RESTARTING , & accel_dev -> status ) ; reset_data = kzalloc ( sizeof ( * reset_data ) , GFP_KERNEL ) ; if ( ! reset_data ) { return - ENOMEM ; } reset_data -> accel_dev = accel_dev ; init_completion ( & reset_data -> compl ) ; reset_data -> mode = mode ; INIT_WORK ( & reset_data -> reset_work , adf_device_reset_worker ) ; queue_work ( device_reset_wq , & reset_data -> reset_work ) ; if ( mode == ADF_DEV_RESET_SYNC ) { int ret = 0 ; unsigned long wait_jiffies = msecs_to_jiffies ( 10000 ) ; unsigned long timeout = wait_for_completion_timeout ( & reset_data -> compl , wait_jiffies ) ; if ( ! timeout ) { dev_err ( & GET_DEV ( accel_dev ) , \"Reset device timeout expired\\n\" ) ; ret = - EFAULT ; } return ret ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gbaudio_dapm_free_widget ( struct snd_soc_dapm_widget * w ) { struct snd_soc_dapm_path * p , * next_p ; enum snd_soc_dapm_direction dir ; list_del ( & w -> list ) ; gbaudio_dapm_for_each_direction ( ) { snd_soc_dapm_widget_for_each_path_safe ( , , , ) gbaudio_dapm_free_path ( p ) ; } kfree_const ( w -> name ) ; kfree_const ( w -> sname ) ; kfree ( w ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dm_mmc_hs400_prepare_ddr ( struct udevice * dev ) { struct dm_mmc_ops * ops = mmc_get_ops ( dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xhci_check_bw_table ( struct xhci_hcd * xhci , struct xhci_virt_device * virt_dev , int old_active_eps ) { unsigned int bw_reserved ; unsigned int max_bandwidth ; unsigned int bw_used ; unsigned int block_size ; struct xhci_interval_bw_table * bw_table ; int packet_size = 0 ; unsigned int overhead = 0 ; unsigned int packets_transmitted = 0 ; unsigned int packets_remaining = 0 ; unsigned int i ; if ( virt_dev -> udev -> speed >= USB_SPEED_SUPER ) { return xhci_check_ss_bw ( xhci , virt_dev ) ; } if ( virt_dev -> udev -> speed == USB_SPEED_HIGH ) { max_bandwidth = HS_BW_LIMIT ; bw_reserved = DIV_ROUND_UP ( HS_BW_RESERVED * max_bandwidth , 100 ) ; } else { max_bandwidth = FS_BW_LIMIT ; bw_reserved = DIV_ROUND_UP ( FS_BW_RESERVED * max_bandwidth , 100 ) ; } bw_table = virt_dev -> bw_table ; block_size = xhci_get_block_size ( virt_dev -> udev ) ; if ( virt_dev -> tt_info ) { xhci_dbg_trace ( xhci , trace_xhci_dbg_quirks , \"Recalculating BW for rootport %u\" , virt_dev -> real_port ) ; if ( xhci_check_tt_bw_table ( xhci , virt_dev , old_active_eps ) ) { xhci_warn ( xhci , \"Not enough bandwidth on HS bus for \" \"newly activated TT.\\n\" ) ; return - ENOMEM ; } xhci_dbg_trace ( xhci , trace_xhci_dbg_quirks , \"Recalculating BW for TT slot %u port %u\" , virt_dev -> tt_info -> slot_id , virt_dev -> tt_info -> ttport ) ; } else { xhci_dbg_trace ( xhci , trace_xhci_dbg_quirks , \"Recalculating BW for rootport %u\" , virt_dev -> real_port ) ; } bw_used = DIV_ROUND_UP ( bw_table -> interval0_esit_payload , block_size ) + bw_table -> interval_bw [ 0 ] . num_packets * xhci_get_largest_overhead ( & bw_table -> interval_bw [ 0 ] ) ; for ( i = 1 ; i < XHCI_MAX_INTERVAL ; i ++ ) { unsigned int bw_added ; unsigned int largest_mps ; unsigned int interval_overhead ; packets_remaining = 2 * packets_remaining + bw_table -> interval_bw [ i ] . num_packets ; if ( list_empty ( & bw_table -> interval_bw [ i ] . endpoints ) ) { largest_mps = 0 ; } else { struct xhci_virt_ep * virt_ep ; struct list_head * ep_entry ; ep_entry = bw_table -> interval_bw [ i ] . endpoints . next ; virt_ep = list_entry ( ep_entry , xhci_virt_ep , bw_endpoint_list ) ; largest_mps = DIV_ROUND_UP ( virt_ep -> bw_info . max_packet_size , block_size ) ; } if ( largest_mps > packet_size ) { packet_size = largest_mps ; } interval_overhead = xhci_get_largest_overhead ( & bw_table -> interval_bw [ i ] ) ; if ( interval_overhead > overhead ) { overhead = interval_overhead ; } packets_transmitted = packets_remaining >> ( i + 1 ) ; bw_added = packets_transmitted * ( overhead + packet_size ) ; packets_remaining = packets_remaining % ( 1 << ( i + 1 ) ) ; if ( packets_remaining == 0 ) { packet_size = 0 ; overhead = 0 ; } if ( packets_transmitted > 0 ) { packet_size = largest_mps ; overhead = interval_overhead ; } bw_used += bw_added ; if ( bw_used > max_bandwidth ) { xhci_warn ( xhci , \"Not enough bandwidth. \" \"Proposed: %u, Max: %u\\n\" , bw_used , max_bandwidth ) ; return - ENOMEM ; } } if ( packets_remaining > 0 ) { bw_used += overhead + packet_size ; } if ( ! virt_dev -> tt_info && virt_dev -> udev -> speed == USB_SPEED_HIGH ) { unsigned int port_index = virt_dev -> real_port - 1 ; bw_used += TT_HS_OVERHEAD * xhci -> rh_bw [ port_index ] . num_active_tts ; } xhci_dbg_trace ( xhci , trace_xhci_dbg_quirks , \"Final bandwidth: %u, Limit: %u, Reserved: %u, \" \"Available: %u \" \"percent\" , bw_used , max_bandwidth , bw_reserved , ( max_bandwidth - bw_used - bw_reserved ) * 100 / max_bandwidth ) ; bw_used += bw_reserved ; if ( bw_used > max_bandwidth ) { xhci_warn ( xhci , \"Not enough bandwidth. Proposed: %u, Max: %u\\n\" , bw_used , max_bandwidth ) ; return - ENOMEM ; } bw_table -> bw_used = bw_used ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "union recv_frame * r8712_alloc_recvframe ( struct __queue * pfree_recv_queue ) { cfs_time_t irqL ; union recv_frame * precvframe ; struct _adapter * padapter ; struct recv_priv * precvpriv ; spin_lock_irqsave ( & pfree_recv_queue -> lock , irqL ) ; precvframe = list_first_entry_or_null ( & pfree_recv_queue -> queue , recv_frame , u . hdr . list ) ; if ( precvframe ) { list_del_init ( & precvframe -> u . hdr . list ) ; padapter = precvframe -> u . hdr . adapter ; if ( padapter ) { precvpriv = & padapter -> recvpriv ; if ( pfree_recv_queue == & precvpriv -> free_recv_queue ) { precvpriv -> free_recvframe_cnt -- ; } } } spin_unlock_irqrestore ( & pfree_recv_queue -> lock , irqL ) ; return precvframe ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int vas_setup_fault_window ( struct vas_instance * vinst ) { struct vas_rx_win_attr attr ; struct vas_window * win ; vinst -> fault_fifo_size = VAS_FAULT_WIN_FIFO_SIZE ; vinst -> fault_fifo = kzalloc ( vinst -> fault_fifo_size , GFP_KERNEL ) ; if ( ! vinst -> fault_fifo ) { pr_err ( \"Unable to alloc %d bytes for fault_fifo\\n\" , vinst -> fault_fifo_size ) ; return - ENOMEM ; } memset ( vinst -> fault_fifo , FIFO_INVALID_ENTRY , vinst -> fault_fifo_size ) ; vas_init_rx_win_attr ( & attr , VAS_COP_TYPE_FAULT ) ; attr . rx_fifo_size = vinst -> fault_fifo_size ; attr . rx_fifo = __pa ( vinst -> fault_fifo ) ; attr . wcreds_max = vinst -> fault_fifo_size / CRB_SIZE ; attr . lnotify_lpid = 0 ; attr . lnotify_pid = mfspr ( SPRN_PID ) ; attr . lnotify_tid = mfspr ( SPRN_PID ) ; win = vas_rx_win_open ( vinst -> vas_id , VAS_COP_TYPE_FAULT , & attr ) ; if ( IS_ERR ( win ) ) { pr_err ( \"VAS: Error %ld opening FaultWin\\n\" , PTR_ERR ( win ) ) ; return PTR_ERR ( win ) ; } vinst -> fault_win = container_of ( win , pnv_vas_window , vas_win ) ; pr_devel ( \"VAS: Created FaultWin %d, LPID/PID/TID [%d/%d/%d]\\n\" , vinst -> fault_win -> vas_win . winid , attr . lnotify_lpid , attr . lnotify_pid , attr . lnotify_tid ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static size_t tftp_option_add ( tftp_state_data_t * state , size_t csize , char * buf , const char * option ) { strcpy ( buf , option ) ; return strlen ( option ) + 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gen_exception_cause ( DisasContext * dc , uint32_t cause ) { TCGv_i32 tpc = tcg_const_i32 ( dc -> pc ) ; TCGv_i32 tcause = tcg_const_i32 ( cause ) ; gen_helper_exception_cause ( cpu_env , tpc , tcause ) ; tcg_temp_free ( tpc ) ; if ( cause == ILLEGAL_INSTRUCTION_CAUSE || cause == SYSCALL_CAUSE ) { dc -> base . is_jmp = DISAS_NORETURN ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void * spl_ptr_heap_top ( spl_ptr_heap * heap ) { if ( heap -> count == 0 ) { return in ; } return heap -> elements ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dh_set_pg_groupsize ( int groupsize , dh_key * key ) { int err , i ; LTC_ARGCHK ( key != NULL ) ; LTC_ARGCHK ( ltc_mp . name != NULL ) ; LTC_ARGCHK ( groupsize > 0 ) ; for ( i = 0 ; ( groupsize > ltc_dh_sets [ i ] . size ) && ( ltc_dh_sets [ i ] . size != 0 ) ; i ++ ) { } if ( ltc_dh_sets [ i ] . size == 0 ) { return CRYPT_INVALID_KEYSIZE ; } if ( ( err = mp_init_multi ( & key -> x , & key -> y , & key -> base , & key -> prime , LTC_NULL ) ) != CRYPT_OK ) { return err ; } if ( ( err = mp_read_radix ( key -> base , ltc_dh_sets [ i ] . base , 16 ) ) != CRYPT_OK ) { LBL_ERR } if ( ( err = mp_read_radix ( key -> prime , ltc_dh_sets [ i ] . prime , 16 ) ) != CRYPT_OK ) { LBL_ERR } return CRYPT_OK ; LBL_ERR return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int vcm_power_up ( struct v4l2_subdev * sd ) { const struct camera_af_platform_data * vcm_platform_data ; vcm_platform_data = camera_get_af_platform_data ( ) ; return vcm_platform_data -> power_ctrl ( sd , 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct crypto_ahash * ima_alloc_atfm ( enum hash_algo algo ) { struct crypto_ahash * tfm = ima_ahash_tfm ; int rc ; if ( algo < 0 || algo >= HASH_ALGO__LAST ) { algo = ima_hash_algo ; } if ( algo != ima_hash_algo || ! tfm ) { tfm = crypto_alloc_ahash ( hash_algo_name [ algo ] , 0 , 0 ) ; if ( ! IS_ERR ( tfm ) ) { if ( algo == ima_hash_algo ) { ima_ahash_tfm = tfm ; } } else { rc = PTR_ERR ( tfm , NULL ) ; pr_err ( \"Can not allocate %s (reason: %d)\\n\" , hash_algo_name [ algo ] , rc ) ; } } return tfm ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int get_data_reg ( struct pinmux_info * gpioc , unsigned gpio , struct pinmux_data_reg * * drp , int * bitp ) { struct pinmux_gpio * gpiop = & gpioc -> gpios [ gpio ] ; int k , n ; k = ( gpiop -> flags & PINMUX_FLAG_DREG ) >> PINMUX_FLAG_DREG_SHIFT ; n = ( gpiop -> flags & PINMUX_FLAG_DBIT ) >> PINMUX_FLAG_DBIT_SHIFT ; * drp = gpioc -> data_regs + k ; * bitp = n ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dt3155_enum_fmt_vid_cap ( struct file * filp , void * p , struct v4l2_fmtdesc * f ) { f -> pixelformat = V4L2_PIX_FMT_GREY ; strcpy ( f -> description , \"8-bit Greyscale\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void add_cpu_switch ( int i ) { add_event_entry ( ESCAPE_CODE ) ; add_event_entry ( CPU_SWITCH_CODE , NULL ) ; add_event_entry ( i ) ; last_cookie = INVALID_COOKIE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GF_Err adtsmx_configure_pid ( GF_Filter * filter , GF_FilterPid * pid , Bool is_remove ) { u32 i , sr , chan_cfg = 0 ; Bool patch_channels = GF_FALSE ; const GF_PropertyValue * p ; GF_ADTSMxCtx * ctx = gf_filter_get_udta ( filter ) ; if ( is_remove ) { ctx -> ipid = NULL ; if ( ctx -> opid ) { gf_filter_pid_remove ( ctx -> opid ) ; ctx -> opid = NULL ; } return GF_OK ; } if ( ! gf_filter_pid_check_caps ( pid ) ) { return GF_NOT_SUPPORTED ; } p = gf_filter_pid_get_property ( pid , GF_PROP_PID_CODECID ) ; if ( ! p ) { return GF_NOT_SUPPORTED ; } ctx -> codecid = p -> value . uint ; if ( ! ctx -> opid ) { ctx -> opid = gf_filter_pid_new ( filter ) ; } ctx -> ipid = pid ; gf_filter_pid_copy_properties ( ctx -> opid , pid ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_DECODER_CONFIG , NULL ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_UNFRAMED , & PROP_BOOL ( GF_TRUE ) ) ; if ( ctx -> is_latm ) { gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_UNFRAMED_LATM , & PROP_BOOL ( GF_TRUE ) ) ; } gf_filter_pid_set_framing_mode ( ctx -> ipid , GF_TRUE ) ; p = gf_filter_pid_get_property ( pid , GF_PROP_PID_SAMPLE_RATE ) ; if ( ! p ) { return GF_OK ; } sr = p -> value . uint ; ctx -> channels = 0 ; p = gf_filter_pid_get_property ( pid , GF_PROP_PID_NUM_CHANNELS ) ; if ( p ) { ctx -> channels = p -> value . uint ; } ctx -> aac_type = 0 ; if ( ctx -> is_latm ) { u32 crc ; p = gf_filter_pid_get_property ( pid , GF_PROP_PID_DECODER_CONFIG ) ; if ( ! p ) { return GF_NOT_SUPPORTED ; } crc = gf_crc_32 ( p -> value . data . ptr , p -> value . data . size ) ; if ( crc != ctx -> dsi_crc ) { ctx -> dsi_crc = crc ; gf_m4a_get_config ( p -> value . data . ptr , p -> value . data . size , & ctx -> acfg ) ; ctx -> update_dsi = GF_TRUE ; } p = gf_filter_pid_get_property ( pid , GF_PROP_PID_TIMESCALE ) ; if ( ! p ) { return GF_NOT_SUPPORTED ; } ctx -> timescale = p -> value . uint ; } if ( ctx -> codecid == GF_CODECID_AAC_MPEG4 ) { chan_cfg = ctx -> channels ; if ( chan_cfg == 8 ) { chan_cfg = 7 ; } if ( ! ctx -> mpeg2 ) { p = gf_filter_pid_get_property ( pid , GF_PROP_PID_DECODER_CONFIG ) ; if ( p ) { gf_m4a_get_config ( p -> value . data . ptr , p -> value . data . size , & ctx -> acfg ) ; ctx -> aac_type = ctx -> acfg . base_object_type - 1 ; chan_cfg = ctx -> acfg . chan_cfg ; sr = ctx -> acfg . base_sr ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_MEDIA , ( \"[UFADTS] no AAC decoder config, assuming AAC-LC\\n\" ) ) ; ctx -> aac_type = GF_M4A_AAC_LC ; if ( ! ctx -> channels ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_MEDIA , ( \"[UFADTS] no channel config found for ADTS, forcing stereo\\n\" ) ) ; chan_cfg = ctx -> channels = 2 ; patch_channels = GF_TRUE ; } if ( ! chan_cfg ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_MEDIA , ( \"[UFADTS] Unknown channel config, will not be able to signal it in ADTS\\n\" ) ) ; } } } if ( chan_cfg > 7 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_MEDIA , ( \"[UFADTS] Unknown channel config, will not be able to signal it in ADTS\\n\" ) ) ; chan_cfg = 0 ; } } else { ctx -> aac_type = ctx -> codecid - GF_CODECID_AAC_MPEG2_MP ; } if ( ctx -> channels && ctx -> acfg . nb_chan && ( ctx -> channels != ctx -> acfg . nb_chan ) ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_MEDIA , ( \"[UFADTS] Mismatch between container number of channels (%d) and AAC config (%d), using AAC config\\n\" , ctx -> channels , ctx -> acfg . nb_chan ) ) ; ctx -> channels = ctx -> acfg . nb_chan ; patch_channels = GF_TRUE ; } if ( ( ctx -> acfg . base_object_type == 2 ) && ( ctx -> acfg . base_sr != sr ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_MEDIA , ( \"[UFADTS] Mismatch between container samplerate (%d) and AAC config SBR base samplerate (%d), using AAC config\\n\" , sr , ctx -> acfg . base_sr ) ) ; sr = ctx -> acfg . base_sr ; } if ( ! ctx -> acfg . chan_cfg && ctx -> acfg . program_config_element_present ) { GF_BitStream * bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; gf_m4a_write_program_config_element_bs ( bs , & ctx -> acfg ) ; if ( ctx -> pce ) { gf_free ( ctx -> pce ) ; } ctx -> pce = NULL ; gf_bs_get_content ( bs , & ctx -> pce , & ctx -> pce_size ) ; gf_bs_del ( bs ) ; GF_LOG ( GF_LOG_WARNING , GF_LOG_MEDIA , ( \"[UFADTS] ADTS will use multiple raw blocks to signal channel configuration\\n\" ) ) ; } p = gf_filter_pid_get_property ( pid , GF_PROP_PID_DECODER_CONFIG ) ; if ( ! p ) { return GF_NOT_SUPPORTED ; } ctx -> dsi = p -> value . data . ptr ; ctx -> dsi_size = p -> value . data . size ; ctx -> ch_cfg = chan_cfg ; for ( i = 0 ; i < 16 ; i ++ ) { if ( GF_M4ASampleRates [ i ] == ( u32 ) sr ) { ctx -> sr_idx = i ; break ; } } if ( patch_channels ) { gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_NUM_CHANNELS , & PROP_UINT ( ctx -> channels ) ) ; } return GF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct expression * fake_string_from_mtag ( mtag_t tag ) { char * str ; if ( ! tag ) { return in ; } str = get_string_from_mtag ( tag ) ; if ( ! str ) { return NULL ; } return string_expression ( str ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { int map_types [ ] { BPF_MAP_TYPE_LRU_HASH BPF_MAP_TYPE_LRU_PERCPU_HASH } ; ; int map_flags [ ] { 0 BPF_F_NO_COMMON_LRU } ; ; int t , f ; setbuf ( stdout , NULL ) ; nr_cpus = bpf_num_possible_cpus ( ) ; assert ( nr_cpus != - 1 ) ; printf ( \"nr_cpus:%d\\n\\n\" , nr_cpus ) ; libbpf_set_strict_mode ( LIBBPF_STRICT_ALL ) ; for ( f = 0 ; f < ARRAY_SIZE ( map_flags ) ; f ++ ) { int tgt_free = ( map_flags [ f ] & BPF_F_NO_COMMON_LRU ) ?PERCPU_FREE_TARGET : LOCAL_FREE_TARGET ; for ( t = 0 ; t < ARRAY_SIZE ( map_types ) ; t ++ ) { test_lru_sanity0 ( map_types [ t ] , map_flags [ f ] ) ; test_lru_sanity1 ( map_types [ t ] , map_flags [ f ] , tgt_free ) ; test_lru_sanity2 ( map_types [ t ] , map_flags [ f ] , tgt_free ) ; test_lru_sanity3 ( map_types [ t ] , map_flags [ f ] , tgt_free ) ; test_lru_sanity4 ( map_types [ t ] , map_flags [ f ] , tgt_free ) ; test_lru_sanity5 ( map_types [ t ] , map_flags [ f ] ) ; test_lru_sanity6 ( map_types [ t ] , map_flags [ f ] , tgt_free ) ; test_lru_sanity7 ( map_types [ t ] , map_flags [ f ] ) ; test_lru_sanity8 ( map_types [ t ] , map_flags [ f ] ) ; printf ( \"\\n\" ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "iscsi_status_t iscsi_login_start ( void * arg ) { iscsi_task_t * itp = ( iscsi_task_t * ) arg ; iscsi_status_t rval = ISCSI_STATUS_LOGIN_FAILED ; iscsi_conn_t * icp ; iscsi_sess_t * isp ; iscsi_hba_t * ihp ; int status_class ; unsigned char status_detail ; ASSERT ( itp != NULL ) ; icp = ( iscsi_conn_t * ) itp -> t_arg ; ASSERT ( icp != NULL ) ; isp = icp -> conn_sess ; ASSERT ( isp != NULL ) ; ihp = isp -> sess_hba ; ASSERT ( ihp != NULL ) ; login_start ASSERT ( ( icp -> conn_state == ISCSI_CONN_STATE_IN_LOGIN ) || ( icp -> conn_state == ISCSI_CONN_STATE_FAILED ) || ( icp -> conn_state == ISCSI_CONN_STATE_POLLING ) ) ; icp -> conn_state_ffp = B_FALSE ; icp -> conn_login_status = ISCSI_INITIAL_LOGIN_STAGE ; icp -> conn_expstatsn = 0 ; icp -> conn_laststatsn = 0 ; ( void ) iscsi_sess_set_auth ( isp ) ; if ( ! ISCSI_SUCCESS ( iscsi_conn_sync_params ( icp ) ) ) { iscsi_login_end ( icp , ISCSI_STATUS_LOGIN_FAILED , itp ) ; return ( ISCSI_STATUS_LOGIN_FAILED ) ; } if ( ! ISCSI_SUCCESS ( iscsi_login_connect ( icp ) ) ) { if ( ( isp -> sess_boot == B_TRUE ) && ( ihp -> hba_service_status_overwrite == B_TRUE ) && ( isp -> sess_boot_nic_reset == B_FALSE ) ) { if ( iscsi_net_interface ( B_TRUE ) == ISCSI_STATUS_SUCCESS ) { isp -> sess_boot_nic_reset = B_TRUE ; } } login_retry } icp -> conn_login_max_data_length = icp -> conn_params . max_xmit_data_seg_len ; icp -> conn_login_data = kmem_zalloc ( icp -> conn_login_max_data_length , KM_SLEEP ) ; rval = iscsi_login ( icp , & status_class , & status_detail ) ; kmem_free ( icp -> conn_login_data , icp -> conn_login_max_data_length ) ; idm_conn_rele ( icp -> conn_ic ) ; if ( ! ISCSI_SUCCESS ( rval ) ) { switch ( rval ) { case ISCSI_STATUS_AUTHENTICATION_FAILED : case ISCSI_STATUS_INTERNAL_ERROR : case ISCSI_STATUS_VERSION_MISMATCH : case ISCSI_STATUS_NEGO_FAIL : case ISCSI_STATUS_LOGIN_TPGT_NEGO_FAIL : iscsi_login_end ( icp , ISCSI_STATUS_LOGIN_FAILED , itp ) ; return ( ISCSI_STATUS_LOGIN_FAILED ) ; default : login_retry } } switch ( status_class ) { case ISCSI_STATUS_CLASS_SUCCESS : iscsi_login_end ( icp , ISCSI_STATUS_SUCCESS , itp ) ; return ( ISCSI_STATUS_SUCCESS ) ; case ISCSI_STATUS_CLASS_REDIRECT : login_start case ISCSI_STATUS_CLASS_TARGET_ERR : cmn_err ( CE_WARN , \"iscsi connection(%u) login failed - \" \"%s (0x%02x/0x%02x)\" , icp -> conn_oid , iscsi_login_failure_str ( status_class , status_detail ) , status_class , status_detail ) ; login_retry case ISCSI_STATUS_CLASS_INITIATOR_ERR : default : cmn_err ( CE_WARN , \"iscsi connection(%u) login failed - \" \"%s (0x%02x/0x%02x) Target: %s, TPGT: %d\" , icp -> conn_oid , iscsi_login_failure_str ( status_class , status_detail ) , status_class , status_detail , isp -> sess_name , isp -> sess_tpgt_conf ) ; iscsi_login_end ( icp , ISCSI_STATUS_LOGIN_FAILED , itp ) ; break ; } return ( ISCSI_STATUS_LOGIN_FAILED ) ; login_retry if ( icp -> conn_login_max > ddi_get_lbolt ( ) ) { if ( icp -> conn_state == ISCSI_CONN_STATE_POLLING ) { icp -> conn_login_min = ddi_get_lbolt ( ) + SEC_TO_TICK ( icp -> conn_tunable_params . polling_login_delay ) ; } else { icp -> conn_login_min = ddi_get_lbolt ( ) + SEC_TO_TICK ( ISCSI_LOGIN_RETRY_DELAY ) ; } if ( itp -> t_blocking == B_TRUE ) { login_start } else { if ( ddi_taskq_dispatch ( isp -> sess_login_taskq , iscsi_login_cb , itp , DDI_SLEEP ) != DDI_SUCCESS ) { iscsi_login_end ( icp , ISCSI_STATUS_LOGIN_TIMED_OUT , itp ) ; } return ( ISCSI_STATUS_SUCCESS ) ; } } else { iscsi_login_end ( icp , ISCSI_STATUS_LOGIN_TIMED_OUT , itp ) ; } return ( ISCSI_STATUS_LOGIN_FAILED ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int usb_scan_device ( struct udevice * parent , int port , enum usb_device_speed speed , struct udevice * * devp ) { struct udevice * dev ; bool created = false ; struct usb_dev_plat * plat ; struct usb_bus_priv * priv ; struct usb_device * parent_udev ; int ret ; ALLOC_CACHE_ALIGN_BUFFER ( usb_device , udev , 1 ) ; struct usb_interface_descriptor * iface = & udev -> config . if_desc [ 0 ] . desc ; * devp = NULL ; udev -> controller_dev = usb_get_bus ( parent ) ; priv = dev_get_uclass_priv ( udev -> controller_dev ) ; udev -> dev = parent ; udev -> speed = speed ; udev -> devnum = priv -> next_addr + 1 ; udev -> portnr = port ; debug ( \"Calling usb_setup_device(), portnr=%d\\n\" , udev -> portnr ) ; parent_udev = device_get_uclass_id ( parent ) == UCLASS_USB_HUB ?dev_get_parent_priv ( parent ) : NULL ; ret = usb_setup_device ( udev , priv -> desc_before_addr , parent_udev ) ; debug ( \"read_descriptor for '%s': ret=%d\\n\" , parent -> name , ret ) ; if ( ret ) { return ret ; } ret = usb_find_child ( parent , & udev -> descriptor , iface , & dev ) ; debug ( \"** usb_find_child returns %d\\n\" , ret ) ; if ( ret ) { if ( ret != - ENOENT ) { return ret ; } ret = usb_find_and_bind_driver ( parent , & udev -> descriptor , iface , dev_seq ( udev -> controller_dev ) , udev -> devnum , port , & dev ) ; if ( ret ) { return ret ; } created = true ; } plat = dev_get_parent_plat ( dev ) ; debug ( \"%s: Probing '%s', plat=%p\\n\" , __func__ , dev -> name , plat ) ; plat -> devnum = udev -> devnum ; plat -> udev = udev ; priv -> next_addr ++ ; ret = device_probe ( dev ) ; if ( ret ) { debug ( \"%s: Device '%s' probe failed\\n\" , __func__ , dev -> name ) ; priv -> next_addr -- ; if ( created ) { device_unbind ( dev ) ; } return ret ; } * devp = dev ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int legion_action_cache_fetch_from_legion ( struct uwsgi_legion * ul , char * arg ) { uwsgi_log ( \"[legion-cache-fetch] getting cache '%s' dump from legion '%s' nodes\\n\" , arg , ul -> legion ) ; struct uwsgi_cache * uc = uwsgi_cache_by_name ( arg ) ; if ( ! uc ) { uwsgi_log ( \"[legion-cache-fetch] cannot sync, cache '%s' not found\\n\" , arg ) ; return 1 ; } struct uwsgi_string_list * dump_from_nodes = NULL ; uwsgi_rlock ( ul -> lock ) ; struct uwsgi_legion_node * legion_nodes = ul -> nodes_head ; while ( legion_nodes ) { char * dump_socket = NULL ; if ( uwsgi_kvlist_parse ( legion_nodes -> scroll , legion_nodes -> scroll_len , ',' , '=' , \"dump-socket\" , & dump_socket , NULL ) ) { uwsgi_log ( \"[legion-cache-fetch] cannot sync from %.*s, cache socket address not found in legion scroll: %.*s\\n\" , legion_nodes -> name_len , legion_nodes -> name , legion_nodes -> scroll_len , legion_nodes -> scroll ) ; } else { if ( dump_socket ) { uwsgi_string_new_list ( & dump_from_nodes , dump_socket ) ; } else { uwsgi_log ( \"[legion-cache-fetch] cannot sync from %.*s, cache socket address not found in legion scroll: %.*s\\n\" , legion_nodes -> name_len , legion_nodes -> name , legion_nodes -> scroll_len , legion_nodes -> scroll ) ; } } legion_nodes = legion_nodes -> next ; } struct uwsgi_string_list * usl = uc -> sync_nodes ; struct uwsgi_string_list * next ; while ( usl ) { next = usl -> next ; free ( usl -> value ) ; usl = next ; } uwsgi_rwunlock ( ul -> lock ) ; uwsgi_rlock ( uc -> lock ) ; uc -> sync_nodes = dump_from_nodes ; uwsgi_rwunlock ( uc -> lock ) ; uwsgi_cache_sync_from_nodes ( uc ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int corkscrew_close ( struct net_device * dev ) { struct corkscrew_private * vp = netdev_priv ( dev ) ; int ioaddr = dev -> base_addr ; int i ; netif_stop_queue ( dev ) ; if ( corkscrew_debug > 1 ) { pr_debug ( \"%s: corkscrew_close() status %4.4x, Tx status %2.2x.\\n\" , dev -> name , inw ( ioaddr + EL3_STATUS ) , inb ( ioaddr + TxStatus ) ) ; pr_debug ( \"%s: corkscrew close stats: rx_nocopy %d rx_copy %d tx_queued %d.\\n\" , dev -> name , rx_nocopy , rx_copy , queued_packet ) ; } del_timer_sync ( & vp -> timer ) ; outw ( StatsDisable , ioaddr + EL3_CMD ) ; outw ( RxDisable , ioaddr + EL3_CMD ) ; outw ( TxDisable , ioaddr + EL3_CMD ) ; if ( dev -> if_port == XCVR_10base2 ) { outw ( StopCoax , ioaddr + EL3_CMD ) ; } free_irq ( dev -> irq , dev ) ; outw ( SetIntrEnb | 0x0000 , ioaddr + EL3_CMD ) ; update_stats ( ioaddr , dev ) ; if ( vp -> full_bus_master_rx ) { outl ( 0 , ioaddr + UpListPtr ) ; for ( i = 0 ; i < RX_RING_SIZE ; i ++ ) { if ( vp -> rx_skbuff [ i ] ) { dev_kfree_skb ( vp -> rx_skbuff [ i ] ) ; vp -> rx_skbuff [ i ] = NULL ; } } } if ( vp -> full_bus_master_tx ) { outl ( 0 , ioaddr + DownListPtr ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { if ( vp -> tx_skbuff [ i ] ) { dev_kfree_skb ( vp -> tx_skbuff [ i ] ) ; vp -> tx_skbuff [ i ] = NULL ; } } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct mtk_pinctrl_group * mtk_pctrl_find_group_by_pin ( struct mtk_pinctrl * hw , u32 pin ) { int i ; for ( i = 0 ; i < hw -> soc -> ngrps ; i ++ ) { struct mtk_pinctrl_group * grp = hw -> groups + i ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void statuses_chat_defaults_to_all ( void * * state ) { char * setting = prefs_get_string ( PREF_STATUSES_CHAT ) ; assert_non_null ( setting ) ; assert_string_equal ( \"none\" , setting ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void FlowBypassFree ( void * x ) { FlowBypassInfo * fb = ( FlowBypassInfo * ) x ; if ( fb -> bypass_data && fb -> BypassFree ) { fb -> BypassFree ( fb -> bypass_data ) ; } SCFree ( fb ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int motd_forward ( struct Client * cptr , struct MotdCache * cache ) { int i ; assert ( 0 != cptr ) ; send_reply ( cptr , RPL_MOTDSTART , cli_name ( & me ) ) ; send_reply ( cptr , SND_EXPLICIT | RPL_MOTD , \":- %d-%d-%d %d:%02d\" , cache -> modtime . tm_year + 1900 , cache -> modtime . tm_mon + 1 , cache -> modtime . tm_mday , cache -> modtime . tm_hour , cache -> modtime . tm_min ) ; for ( i = 0 ; i < cache -> count ; i ++ ) { send_reply ( cptr , RPL_MOTD , cache -> motd [ i ] ) ; } return send_reply ( cptr , RPL_ENDOFMOTD ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void dwc2_hsotg_disconnect ( struct dwc2_hsotg * hsotg ) { unsigned int ep ; hsotg -> connected = 0 ; hsotg -> test_mode = 0 ; for ( ep = 0 ; ep < hsotg -> num_of_eps ; ep ++ ) { if ( hsotg -> eps_in [ ep ] ) { kill_all_requests ( hsotg , hsotg -> eps_in [ ep ] , - ESHUTDOWN ) ; } if ( hsotg -> eps_out [ ep ] ) { kill_all_requests ( hsotg , hsotg -> eps_out [ ep ] , - ESHUTDOWN ) ; } } call_gadget ( hsotg , disconnect ) ; hsotg -> lx_state = DWC2_L3 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mtk_drm_cmdq_pkt_create ( struct cmdq_client * client , struct cmdq_pkt * pkt , size_t size ) { struct device * dev ; dma_addr_t dma_addr ; pkt -> va_base = kzalloc ( size , GFP_KERNEL ) ; if ( ! pkt -> va_base ) { return - ENOMEM ; } pkt -> buf_size = size ; pkt -> cl = ( void * ) client ; dev = client -> chan -> mbox -> dev ; dma_addr = dma_map_single ( dev , pkt -> va_base , pkt -> buf_size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma_addr ) ) { dev_err ( dev , \"dma map failed, size=%u\\n\" , ( u32 ) ( u64 ) size ) ; kfree ( pkt -> va_base ) ; kfree ( pkt ) ; return - ENOMEM ; } pkt -> pa_base = dma_addr ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct usb_function_instance * gprinter_alloc_inst ( void ) { struct f_printer_opts * opts ; struct usb_function_instance * ret ; int status = 0 ; opts = kzalloc ( sizeof ( * opts ) , GFP_KERNEL ) ; if ( ! opts ) { return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & opts -> lock ) ; opts -> func_inst . free_func_inst = gprinter_free_inst ; ret = & opts -> func_inst ; mutex_lock ( & printer_ida_lock ) ; if ( ida_is_empty ( & printer_ida ) ) { status = gprinter_setup ( PRINTER_MINORS ) ; if ( status ) { ret = ERR_PTR ( status ) ; unlock } } opts -> minor = gprinter_get_minor ( ) ; if ( opts -> minor < 0 ) { ret = ERR_PTR ( opts -> minor ) ; kfree ( opts ) ; if ( ida_is_empty ( & printer_ida ) ) { gprinter_cleanup ( ) ; } unlock } config_group_init_type_name ( & opts -> func_inst . group , \"\" , & printer_func_type ) ; unlock mutex_unlock ( & printer_ida_lock ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "CURLSHcode Curl_share_lock ( struct Curl_easy * data , curl_lock_data type , curl_lock_access accesstype ) { struct Curl_share * share = data -> share ; if ( share -> specifier & ( 1 << type ) ) { if ( share -> lockfunc ) { share -> lockfunc ( data , type , accesstype , share -> clientdata ) ; } } return CURLSHE_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int iwl_mvm_start_get_nvm ( struct iwl_mvm * mvm ) { struct iwl_trans * trans = mvm -> trans ; int ret ; if ( trans -> csme_own ) { if ( WARN ( ! mvm -> mei_registered , \"csme is owner, but we aren't registered to iwlmei\\n\" ) ) { get_nvm_from_fw } mvm -> mei_nvm_data = iwl_mei_get_nvm ( ) ; if ( mvm -> mei_nvm_data ) { mvm -> nvm_data = iwl_parse_mei_nvm_data ( trans , trans -> cfg , mvm -> mei_nvm_data , mvm -> fw ) ; return 0 ; } IWL_ERR ( mvm , \"Got a NULL NVM from CSME, trying to get it from the device\\n\" ) ; } get_nvm_from_fw rtnl_lock ( ) ; wiphy_lock ( mvm -> hw -> wiphy ) ; ret = iwl_trans_start_hw ( mvm -> trans ) ; if ( ret ) { mutex_unlock ( & mvm -> mutex ) ; wiphy_unlock ( mvm -> hw -> wiphy ) ; rtnl_unlock ( ) ; return ret ; } ret = iwl_run_init_mvm_ucode ( mvm ) ; if ( ret && ret != - ERFKILL ) { iwl_fw_dbg_error_collect ( & mvm -> fwrt , FW_DBG_TRIGGER_DRIVER ) ; } if ( ! ret && iwl_mvm_is_lar_supported ( mvm ) ) { mvm -> hw -> wiphy -> regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED ; ret = iwl_mvm_init_mcc ( mvm ) ; } if ( ! iwlmvm_mod_params . init_dbg || ! ret ) { iwl_mvm_stop_device ( mvm ) ; } mutex_unlock ( & mvm -> mutex ) ; wiphy_unlock ( mvm -> hw -> wiphy ) ; rtnl_unlock ( ) ; if ( ret ) { IWL_ERR ( mvm , \"Failed to run INIT ucode: %d\\n\" , ret ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct cxl * cxl_alloc_adapter ( void ) { struct cxl * adapter ; if ( ! ( adapter = kzalloc ( sizeof ( cxl ) , GFP_KERNEL ) ) ) { return in ; } spin_lock_init ( & adapter -> afu_list_lock ) ; if ( cxl_alloc_adapter_nr ( adapter ) ) { err1 } if ( dev_set_name ( & adapter -> dev , \"card%i\" , adapter -> adapter_num ) ) { err2 } atomic_set ( & adapter -> contexts_num , - 1 ) ; return adapter ; err2 cxl_remove_adapter_nr ( adapter ) ; err1 kfree ( adapter ) ; return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "DEFINE_SHOW_ATTRIBUTE ( port_sel_mode ) ; DEFINE_SHOW_ATTRIBUTE ( state ) ; DEFINE_SHOW_ATTRIBUTE ( flags , NULL ) ; DEFINE_SHOW_ATTRIBUTE ( mapping ) ; DEFINE_SHOW_ATTRIBUTE ( members ) ; void mlx5_ldev_add_debugfs ( struct mlx5_core_dev * dev ) { struct dentry * dbg ; dbg = debugfs_create_dir ( \"lag\" , mlx5_debugfs_get_dev_root ( dev ) ) ; dev -> priv . dbg . lag_debugfs = dbg ; debugfs_create_file ( \"type\" , 0444 , dbg , dev , & type_fops ) ; debugfs_create_file ( \"port_sel_mode\" , 0444 , dbg , dev , & port_sel_mode_fops ) ; debugfs_create_file ( \"state\" , 0444 , dbg , dev , & state_fops ) ; debugfs_create_file ( \"flags\" , 0444 , dbg , dev , & flags_fops ) ; debugfs_create_file ( \"mapping\" , 0444 , dbg , dev , & mapping_fops ) ; debugfs_create_file ( \"members\" , 0444 , dbg , dev , & members_fops ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void __cfg80211_sme_scan_done ( struct net_device * dev ) { struct wireless_dev * wdev = dev -> ieee80211_ptr ; struct cfg80211_registered_device * rdev = wiphy_to_rdev ( wdev -> wiphy ) ; struct cfg80211_bss * bss ; ASSERT_WDEV_LOCK ( wdev ) ; if ( wdev -> conn -> state != CFG80211_CONN_SCANNING && wdev -> conn -> state != CFG80211_CONN_SCAN_AGAIN ) { return ; } bss = cfg80211_get_conn_bss ( wdev ) ; if ( bss ) { cfg80211_put_bss ( & rdev -> wiphy , bss ) ; } else { schedule_work ( & rdev -> conn_work ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int fsl_ssi_startup ( struct snd_pcm_substream * substream , struct snd_soc_dai * dai ) { struct snd_soc_pcm_runtime * rtd = substream -> private_data ; struct fsl_ssi_private * ssi_private = snd_soc_dai_get_drvdata ( rtd -> cpu_dai ) ; int ret ; ret = clk_prepare_enable ( ssi_private -> clk ) ; if ( ssi_private -> use_dual_fifo ) { snd_pcm_hw_constraint_step ( substream -> runtime , 0 , SNDRV_PCM_HW_PARAM_PERIOD_SIZE , 2 ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vdec_recycle_thread ( void * data ) { struct amvdec_session * sess = data ; struct amvdec_core * core = sess -> core ; struct amvdec_codec_ops * codec_ops = sess -> fmt_out -> codec_ops ; struct amvdec_buffer * tmp , * n ; while ( ! kthread_should_stop ( ) ) { mutex_lock ( & sess -> bufs_recycle_lock ) ; list_for_each_entry_safe ( , , , ) { codec_ops -> recycle ( core , tmp -> vb -> index ) ; list_del ( & tmp -> list ) ; kfree ( tmp ) ; } mutex_unlock ( & sess -> bufs_recycle_lock ) ; usleep_range ( 5000 , 10000 ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "uint32_t HostTimeoutHash ( SCTime_t ts ) { uint32_t idx = 0 ; uint32_t cnt = 0 ; for ( idx = 0 ; idx < host_config . hash_size ; idx ++ ) { HostHashRow * hb = & host_hash [ idx ] ; if ( hb -> tail == NULL ) { HRLOCK_UNLOCK ( hb ) ; continue ; } cnt += HostHashRowTimeout ( hb , hb -> tail , ts ) ; HRLOCK_UNLOCK ( hb ) ; } return cnt ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void WriteUncompressed ( Image * image , ExceptionInfo * exception ) { const Quantum * p ; ssize_t x ; ssize_t y ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( GetPixelBlue ( image , p ) ) ) ; ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( GetPixelGreen ( image , p ) ) ) ; ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( GetPixelRed ( image , p ) ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( GetPixelAlpha ( image , p ) ) ) ; } p += GetPixelChannels ( image ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ibnex_devname_to_portnum ( char * device_name , uint8_t * portnum ) { int ret ; char * temp1 , * temp2 ; temp1 = strchr ( device_name , '@' ) ; temp2 = strchr ( temp1 , ',' ) ; if ( temp2 == NULL ) { return ( IBNEX_FAILURE ) ; } temp1 ++ ; * portnum = ibnex_str2hex ( temp1 , ( temp2 - temp1 ) , & ret ) ; return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "node_free ( ) { ret_t ret ; if ( key == NULL ) { return ret_ok ; } ret = node_mrproper ( key ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nfit_test_cmd_get_config_size ( struct nd_cmd_get_config_size * nd_cmd , unsigned int buf_len ) { nd_cmd -> status = 0 ; nd_cmd -> config_size = LABEL_SIZE ; nd_cmd -> max_xfer = SZ_4K ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "pfn_t sfmmu_kpm_vatopfn ( caddr_t vaddr ) { uintptr_t paddr ; pfn_t pfn ; page_t * pp ; ASSERT ( kpm_enable && IS_KPM_ADDR ( vaddr ) ) ; SFMMU_KPM_VTOP ( vaddr , paddr ) ; pfn = ( pfn_t ) btop ( paddr ) ; pp = page_numtopp_nolock ( pfn , NULL ) ; if ( pp && pp -> p_kpmref ) { return ( pfn ) ; } else { return ( ( pfn_t ) PFN_INVALID ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned int intel_rotation_info_size ( const struct intel_rotation_info * rot_info ) { int size = 0 ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( rot_info -> plane ) ; i ++ ) { size += rot_info -> plane [ i ] . width * rot_info -> plane [ i ] . height ; } return size ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int feed_mailstorage_init ( struct mailstorage * storage , const char * feed_url , int feed_cached , const char * feed_cache_directory , const char * feed_flags_directory ) { struct feed_mailstorage * feed_storage ; int res ; feed_storage = malloc ( sizeof ( * feed_storage ) ) ; if ( feed_storage == NULL ) { res = MAIL_ERROR_MEMORY ; err } feed_storage -> feed_url = strdup ( feed_url ) ; if ( feed_storage -> feed_url == NULL ) { res = MAIL_ERROR_MEMORY ; free } feed_storage -> feed_cached = feed_cached ; if ( feed_cached && ( feed_cache_directory != NULL ) && ( feed_flags_directory != NULL ) ) { feed_storage -> feed_cache_directory = strdup ( feed_cache_directory ) ; if ( feed_storage -> feed_cache_directory == NULL ) { res = MAIL_ERROR_MEMORY ; free_url } feed_storage -> feed_flags_directory = strdup ( feed_flags_directory ) ; if ( feed_storage -> feed_flags_directory == NULL ) { res = MAIL_ERROR_MEMORY ; free_cache_directory } } else { feed_storage -> feed_cached = FALSE ; feed_storage -> feed_cache_directory = NULL ; feed_storage -> feed_flags_directory = NULL ; } storage -> sto_data = feed_storage ; storage -> sto_driver = & feed_mailstorage_driver ; return MAIL_NO_ERROR ; free_cache_directory free_url free ( feed_storage -> feed_url ) ; free free ( feed_storage ) ; err return res ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static double jsM_round ( double x ) { if ( isnan ( x ) ) { return x ; } if ( isinf ( x ) ) { return x ; } if ( x == 0 ) { return x ; } if ( x < 0 && x >= - 0.5 ) { return - 0 ; } return floor ( x + 0.5 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pid_is_firejail ( pid_t pid ) { printf ( \"%s: %d, pid %d\\n\" , __FUNCTION__ , __LINE__ , pid ) ; uid_t rv = 0 ; char * file ; if ( asprintf ( & file , \"/proc/%u/comm\" , pid ) == - 1 ) { errExit ( \"asprintf\" ) ; } FILE * fp = fopen ( file , \"r\" ) ; if ( ! fp ) { free ( file ) ; return 0 ; } char buf [ PIDS_BUFLEN ] ; if ( fgets ( buf , PIDS_BUFLEN - 1 , fp ) ) { if ( strncmp ( buf , \"firejail\" , 8 ) == 0 ) { rv = 1 ; } } printf ( \"%s: %d, comm %s, rv %d\\n\" , __FUNCTION__ , __LINE__ , buf , rv ) ; if ( rv ) { char * fname ; int fd ; if ( asprintf ( & fname , \"/proc/%d/cmdline\" , pid ) == - 1 ) { errExit ( \"asprintf\" ) ; } if ( ( fd = open ( fname , O_RDONLY ) ) < 0 ) { printf ( \"%s: %d, comm %s, rv %d\\n\" , __FUNCTION__ , __LINE__ , buf , rv ) ; doexit } free ( fname ) ; unsigned char buffer [ BUFLEN ] ; ssize_t len ; if ( ( len = read ( fd , buffer , sizeof ( buffer ) - 1 ) ) <= 0 ) { close ( fd ) ; printf ( \"%s: %d, comm %s, rv %d\\n\" , __FUNCTION__ , __LINE__ , buf , rv ) ; doexit } buffer [ len ] = '\\0' ; close ( fd ) ; char * exclude_args [ ] { \"apparmor.print\" \"caps.print\" \"cpu.print\" \"dns.print\" \"fs.print\" \"netfilter.print\" \"netfilter6.print\" \"profile.print\" \"protocol.print\" \"seccomp.print\" \"debug-caps\" \"debug-errnos\" \"debug-protocols\" \"debug-syscalls\" \"debug-syscalls32\" \"ls\" \"get\" \"put\" \"cat\" \"tree\" \"list\" \"top\" \"netstats\" \"bandwidth\" \"help\" \"version\" \"overlay-clean\" NULL } ; ; int i ; char * start ; int first = 1 ; for ( i = 0 ; i < len ; i ++ ) { if ( buffer [ i ] != '\\0' ) { continue ; } if ( first ) { first = 0 ; start = ( char * ) buffer + i + 1 ; continue ; } if ( strncmp ( start , \"--\" , 2 ) != 0 ) { break ; } start += 2 ; char * ptr = strchr ( start , '=' ) ; if ( ptr ) { * ptr = '\\0' ; } int j = 0 ; while ( exclude_args [ j ] != NULL ) { if ( strcmp ( start , exclude_args [ j ] ) == 0 ) { rv = 0 ; printf ( \"start=#%s#,  ptr=#%s#, flip rv %d\\n\" , start , ptr , rv ) ; break ; } j ++ ; } start = ( char * ) buffer + i + 1 ; } } doexit fclose ( fp ) ; free ( file ) ; printf ( \"%s: %d: return %d\\n\" , __FUNCTION__ , __LINE__ , rv ) ; return rv ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void _roster_publish_free ( module_t mod ) { roster_publish_t roster_publish = ( roster_publish_t ) mod -> private ; if ( roster_publish -> active_cache ) { xhash_walk ( roster_publish -> active_cache , _roster_publish_free_active_cache_walker , NULL ) ; xhash_free ( roster_publish -> active_cache ) ; } if ( roster_publish -> group_cache ) { xhash_walk ( roster_publish -> group_cache , _roster_publish_free_group_cache_walker , NULL ) ; xhash_free ( roster_publish -> group_cache ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int tcpedit_dlt_post_args ( tcpedit_t * tcpedit ) { tcpeditdlt_t * ctx ; const char * dst_dlt_name ; int rcode ; ctx = tcpedit -> dlt_ctx ; assert ( ctx ) ; dst_dlt_name = OPT_ARG ( DLT ) ?OPT_ARG ( DLT ) : ctx -> decoder -> name ; if ( ( ctx -> encoder = tcpedit_dlt_getplugin_byname ( ctx , dst_dlt_name ) ) == NULL ) { tcpedit_seterr ( tcpedit , \"No output DLT plugin available for: %s\" , dst_dlt_name ) ; return TCPEDIT_ERROR ; } if ( HAVE_OPT ( SKIPL2BROADCAST ) ) { ctx -> skip_broadcast = 1 ; } if ( ctx -> encoder -> dlt != ctx -> decoder -> dlt ) { if ( ( rcode = ctx -> encoder -> plugin_init ( ctx ) ) != TCPEDIT_OK ) { return TCPEDIT_ERROR ; } } if ( ( rcode = tcpedit_dlt_parse_opts ( ctx ) ) != TCPEDIT_OK ) { return TCPEDIT_ERROR ; } return tcpedit_dlt_post_init ( ctx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { int number_failed = 0 ; SRunner * sr ; rundebug ( ) ; sr = srunner_create ( dec_rpys_suite ( ) ) ; srunner_set_log ( sr , \"dec_rpys_suite.log\" ) ; srunner_run_all ( sr , CK_NORMAL ) ; number_failed = srunner_ntests_failed ( sr ) ; srunner_free ( sr ) ; return number_failed ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cx23885_alsa_dma_init ( struct cx23885_audio_dev * chip , unsigned long nr_pages ) { struct cx23885_audio_buffer * buf = chip -> buf ; struct page * pg ; int i ; buf -> vaddr = vmalloc_32 ( nr_pages << PAGE_SHIFT ) ; if ( NULL == buf -> vaddr ) { dprintk ( 1 , \"vmalloc_32(%lu pages) failed\\n\" , nr_pages ) ; return - ENOMEM ; } dprintk ( 1 , \"vmalloc is at addr %p, size=%lu\\n\" , buf -> vaddr , nr_pages << PAGE_SHIFT ) ; memset ( buf -> vaddr , 0 , nr_pages << PAGE_SHIFT ) ; buf -> nr_pages = nr_pages ; buf -> sglist = vzalloc ( array_size ( sizeof ( * buf -> sglist ) , buf -> nr_pages ) ) ; if ( NULL == buf -> sglist ) { vzalloc_err } sg_init_table ( buf -> sglist , buf -> nr_pages ) ; for ( i = 0 ; i < buf -> nr_pages ; i ++ ) { pg = vmalloc_to_page ( buf -> vaddr + i * PAGE_SIZE ) ; if ( NULL == pg ) { vmalloc_to_page_err } sg_set_page ( & buf -> sglist [ i ] , pg , PAGE_SIZE , 0 ) ; } return 0 ; vmalloc_to_page_err vfree ( buf -> sglist ) ; vzalloc_err vfree ( buf -> vaddr ) ; buf -> vaddr = NULL ; return - ENOMEM ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cfg80211_connect ( struct cfg80211_registered_device * rdev , struct net_device * dev , struct cfg80211_connect_params * connect , struct cfg80211_cached_keys * connkeys , const u8 * prev_bssid ) { struct wireless_dev * wdev = dev -> ieee80211_ptr ; int err ; ASSERT_WDEV_LOCK ( wdev ) ; if ( wdev -> u . client . ssid_len && ( wdev -> u . client . ssid_len != connect -> ssid_len || memcmp ( wdev -> u . client . ssid , connect -> ssid , wdev -> u . client . ssid_len ) ) ) { return - EALREADY ; } if ( wdev -> connected ) { if ( ! ether_addr_equal ( prev_bssid , wdev -> u . client . connected_addr ) ) { return - ENOTCONN ; } } if ( wdev -> connect_keys ) { return - EINPROGRESS ; } cfg80211_oper_and_ht_capa ( & connect -> ht_capa_mask , rdev -> wiphy . ht_capa_mod_mask ) ; cfg80211_oper_and_vht_capa ( & connect -> vht_capa_mask , rdev -> wiphy . vht_capa_mod_mask ) ; if ( connkeys && connkeys -> def >= 0 ) { int idx ; u32 cipher ; idx = connkeys -> def ; cipher = connkeys -> params [ idx ] . cipher ; if ( cipher == WLAN_CIPHER_SUITE_WEP40 || cipher == WLAN_CIPHER_SUITE_WEP104 ) { connect -> key_idx = idx ; connect -> key = connkeys -> params [ idx ] . key ; connect -> key_len = connkeys -> params [ idx ] . key_len ; if ( connect -> crypto . cipher_group == 0 ) { connect -> crypto . cipher_group = cipher ; } if ( connect -> crypto . n_ciphers_pairwise == 0 ) { connect -> crypto . n_ciphers_pairwise = 1 ; connect -> crypto . ciphers_pairwise [ 0 ] = cipher ; } } } else { if ( WARN_ON ( connkeys ) ) { return - EINVAL ; } connect -> key = NULL ; connect -> key_len = 0 ; connect -> key_idx = 0 ; connect -> crypto . cipher_group = 0 ; connect -> crypto . n_ciphers_pairwise = 0 ; } wdev -> connect_keys = connkeys ; memcpy ( wdev -> u . client . ssid , connect -> ssid , connect -> ssid_len ) ; wdev -> u . client . ssid_len = connect -> ssid_len ; wdev -> conn_bss_type = connect -> pbss ?IEEE80211_BSS_TYPE_PBSS : IEEE80211_BSS_TYPE_ESS ; if ( ! rdev -> ops -> connect ) { err = cfg80211_sme_connect ( wdev , connect , prev_bssid ) ; } else { err = rdev_connect ( rdev , dev , connect ) ; } if ( err ) { wdev -> connect_keys = NULL ; if ( ! wdev -> connected ) { wdev -> u . client . ssid_len = 0 ; } return err ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool atomisp_subdev_is_compressed ( u32 code ) { int i ; for ( i = 0 ; i < ARRAY_SIZE ( atomisp_in_fmt_conv ) - 1 ; i ++ ) { if ( code == atomisp_in_fmt_conv [ i ] . code ) { return atomisp_in_fmt_conv [ i ] . bpp != atomisp_in_fmt_conv [ i ] . depth ; } } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int emit_compressed_certificate ( ptls_emit_certificate_t * _self , ptls_t * tls , ptls_message_emitter_t * emitter , ptls_key_schedule_t * key_sched , ptls_iovec_t context , int push_status_request , const uint16_t * compress_algos , size_t num_compress_algos ) { ptls_emit_compressed_certificate_t * self = ( void * ) _self ; struct st_ptls_compressed_certificate_entry_t * entry ; int ret ; assert ( context . len == 0 || ! \"precompressed mode can only be used for server certificates\" ) ; for ( size_t i = 0 ; i != num_compress_algos ; ++ i ) { if ( compress_algos [ i ] == PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI ) { FoundBrotli } } ret = PTLS_ERROR_DELEGATE ; Exit FoundBrotli entry = & self -> without_ocsp_status ; if ( push_status_request && self -> with_ocsp_status . uncompressed_length != 0 ) { entry = & self -> with_ocsp_status ; } ptls_push_message ( , , , 3 ) Exit return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "PHP_MINIT_FUNCTION ( ) { using_history ( ) ; ZVAL_UNDEF ( & _readline_completion ) ; ZVAL_UNDEF ( & _prepped_callback ) ; register_readline_symbols ( module_number , NULL ) ; return PHP_MINIT ( cli_readline ) ( INIT_FUNC_ARGS_PASSTHRU ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int release_snapshot ( struct snapshot * snapshot ) { if ( ! -- snapshot -> referrers ) { stat_validity_clear ( & snapshot -> validity ) ; clear_snapshot_buffer ( snapshot ) ; return 1 ; } else { return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int rms_playfile ( call_leg_media_t * m , rms_action_t * a ) { int channels = 1 ; int file_sample_rate = 8000 ; ms_filter_add_notify_callback ( m -> ms_player , rms_player_eof , a , TRUE ) ; ms_filter_call_method ( m -> ms_player , MS_FILE_PLAYER_OPEN , ( void * ) a -> param . s ) ; ms_filter_call_method ( m -> ms_player , MS_FILE_PLAYER_START , NULL ) ; ms_filter_call_method ( m -> ms_player , MS_FILTER_GET_SAMPLE_RATE , & file_sample_rate ) ; ms_filter_call_method ( m -> ms_player , MS_FILTER_GET_NCHANNELS , & channels ) ; if ( m -> ms_resampler ) { ms_filter_call_method ( m -> ms_resampler , MS_FILTER_SET_SAMPLE_RATE , & file_sample_rate ) ; LM_INFO ( \"clock[%d]file[%d]\\n\" , m -> pt -> clock_rate , file_sample_rate ) ; ms_filter_call_method ( m -> ms_resampler , MS_FILTER_SET_OUTPUT_SAMPLE_RATE , & m -> pt -> clock_rate ) ; ms_filter_call_method ( m -> ms_resampler , MS_FILTER_SET_OUTPUT_NCHANNELS , & m -> pt -> channels ) ; } LM_INFO ( \"[%s]clock[%d][%d]\\n\" , m -> pt -> mime_type , m -> pt -> clock_rate , file_sample_rate ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int process_futurerelease ( struct caldav_alarm_data * data , struct mailbox * mailbox , struct index_record * record , time_t runtime ) { message_t * m = message_new_from_record ( mailbox , record ) ; struct buf buf = BUF_INITIALIZER ; json_t * submission = NULL , * identity , * envelope , * onSend ; smtpclient_t * sm = NULL ; int do_move = 0 ; int r = 0 ; syslog ( LOG_DEBUG , \"processing future release for mailbox %s uid %u\" , mailbox_name ( mailbox ) , record -> uid ) ; if ( record -> system_flags & FLAG_ANSWERED ) { syslog ( LOG_NOTICE , \"email already sent for mailbox %s uid %u\" , mailbox_name ( mailbox ) , record -> uid ) ; r = IMAP_NO_NOSUCHMSG ; done } if ( record -> system_flags & FLAG_FLAGGED ) { syslog ( LOG_NOTICE , \"submission canceled for mailbox %s uid %u\" , mailbox_name ( mailbox ) , record -> uid ) ; r = IMAP_NO_NOSUCHMSG ; done } r = message_get_field ( m , JMAP_SUBMISSION_HDR , MESSAGE_RAW , & buf ) ; if ( ! r ) { json_error_t jerr ; submission = json_loadb ( buf_base ( & buf ) , buf_len ( & buf ) , JSON_DISABLE_EOF_CHECK , & jerr ) ; } if ( ! submission ) { syslog ( LOG_ERR , \"process_futurerelease: failed to parse submission obj\" ) ; done } envelope = json_object_get ( submission , \"envelope\" ) ; identity = json_object_get ( submission , \"identityId\" ) ; onSend = json_object_get ( submission , \"onSend\" ) ; if ( JNULL ( onSend ) ) { onSend = NULL ; } r = message_get_field ( m , \"rawbody\" , MESSAGE_RAW , & buf ) ; if ( r ) { syslog ( LOG_ERR , \"process_futurerelease: can't get body for %s:%u\" , mailbox_name ( mailbox ) , record -> uid ) ; done } unsigned code = 0 , cancel = 0 ; const char * err = NULL ; r = smtpclient_open ( & sm ) ; if ( r ) { err = error_message ( r ) ; syslog ( LOG_ERR , \"smtpclient_open failed: %s\" , err ) ; } else { char * authid = mboxname_to_userid ( mailbox_name ( mailbox ) ) ; smtpclient_set_auth ( sm , authid ) ; if ( JNOTNULL ( identity ) ) { const char * jmapid = json_string_value ( identity ) ; if ( strchr ( jmapid , '@' ) && envelope ) { json_t * from_params = json_object_get ( json_object_get ( envelope , \"mailFrom\" ) , \"parameters\" ) ; if ( from_params && ( identity = json_object_get ( from_params , \"IDENTITY\" ) ) && ! strchr ( json_string_value ( identity ) , '@' ) ) { jmapid = json_string_value ( identity ) ; } } smtpclient_set_jmapid ( sm , jmapid ) ; } smtp_envelope_t smtpenv = SMTP_ENVELOPE_INITIALIZER ; jmap_emailsubmission_envelope_to_smtp ( & smtpenv , envelope ) ; r = smtpclient_send ( sm , & smtpenv , & buf ) ; smtp_envelope_fini ( & smtpenv ) ; if ( r ) { code = smtpclient_get_resp_code ( sm ) ; if ( code >= 500 ) { cancel = 1 ; } if ( code ) { err = smtpclient_get_resp_text ( sm ) ; } if ( ! err ) { err = error_message ( r ) ; } syslog ( LOG_ERR , \"smtpclient_send failed: %s\" , err ) ; } } const char * destmboxid = NULL ; json_t * setkeywords = NULL ; char * userid = NULL ; if ( r ) { unsigned duration ; switch ( data -> num_retries ) { case 0 : duration = 300 ; break ; case 1 : duration = 600 ; break ; case 2 : duration = 900 ; break ; case 3 : duration = 1800 ; break ; default : cancel = 1 ; break ; } if ( ! cancel ) { caldav_alarm_bump_nextcheck ( data , runtime + duration , runtime , err ) ; if ( sm ) { smtpclient_close ( & sm ) ; } done } if ( onSend ) { do_move = 1 ; userid = mboxname_to_userid ( data -> mboxname ) ; char * destname = mboxlist_find_specialuse ( \"\\\\Drafts\" , userid ) ; mbentry_t * mbentry = NULL ; if ( ! destname ) { destname = mboxname_user_mbox ( userid , NULL ) ; } mboxlist_lookup ( destname , & mbentry , NULL ) ; if ( mbentry ) { buf_setcstr ( & buf , mbentry -> uniqueid ) ; destmboxid = buf_cstring ( & buf ) ; setkeywords = json_pack ( \"{ s:b }\" , \"$draft\" , 1 ) ; mboxlist_entry_free ( & mbentry ) ; } free ( destname ) ; } } else { record -> system_flags |= FLAG_ANSWERED ; if ( onSend ) { do_move = 1 ; destmboxid = json_string_value ( json_object_get ( onSend , \"moveToMailboxId\" ) ) ; setkeywords = json_deep_copy ( json_object_get ( onSend , \"setKeywords\" ) ) ; } } if ( sm ) { smtpclient_close ( & sm ) ; } if ( cancel || config_getswitch ( IMAPOPT_JMAPSUBMISSION_DELETEONSEND ) ) { record -> system_flags |= FLAG_DELETED ; record -> internal_flags |= FLAG_INTERNAL_EXPUNGED ; } r = mailbox_rewrite_index_record ( mailbox , record ) ; if ( r ) { syslog ( LOG_ERR , \"IOERROR: marking emailsubmission as %s (%s:%u) failed: %s\" , cancel ?\"cancelled\" : \"sent\" , mailbox_name ( mailbox ) , record -> uid , error_message ( r ) ) ; } caldav_alarm_delete_record ( mailbox_name ( mailbox ) , record -> uid ) ; if ( do_move ) { if ( ! userid ) { userid = mboxname_to_userid ( data -> mboxname ) ; } const char * emailid = json_string_value ( json_object_get ( submission , \"emailId\" ) ) ; struct find_sched_rock frock = { userid NULL 0 } ; struct mailbox * sched_mbox = NULL ; struct index_record sched_rec ; r = find_scheduled_email ( emailid , & frock ) ; if ( r || ! frock . mboxname ) { syslog ( LOG_ERR , \"IOERROR: failed to find \\\\Scheduled mailbox for user %s (%s)\" , frock . userid , error_message ( r ) ) ; } if ( ( r = mailbox_open_iwl ( frock . mboxname , & sched_mbox ) ) ) { syslog ( LOG_ERR , \"IOERROR: failed to open %s: %s\" , frock . mboxname , error_message ( r ) ) ; } if ( ( r = mailbox_find_index_record ( sched_mbox , frock . uid , & sched_rec ) ) ) { syslog ( LOG_ERR , \"IOERROR: failed find message %u in %s: %s\" , frock . uid , frock . mboxname , error_message ( r ) ) ; } else { r = move_to_mailboxid ( sched_mbox , & sched_rec , destmboxid , time ( 0 ) , setkeywords , 0 ) ; if ( r ) { syslog ( LOG_ERR , \"IOERROR: failed to move %s:%u (%s)\" , frock . mboxname , frock . uid , error_message ( r ) ) ; } if ( cancel ) { update_unscheduled ( data -> mboxname , runtime + 300 ) ; } } if ( setkeywords ) { json_decref ( setkeywords ) ; } mailbox_close ( & sched_mbox ) ; free ( frock . mboxname ) ; } free ( userid ) ; done if ( submission ) { json_decref ( submission ) ; } if ( m ) { message_unref ( & m ) ; } buf_free ( & buf ) ; return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cond_evaluate_expr ( struct policydb * p , struct cond_expr * expr ) { struct cond_expr * cur ; int s [ COND_EXPR_MAXDEPTH ] ; int sp = - 1 ; for ( cur = expr ; cur ; cur = cur -> next ) { switch ( cur -> expr_type ) { case COND_BOOL : if ( sp == ( COND_EXPR_MAXDEPTH - 1 ) ) { return - 1 ; } sp ++ ; s [ sp ] = p -> bool_val_to_struct [ cur -> bool - 1 ] -> state ; break ; case COND_NOT : s [ sp ] = ! s [ sp ] ; break ; case COND_OR : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] |= s [ sp + 1 ] ; break ; case COND_AND : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] &= s [ sp + 1 ] ; break ; case COND_XOR : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] ^= s [ sp + 1 ] ; break ; case COND_EQ : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] = ( s [ sp ] == s [ sp + 1 ] ) ; break ; case COND_NEQ : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] = ( s [ sp ] != s [ sp + 1 ] ) ; break ; default : return - 1 ; } } return s [ 0 ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int amixer_mgr_put_ctrl_blk ( void * blk ) { return 0 ; } dai_dirty { { u16 srt 1 ; u16 rsv 15 ; } , bf u16 data ; } dai_ctrl_blk { unsigned int srt ; union dai_dirty dirty ; } daoimap { int aim ; unsigned int idx ; } dao_dirty { { u16 atxcsl 1 ; u16 rsv 15 ; } , bf u16 data ; } dao_ctrl_blk { unsigned int atxcsl ; union dao_dirty dirty ; } daio_mgr_dirty { { u32 atxctl 8 ; u32 arxctl 8 ; u32 daoimap 1 ; u32 rsv 15 ; } , bf u32 data ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int kvaser_usb_leaf_verify_size ( const struct kvaser_usb * dev , const struct kvaser_cmd * cmd ) { u8 min_size = 0 ; switch ( dev -> driver_info -> family ) { case KVASER_LEAF : if ( cmd -> id < ARRAY_SIZE ( kvaser_usb_leaf_cmd_sizes_leaf ) ) { min_size = kvaser_usb_leaf_cmd_sizes_leaf [ cmd -> id ] ; } break ; case KVASER_USBCAN : if ( cmd -> id < ARRAY_SIZE ( kvaser_usb_leaf_cmd_sizes_usbcan ) ) { min_size = kvaser_usb_leaf_cmd_sizes_usbcan [ cmd -> id ] ; } break ; } if ( min_size == CMD_SIZE_ANY ) { return 0 ; } if ( min_size ) { min_size += CMD_HEADER_LEN ; dev_err_ratelimited ( & dev -> intf -> dev , \"Received command %u too short (size %u, needed %u)\" , cmd -> id , cmd -> len , min_size ) ; return - EIO ; } dev_warn_ratelimited ( & dev -> intf -> dev , \"Unhandled command (%d, size %d)\\n\" , cmd -> id , cmd -> len ) ; return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct comm_str * comm_str__get ( struct comm_str * cs ) { return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mxs_auart_dma_init ( struct mxs_auart_port * s ) { if ( auart_dma_enabled ( s ) ) { return 0 ; } if ( ! s -> rx_dma_chan ) { err_out } s -> rx_dma_buf = kzalloc ( UART_XMIT_SIZE , GFP_KERNEL | GFP_DMA ) ; if ( ! s -> rx_dma_buf ) { err_out } s -> tx_dma_chan = dma_request_slave_channel ( s -> dev , \"tx\" ) ; if ( ! s -> tx_dma_chan ) { err_out } s -> tx_dma_buf = kzalloc ( UART_XMIT_SIZE , GFP_KERNEL | GFP_DMA ) ; if ( ! s -> tx_dma_buf ) { err_out } s -> flags |= MXS_AUART_DMA_ENABLED ; dev_dbg ( s -> dev , \"enabled the DMA support.\" ) ; s -> port . fifosize = UART_XMIT_SIZE ; return 0 ; err_out mxs_auart_dma_exit_channel ( s ) ; return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void encode_slice_header ( FFV1Context * f , FFV1Context * fs ) { RangeCoder * c = & fs -> c ; uint8_t state [ CONTEXT_SIZE ] ; int j ; put_symbol ( c , state , ( fs -> slice_x + 1 ) * f -> num_h_slices / f -> width , 0 ) ; put_symbol ( c , state , ( fs -> slice_y + 1 ) * f -> num_v_slices / f -> height , 0 ) ; put_symbol ( c , state , ( fs -> slice_width + 1 ) * f -> num_h_slices / f -> width - 1 , 0 ) ; put_symbol ( c , state , ( fs -> slice_height + 1 ) * f -> num_v_slices / f -> height - 1 , 0 ) ; for ( j = 0 ; j < f -> plane_count ; j ++ ) { put_symbol ( c , state , f -> plane [ j ] . quant_table_index , 0 ) ; av_assert0 ( f -> plane [ j ] . quant_table_index == f -> context_model ) ; } if ( ! f -> frame -> interlaced_frame ) { put_symbol ( c , state , 3 , 0 ) ; } else { put_symbol ( c , state , 1 + ! f -> frame -> top_field_first , 0 ) ; } put_symbol ( c , state , f -> frame -> sample_aspect_ratio . num , 0 ) ; put_symbol ( c , state , f -> frame -> sample_aspect_ratio . den , 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int macronix_nand_randomizer_check_enable ( struct nand_chip * chip ) { u8 feature [ ONFI_SUBFEATURE_PARAM_LEN ] ; int ret ; ret = nand_get_features ( chip , ONFI_FEATURE_ADDR_MXIC_RANDOMIZER , feature ) ; if ( feature [ 0 ] ) { return feature [ 0 ] ; } feature [ 0 ] = MACRONIX_RANDOMIZER_MODE_ENTER ; ret = nand_set_features ( chip , ONFI_FEATURE_ADDR_MXIC_RANDOMIZER , feature ) ; if ( ret < 0 ) { return ret ; } feature [ 0 ] = 0x0 ; ret = nand_prog_page_op ( chip , 0 , 0 , feature , 1 ) ; if ( ret < 0 ) { return ret ; } ret = nand_get_features ( chip , ONFI_FEATURE_ADDR_MXIC_RANDOMIZER , feature ) ; if ( ret < 0 ) { return ret ; } feature [ 0 ] &= MACRONIX_RANDOMIZER_MODE_EXIT ; ret = nand_set_features ( chip , ONFI_FEATURE_ADDR_MXIC_RANDOMIZER , feature ) ; if ( ret < 0 ) { return ret ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void amdgpu_job_timedout ( struct amd_sched_job * s_job ) { struct amdgpu_job * job = container_of ( s_job , amdgpu_job , base ) ; DRM_ERROR ( \"ring %s timeout, last signaled seq=%u, last emitted seq=%u\\n\" , job -> base . sched -> name , atomic_read ( & job -> ring -> fence_drv . last_seq ) , job -> ring -> fence_drv . sync_seq ) ; amdgpu_gpu_reset ( job -> adev , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int parse_sequence_header ( AV1SequenceParameters * seq_params , const uint8_t * buf , int size ) { GetBitContext gb ; int reduced_still_picture_header ; int frame_width_bits_minus_1 , frame_height_bits_minus_1 ; int size_bits , ret ; size_bits = get_obu_bit_length ( buf , size , AV1_OBU_SEQUENCE_HEADER ) ; if ( size_bits < 0 ) { return size_bits ; } ret = init_get_bits ( & gb , buf , size_bits ) ; if ( ret < 0 ) { return ret ; } seq_params -> profile = get_bits ( & gb , 3 ) ; skip_bits1 ( & gb ) ; reduced_still_picture_header = get_bits1 ( & gb ) ; if ( reduced_still_picture_header ) { seq_params -> level = get_bits ( & gb , 5 ) ; seq_params -> tier = 0 ; } else { int initial_display_delay_present_flag , operating_points_cnt_minus_1 ; int decoder_model_info_present_flag , buffer_delay_length_minus_1 ; if ( get_bits1 ( & gb ) ) { skip_bits_long ( & gb , 32 ) ; skip_bits_long ( & gb , 32 ) ; if ( get_bits1 ( & gb ) ) { uvlc ( & gb ) ; } decoder_model_info_present_flag = get_bits1 ( & gb ) ; if ( decoder_model_info_present_flag ) { buffer_delay_length_minus_1 = get_bits ( & gb , 5 ) ; skip_bits_long ( & gb , 32 ) ; skip_bits ( & gb , 10 ) ; } } else { decoder_model_info_present_flag = 0 ; } initial_display_delay_present_flag = get_bits1 ( & gb ) ; operating_points_cnt_minus_1 = get_bits ( & gb , 5 ) ; for ( int i = 0 ; i <= operating_points_cnt_minus_1 ; i ++ ) { int seq_level_idx , seq_tier ; skip_bits ( & gb , 12 ) ; seq_level_idx = get_bits ( & gb , 5 ) ; if ( seq_level_idx > 7 ) { seq_tier = get_bits1 ( & gb ) ; } else { seq_tier = 0 ; } if ( decoder_model_info_present_flag ) { if ( get_bits1 ( & gb ) ) { skip_bits_long ( & gb , buffer_delay_length_minus_1 + 1 ) ; skip_bits_long ( & gb , buffer_delay_length_minus_1 + 1 ) ; skip_bits1 ( & gb ) ; } } if ( initial_display_delay_present_flag ) { if ( get_bits1 ( & gb ) ) { skip_bits ( & gb , 4 ) ; } } if ( i == 0 ) { seq_params -> level = seq_level_idx ; seq_params -> tier = seq_tier ; } } } frame_width_bits_minus_1 = get_bits ( & gb , 4 ) ; frame_height_bits_minus_1 = get_bits ( & gb , 4 ) ; skip_bits ( & gb , frame_width_bits_minus_1 + 1 ) ; skip_bits ( & gb , frame_height_bits_minus_1 + 1 ) ; if ( ! reduced_still_picture_header ) { if ( get_bits1 ( & gb ) ) { skip_bits ( & gb , 7 ) ; } } skip_bits ( & gb , 3 ) ; if ( ! reduced_still_picture_header ) { int enable_order_hint , seq_force_screen_content_tools ; skip_bits ( & gb , 4 ) ; enable_order_hint = get_bits1 ( & gb ) ; if ( enable_order_hint ) { skip_bits ( & gb , 2 ) ; } if ( get_bits1 ( & gb ) ) { seq_force_screen_content_tools = 2 ; } else { seq_force_screen_content_tools = get_bits1 ( & gb ) ; } if ( seq_force_screen_content_tools ) { if ( ! get_bits1 ( & gb ) ) { skip_bits1 ( & gb ) ; } } if ( enable_order_hint ) { skip_bits ( & gb , 3 ) ; } } skip_bits ( & gb , 3 ) ; parse_color_config ( seq_params , & gb ) ; skip_bits1 ( & gb ) ; if ( get_bits_left ( & gb ) ) { return AVERROR_INVALIDDATA ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _mysql_make_table_current ( mysql_conn_t * mysql_conn , char * table_name , storage_field_t * fields , char * ending ) { char * query = NULL ; char * correct_query = NULL ; MYSQL_RES * result = NULL ; MYSQL_ROW row ; int i = 0 ; List columns = NULL ; ListIterator itr = NULL ; char * col = NULL ; int adding = 0 ; int run_update = 0 ; char * primary_key = NULL ; char * unique_index = NULL ; int old_primary = 0 ; char * old_index = NULL ; char * temp = NULL , * temp2 = NULL ; List keys_list = NULL ; db_key_t * db_key = NULL ; DEF_TIMERS ; query = xstrdup_printf ( \"show index from %s where non_unique=0\" , table_name ) ; if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) { return SLURM_ERROR ; } xfree ( query ) ; while ( ( row = mysql_fetch_row ( result ) ) ) { if ( ! xstrcasecmp ( row [ 2 ] , \"PRIMARY\" ) ) { old_primary = 1 ; } if ( ! old_index ) { old_index = xstrdup ( row [ 2 ] ) ; } } mysql_free_result ( result ) ; query = xstrdup_printf ( \"show index from %s where non_unique=1\" , table_name ) ; if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) { xfree ( query ) ; xfree ( old_index ) ; return SLURM_ERROR ; } xfree ( query ) ; itr = NULL ; keys_list = list_create ( _destroy_db_key ) ; while ( ( row = mysql_fetch_row ( result ) ) ) { if ( ! itr ) { itr = list_iterator_create ( keys_list ) ; } else { list_iterator_reset ( itr ) ; } while ( ( db_key = list_next ( itr ) ) ) { if ( ! xstrcmp ( db_key -> name , row [ 2 ] ) ) { break ; } } if ( db_key ) { xstrfmtcat ( db_key -> columns , \", %s\" , row [ 4 ] ) ; } else { db_key = xmalloc ( sizeof ( db_key_t ) ) ; db_key -> name = xstrdup ( row [ 2 ] ) ; db_key -> columns = xstrdup ( row [ 4 ] ) ; list_append ( keys_list , db_key ) ; } } mysql_free_result ( result ) ; if ( itr ) { list_iterator_destroy ( itr ) ; itr = NULL ; } query = xstrdup_printf ( \"show columns from %s\" , table_name ) ; if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) { xfree ( query ) ; xfree ( old_index ) ; FREE_NULL_LIST ( keys_list ) ; return SLURM_ERROR ; } xfree ( query ) ; columns = list_create ( xfree_ptr ) ; while ( ( row = mysql_fetch_row ( result ) ) ) { col = xstrdup ( row [ 0 ] ) ; list_append ( columns , col ) ; } mysql_free_result ( result ) ; itr = list_iterator_create ( columns ) ; query = xstrdup_printf ( \"alter table %s\" , table_name ) ; correct_query = xstrdup ( query ) ; START_TIMER ; while ( fields [ i ] . name ) { int found = 0 ; list_iterator_reset ( itr ) ; while ( ( col = list_next ( itr ) ) ) { if ( ! xstrcmp ( col , fields [ i ] . name ) ) { xstrfmtcat ( query , \" modify `%s` %s,\" , fields [ i ] . name , fields [ i ] . options ) ; xstrfmtcat ( correct_query , \" modify `%s` %s,\" , fields [ i ] . name , fields [ i ] . options ) ; list_delete_item ( itr ) ; found = 1 ; break ; } } if ( ! found ) { if ( i ) { info ( \"adding column %s after %s in table %s\" , fields [ i ] . name , fields [ i - 1 ] . name , table_name ) ; xstrfmtcat ( query , \" add `%s` %s after %s,\" , fields [ i ] . name , fields [ i ] . options , fields [ i - 1 ] . name ) ; xstrfmtcat ( correct_query , \" modify `%s` %s,\" , fields [ i ] . name , fields [ i ] . options ) ; } else { info ( \"adding column %s at the beginning \" \"of table %s\" , fields [ i ] . name , table_name ) ; xstrfmtcat ( query , \" add `%s` %s first,\" , fields [ i ] . name , fields [ i ] . options ) ; xstrfmtcat ( correct_query , \" modify `%s` %s,\" , fields [ i ] . name , fields [ i ] . options ) ; } adding = 1 ; } i ++ ; } list_iterator_reset ( itr ) ; while ( ( col = list_next ( itr ) ) ) { adding = 1 ; info ( \"dropping column %s from table %s\" , col , table_name ) ; xstrfmtcat ( query , \" drop %s,\" , col ) ; } list_iterator_destroy ( itr ) ; FREE_NULL_LIST ( columns ) ; if ( ( temp = strstr ( ending , \"primary key (\" ) ) ) { int open = 0 , close = 0 ; int end = 0 ; while ( temp [ end ++ ] ) { if ( temp [ end ] == '(' ) { open ++ ; } if ( temp [ end ] == ')' ) { close ++ ; } else { continue ; } if ( open == close ) { break ; } } if ( temp [ end ] ) { end ++ ; primary_key = xstrndup ( temp , end ) ; if ( old_primary ) { xstrcat ( query , \" drop primary key,\" ) ; } xstrcat ( correct_query , \" drop primary key,\" ) ; xstrfmtcat ( query , \" add %s,\" , primary_key ) ; xstrfmtcat ( correct_query , \" add %s,\" , primary_key ) ; xfree ( primary_key ) ; } } if ( ( temp = strstr ( ending , \"unique index\" ) ) ) { int open = 0 , close = 0 ; int end = sizeof ( \"unique index\" ) - 2 ; char * udex_name = NULL , * name_marker = NULL ; while ( temp [ end ++ ] ) { if ( name_marker ) { if ( ! udex_name && ( temp [ end ] == '(' || temp [ end ] == ')' || temp [ end ] == ' ' || temp [ end ] == ',' ) ) { udex_name = xstrndup ( name_marker , temp + end - name_marker ) ; } } if ( temp [ end ] != '(' && temp [ end ] != ' ' ) { name_marker = temp + end ; } if ( temp [ end ] == '(' ) { open ++ ; } if ( temp [ end ] == ')' ) { close ++ ; } else { continue ; } if ( open == close ) { break ; } } if ( temp [ end ] ) { end ++ ; unique_index = xstrndup ( temp , end ) ; if ( old_index ) { xstrfmtcat ( query , \" drop index %s,\" , old_index ) ; } xstrfmtcat ( correct_query , \" drop index %s,\" , udex_name ) ; xstrfmtcat ( query , \" add %s,\" , unique_index ) ; xstrfmtcat ( correct_query , \" add %s,\" , unique_index ) ; xfree ( unique_index ) ; } xfree ( udex_name ) ; } xfree ( old_index ) ; temp2 = ending ; itr = list_iterator_create ( keys_list ) ; while ( ( temp = strstr ( temp2 , \", key \" ) ) ) { int open = 0 , close = 0 , name_end = 0 ; int end = 5 ; char * new_key_name = NULL , * new_key = NULL ; while ( temp [ end ++ ] ) { if ( ! name_end && ( temp [ end ] == ' ' ) ) { name_end = end ; continue ; } if ( temp [ end ] == '(' ) { open ++ ; if ( ! name_end ) { name_end = end ; } } if ( temp [ end ] == ')' ) { close ++ ; } else { continue ; } if ( open == close ) { break ; } } if ( temp [ end ] ) { end ++ ; new_key_name = xstrndup ( temp + 6 , name_end - 6 ) ; new_key = xstrndup ( temp + 2 , end - 2 ) ; while ( ( db_key = list_next ( itr ) ) ) { if ( ! xstrcmp ( db_key -> name , new_key_name ) ) { list_remove ( itr ) ; break ; } } list_iterator_reset ( itr ) ; if ( db_key ) { xstrfmtcat ( query , \" drop key %s,\" , db_key -> name ) ; _destroy_db_key ( db_key ) ; } else { info ( \"adding %s to table %s\" , new_key , table_name ) ; } xstrfmtcat ( correct_query , \" drop key %s,\" , new_key_name ) ; xstrfmtcat ( query , \" add %s,\" , new_key ) ; xstrfmtcat ( correct_query , \" add %s,\" , new_key ) ; xfree ( new_key ) ; xfree ( new_key_name ) ; } temp2 = temp + end ; } while ( ( db_key = list_next ( itr ) ) ) { info ( \"dropping key %s from table %s\" , db_key -> name , table_name ) ; xstrfmtcat ( query , \" drop key %s,\" , db_key -> name ) ; } list_iterator_destroy ( itr ) ; FREE_NULL_LIST ( keys_list ) ; query [ strlen ( query ) - 1 ] = ';' ; correct_query [ strlen ( correct_query ) - 1 ] = ';' ; if ( ! adding && _alter_table_after_upgrade ( mysql_conn , query ) ) { run_update = 3 ; } if ( ! adding && ! run_update ) { char * quoted = slurm_add_slash_to_quotes ( query ) ; char * query2 = xstrdup_printf ( \"select table_name from \" \"%s where definition='%s'\" , table_defs_table , quoted ) ; MYSQL_RES * result = NULL ; MYSQL_ROW row ; xfree ( quoted ) ; run_update = 1 ; if ( ( result = mysql_db_query_ret ( mysql_conn , query2 , 0 ) ) ) { if ( ( row = mysql_fetch_row ( result ) ) ) { run_update = 0 ; } mysql_free_result ( result ) ; } xfree ( query2 ) ; if ( run_update ) { run_update = 2 ; query2 = xstrdup_printf ( \"select table_name from \" \"%s where table_name='%s'\" , table_defs_table , table_name ) ; if ( ( result = mysql_db_query_ret ( mysql_conn , query2 , 0 ) ) ) { if ( ( row = mysql_fetch_row ( result ) ) ) { run_update = 1 ; } mysql_free_result ( result ) ; } xfree ( query2 ) ; } } if ( run_update || adding ) { time_t now = time ( NULL ) ; char * query2 = NULL ; char * quoted = NULL ; if ( run_update == 2 ) { debug4 ( \"Table %s doesn't exist, adding\" , table_name ) ; } if ( run_update == 3 ) { info ( \"MariaDB>= 10.2.1 in use with a table from an earlier version or from MySQL. Updating table %s...\" , table_name ) ; } else { debug ( \"Table %s has changed.  Updating...\" , table_name ) ; } debug2 ( \"query\\n%s\" , query ) ; if ( mysql_db_query ( mysql_conn , query ) ) { xfree ( query ) ; return SLURM_ERROR ; } quoted = slurm_add_slash_to_quotes ( correct_query ) ; query2 = xstrdup_printf ( \"insert into %s (creation_time, \" \"mod_time, table_name, definition) \" \"values (%ld, %ld, '%s', '%s') \" \"on duplicate key update \" \"definition='%s', mod_time=%ld;\" , table_defs_table , now , now , table_name , quoted , quoted , now ) ; xfree ( quoted ) ; debug3 ( \"query\\n%s\" , query2 ) ; if ( mysql_db_query ( mysql_conn , query2 ) ) { xfree ( query2 ) ; return SLURM_ERROR ; } xfree ( query2 ) ; } xfree ( query ) ; xfree ( correct_query ) ; query = xstrdup_printf ( \"make table current %s\" , table_name ) ; END_TIMER2 ( query ) ; xfree ( query ) ; return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int elf_cntl ( Elf * elf , Elf_Cmd cmd ) { if ( elf == 0 ) { return ( 0 ) ; } ELFWLOCK ( elf , NULL ) ; switch ( cmd ) { case ELF_C_FDREAD : { int j = 0 ; if ( ( elf -> ed_myflags & EDF_READ ) == 0 ) { _elf_seterr ( EREQ_CNTLWRT , 0 ) ; ELFUNLOCK ( elf ) ; return ( - 1 ) ; } if ( ( elf -> ed_status != ES_FROZEN ) && ( ( _elf_cook ( elf ) != OK_YES ) || ( _elf_vm ( elf , ( size_t ) 0 , elf -> ed_fsz ) != OK_YES ) ) ) { j = - 1 ; } elf -> ed_fd = - 1 ; ELFUNLOCK ( elf ) ; return ( j ) ; } case ELF_C_FDDONE : if ( ( elf -> ed_myflags & EDF_READ ) == 0 ) { _elf_seterr ( EREQ_CNTLWRT , 0 ) ; ELFUNLOCK ( elf ) ; return ( - 1 ) ; } elf -> ed_fd = - 1 ; ELFUNLOCK ( elf ) ; return ( 0 ) ; default : _elf_seterr ( EREQ_CNTLCMD , 0 ) ; break ; } ELFUNLOCK ( elf ) ; return ( - 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void i40iw_fill_device_info ( struct irdma_device * iwdev , struct i40e_info * cdev_info ) { struct irdma_pci_f * rf = iwdev -> rf ; rf -> rdma_ver = IRDMA_GEN_1 ; rf -> gen_ops . request_reset = i40iw_request_reset ; rf -> pcidev = cdev_info -> pcidev ; rf -> pf_id = cdev_info -> fid ; rf -> hw . hw_addr = cdev_info -> hw_addr ; rf -> cdev = cdev_info ; rf -> msix_count = cdev_info -> msix_count ; rf -> msix_entries = cdev_info -> msix_entries ; rf -> limits_sel = 5 ; rf -> protocol_used = IRDMA_IWARP_PROTOCOL_ONLY ; rf -> iwdev = iwdev ; iwdev -> init_state = INITIAL_STATE ; iwdev -> rcv_wnd = IRDMA_CM_DEFAULT_RCV_WND_SCALED ; iwdev -> rcv_wscale = IRDMA_CM_DEFAULT_RCV_WND_SCALE ; iwdev -> netdev = cdev_info -> netdev ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "Bool gf_svg_node_init ( GF_Node * node ) { switch ( node -> sgprivate -> tag ) { case TAG_SVG_script : if ( node -> sgprivate -> scenegraph -> script_load ) { node -> sgprivate -> scenegraph -> script_load ( node ) ; } return 1 ; case TAG_SVG_handler : if ( node -> sgprivate -> scenegraph -> script_load ) { node -> sgprivate -> scenegraph -> script_load ( node ) ; } if ( node -> sgprivate -> scenegraph -> script_action ) { ( ( SVG_handlerElement * ) node ) -> handle_event = gf_sg_handle_dom_event ; } return 1 ; case TAG_LSR_conditional : gf_smil_timing_init_runtime_info ( node ) ; gf_smil_setup_events ( node , NULL ) ; return 1 ; case TAG_SVG_animateMotion : case TAG_SVG_set : case TAG_SVG_animate : case TAG_SVG_animateColor : case TAG_SVG_animateTransform : gf_smil_anim_init_node ( node ) ; gf_smil_setup_events ( node ) ; return ( node -> sgprivate -> UserPrivate || node -> sgprivate -> UserCallback ) ?1 : 0 ; case TAG_SVG_audio : case TAG_SVG_video : case TAG_LSR_updates : gf_smil_timing_init_runtime_info ( node ) ; gf_smil_setup_events ( node ) ; return ( node -> sgprivate -> UserPrivate || node -> sgprivate -> UserCallback ) ?1 : 0 ; case TAG_SVG_animation : gf_smil_timing_init_runtime_info ( node ) ; gf_smil_setup_events ( node ) ; return 0 ; case TAG_SVG_discard : gf_smil_anim_init_discard ( node ) ; gf_smil_setup_events ( node ) ; return 1 ; default : return 0 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mt2712_rtc_read_time ( struct device * dev , struct rtc_time * tm ) { struct mt2712_rtc * mt2712_rtc = dev_get_drvdata ( dev ) ; int sec ; { __mt2712_rtc_read_time ( mt2712_rtc , tm , & sec ) ; } sec < tm -> tm_sec ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mdl_dump ( const struct uniphier_ddrphy_param * param ) { printf ( \"\\n--- Master Delay Line ---\\n\" ) ; printf ( \"          IPRD TPRD MDLD\\n\" ) ; dump_loop ( param , & __mdl_dump ) ; } { int ofst = PHY_ # # x ; void __iomem * reg = phy_base + ofst ; printf ( \"%3d: %-10s: %08x : %08x\\n\" , ofst >> PHY_REG_SHIFT , # x , ptr_to_uint ( reg ) , readl ( reg ) ) ; } { int ofst = PHY_DX_BASE + PHY_DX_STRIDE * ( dx ) + PHY_DX_ # # x ; void __iomem * reg = phy_base + ofst ; printf ( \"%3d: DX%d%-7s: %08x : %08x\\n\" , ofst >> PHY_REG_SHIFT , ( dx ) , # x , ptr_to_uint ( reg ) , readl ( reg ) ) ; } static void reg_dump ( const struct uniphier_ddrphy_param * param ) { void __iomem * phy_base ; int phy , dx ; printf ( \"\\n--- DDR PHY registers ---\\n\" ) ; for ( phy = 0 ; phy < param -> nr_phy ; phy ++ ) { phy_base = ioremap ( param -> phy [ phy ] . base , SZ_4K ) ; printf ( \"== PHY%d (base: %08x) ==\\n\" , phy , ptr_to_uint ( phy_base ) ) ; printf ( \" No: Name      : Address  : Data\\n\" ) ; REG_DUMP ( RIDR ) ; REG_DUMP ( PIR ) ; REG_DUMP ( PGCR0 ) ; REG_DUMP ( PGCR1 ) ; REG_DUMP ( PGSR0 ) ; REG_DUMP ( PGSR1 ) ; REG_DUMP ( PLLCR ) ; REG_DUMP ( PTR0 , NULL ) ; REG_DUMP ( PTR1 ) ; REG_DUMP ( PTR2 ) ; REG_DUMP ( PTR3 ) ; REG_DUMP ( PTR4 ) ; REG_DUMP ( ACMDLR ) ; REG_DUMP ( ACBDLR ) ; REG_DUMP ( DXCCR ) ; REG_DUMP ( DSGCR ) ; REG_DUMP ( DCR ) ; REG_DUMP ( DTPR0 ) ; REG_DUMP ( DTPR1 ) ; REG_DUMP ( DTPR2 ) ; REG_DUMP ( MR0 ) ; REG_DUMP ( MR1 ) ; REG_DUMP ( MR2 ) ; REG_DUMP ( MR3 ) ; for ( dx = 0 ; dx < param -> phy [ phy ] . nr_dx ; dx ++ ) { DX_REG_DUMP ( dx , GCR ) ; DX_REG_DUMP ( dx , GTR ) ; } iounmap ( phy_base ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dp_aux_i2c_handler ( struct dp_aux_private * aux , u32 isr ) { if ( isr & DP_INTR_AUX_I2C_DONE ) { if ( isr & ( DP_INTR_I2C_NACK | DP_INTR_I2C_DEFER ) ) { aux -> aux_error_num = DP_AUX_ERR_NACK ; } else { aux -> aux_error_num = DP_AUX_ERR_NONE ; } } else { if ( isr & DP_INTR_WRONG_ADDR ) { aux -> aux_error_num = DP_AUX_ERR_ADDR ; } if ( isr & DP_INTR_TIMEOUT ) { aux -> aux_error_num = DP_AUX_ERR_TOUT ; } if ( isr & DP_INTR_NACK_DEFER ) { aux -> aux_error_num = DP_AUX_ERR_NACK_DEFER ; } if ( isr & DP_INTR_I2C_NACK ) { aux -> aux_error_num = DP_AUX_ERR_NACK ; } if ( isr & DP_INTR_I2C_DEFER ) { aux -> aux_error_num = DP_AUX_ERR_DEFER ; } if ( isr & DP_INTR_AUX_ERROR ) { aux -> aux_error_num = DP_AUX_ERR_PHY ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void k5_arcfour_free_state ( krb5_data * state ) { struct arcfour_state * arcstate = ( void * ) state -> data ; EVP_CIPHER_CTX_free ( arcstate -> ctx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test_cherrypick_bare__orphan ( void ) { git_commit * head = NULL , * commit = NULL ; git_index * index = NULL ; git_oid head_oid , cherry_oid ; struct merge_index_entry merge_index_entries [ ] { { 0100644 \"38c05a857e831a7e759d83778bfc85d003e21c45\" 0 \"file1.txt\" } { 0100644 \"a661b5dec1004e2c62654ded3762370c27cf266b\" 0 \"file2.txt\" } { 0100644 \"85a4a1d791973644f24c72f5e89420d3064cc452\" 0 \"file3.txt\" } { 0100644 \"9ccb9bf50c011fd58dcbaa65df917bf79539717f\" 0 \"orphan.txt\" } } ; ; git_oid__fromstr ( & head_oid , \"d3d77487660ee3c0194ee01dc5eaf478782b1c7e\" , GIT_OID_SHA1 ) ; cl_git_pass ( git_commit_lookup ( & head , repo , & head_oid ) ) ; git_oid__fromstr ( & cherry_oid , \"74f06b5bfec6d33d7264f73606b57a7c0b963819\" , GIT_OID_SHA1 ) ; cl_git_pass ( git_commit_lookup ( & commit , repo , & cherry_oid ) ) ; cl_git_pass ( git_cherrypick_commit ( & index , repo , commit , head , 0 , NULL ) ) ; cl_assert ( merge_test_index ( index , merge_index_entries , 4 ) ) ; git_index_free ( index ) ; git_commit_free ( commit ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GF_Err BM_ParseDelete ( GF_BifsDecoder * codec , GF_BitStream * bs , GF_List * com_list ) { u8 type ; u32 ID ; GF_Command * com ; GF_Node * n ; type = gf_bs_read_int ( bs , 2 ) ; switch ( type ) { case 0 : ID = 1 + gf_bs_read_int ( bs , codec -> info -> config . NodeIDBits ) ; n = gf_sg_find_node ( codec -> current_graph , ID ) ; com = gf_sg_command_new ( codec -> current_graph , GF_SG_NODE_DELETE ) ; BM_SetCommandNode ( com , n ) ; gf_list_add ( com_list , com ) ; return GF_OK ; case 2 : return BM_ParseIndexDelete ( codec , bs , com_list ) ; case 3 : com = gf_sg_command_new ( codec -> current_graph , GF_SG_ROUTE_DELETE ) ; com -> RouteID = 1 + gf_bs_read_int ( bs , codec -> info -> config . RouteIDBits ) ; gf_list_add ( com_list , com ) ; return GF_OK ; default : return GF_NON_COMPLIANT_BITSTREAM ; } return GF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void set_timing_cfg_5 ( fsl_ddr_cfg_regs_t * ddr , unsigned int cas_latency ) { int rodt_on = 0 ; unsigned int rodt_off = 0 ; unsigned int wodt_on = 0 ; unsigned int wodt_off = 0 ; unsigned int wr_lat = ( ( ddr -> timing_cfg_2 & 0x00780000 ) >> 19 ) + ( ( ddr -> timing_cfg_2 & 0x00040000 ) >> 14 ) ; if ( cas_latency >= wr_lat ) { rodt_on = cas_latency - wr_lat + 1 ; } rodt_off = 4 ; wodt_on = 1 ; wodt_off = 4 ; ddr -> timing_cfg_5 = ( 0 | ( ( rodt_on & 0x1f ) << 24 ) | ( ( rodt_off & 0x7 ) << 20 ) | ( ( wodt_on & 0x1f ) << 12 ) | ( ( wodt_off & 0x7 ) << 8 ) ) ; debug ( \"FSLDDR: timing_cfg_5 = 0x%08x\\n\" , ddr -> timing_cfg_5 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int c4iw_uld_control ( void * handle , enum cxgb4_control control , ... ) { struct uld_ctx * ctx = handle ; switch ( control ) { case CXGB4_CONTROL_DB_FULL : stop_queues ( ctx ) ; ctx -> dev -> rdev . stats . db_full ++ ; break ; case CXGB4_CONTROL_DB_EMPTY : resume_queues ( ctx , NULL ) ; mutex_lock ( & ctx -> dev -> rdev . stats . lock ) ; ctx -> dev -> rdev . stats . db_empty ++ ; mutex_unlock ( & ctx -> dev -> rdev . stats . lock ) ; break ; case CXGB4_CONTROL_DB_DROP : recover_queues ( ctx ) ; mutex_lock ( & ctx -> dev -> rdev . stats . lock ) ; ctx -> dev -> rdev . stats . db_drop ++ ; mutex_unlock ( & ctx -> dev -> rdev . stats . lock ) ; break ; default : pr_warn ( \"%s: unknown control cmd %u\\n\" , pci_name ( ctx -> lldi . pdev ) , control ) ; break ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long xics_rm_h_xirr ( struct kvm_vcpu * vcpu ) { union kvmppc_icp_state old_state , new_state ; struct kvmppc_xics * xics = vcpu -> kvm -> arch . xics ; struct kvmppc_icp * icp = vcpu -> arch . icp ; u32 xirr ; icp_rm_clr_vcpu_irq ( icp -> vcpu ) ; { old_state = new_state = READ_ONCE ( icp -> state ) ; xirr = old_state . xisr | ( ( ( u32 ) old_state . cppr ) << 24 ) ; if ( ! old_state . xisr ) { break ; } new_state . cppr = new_state . pending_pri ; new_state . pending_pri = 0xff ; new_state . xisr = 0 ; } ! icp_rm_try_update ( icp , old_state , new_state ) ; vcpu -> arch . gpr [ 4 ] = xirr ; return check_too_hard ( xics , icp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void octeon2_usb_clocks_start ( struct device * dev ) { u64 div ; union cvmx_uctlx_if_ena if_ena ; union cvmx_uctlx_clk_rst_ctl clk_rst_ctl ; union cvmx_uctlx_uphy_portx_ctl_status port_ctl_status ; int i ; unsigned long io_clk_64_to_ns ; u32 clock_rate = 12000000 ; bool is_crystal_clock = false ; mutex_lock ( & octeon2_usb_clocks_mutex ) ; octeon2_usb_clock_start_cnt ++ ; if ( octeon2_usb_clock_start_cnt != 1 ) { exit } io_clk_64_to_ns = 64000000000ull / octeon_get_io_clock_rate ( ) ; if ( dev -> of_node ) { struct device_node * uctl_node ; const char * clock_type ; uctl_node = of_get_parent ( dev -> of_node ) ; if ( ! uctl_node ) { dev_err ( dev , \"No UCTL device node\\n\" ) ; exit } i = of_property_read_u32 ( uctl_node , \"refclk-frequency\" , & clock_rate ) ; if ( i ) { dev_err ( dev , \"No UCTL \\\"refclk-frequency\\\"\\n\" ) ; of_node_put ( uctl_node ) ; exit } i = of_property_read_string ( uctl_node , \"refclk-type\" , & clock_type ) ; of_node_put ( uctl_node ) ; if ( ! i && strcmp ( \"crystal\" , clock_type ) == 0 ) { is_crystal_clock = true ; } } if_ena . u64 = 0 ; if_ena . s . en = 1 ; cvmx_write_csr ( CVMX_UCTLX_IF_ENA ( 0 ) , if_ena . u64 ) ; for ( i = 0 ; i <= 1 ; i ++ ) { port_ctl_status . u64 = cvmx_read_csr ( CVMX_UCTLX_UPHY_PORTX_CTL_STATUS ( i , 0 ) ) ; port_ctl_status . s . txvreftune = 15 ; port_ctl_status . s . txrisetune = 1 ; port_ctl_status . s . txpreemphasistune = 1 ; cvmx_write_csr ( CVMX_UCTLX_UPHY_PORTX_CTL_STATUS ( i , 0 ) , port_ctl_status . u64 ) ; } clk_rst_ctl . u64 = cvmx_read_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) ) ; if ( clk_rst_ctl . s . hrst ) { end_clock } clk_rst_ctl . s . hrst = 0 ; clk_rst_ctl . s . p_prst = 0 ; clk_rst_ctl . s . h_clkdiv_rst = 0 ; clk_rst_ctl . s . o_clkdiv_rst = 0 ; clk_rst_ctl . s . h_clkdiv_en = 0 ; clk_rst_ctl . s . o_clkdiv_en = 0 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; clk_rst_ctl . s . p_refclk_sel = is_crystal_clock ?0 : 1 ; switch ( clock_rate ) { default : pr_err ( \"Invalid UCTL clock rate of %u, using 12000000 instead\\n\" , clock_rate ) ; fallthrough ; case 12000000 : clk_rst_ctl . s . p_refclk_div = 0 ; break ; case 24000000 : clk_rst_ctl . s . p_refclk_div = 1 ; break ; case 48000000 : clk_rst_ctl . s . p_refclk_div = 2 ; break ; } cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; div = octeon_get_io_clock_rate ( ) / 130000000ull ; switch ( div ) { case 0 : div = 1 ; break ; case 1 : case 2 : case 3 : case 4 : break ; case 5 : div = 4 ; break ; case 6 : case 7 : div = 6 ; break ; case 8 : case 9 : case 10 : case 11 : div = 8 ; break ; default : div = 12 ; break ; } clk_rst_ctl . s . h_div = div ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; clk_rst_ctl . u64 = cvmx_read_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) ) ; clk_rst_ctl . s . h_clkdiv_en = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; clk_rst_ctl . s . h_clkdiv_rst = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; ndelay ( io_clk_64_to_ns ) ; clk_rst_ctl . s . p_por = 0 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; mdelay ( 3 ) ; clk_rst_ctl . s . o_clkdiv_rst = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; clk_rst_ctl . s . o_clkdiv_en = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; ndelay ( io_clk_64_to_ns ) ; clk_rst_ctl . s . p_prst = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; udelay ( 1 ) ; clk_rst_ctl . s . p_prst = 0 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; mdelay ( 1 ) ; clk_rst_ctl . s . p_prst = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; udelay ( 1 ) ; clk_rst_ctl . s . hrst = 1 ; cvmx_write_csr ( CVMX_UCTLX_CLK_RST_CTL ( 0 ) , clk_rst_ctl . u64 ) ; end_clock cvmx_write_csr ( CVMX_UCTLX_EHCI_FLA ( 0 ) , 0x20ull ) ; exit mutex_unlock ( & octeon2_usb_clocks_mutex ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nf_conntrack_cleanup_net_list ( struct list_head * net_exit_list ) { int busy ; struct net * net ; synchronize_net ( ) ; i_see_dead_people busy = 0 ; list_for_each_entry ( , , ) { nf_ct_iterate_cleanup ( net , kill_all , NULL , 0 , 0 ) ; if ( atomic_read ( & net -> ct . count ) != 0 ) { busy = 1 ; } } if ( busy ) { schedule ( ) ; i_see_dead_people } list_for_each_entry ( , , ) { nf_conntrack_proto_pernet_fini ( net ) ; nf_conntrack_helper_pernet_fini ( net ) ; nf_conntrack_ecache_pernet_fini ( net ) ; nf_conntrack_tstamp_pernet_fini ( net ) ; nf_conntrack_acct_pernet_fini ( net ) ; nf_conntrack_expect_pernet_fini ( net ) ; free_percpu ( net -> ct . stat ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int portable_extract ( const char * name_or_path , char * * matches , char * * extension_image_paths , PortableFlags flags , PortableMetadata * * ret_os_release , OrderedHashmap * * ret_extension_releases , Hashmap * * ret_unit_files , char * * * ret_valid_prefixes , sd_bus_error * error ) { _cleanup_ ( ) PortableMetadata * os_release = NULL ; _cleanup_ordered_hashmap_free_ OrderedHashmap * extension_images = NULL , * extension_releases = NULL ; _cleanup_hashmap_free_ Hashmap * unit_files = NULL ; _cleanup_ ( ) char * * valid_prefixes = NULL ; _cleanup_ ( ) Image * image = NULL ; int r ; assert ( name_or_path ) ; r = extract_image_and_extensions ( name_or_path , matches , extension_image_paths , false , FLAGS_SET ( flags , PORTABLE_FORCE_SYSEXT ) , & image , & extension_images , & extension_releases , & os_release , & unit_files , ret_valid_prefixes ?& valid_prefixes : NULL , error ) ; if ( r < 0 ) { return r ; } if ( hashmap_isempty ( unit_files ) ) { _cleanup_free_ char * extensions = strv_join ( extension_image_paths , \", \" ) ; return sd_bus_error_setf ( error , SD_BUS_ERROR_INVALID_ARGS , \"Couldn't find any matching unit files in image '%s%s%s', refusing.\" , image -> path , isempty ( extensions ) ?\"\" : \"' or any of its extensions '\" , isempty ( extensions ) ?\"\" : extensions ) ; } if ( ret_os_release ) { * ret_os_release = TAKE_PTR ( os_release ) ; } if ( ret_extension_releases ) { * ret_extension_releases = TAKE_PTR ( extension_releases ) ; } if ( ret_unit_files ) { * ret_unit_files = TAKE_PTR ( unit_files ) ; } if ( ret_valid_prefixes ) { * ret_valid_prefixes = TAKE_PTR ( valid_prefixes ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t ad7746_start_offset_calib ( struct device * dev , struct device_attribute * attr , const char * buf , size_t len ) { struct iio_dev * indio_dev = dev_to_iio_dev ( dev ) ; int ret = ad7746_select_channel ( indio_dev , & ad7746_channels [ to_iio_dev_attr ( attr ) -> address ] ) ; return ad7746_start_calib ( dev , attr , buf , len , FIELD_PREP ( AD7746_CONF_MODE_MASK , AD7746_CONF_MODE_OFFS_CAL ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s_ecc_cmp_hex_bn ( const char * left_hex , void * right_bn , void * tmp_bn ) { if ( mp_cmp ( tmp_bn , right_bn ) != LTC_MP_EQ ) { return 0 ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * filter_list ( const char * proposal , const char * filter , int denylist ) { size_t len = strlen ( proposal ) + 1 ; char * fix_prop = malloc ( len ) ; char * orig_prop = strdup ( proposal ) ; char * cp , * tmp ; int r ; if ( fix_prop == NULL || orig_prop == NULL ) { free ( orig_prop ) ; return NULL ; } tmp = orig_prop ; * fix_prop = '\\0' ; while ( ( cp = strsep ( & tmp , \",\" ) ) != NULL ) { r = match_pattern_list ( cp , filter , 0 ) ; if ( ( denylist && r != 1 ) || ( ! denylist && r == 1 ) ) { if ( * fix_prop != '\\0' ) { strlcat ( fix_prop , \",\" , len ) ; } strlcat ( fix_prop , cp , len ) ; } } free ( orig_prop ) ; return fix_prop ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct amdgpu_i2c_bus_rec amdgpu_atombios_lookup_i2c_gpio ( struct amdgpu_device * adev , uint8_t id ) { struct atom_context * ctx = adev -> mode_info . atom_context ; ATOM_GPIO_I2C_ASSIGMENT * gpio ; struct amdgpu_i2c_bus_rec i2c ; int index = GetIndexIntoMasterTable ( DATA , GPIO_I2C_Info ) ; struct _ATOM_GPIO_I2C_INFO * i2c_info ; uint16_t data_offset , size ; int i , num_indices ; i2c . valid = false ; if ( amdgpu_atom_parse_data_header ( ctx , index , & size , NULL , NULL , & data_offset ) ) { i2c_info = ( _ATOM_GPIO_I2C_INFO * ) ( ctx -> bios + data_offset ) ; num_indices = ( size - sizeof ( ATOM_COMMON_TABLE_HEADER ) ) / sizeof ( ATOM_GPIO_I2C_ASSIGMENT ) ; gpio = & i2c_info -> asGPIO_Info [ 0 ] ; for ( i = 0 ; i < num_indices ; i ++ ) { amdgpu_atombios_lookup_i2c_gpio_quirks ( adev , gpio , i ) ; if ( gpio -> sucI2cId . ucAccess == id ) { i2c = amdgpu_atombios_get_bus_rec_for_i2c_gpio ( gpio ) ; break ; } gpio = ( ATOM_GPIO_I2C_ASSIGMENT * ) ( ( u8 * ) gpio + sizeof ( ATOM_GPIO_I2C_ASSIGMENT ) ) ; } } return i2c ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sc_pkcs15emu_din_66291_init_ex ( sc_pkcs15_card_t * p15card , struct sc_aid * aid ) { int r = SC_ERROR_WRONG_CARD ; sc_path_t path ; unsigned char * tokeninfo_content = NULL ; struct sc_file * file_tokeninfo = NULL ; struct sc_pkcs15_tokeninfo * tokeninfo = NULL ; sc_serial_number_t serial ; SC_FUNC_CALLED ( p15card -> card -> ctx , 1 ) ; tokeninfo = sc_pkcs15_tokeninfo_new ( ) ; if ( ! p15card || ! tokeninfo || ( aid && ( aid -> len != sizeof aid_CIA || 0 != memcmp ( aid -> value , aid_CIA , sizeof aid_CIA ) ) ) ) { err } if ( ! p15card -> tokeninfo || ! p15card -> tokeninfo -> profile_indication . name || 0 != strcmp ( \"DIN V 66291\" , p15card -> tokeninfo -> profile_indication . name ) ) { sc_path_set ( & path , SC_PATH_TYPE_DF_NAME , aid_CIA , sizeof aid_CIA , 0 , 0 ) ; if ( SC_SUCCESS != sc_select_file ( p15card -> card , & path , NULL ) ) { err } sc_format_path ( \"5032\" , & path ) ; if ( SC_SUCCESS != sc_select_file ( p15card -> card , & path , & file_tokeninfo ) ) { err } tokeninfo_content = malloc ( file_tokeninfo -> size ) ; if ( ! tokeninfo_content ) { err } r = sc_read_binary ( p15card -> card , 0 , tokeninfo_content , file_tokeninfo -> size , 0 ) ; if ( r < 0 ) { err } r = sc_pkcs15_parse_tokeninfo ( p15card -> card -> ctx , tokeninfo , tokeninfo_content , r ) ; if ( r != SC_SUCCESS ) { err } if ( ! tokeninfo -> profile_indication . name || 0 != strcmp ( \"DIN V 66291\" , tokeninfo -> profile_indication . name ) ) { err } } if ( SC_SUCCESS != sc_pkcs15emu_din_66291_init ( p15card ) ) { err } sc_pkcs15_free_tokeninfo ( p15card -> tokeninfo ) ; sc_file_free ( p15card -> file_tokeninfo ) ; p15card -> tokeninfo = tokeninfo ; p15card -> file_tokeninfo = file_tokeninfo ; tokeninfo = NULL ; file_tokeninfo = NULL ; if ( ! p15card -> tokeninfo -> serial_number && SC_SUCCESS == sc_card_ctl ( p15card -> card , SC_CARDCTL_GET_SERIALNR , & serial ) ) { char serial_hex [ SC_MAX_SERIALNR * 2 + 2 ] ; sc_bin_to_hex ( serial . value , serial . len , serial_hex , sizeof serial_hex , 0 ) ; set_string ( & p15card -> tokeninfo -> serial_number , serial_hex ) ; } r = SC_SUCCESS ; err sc_pkcs15_free_tokeninfo ( tokeninfo ) ; sc_file_free ( file_tokeninfo ) ; free ( tokeninfo_content ) ; return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void add_led_refs ( led_dtls_t * dtls ) { int d , i , r ; int ledlen ; char ledstr [ MAXPATHLEN ] ; picl_nodehdl_t slot_node ; ledlen = strlen ( dtls -> disk_led_nodes ) ; ( void ) strlcpy ( ledstr , dtls -> disk_led_nodes , MAXPATHLEN ) ; for ( d = 0 ; d < dtls -> n_disks ; d ++ ) { picl_prophdl_t tbl_hdl ; picl_prophdl_t tbl_prop_hdl ; picl_nodehdl_t led_node_hdl ; picl_prophdl_t tbl_prop [ FCAL_DEVTABLE_NCOLS ] ; ptree_propinfo_t propinfo ; r = create_Device_table ( & tbl_hdl , & tbl_prop_hdl ) ; if ( r != PICL_SUCCESS ) { break ; } if ( find_disk_slot ( dtls , d , & slot_node ) != PICL_SUCCESS ) { break ; } for ( i = 0 ; i < FCAL_LED_CNT ; i ++ ) { ( void ) snprintf ( ledstr + ledlen , MAXPATHLEN - ledlen , \"%x\" , dtls -> led_addr [ i ] [ d ] ) ; r = ptree_get_node_by_path ( ledstr , & led_node_hdl ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_init_propinfo ( & propinfo , PTREE_PROPINFO_VERSION , PICL_PTYPE_CHARSTRING , PICL_READ | PICL_VOLATILE , MAX_LEN_LED_STATE , PICL_PROP_STATE , read_led_state , NULL ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_create_and_add_prop ( led_node_hdl , & propinfo , NULL , NULL ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_init_propinfo ( & propinfo , PTREE_PROPINFO_VERSION , PICL_PTYPE_CHARSTRING , PICL_READ , sizeof ( PICL_CLASS_LED ) , PICL_PROP_CLASS , NULL , NULL ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_create_prop ( & propinfo , PICL_CLASS_LED , & tbl_prop [ 0 ] ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_init_propinfo ( & propinfo , PTREE_PROPINFO_VERSION , PICL_PTYPE_REFERENCE , PICL_READ , sizeof ( picl_prophdl_t ) , FCAL_PICL_LED_REF , NULL , NULL ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_create_prop ( & propinfo , & led_node_hdl , & tbl_prop [ 1 ] ) ; if ( r != PICL_SUCCESS ) { break ; } r = ptree_add_row_to_table ( tbl_hdl , FCAL_DEVTABLE_NCOLS , tbl_prop ) ; if ( r != PICL_SUCCESS ) { break ; } } if ( r != PICL_SUCCESS ) { break ; } ( void ) ptree_add_prop ( slot_node , tbl_prop_hdl ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int regulator_haptic_resume ( struct device * dev ) { struct platform_device * pdev = to_platform_device ( dev ) ; struct regulator_haptic * haptic = platform_get_drvdata ( pdev ) ; unsigned int magnitude ; haptic -> suspended = false ; magnitude = READ_ONCE ( haptic -> magnitude ) ; if ( magnitude ) { regulator_haptic_set_voltage ( haptic , magnitude ) ; } mutex_unlock ( & haptic -> mutex ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int qmi_wwan_mac_addr ( struct net_device * dev , void * p ) { int ret ; struct sockaddr * addr = p ; ret = eth_prepare_mac_addr_change ( dev , p ) ; if ( possibly_iphdr ( addr -> sa_data ) ) { return - EADDRNOTAVAIL ; } eth_commit_mac_addr_change ( dev , p ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void PQtrace ( PGconn * conn , FILE * debug_port ) { if ( conn == NULL ) { return ; } PQuntrace ( conn ) ; conn -> Pfdebug = debug_port ; conn -> traceFlags = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ccp_sha_import ( struct ahash_request * req , const void * in ) { struct ccp_sha_req_ctx * rctx = ahash_request_ctx_dma ( req ) ; struct ccp_sha_exp_ctx state ; memcpy ( & state , in , sizeof ( state ) ) ; rctx -> type = state . type ; rctx -> msg_bits = state . msg_bits ; rctx -> first = state . first ; memcpy ( rctx -> ctx , state . ctx , sizeof ( rctx -> ctx ) ) ; rctx -> buf_count = state . buf_count ; memcpy ( rctx -> buf , state . buf , sizeof ( rctx -> buf ) ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pblk_write_ts ( void * data ) { struct pblk * pblk = data ; while ( ! kthread_should_stop ( ) ) { set_current_state ( TASK_INTERRUPTIBLE ) ; io_schedule ( ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void parse_test ( struct peer * peer , struct test_segment * t , int type ) { int parse_ret = 0 , nlri_ret = 0 ; struct attr attr = { } ; struct bgp_nlri nlri = { } ; struct bgp_attr_parser_args attr_args = { . peer = peer . length = t -> len . total = 1 . attr = & attr . type = type . flags = BGP_ATTR_FLAG_OPTIONAL . startp = BGP_INPUT_PNT ( peer ) } ; stream_reset ( peer -> curr ) ; stream_put ( peer -> curr , RANDOM_FUZZ ) ; stream_set_getp ( peer -> curr , RANDOM_FUZZ ) ; stream_write ( peer -> curr , t -> data , t -> len ) ; printf ( \"%s: %s\\n\" , t -> name , t -> desc ) ; switch ( type ) { case BGP_ATTR_MP_REACH_NLRI : parse_ret = bgp_mp_reach_parse ( & attr_args , & nlri ) ; break ; case BGP_ATTR_MP_UNREACH_NLRI : parse_ret = bgp_mp_unreach_parse ( & attr_args , & nlri ) ; break ; case BGP_ATTR_PREFIX_SID : parse_ret = bgp_attr_prefix_sid ( & attr_args ) ; break ; default : printf ( \"unknown type\" ) ; return ; } if ( ! parse_ret ) { iana_afi_t pkt_afi ; iana_safi_t pkt_safi ; if ( bgp_map_afi_safi_int2iana ( nlri . afi , nlri . safi , & pkt_afi , & pkt_safi ) ) { assert ( 0 ) ; } printf ( \"MP: %u(%u)/%u(%u): recv %u, nego %u\\n\" , nlri . afi , pkt_afi , nlri . safi , pkt_safi , peer -> afc_recv [ nlri . afi ] [ nlri . safi ] , peer -> afc_nego [ nlri . afi ] [ nlri . safi ] ) ; } if ( ! parse_ret ) { if ( type == BGP_ATTR_MP_REACH_NLRI ) { nlri_ret = bgp_nlri_parse ( peer , & attr , & nlri , 0 ) ; } if ( type == BGP_ATTR_MP_UNREACH_NLRI ) { nlri_ret = bgp_nlri_parse ( peer , & attr , & nlri , 1 ) ; } } handle_result ( peer , t , parse_ret , nlri_ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int aq_set_data_fl3l4 ( struct aq_nic_s * aq_nic , struct aq_rx_filter * aq_rx_fltr , struct aq_rx_filter_l3l4 * data , bool add ) { struct aq_hw_rx_fltrs_s * rx_fltrs = aq_get_hw_rx_fltrs ( aq_nic ) ; const struct ethtool_rx_flow_spec * fsp = & aq_rx_fltr -> aq_fsp ; data -> is_ipv6 = rx_fltrs -> fl3l4 . is_ipv6 ; data -> location = HW_ATL_GET_REG_LOCATION_FL3L4 ( fsp -> location ) ; if ( ! add ) { if ( ! data -> is_ipv6 ) { rx_fltrs -> fl3l4 . active_ipv4 &= ~ BIT ( data -> location ) ; } else { rx_fltrs -> fl3l4 . active_ipv6 &= ~ BIT ( ( data -> location ) / 4 ) ; } return 0 ; } data -> cmd |= HW_ATL_RX_ENABLE_FLTR_L3L4 ; switch ( fsp -> flow_type ) { case TCP_V4_FLOW : case TCP_V6_FLOW : data -> cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4 ; break ; case UDP_V4_FLOW : case UDP_V6_FLOW : data -> cmd |= HW_ATL_RX_UDP ; data -> cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4 ; break ; case SCTP_V4_FLOW : case SCTP_V6_FLOW : data -> cmd |= HW_ATL_RX_SCTP ; data -> cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4 ; break ; default : break ; } if ( ! data -> is_ipv6 ) { data -> ip_src [ 0 ] = ntohl ( fsp -> h_u . tcp_ip4_spec . ip4src ) ; data -> ip_dst [ 0 ] = ntohl ( fsp -> h_u . tcp_ip4_spec . ip4dst ) ; rx_fltrs -> fl3l4 . active_ipv4 |= BIT ( data -> location ) ; } else { int i ; rx_fltrs -> fl3l4 . active_ipv6 |= BIT ( ( data -> location ) / 4 ) ; for ( i = 0 ; i < HW_ATL_RX_CNT_REG_ADDR_IPV6 ; ++ i ) { data -> ip_dst [ i ] = ntohl ( fsp -> h_u . tcp_ip6_spec . ip6dst [ i ] ) ; data -> ip_src [ i ] = ntohl ( fsp -> h_u . tcp_ip6_spec . ip6src [ i ] ) ; } data -> cmd |= HW_ATL_RX_ENABLE_L3_IPV6 ; } if ( fsp -> flow_type != IP_USER_FLOW && fsp -> flow_type != IPV6_USER_FLOW ) { if ( ! data -> is_ipv6 ) { data -> p_dst = ntohs ( fsp -> h_u . tcp_ip4_spec . pdst ) ; data -> p_src = ntohs ( fsp -> h_u . tcp_ip4_spec . psrc ) ; } else { data -> p_dst = ntohs ( fsp -> h_u . tcp_ip6_spec . pdst ) ; data -> p_src = ntohs ( fsp -> h_u . tcp_ip6_spec . psrc ) ; } } if ( data -> ip_src [ 0 ] && ! data -> is_ipv6 ) { data -> cmd |= HW_ATL_RX_ENABLE_CMP_SRC_ADDR_L3 ; } if ( data -> ip_dst [ 0 ] && ! data -> is_ipv6 ) { data -> cmd |= HW_ATL_RX_ENABLE_CMP_DEST_ADDR_L3 ; } if ( data -> p_dst ) { data -> cmd |= HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4 ; } if ( data -> p_src ) { data -> cmd |= HW_ATL_RX_ENABLE_CMP_SRC_PORT_L4 ; } if ( fsp -> ring_cookie != RX_CLS_FLOW_DISC ) { data -> cmd |= HW_ATL_RX_HOST << HW_ATL_RX_ACTION_FL3F4_SHIFT ; data -> cmd |= fsp -> ring_cookie << HW_ATL_RX_QUEUE_FL3L4_SHIFT ; data -> cmd |= HW_ATL_RX_ENABLE_QUEUE_L3L4 ; } else { data -> cmd |= HW_ATL_RX_DISCARD << HW_ATL_RX_ACTION_FL3F4_SHIFT ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void dwc2_hcd_qh_free_ddma ( struct dwc2_hsotg * hsotg , struct dwc2_qh * qh ) { unsigned long flags ; dwc2_desc_list_free ( hsotg , qh ) ; spin_lock_irqsave ( & hsotg -> lock , flags ) ; if ( qh -> channel ) { dwc2_release_channel_ddma ( hsotg , qh ) ; } spin_unlock_irqrestore ( & hsotg -> lock , flags ) ; if ( ( qh -> ep_type == USB_ENDPOINT_XFER_ISOC || qh -> ep_type == USB_ENDPOINT_XFER_INT ) && ( hsotg -> params . uframe_sched || ! hsotg -> periodic_channels ) && hsotg -> frame_list ) { dwc2_per_sched_disable ( hsotg ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int max8660_dcdc_set_voltage_sel ( struct regulator_dev * rdev , unsigned int selector ) { struct max8660 * max8660 = rdev_get_drvdata ( rdev ) ; u8 reg , bits ; int ret ; reg = ( rdev_get_id ( rdev ) == MAX8660_V3 ) ?MAX8660_ADTV2 : MAX8660_SDTV2 ; ret = max8660_write ( max8660 , reg , 0 , selector ) ; bits = ( rdev_get_id ( rdev ) == MAX8660_V3 ) ?0x03 : 0x30 ; return max8660_write ( max8660 , MAX8660_VCC1 , 0xff , bits ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nv_abort_active ( nv_port_t * nvp , sata_pkt_t * spkt , int abort_reason , boolean_t reset ) { int aborted = 0 , i , reset_once = B_FALSE ; struct nv_slot * nv_slotp ; sata_pkt_t * spkt_slot ; ASSERT ( MUTEX_HELD ( & nvp -> nvp_mutex ) ) ; NVLOG ( NVDBG_ENTRY , nvp -> nvp_ctlp , nvp , \"nv_abort_active\" , NULL ) ; nvp -> nvp_state |= NV_ABORTING ; for ( i = 0 ; i < nvp -> nvp_queue_depth ; i ++ ) { nv_slotp = & ( nvp -> nvp_slot [ i ] ) ; spkt_slot = nv_slotp -> nvslot_spkt ; if ( ( spkt != NULL ) && ( spkt != spkt_slot ) ) { continue ; } if ( reset_once == B_FALSE ) { ddi_acc_handle_t bmhdl = nvp -> nvp_bm_hdl ; nv_put8 ( bmhdl , nvp -> nvp_bmicx , 0 ) ; if ( reset == B_TRUE ) { reset_once = B_TRUE ; nv_reset ( nvp , \"abort_active\" ) ; } } spkt_slot -> satapkt_reason = abort_reason ; nv_complete_io ( nvp , spkt_slot , i ) ; aborted ++ ; } nvp -> nvp_state &= ~ NV_ABORTING ; return ( aborted ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool on_option ( char key , char * value ) { bool result = true ; switch ( key ) { case 'L' : ctx . policy_digest_file_path = value ; break ; case 'S' : ctx . session_file_path = value ; break ; case 0 : result = process_input_template_hash ( value , NULL ) ; break ; } return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ds_scsi_close ( void * arg ) { ds_scsi_info_t * sip = arg ; if ( sip -> si_sim ) { ( void ) dlclose ( sip -> si_sim ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { krb5_error_code ret ; setprogname ( argv [ 0 ] ) ; ret = krb5_init_context ( & kcm_context ) ; if ( ret ) { errx ( 1 , \"krb5_init_context failed: %d\" , ret ) ; return ret ; } kcm_configure ( argc , argv ) ; { struct sigaction sa ; sa . sa_flags = 0 ; sa . sa_handler = sigusr1 ; sigemptyset ( & sa . sa_mask ) ; sigaction ( SIGUSR1 , & sa , NULL ) ; sa . sa_handler = sigusr2 ; sigaction ( SIGUSR2 , & sa , NULL ) ; sa . sa_handler = SIG_IGN ; sigaction ( SIGPIPE , & sa , NULL ) ; } signal ( SIGUSR1 , sigusr1 ) ; signal ( SIGUSR2 , sigusr2 ) ; signal ( SIGPIPE , SIG_IGN ) ; if ( detach_from_console && ! launchd_flag && daemon_child == - 1 ) { daemon_child = roken_detach_prep ( argc , argv , \"--daemon-child\" ) ; } rk_pidfile ( NULL ) ; if ( socket_path ) { setenv ( \"HEIM_IPC_DIR\" , socket_path , 1 ) ; } if ( launchd_flag ) { heim_sipc mach ; ret = heim_sipc_launchd_mach_init ( service_name , kcm_service , NULL , & mach ) ; if ( ret ) { krb5_err ( kcm_context , 1 , ret , \"Could not setup launchd service\" ) ; } } else { heim_sipc un ; ret = heim_sipc_service_unix ( service_name , kcm_service , NULL , & un ) ; if ( ret ) { krb5_err ( kcm_context , 1 , ret , \"Could not setup Unix domain socket service\" ) ; } } { heim_sipc door ; ret = heim_sipc_service_door ( service_name , kcm_service , NULL , & door ) ; if ( ret ) { krb5_err ( kcm_context , 1 , ret , \"Could not setup door service\" ) ; } } roken_detach_finish ( NULL , daemon_child ) ; heim_ipc_main ( ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void hisi_ptt_free ( struct perf_session * session ) { struct hisi_ptt * ptt = container_of ( session -> auxtrace , hisi_ptt , auxtrace ) ; session -> auxtrace = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ks0127_probe ( struct i2c_client * client , const struct i2c_device_id * id ) { struct ks0127 * ks ; struct v4l2_subdev * sd ; v4l_info ( client , \"%s chip found @ 0x%x (%s)\\n\" , client -> addr == ( I2C_KS0127_ADDON >> 1 ) ?\"addon\" : \"on-board\" , client -> addr << 1 , client -> adapter -> name ) ; ks = devm_kzalloc ( & client -> dev , sizeof ( * ks ) , GFP_KERNEL ) ; sd = & ks -> sd ; v4l2_i2c_subdev_init ( sd , client , & ks0127_ops ) ; init_reg_defaults ( ) ; ks0127_write ( sd , KS_CMDA , 0x2c ) ; mdelay ( 10 ) ; ks0127_init ( sd ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ssize_t tls13_phh_received_cb ( void * cb_arg ) { ssize_t ret = TLS13_IO_FAILURE ; struct tls13_ctx * ctx = cb_arg ; CBS cbs ; if ( ( ctx -> hs_msg == NULL ) && ( ( ctx -> hs_msg = tls13_handshake_msg_new ( ) ) == NULL ) ) { return TLS13_IO_FAILURE ; } if ( ( ret = tls13_handshake_msg_recv ( ctx -> hs_msg , ctx -> rl ) ) != TLS13_IO_SUCCESS ) { return ret ; } if ( ! tls13_handshake_msg_content ( ctx -> hs_msg , & cbs ) ) { return TLS13_IO_FAILURE ; } switch ( tls13_handshake_msg_type ( ctx -> hs_msg ) ) { case TLS13_MT_KEY_UPDATE : ret = tls13_key_update_recv ( ctx , & cbs ) ; break ; case TLS13_MT_NEW_SESSION_TICKET : ret = tls13_new_session_ticket_recv ( ctx , & cbs ) ; break ; case TLS13_MT_CERTIFICATE_REQUEST : default : ret = TLS13_IO_FAILURE ; break ; } tls13_handshake_msg_free ( ctx -> hs_msg ) ; ctx -> hs_msg = NULL ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ns_parse_badblocks ( struct nandsim * ns , struct mtd_info * mtd ) { char * w ; int zero_ok ; unsigned int erase_block_no ; loff_t offset ; w = badblocks ; { zero_ok = ( * w == '0' ?1 : 0 ) ; erase_block_no = simple_strtoul ( w , & w , 0 ) ; if ( ! zero_ok && ! erase_block_no ) { NS_ERR ( \"invalid badblocks.\\n\" ) ; return - EINVAL ; } offset = ( loff_t ) erase_block_no * ns -> geom . secsz ; if ( mtd_block_markbad ( mtd , offset ) ) { NS_ERR ( \"invalid badblocks.\\n\" ) ; return - EINVAL ; } if ( * w == ',' ) { w += 1 ; } } * w ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _post_res_list ( List res_list ) { if ( res_list && ! slurmdbd_conf ) { slurmdb_res_rec_t * object = NULL ; ListIterator itr = list_iterator_create ( res_list ) ; while ( ( object = list_next ( itr ) ) ) { if ( object -> clus_res_list && list_count ( object -> clus_res_list ) ) { xassert ( ! object -> clus_res_rec ) ; while ( ( object -> clus_res_rec = list_pop ( object -> clus_res_list ) ) ) { if ( ! xstrcasecmp ( object -> clus_res_rec -> cluster , slurm_conf . cluster_name ) ) { break ; } slurmdb_destroy_clus_res_rec ( object -> clus_res_rec ) ; } FREE_NULL_LIST ( object -> clus_res_list ) ; } if ( ! object -> clus_res_rec ) { error ( \"Bad resource given %s@%s\" , object -> name , object -> server ) ; list_delete_item ( itr , NULL ) ; } } list_iterator_destroy ( itr ) ; } if ( init_setup . sync_license_notify ) { init_setup . sync_license_notify ( res_list ) ; } return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int irdma_puda_cq_create ( struct irdma_puda_rsrc * rsrc ) { struct irdma_sc_dev * dev = rsrc -> dev ; struct irdma_sc_cq * cq = & rsrc -> cq ; int ret = 0 ; u32 cqsize ; struct irdma_dma_mem * mem ; struct irdma_cq_init_info info = { } ; struct irdma_cq_uk_init_info * init_info = & info . cq_uk_init_info ; cq -> vsi = rsrc -> vsi ; cqsize = rsrc -> cq_size * ( sizeof ( irdma_cqe ) ) ; rsrc -> cqmem . size = ALIGN ( cqsize + sizeof ( irdma_cq_shadow_area ) , IRDMA_CQ0_ALIGNMENT ) ; rsrc -> cqmem . va = dma_alloc_coherent ( dev -> hw -> device , rsrc -> cqmem . size , & rsrc -> cqmem . pa , GFP_KERNEL ) ; mem = & rsrc -> cqmem ; info . dev = dev ; info . type = ( rsrc -> type == IRDMA_PUDA_RSRC_TYPE_ILQ ) ?IRDMA_CQ_TYPE_ILQ : IRDMA_CQ_TYPE_IEQ ; info . shadow_read_threshold = rsrc -> cq_size >> 2 ; info . cq_base_pa = mem -> pa ; info . shadow_area_pa = mem -> pa + cqsize ; init_info -> cq_base = mem -> va ; init_info -> shadow_area = ( __le64 * ) ( ( u8 * ) mem -> va + cqsize ) ; init_info -> cq_size = rsrc -> cq_size ; init_info -> cq_id = rsrc -> cq_id ; info . ceqe_mask = true ; info . ceq_id_valid = true ; info . vsi = rsrc -> vsi ; ret = irdma_sc_cq_init ( cq , & info ) ; if ( ret ) { error } if ( rsrc -> dev -> ceq_valid ) { ret = irdma_cqp_cq_create_cmd ( dev , cq ) ; } else { ret = irdma_puda_cq_wqe ( dev , cq ) ; } error if ( ret ) { dma_free_coherent ( dev -> hw -> device , rsrc -> cqmem . size , rsrc -> cqmem . va , rsrc -> cqmem . pa ) ; rsrc -> cqmem . va = NULL ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void * reloc_kmap ( struct drm_i915_gem_object * obj , struct reloc_cache * cache , int page ) { void * vaddr ; if ( cache -> vaddr ) { kunmap_atomic ( unmask_page ( cache -> vaddr ) ) ; } else { unsigned int flushes ; int ret ; ret = i915_gem_obj_prepare_shmem_write ( obj , & flushes ) ; BUILD_BUG_ON ( KMAP & CLFLUSH_FLAGS ) ; BUILD_BUG_ON ( ( KMAP | CLFLUSH_FLAGS ) & PAGE_MASK ) ; cache -> vaddr = flushes | KMAP ; cache -> node . mm = ( void * ) obj ; if ( flushes ) { mb ( ) ; } } vaddr = kmap_atomic ( i915_gem_object_get_dirty_page ( obj , page ) ) ; cache -> vaddr = unmask_flags ( cache -> vaddr ) | ( unsigned long ) vaddr ; cache -> page = page ; return vaddr ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sun50i_cpufreq_get_efuse ( u32 * versions ) { struct nvmem_cell * speedbin_nvmem ; struct device_node * np ; struct device * cpu_dev ; u32 * speedbin , efuse_value ; size_t len ; int ret ; cpu_dev = get_cpu_device ( 0 ) ; if ( ! cpu_dev ) { return - ENODEV ; } np = dev_pm_opp_of_get_opp_desc_node ( cpu_dev ) ; if ( ! np ) { return - ENOENT ; } ret = of_device_is_compatible ( np , \"allwinner,sun50i-h6-operating-points\" ) ; if ( ! ret ) { of_node_put ( np ) ; return - ENOENT ; } speedbin_nvmem = of_nvmem_cell_get ( np , NULL ) ; of_node_put ( np ) ; if ( IS_ERR ( speedbin_nvmem ) ) { return dev_err_probe ( cpu_dev , PTR_ERR ( speedbin_nvmem ) , \"Could not get nvmem cell\\n\" ) ; } speedbin = nvmem_cell_read ( speedbin_nvmem , & len ) ; nvmem_cell_put ( speedbin_nvmem ) ; if ( IS_ERR ( speedbin ) ) { return PTR_ERR ( speedbin ) ; } efuse_value = ( * speedbin >> NVMEM_SHIFT ) & NVMEM_MASK ; if ( efuse_value >= 1 && efuse_value <= 3 ) { * versions = efuse_value - 1 ; } else { * versions = 0 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sdioctl ( dev_t dev , u_long cmd , caddr_t addr , int flag , struct proc * p ) { struct scsi_link * link ; struct sd_softc * sc ; struct disklabel * lp ; int error = 0 ; int part = DISKPART ( dev ) ; sc = sdlookup ( DISKUNIT ( dev ) ) ; if ( ISSET ( sc -> flags , SDF_DYING ) ) { device_unref ( & sc -> sc_dev ) ; return ENXIO ; } link = sc -> sc_link ; SC_DEBUG ( link , SDEV_DB2 , ( \"sdioctl 0x%lx\\n\" , cmd ) ) ; if ( ! ISSET ( link -> flags , SDEV_MEDIA_LOADED ) ) { switch ( cmd ) { case DIOCLOCK : case DIOCEJECT : case SCIOCIDENTIFY : case SCIOCCOMMAND : case SCIOCDEBUG : if ( part == RAW_PART ) { break ; } default : if ( ! ISSET ( link -> flags , SDEV_OPEN ) ) { error = ENODEV ; exit } else { error = EIO ; exit } } } switch ( cmd ) { case DIOCRLDINFO : lp = malloc ( sizeof ( * lp ) , M_TEMP , M_WAITOK ) ; sdgetdisklabel ( dev , sc , lp , 0 ) ; memcpy ( sc -> sc_dk . dk_label , lp , sizeof ( * lp ) ) ; free ( lp , M_TEMP , sizeof ( * lp ) ) ; exit case DIOCGPDINFO : sdgetdisklabel ( dev , sc , ( disklabel * ) addr , 1 ) ; exit case DIOCGDINFO : * ( disklabel * ) addr = * ( sc -> sc_dk . dk_label ) ; exit case DIOCGPART : ( ( partinfo * ) addr ) -> disklab = sc -> sc_dk . dk_label ; ( ( partinfo * ) addr ) -> part = & sc -> sc_dk . dk_label -> d_partitions [ DISKPART ( dev ) ] ; exit case DIOCWDINFO : case DIOCSDINFO : if ( ! ISSET ( flag , FWRITE ) ) { error = EBADF ; exit } if ( ( error = disk_lock ( & sc -> sc_dk ) ) != 0 ) { exit } error = setdisklabel ( sc -> sc_dk . dk_label , ( disklabel * ) addr , sc -> sc_dk . dk_openmask ) ; if ( error == 0 ) { if ( cmd == DIOCWDINFO ) { error = writedisklabel ( DISKLABELDEV ( dev ) , sdstrategy , sc -> sc_dk . dk_label ) ; } } disk_unlock ( & sc -> sc_dk ) ; exit case DIOCLOCK : error = scsi_prevent ( link , ( * ( int * ) addr ) ?PR_PREVENT : PR_ALLOW , 0 ) ; exit case MTIOCTOP : if ( ( ( mtop * ) addr ) -> mt_op != MTOFFL ) { error = EIO ; exit } case DIOCEJECT : if ( ! ISSET ( link -> flags , SDEV_REMOVABLE ) ) { error = ENOTTY ; exit } SET ( link -> flags , SDEV_EJECTING ) ; exit case DIOCINQ : error = scsi_do_ioctl ( link , cmd , addr , flag ) ; if ( error == ENOTTY ) { error = sd_ioctl_inquiry ( sc , ( dk_inquiry * ) addr ) ; } exit case DIOCSCACHE : if ( ! ISSET ( flag , FWRITE ) ) { error = EBADF ; exit } case DIOCGCACHE : error = sd_ioctl_cache ( sc , cmd , ( dk_cache * ) addr ) ; exit case DIOCCACHESYNC : if ( ! ISSET ( flag , FWRITE ) ) { error = EBADF ; exit } if ( ISSET ( sc -> flags , SDF_DIRTY ) || * ( int * ) addr != 0 ) { error = sd_flush ( sc , 0 ) ; } exit default : if ( part != RAW_PART ) { error = ENOTTY ; exit } error = scsi_do_ioctl ( link , cmd , addr , flag ) ; } exit device_unref ( & sc -> sc_dev ) ; return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int logsetup ( caddr_t devstr ) { void * buf ; extent_block_t * ebp ; ml_unit_t * ul ; ml_odunit_t * ud ; void * ud_buf ; int badlog ; islog = islogok = 0 ; if ( bflag != 0 ) { return ( 1 ) ; } sblock . fs_logbno = 0 ; badlog = 0 ; if ( ! read_super_block ( 0 ) ) { return ( 1 ) ; } if ( sblock . fs_logbno && ( ( ( mount_point == NULL ) && ( sblock . fs_rolled != FS_ALL_ROLLED ) ) || ( ( mount_point != NULL ) && ! mflag ) ) ) { int roll_log_err = 0 ; if ( sblock . fs_ronly && ( sblock . fs_clean == FSSTABLE ) && ( sblock . fs_state + sblock . fs_time == FSOKAY ) ) { flush_fs ( ) ; } if ( sblock . fs_clean == FSLOG && ( sblock . fs_state + sblock . fs_time == FSOKAY ) ) { if ( rl_roll_log ( devstr ) != RL_SUCCESS ) { roll_log_err = 1 ; } } if ( roll_log_err ) { ( void ) printf ( \"Can't roll the log for %s.\\n\" , devstr ) ; if ( preen || ( ! hotroot && reply ( \"DISCARDING THE LOG MAY DISCARD PENDING TRANSACTIONS.\\n\" \"DISCARD THE LOG AND CONTINUE\" ) == 0 ) ) { exitstat = EXERRFATAL ; return ( 0 ) ; } ++ badlog ; } } if ( sblock . fs_logbno ) { ++ islog ; if ( FSOKAY != ( sblock . fs_state + sblock . fs_time ) ) { return ( 1 ) ; } if ( ! ( ( sblock . fs_clean == FSLOG ) || ( sblock . fs_clean == FSSTABLE ) && ( mount_point != NULL ) ) ) { return ( 1 ) ; } buf = malloc ( dev_bsize ) ; if ( buf == NULL ) { return ( 1 ) ; } ud_buf = malloc ( dev_bsize ) ; if ( ud_buf == NULL ) { return ( 1 ) ; } ( void ) fsck_bread ( fsreadfd , buf , logbtodb ( & sblock , sblock . fs_logbno ) , dev_bsize ) ; ebp = ( extent_block_t * ) buf ; if ( ebp -> type != LUFS_EXTENTS ) { free ( buf ) ; free ( ud_buf ) ; return ( 1 ) ; } if ( fsck_bread ( fsreadfd , ud_buf , ( logbtodb ( & sblock , ebp -> extents [ 0 ] . pbno ) ) , dev_bsize ) ) { ( void ) fsck_bread ( fsreadfd , ud_buf , ( logbtodb ( & sblock , ebp -> extents [ 0 ] . pbno ) ) + 1 , dev_bsize ) ; } ud = ( ml_odunit_t * ) ud_buf ; ul = ( ml_unit_t * ) malloc ( sizeof ( * ul ) ) ; if ( ul == NULL ) { free ( buf ) ; free ( ud_buf ) ; return ( 1 ) ; } ul -> un_ondisk = * ud ; if ( ( ul -> un_chksum == ul -> un_head_ident + ul -> un_tail_ident ) && ( ul -> un_version == LUFS_VERSION_LATEST ) && ( ul -> un_badlog == 0 ) && ( ! badlog ) ) { ++ islogok ; } free ( ud_buf ) ; free ( buf ) ; free ( ul ) ; } return ( 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int rio_request_inb_mbox ( struct rio_mport * mport , void * dev_id , int mbox , int entries , void * minb ( struct rio_mport * mport , void * dev_id , int mbox , int slot ) ) { int rc = - ENOSYS ; struct resource * res ; if ( ! mport -> ops -> open_inb_mbox ) { out } res = kzalloc ( sizeof ( * res ) , GFP_KERNEL ) ; if ( res ) { rio_init_mbox_res ( res , mbox , mbox ) ; rc = request_resource ( & mport -> riores [ RIO_INB_MBOX_RESOURCE ] , res ) ; if ( rc < 0 ) { out } mport -> inb_msg [ mbox ] . res = res ; mport -> inb_msg [ mbox ] . mcback = minb ; rc = mport -> ops -> open_inb_mbox ( mport , dev_id , mbox , entries ) ; if ( rc ) { mport -> inb_msg [ mbox ] . mcback = NULL ; mport -> inb_msg [ mbox ] . res = NULL ; release_resource ( res ) ; kfree ( res ) ; } } else { rc = - ENOMEM ; } out return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void UI_DisplayOptionsMenu_Event ( void * ptr , int event ) { switch ( ( ( menucommon_s * ) ptr ) -> id ) { case ID_GRAPHICS : UI_PopMenu ( ) ; UI_GraphicsOptionsMenu ( ) ; break ; case ID_DISPLAY : break ; case ID_SOUND : UI_PopMenu ( ) ; UI_SoundOptionsMenu ( ) ; break ; case ID_NETWORK : UI_PopMenu ( ) ; UI_NetworkOptionsMenu ( ) ; break ; case ID_BRIGHTNESS : trap_Cvar_SetValue ( \"r_gamma\" , displayOptionsInfo . brightness . curvalue / 10.0f ) ; break ; case ID_SCREENSIZE : trap_Cvar_SetValue ( \"cg_viewsize\" , displayOptionsInfo . screensize . curvalue * 10 ) ; break ; case ID_BACK : UI_PopMenu ( ) ; break ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void scsa2usb_cbi_reset_recovery ( scsa2usb_state_t * scsa2usbp ) { int i , rval ; mblk_t * cdb ; usb_cr_t completion_reason ; usb_cb_flags_t cb_flags ; USB_DPRINTF_L4 ( DPRINT_MASK_SCSA , scsa2usbp -> scsa2usb_log_handle , \"scsa2usb_cbi_reset_recovery: (0x%p)\" , ( void * ) scsa2usbp ) ; ASSERT ( mutex_owned ( & scsa2usbp -> scsa2usb_mutex ) ) ; if ( scsa2usbp -> scsa2usb_cur_pkt ) { scsa2usbp -> scsa2usb_cur_pkt -> pkt_statistics |= STAT_DEV_RESET ; } cdb = allocb_wait ( CBI_CLASS_CMD_LEN , BPRI_LO , STR_NOSIG , NULL ) ; * cdb -> b_wptr ++ = SCMD_SDIAG ; * cdb -> b_wptr ++ = CBI_SELF_TEST ; for ( i = 2 ; i < CBI_CLASS_CMD_LEN ; i ++ ) { * cdb -> b_wptr ++ = CBI_CBR_VALUE ; } scsa2usbp -> scsa2usb_pipe_state = SCSA2USB_PIPE_DEV_RESET ; mutex_exit ( & scsa2usbp -> scsa2usb_mutex ) ; rval = usb_pipe_sync_ctrl_xfer ( scsa2usbp -> scsa2usb_dip , scsa2usbp -> scsa2usb_default_pipe , CBI_REQUEST_TYPE , 0 , CBI_WVALUE , scsa2usbp -> scsa2usb_intfc_num , CBI_CLASS_CMD_LEN , & cdb , 0 , & completion_reason , & cb_flags , 0 ) ; mutex_enter ( & scsa2usbp -> scsa2usb_mutex ) ; USB_DPRINTF_L3 ( DPRINT_MASK_SCSA , scsa2usbp -> scsa2usb_log_handle , \"\\tCBI RESET: rval = %x cr = %x\" , rval , completion_reason ) ; if ( rval != USB_SUCCESS ) { exc_exit } rval = scsa2usb_clear_ept_stall ( scsa2usbp , scsa2usbp -> scsa2usb_bulkin_ept . bEndpointAddress , scsa2usbp -> scsa2usb_bulkin_pipe , \"bulk-in\" ) ; USB_DPRINTF_L3 ( DPRINT_MASK_SCSA , scsa2usbp -> scsa2usb_log_handle , \"\\tclear stall on bulk-in pipe: %d\" , rval ) ; if ( rval != USB_SUCCESS ) { exc_exit } rval = scsa2usb_clear_ept_stall ( scsa2usbp , scsa2usbp -> scsa2usb_bulkout_ept . bEndpointAddress , scsa2usbp -> scsa2usb_bulkout_pipe , \"bulk-out\" ) ; USB_DPRINTF_L3 ( DPRINT_MASK_SCSA , scsa2usbp -> scsa2usb_log_handle , \"\\tclear stall on bulk-out pipe: %d\" , rval ) ; if ( rval != USB_SUCCESS ) { exc_exit } if ( SCSA2USB_IS_CBI ( scsa2usbp ) ) { rval = scsa2usb_clear_ept_stall ( scsa2usbp , scsa2usbp -> scsa2usb_intr_ept . bEndpointAddress , scsa2usbp -> scsa2usb_intr_pipe , \"intr\" ) ; USB_DPRINTF_L3 ( DPRINT_MASK_SCSA , scsa2usbp -> scsa2usb_log_handle , \"\\tclear stall on intr pipe:  %d\" , rval ) ; } exc_exit SCSA2USB_FREE_MSG ( cdb ) ; scsa2usbp -> scsa2usb_pipe_state &= ~ SCSA2USB_PIPE_DEV_RESET ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void nvidia_smmu_tlb_sync ( struct arm_smmu_device * smmu , int page , int sync , int status ) { struct nvidia_smmu * nvidia = to_nvidia_smmu ( smmu ) ; unsigned int delay ; arm_smmu_writel ( smmu , page , sync , 0 ) ; for ( delay = 1 ; delay < TLB_LOOP_TIMEOUT ; delay *= 2 ) { unsigned int spin_cnt ; for ( spin_cnt = TLB_SPIN_COUNT ; spin_cnt > 0 ; spin_cnt -- ) { u32 val = 0 ; unsigned int i ; for ( i = 0 ; i < nvidia -> num_instances ; i ++ ) { void __iomem * reg ; reg = nvidia_smmu_page ( smmu , i , page ) + status ; val |= readl_relaxed ( reg ) ; } cpu_relax ( ) ; } udelay ( delay ) ; } dev_err_ratelimited ( smmu -> dev , \"TLB sync timed out -- SMMU may be deadlocked\\n\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cros_ec_get_sensor_count ( struct cros_ec_dev * ec ) { int ret , sensor_count ; struct ec_params_motion_sense * params ; struct ec_response_motion_sense * resp ; struct cros_ec_command * msg ; struct cros_ec_device * ec_dev = ec -> ec_dev ; u8 status ; msg = kzalloc ( sizeof ( * msg ) + max ( sizeof ( * params ) , sizeof ( * resp ) ) , GFP_KERNEL ) ; if ( ! msg ) { return - ENOMEM ; } msg -> version = 1 ; msg -> command = EC_CMD_MOTION_SENSE_CMD + ec -> cmd_offset ; msg -> outsize = sizeof ( * params ) ; msg -> insize = sizeof ( * resp ) ; params = ( ec_params_motion_sense * ) msg -> data ; params -> cmd = MOTIONSENSE_CMD_DUMP ; ret = cros_ec_cmd_xfer_status ( ec -> ec_dev , msg ) ; if ( ret < 0 ) { sensor_count = ret ; } else { resp = ( ec_response_motion_sense * ) msg -> data ; sensor_count = resp -> dump . sensor_count ; } if ( sensor_count < 0 && ec -> cmd_offset == 0 && ec_dev -> cmd_readmem ) { ret = ec_dev -> cmd_readmem ( ec_dev , EC_MEMMAP_ACC_STATUS , 1 , & status ) ; if ( ret >= 0 && ( status & EC_MEMMAP_ACC_STATUS_PRESENCE_BIT ) ) { sensor_count = 2 ; } else { sensor_count = 0 ; } } return sensor_count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void h_free ( char * hex ) { if ( hex == NULL ) { return ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool add_retire ( struct intel_engine_cs * engine , struct intel_timeline * tl ) { struct intel_timeline * first ; intel_timeline_get ( tl ) ; first = READ_ONCE ( engine -> retire ) ; { tl -> retire = ptr_pack_bits ( first , 1 , 1 ) ; } ! try_cmpxchg ( & engine -> retire , & first , tl ) ; return ! first ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dma_txenq ( struct dma_info * di , struct sk_buff * p ) { unsigned char * data ; uint len ; u16 txout ; u32 flags = 0 ; dma_addr_t pa ; txout = di -> txout ; if ( WARN_ON ( nexttxd ( di , txout ) == di -> txin ) ) { return ; } data = p -> data ; len = p -> len ; pa = dma_map_single ( di -> dmadev , data , len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( di -> dmadev , pa ) ) { return ; } flags = D64_CTRL1_SOF | D64_CTRL1_IOC | D64_CTRL1_EOF ; if ( txout == ( di -> ntxd - 1 ) ) { flags |= D64_CTRL1_EOT ; } dma64_dd_upd ( di , di -> txd64 , pa , txout , & flags , len ) ; txout = nexttxd ( di , txout ) ; di -> txp [ prevtxd ( di , txout ) ] = p ; di -> txout = txout ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void context_detach_window ( MMapCache * m , Context * c ) { Window * w ; assert ( m ) ; assert ( c ) ; w = TAKE_PTR ( c -> window ) ; LIST_REMOVE ( by_window , w -> contexts , c ) ; if ( ! w -> contexts && ! w -> keep_always ) { window_free ( w ) ; LIST_PREPEND ( unused , m -> unused , w ) ; if ( ! m -> last_unused ) { m -> last_unused = w ; } w -> in_unused = true ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "const struct fb_videomode * fb_find_best_display ( const struct fb_monspecs * specs , struct list_head * head ) { struct list_head * pos ; struct fb_modelist * modelist ; const struct fb_videomode * m , * m1 = NULL , * md = NULL , * best = NULL ; int first = 0 ; if ( ! head -> prev || ! head -> next || list_empty ( head ) ) { finished } list_for_each ( , ) { modelist = list_entry ( pos , fb_modelist , list ) ; m = & modelist -> mode ; if ( ! first ) { m1 = m ; first = 1 ; } if ( m -> flag & FB_MODE_IS_FIRST ) { md = m ; break ; } } if ( specs -> misc & FB_MISC_1ST_DETAIL ) { best = md ; finished } if ( specs -> max_x && specs -> max_y ) { struct fb_var_screeninfo var ; var . xres = ( specs -> max_x * 7200 ) / 254 ; var . yres = ( specs -> max_y * 7200 ) / 254 ; m = fb_find_best_mode ( & var , head ) ; if ( m ) { best = m ; finished } } if ( md ) { best = md ; finished } best = m1 ; finished return best ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ENIPExtractUint8 ( uint8_t * res , const uint8_t * input , uint16_t * offset , uint32_t input_len ) { if ( input_len < sizeof ( uint8_t ) || * offset > ( input_len - sizeof ( uint8_t ) ) ) { return 0 ; } * res = * ( input + * offset ) ; * offset += sizeof ( uint8_t ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pcc_cpufreq_cpu_init ( struct cpufreq_policy * policy ) { unsigned int cpu = policy -> cpu ; int result = 0 ; if ( ! pcch_virt_addr ) { result = - 1 ; out } result = pcc_get_offset ( cpu ) ; if ( result ) { pr_debug ( \"init: PCCP evaluation failed\\n\" ) ; out } policy -> max = policy -> cpuinfo . max_freq = ioread32 ( & pcch_hdr -> nominal ) * 1000 ; policy -> min = policy -> cpuinfo . min_freq = ioread32 ( & pcch_hdr -> minimum_frequency ) * 1000 ; pr_debug ( \"init: policy->max is %d, policy->min is %d\\n\" , policy -> max , policy -> min ) ; out return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static uint64_t port92_read ( void * opaque , hwaddr addr , unsigned size ) { Port92State * s = opaque ; uint32_t ret ; ret = s -> outport ; trace_port92_read ( ret , NULL ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void carl9170_ba_check ( struct ar9170 * ar , void * data , unsigned int len ) { struct ieee80211_bar * bar = data ; struct carl9170_bar_list_entry * entry ; unsigned int queue ; if ( likely ( ! ieee80211_is_back ( bar -> frame_control ) ) ) { return ; } queue = TID_TO_WME_AC ( ( ( le16_to_cpu ( bar -> control ) & IEEE80211_BAR_CTRL_TID_INFO_MASK ) >> IEEE80211_BAR_CTRL_TID_INFO_SHIFT ) & 7 ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( , , ) { struct sk_buff * entry_skb = entry -> skb ; struct _carl9170_tx_superframe * super = ( void * ) entry_skb -> data ; struct ieee80211_bar * entry_bar = ( void * ) super -> frame_data ; ( ( a ) & cpu_to_le16 ( IEEE80211_BAR_CTRL_TID_INFO_MASK ) ) == ( ( b ) & cpu_to_le16 ( IEEE80211_BAR_CTRL_TID_INFO_MASK ) ) ; } , entry_bar -> control ; } , entry_bar ta && ether_addr_equal_64bits ( bar -> ta , entry_bar -> ra ) ; { struct ieee80211_tx_info * tx_info ; tx_info = IEEE80211_SKB_CB ( entry_skb ) ; tx_info -> flags |= IEEE80211_TX_STAT_ACK ; spin_lock_bh ( & ar -> bar_list_lock [ queue ] ) ; list_del_rcu ( & entry -> list ) ; spin_unlock_bh ( & ar -> bar_list_lock [ queue ] ) ; kfree_rcu ( entry , head ) ; break ; } ( ) ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int fini ( void ) { if ( job_comp_fd >= 0 ) { close ( job_comp_fd ) ; } return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nct3018y_probe ( struct i2c_client * client ) { struct nct3018y * nct3018y ; int err , flags ; if ( ! i2c_check_functionality ( client -> adapter , I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BLOCK_DATA ) ) { return - ENODEV ; } nct3018y = devm_kzalloc ( & client -> dev , sizeof ( nct3018y ) , GFP_KERNEL ) ; i2c_set_clientdata ( client , nct3018y ) ; nct3018y -> client = client ; device_set_wakeup_capable ( & client -> dev , 1 ) ; flags = i2c_smbus_read_byte_data ( client , NCT3018Y_REG_CTRL ) ; if ( flags < 0 ) { dev_dbg ( & client -> dev , \"%s: read error\\n\" , __func__ ) ; return flags ; } if ( flags & NCT3018Y_BIT_TWO ) { dev_dbg ( & client -> dev , \"%s: NCT3018Y_BIT_TWO is set\\n\" , __func__ ) ; } flags = NCT3018Y_BIT_TWO ; err = i2c_smbus_write_byte_data ( client , NCT3018Y_REG_CTRL , flags ) ; if ( err < 0 ) { dev_dbg ( & client -> dev , \"Unable to write NCT3018Y_REG_CTRL\\n\" ) ; return err ; } flags = 0 ; err = i2c_smbus_write_byte_data ( client , NCT3018Y_REG_ST , flags ) ; if ( err < 0 ) { dev_dbg ( & client -> dev , \"%s: write error\\n\" , __func__ ) ; return err ; } nct3018y -> rtc = devm_rtc_allocate_device ( & client -> dev ) ; if ( IS_ERR ( nct3018y -> rtc ) ) { return PTR_ERR ( nct3018y -> rtc ) ; } nct3018y -> rtc -> ops = & nct3018y_rtc_ops ; nct3018y -> rtc -> range_min = RTC_TIMESTAMP_BEGIN_2000 ; nct3018y -> rtc -> range_max = RTC_TIMESTAMP_END_2099 ; if ( client -> irq > 0 ) { err = devm_request_threaded_irq ( & client -> dev , client -> irq , NULL , nct3018y_irq , IRQF_ONESHOT | IRQF_TRIGGER_FALLING , \"nct3018y\" , client ) ; if ( err ) { dev_dbg ( & client -> dev , \"unable to request IRQ %d\\n\" , client -> irq ) ; return err ; } } else { clear_bit ( RTC_FEATURE_UPDATE_INTERRUPT , nct3018y -> rtc -> features ) ; clear_bit ( RTC_FEATURE_ALARM , nct3018y -> rtc -> features ) ; } nct3018y_clkout_register_clk ( nct3018y ) ; return devm_rtc_register_device ( nct3018y -> rtc ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ucs2_to_utf8 ( const CHAR16 * nm , char * * name ) { size_t len , sz ; CHAR16 c ; char * cp ; int freeit = * name == NULL ; sz = utf8_len_of_ucs2 ( nm ) + 1 ; len = 0 ; if ( * name != NULL ) { cp = * name ; } else { cp = * name = malloc ( sz ) ; } while ( * nm ) { c = * nm ++ ; if ( c > 0x7ff ) { if ( len ++ < sz ) { * cp ++ = ( char ) ( 0xE0 | ( c >> 12 ) ) ; } if ( len ++ < sz ) { * cp ++ = ( char ) ( 0x80 | ( ( c >> 6 ) & 0x3f ) ) ; } if ( len ++ < sz ) { * cp ++ = ( char ) ( 0x80 | ( c & 0x3f ) ) ; } } if ( c > 0x7f ) { if ( len ++ < sz ) { * cp ++ = ( char ) ( 0xC0 | ( ( c >> 6 ) & 0x1f ) ) ; } if ( len ++ < sz ) { * cp ++ = ( char ) ( 0x80 | ( c & 0x3f ) ) ; } } else { if ( len ++ < sz ) { * cp ++ = ( char ) ( c & 0x7f ) ; } } } if ( len >= sz ) { if ( freeit ) { free ( * name ) ; * name = NULL ; } return ( EOVERFLOW ) ; } * cp ++ = '\\0' ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int check_info_id ( const char * name , uint32_t id ) { if ( info_id != 0 && info_id == id ) { return ( 1 ) ; } if ( * info_name != '\\0' && name && strcmp ( info_name , name ) == 0 ) { return ( 1 ) ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static gboolean infinoted_plugin_document_stream_process ( InfinotedPluginDocumentStreamStream * stream , const gchar * * data , gsize * len ) { guint32 command ; if ( * len < 4 ) { return FALSE ; } command = * ( guint32 * ) ( * data ) ; * data += 4 ; * len -= 4 ; switch ( command ) { case 0 : return infinoted_plugin_document_stream_process_get_document ( stream , data , len ) ; case 1 : return infinoted_plugin_document_stream_process_send_chat_message ( stream , data , len ) ; default : infinoted_plugin_document_stream_close_stream ( stream , NULL ) ; return FALSE ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void fsnotify_recalc_mask ( struct fsnotify_mark_connector * conn ) { if ( ! conn ) { return ; } spin_lock ( & conn -> lock ) ; __fsnotify_recalc_mask ( conn , NULL ) ; spin_unlock ( & conn -> lock ) ; if ( conn -> flags & FSNOTIFY_OBJ_TYPE_INODE ) { __fsnotify_update_child_dentry_flags ( conn -> inode ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int is_blktype ( struct lxc_storage * b ) { return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void copy_args_from_argbuf ( struct fuse_args * args , struct fuse_req * req ) { unsigned int remaining ; unsigned int offset ; unsigned int num_in ; unsigned int num_out ; unsigned int i ; remaining = req -> out . h . len - sizeof ( req -> out . h ) ; num_in = args -> in_numargs - args -> in_pages ; num_out = args -> out_numargs - args -> out_pages ; offset = fuse_len_args ( num_in , ( fuse_arg * ) args -> in_args ) ; for ( i = 0 ; i < num_out ; i ++ ) { unsigned int argsize = args -> out_args [ i ] . size ; if ( args -> out_argvar && i == args -> out_numargs - 1 && argsize > remaining ) { argsize = remaining ; } memcpy ( args -> out_args [ i ] . value , req -> argbuf + offset , argsize ) ; offset += argsize ; if ( i != args -> out_numargs - 1 ) { remaining -= argsize ; } } if ( args -> out_argvar ) { args -> out_args [ args -> out_numargs - 1 ] . size = remaining ; } kfree ( req -> argbuf ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dsi_perf_show ( struct dsi_data * dsi , const char * name ) { ktime_t t , setup_time , trans_time ; u32 total_bytes ; u32 setup_us , trans_us , total_us ; t = ktime_get ( ) ; setup_time = ktime_sub ( dsi -> perf_start_time , dsi -> perf_setup_time ) ; setup_us = ( u32 ) ktime_to_us ( setup_time ) ; if ( setup_us == 0 ) { setup_us = 1 ; } trans_time = ktime_sub ( t , dsi -> perf_start_time ) ; trans_us = ( u32 ) ktime_to_us ( trans_time ) ; if ( trans_us == 0 ) { trans_us = 1 ; } total_us = setup_us + trans_us ; total_bytes = dsi -> update_bytes ; pr_info ( \"DSI(%s): %u us + %u us = %u us (%uHz), %u bytes, %u kbytes/sec\\n\" , name , setup_us , trans_us , total_us , 1000 * 1000 / total_us , total_bytes , total_bytes * 1000 / total_us ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct phy * lynx_28g_xlate ( struct device * dev , struct of_phandle_args * args ) { struct lynx_28g_priv * priv = dev_get_drvdata ( dev ) ; int idx = args -> args [ 0 ] ; return priv -> lane [ idx ] . phy ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int acpi_smbus_cmi_add ( struct acpi_device * device ) { struct acpi_smbus_cmi * smbus_cmi ; const struct acpi_device_id * id ; smbus_cmi = kzalloc ( sizeof ( acpi_smbus_cmi ) , GFP_KERNEL ) ; if ( ! smbus_cmi ) { return - ENOMEM ; } smbus_cmi -> handle = device -> handle ; strcpy ( acpi_device_name ( device ) , ACPI_SMBUS_HC_DEVICE_NAME ) ; strcpy ( acpi_device_class ( device ) , ACPI_SMBUS_HC_CLASS ) ; device -> driver_data = smbus_cmi ; smbus_cmi -> cap_info = 0 ; smbus_cmi -> cap_read = 0 ; smbus_cmi -> cap_write = 0 ; for ( id = acpi_smbus_cmi_ids ; id -> id [ 0 ] ; id ++ ) { if ( ! strcmp ( id -> id , acpi_device_hid ( device ) ) ) { smbus_cmi -> methods = ( smbus_methods_t * ) id -> driver_data ; } } acpi_walk_namespace ( ACPI_TYPE_METHOD , smbus_cmi -> handle , 1 , acpi_smbus_cmi_query_methods , NULL , smbus_cmi , NULL ) ; if ( smbus_cmi -> cap_info == 0 ) { err } snprintf ( smbus_cmi -> adapter . name , sizeof ( smbus_cmi -> adapter . name ) , \"SMBus CMI adapter %s\" , acpi_device_name ( device ) ) ; smbus_cmi -> adapter . owner = THIS_MODULE ; smbus_cmi -> adapter . algo = & acpi_smbus_cmi_algorithm ; smbus_cmi -> adapter . algo_data = smbus_cmi ; smbus_cmi -> adapter . class = I2C_CLASS_HWMON | I2C_CLASS_SPD ; smbus_cmi -> adapter . dev . parent = & device -> dev ; if ( i2c_add_adapter ( & smbus_cmi -> adapter ) ) { dev_err ( & device -> dev , \"Couldn't register adapter!\\n\" ) ; err } return 0 ; err device -> driver_data = NULL ; return - EIO ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t adp8870_show ( struct device * dev , char * buf , int reg ) { struct adp8870_bl * data = dev_get_drvdata ( dev ) ; int error ; uint8_t reg_val ; mutex_lock ( & data -> lock ) ; error = adp8870_read ( data -> client , reg , & reg_val ) ; mutex_unlock ( & data -> lock ) ; return sprintf ( buf , \"%u\\n\" , reg_val ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int qcow2_cache_set_dependency ( BlockDriverState * bs , Qcow2Cache * c , Qcow2Cache * dependency ) { int ret ; if ( dependency -> depends ) { ret = qcow2_cache_flush_dependency ( bs , dependency ) ; } if ( c -> depends && ( c -> depends != dependency ) ) { ret = qcow2_cache_flush_dependency ( bs , c ) ; if ( ret < 0 ) { return ret ; } } c -> depends = dependency ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void read_block_list ( unsigned int * block_list , long long start , unsigned int offset , int blocks ) { int res ; TRACE ( \"read_block_list: blocks %d\\n\" , blocks ) ; if ( swap ) { unsigned int * block_ptr = malloc ( blocks * ( unsigned int ) ) ; if ( block_ptr == NULL ) { MEM_ERROR ( ) ; } res = read_inode_data ( block_ptr , & start , & offset , blocks * ( unsigned int ) ) ; if ( res == FALSE ) { EXIT_UNSQUASH ( \"read_block_list: failed to read \" \"inode index %lld:%d\\n\" , start , offset ) ; } SQUASHFS_SWAP_INTS_3 ( block_list , block_ptr , blocks ) ; } else { res = read_inode_data ( block_list , & start , & offset , blocks * ( unsigned int ) ) ; if ( res == FALSE ) { EXIT_UNSQUASH ( \"read_block_list: failed to read \" \"inode index %lld:%d\\n\" , start , offset ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void softintr_biglock_wrap ( void * arg ) { struct soft_intrhand * sih = arg ; KERNEL_LOCK ( ) ; sih -> sih_fnwrap ( sih -> sih_argwrap , NULL ) ; KERNEL_UNLOCK ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "DEVICE_ATTR ( phy_event_threshold , S_IRUGO | S_IWUSR , phy_event_threshold_show , phy_event_threshold_store ) ; EXPORT_SYMBOL_GPL ( dev_attr_phy_event_threshold ) ; struct scsi_transport_template * sas_domain_attach_transport ( struct sas_domain_function_template * dft ) { struct scsi_transport_template * stt = sas_attach_transport ( & sft ) ; struct sas_internal * i ; if ( ! stt ) { return stt ; } i = to_sas_internal ( stt ) ; i -> dft = dft ; stt -> eh_strategy_handler = sas_scsi_recover_host ; return stt ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int socfpga_sysreset_probe ( struct udevice * dev ) { struct socfpga_sysreset_data * data = dev_get_priv ( dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mlx5i_pkey_qpn_ht_init ( struct net_device * netdev ) { struct mlx5i_priv * ipriv = netdev_priv ( netdev ) ; struct mlx5i_pkey_qpn_ht * qpn_htbl ; qpn_htbl = kzalloc ( sizeof ( * qpn_htbl ) , GFP_KERNEL ) ; ipriv -> qpn_htbl = qpn_htbl ; spin_lock_init ( & qpn_htbl -> ht_lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int machine_crash_setup ( void ) { static struct notifier_block kdump_init_notifier_nb = { . notifier_call = kdump_init_notifier . priority = 1 } ; int ret ; register_sysctl_table ( sys_table ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int do_chmod ( const char * pfile ) { int ret = 0 ; if ( chmod ( pfile , ALL_MODE ) == - 1 ) { ( void ) fprintf ( stderr , \"chmod(%s, ALL_MODE) failed with \" \"errno %d\\n\" , pfile , errno ) ; return ( 1 ) ; } return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int namematch ( const char * label , char * line , const char * name ) { char * lend ; if ( strncmp ( label , line , strlen ( label ) ) != SAME ) { return ( FALSE ) ; } line += strlen ( label ) ; while ( ( lend = strchr ( line , ':' ) ) != NULL ) { * lend = '\\0' ; if ( strcmp ( line , name ) == SAME ) { return ( TRUE ) ; } line = lend + 1 ; } return ( strcmp ( line , name ) == SAME ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "Status_t sa_BufferControlTableRecord_Set ( uint8_t * pRec , Node_t * pNode , Port_t * pPort ) { STL_BUFFER_CONTROL_TABLE_RECORD record ; IB_ENTER ( \"sa_BufferControlTableRecord_Set\" , pRec , pNode , pPort , 0 ) ; Port_t * swport ; STL_LID lid ; if ( ( pNode -> nodeInfo . NodeType == NI_TYPE_SWITCH ) && ( sm_valid_port ( ( swport = sm_get_port ( pNode , 0 ) ) ) ) ) { lid = swport -> portData -> lid ; } else { lid = pPort -> portData -> lid ; } record . RID . LID = lid ; record . RID . Port = pPort -> index ; record . BufferControlTable = pPort -> portData -> bufCtrlTable ; BSWAPCOPY_STL_BUFFER_CONTROL_TABLE_RECORD ( & record , ( STL_BUFFER_CONTROL_TABLE_RECORD * ) pRec ) ; IB_EXIT ( \"sa_BufferControlTableRecord_Set\" , VSTATUS_OK ) ; return ( VSTATUS_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline struct kvm_pmc * get_gp_pmc_amd ( struct kvm_pmu * pmu , u32 msr , enum pmu_type type ) { struct kvm_vcpu * vcpu = pmu_to_vcpu ( pmu ) ; unsigned int idx ; if ( ! vcpu -> kvm -> arch . enable_pmu ) { return NULL ; } switch ( msr ) { case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5 : if ( ! guest_cpuid_has ( vcpu , X86_FEATURE_PERFCTR_CORE ) ) { return in ; } idx = ( unsigned int ) ( ( msr - MSR_F15H_PERF_CTL0 ) / 2 ) ; if ( ! ( msr & 0x1 ) != ( type == PMU_TYPE_EVNTSEL ) ) { return NULL ; } break ; case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3 : if ( type != PMU_TYPE_EVNTSEL ) { return NULL ; } idx = msr - MSR_K7_EVNTSEL0 ; break ; case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3 : if ( type != PMU_TYPE_COUNTER ) { return NULL ; } idx = msr - MSR_K7_PERFCTR0 ; break ; default : return NULL ; } return amd_pmc_idx_to_pmc ( pmu , idx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "{ void * data ; struct hash_entry * next ; } hash_table { struct hash_entry * bucket ; struct hash_entry const * bucket_limit ; size_t n_buckets ; int n_buckets_used ; size_t n_entries ; const Hash_tuning * tuning ; Hash_hasher hasher ; Hash_comparator comparator ; Hash_data_freer data_freer ; struct hash_entry * free_entry_list ; struct obstack entry_stack ; } static const Hash_tuning default_tuning = { DEFAULT_SHRINK_THRESHOLD DEFAULT_SHRINK_FACTOR DEFAULT_GROWTH_THRESHOLD DEFAULT_GROWTH_FACTOR false } ; size_t hash_get_n_buckets ( const Hash_table * table ) { return table -> n_buckets ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t fuse_read ( struct file * fd , struct kobject * kobj , struct bin_attribute * attr , char * buf , loff_t pos , size_t size ) { struct device * dev = kobj_to_dev ( kobj ) ; struct tegra_fuse * fuse = dev_get_drvdata ( dev ) ; int i ; if ( size > attr -> size - pos ) { size = attr -> size - pos ; } for ( i = 0 ; i < size ; i ++ ) { buf [ i ] = fuse_readb ( fuse , pos + i ) ; } return i ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "rio_remove1 ( ) { struct net_device * dev = pci_get_drvdata ( pdev ) ; if ( dev ) { struct netdev_private * np = netdev_priv ( dev ) ; unregister_netdev ( dev ) ; dma_free_coherent ( & pdev -> dev , RX_TOTAL_SIZE , np -> rx_ring , np -> rx_ring_dma ) ; dma_free_coherent ( & pdev -> dev , TX_TOTAL_SIZE , np -> tx_ring , np -> tx_ring_dma ) ; pci_iounmap ( pdev , np -> ioaddr ) ; pci_iounmap ( pdev , np -> eeprom_addr ) ; pci_release_regions ( pdev ) ; pci_disable_device ( pdev ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "long do_rt_sigreturn ( CPUOpenRISCState * env ) { abi_ulong frame_addr = get_sp_from_cpustate ( env ) ; target_rt_sigframe * frame ; sigset_t set ; trace_user_do_rt_sigreturn ( env , 0 ) ; if ( ! lock_user_struct ( VERIFY_READ , frame , frame_addr , 1 ) ) { badframe } if ( frame_addr & 3 ) { badframe } target_to_host_sigset ( & set , & frame -> uc . tuc_sigmask ) ; set_sigmask ( & set ) ; restore_sigcontext ( env , & frame -> uc . tuc_mcontext ) ; target_restore_altstack ( & frame -> uc . tuc_stack , env ) ; unlock_user_struct ( frame , frame_addr , 0 ) ; return cpu_get_gpr ( env , 11 ) ; badframe unlock_user_struct ( frame , frame_addr , 0 ) ; force_sig ( TARGET_SIGSEGV , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int unsetenv ( const char * name ) { size_t len ; char * * ep ; if ( name == NULL || * name == '\\0' || strchr ( name , '=' ) != NULL ) { return - 1 ; } len = strlen ( name ) ; LOCK ; ep = __environ ; while ( * ep != NULL ) { if ( ! strncmp ( * ep , name , len ) && ( * ep ) [ len ] == '=' ) { char * * dp = ep ; { dp [ 0 ] = dp [ 1 ] ; } * dp ++ ; } else { ++ ep ; } } UNLOCK ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void unregister_kmmio_probe ( struct kmmio_probe * p ) { unsigned long flags ; unsigned long size = 0 ; unsigned long addr = p -> addr & PAGE_MASK ; const unsigned long size_lim = p -> len + ( p -> addr & ~ PAGE_MASK ) ; struct kmmio_fault_page * release_list = NULL ; struct kmmio_delayed_release * drelease ; unsigned int l ; pte_t * pte ; pte = lookup_address ( addr , & l ) ; local_irq_save ( flags ) ; arch_spin_lock ( & kmmio_lock ) ; while ( size < size_lim ) { release_kmmio_fault_page ( addr + size , & release_list ) ; size += page_level_size ( l ) ; } list_del_rcu ( & p -> list ) ; kmmio_count -- ; arch_spin_unlock ( & kmmio_lock ) ; local_irq_restore ( flags ) ; if ( ! release_list ) { return ; } drelease = kmalloc ( sizeof ( * drelease ) , GFP_ATOMIC ) ; if ( ! drelease ) { pr_crit ( \"leaking kmmio_fault_page objects.\\n\" ) ; return ; } drelease -> release_list = release_list ; call_rcu ( & drelease -> rcu , remove_kmmio_fault_pages ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s390_storage_keys_load ( QEMUFile * f , void * opaque , int version_id ) { S390SKeysState * ss = S390_SKEYS ( opaque ) ; S390SKeysClass * skeyclass = S390_SKEYS_GET_CLASS ( ss ) ; int ret = 0 ; if ( skeyclass -> enable_skeys ) { skeyclass -> enable_skeys ( ss ) ; } while ( ! ret ) { ram_addr_t addr ; int flags ; addr = qemu_get_be64 ( f ) ; flags = addr & ~ TARGET_PAGE_MASK ; addr &= TARGET_PAGE_MASK ; switch ( flags ) { case S390_SKEYS_SAVE_FLAG_SKEYS : { const uint64_t total_count = qemu_get_be64 ( f ) ; uint64_t handled_count = 0 , cur_count ; uint64_t cur_gfn = addr / TARGET_PAGE_SIZE ; uint8_t * buf = g_try_malloc ( S390_SKEYS_BUFFER_SIZE ) ; if ( ! buf ) { error_report ( \"storage key load could not allocate memory\" ) ; ret = - ENOMEM ; break ; } while ( handled_count < total_count ) { cur_count = MIN ( total_count - handled_count , S390_SKEYS_BUFFER_SIZE ) ; qemu_get_buffer ( f , buf , cur_count ) ; ret = skeyclass -> set_skeys ( ss , cur_gfn , cur_count , buf ) ; if ( ret < 0 ) { error_report ( \"S390_SET_KEYS error %d\" , ret ) ; break ; } handled_count += cur_count ; cur_gfn += cur_count ; } break ; } case S390_SKEYS_SAVE_FLAG_ERROR : { error_report ( \"Storage key data is incomplete\" ) ; ret = - EINVAL ; break ; } case S390_SKEYS_SAVE_FLAG_EOS : return 0 ; default : error_report ( \"Unexpected storage key flag data: %#x\" , flags ) ; ret = - EINVAL ; } } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int lp3943_pwm_apply ( struct pwm_chip * chip , struct pwm_device * pwm , const struct pwm_state * state ) { int err ; if ( ! state -> enabled ) { if ( pwm -> state . enabled ) { lp3943_pwm_disable ( chip , pwm ) ; } return 0 ; } err = lp3943_pwm_config ( chip , pwm , state -> duty_cycle , state -> period ) ; if ( err ) { return err ; } if ( ! pwm -> state . enabled ) { err = lp3943_pwm_enable ( chip , pwm ) ; } return err ; } static const struct pwm_ops lp3943_pwm_ops = { . request = lp3943_pwm_request . free = lp3943_pwm_free . apply = lp3943_pwm_apply . owner = THIS_MODULE } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int crypto_sign_ed25519_open ( unsigned char * m , unsigned long long * mlen , const unsigned char * sm , unsigned long long smlen , const unsigned char * pk ) { int i ; int ret ; unsigned char t2 [ 32 ] ; ge25519 get1 , get2 ; sc25519 schram , scs ; unsigned char hram [ crypto_hash_sha512_BYTES ] ; * mlen = ( unsigned long long ) - 1 ; if ( smlen < 64 ) { return - 1 ; } if ( ge25519_unpackneg_vartime ( & get1 , pk ) ) { return - 1 ; } get_hram ( hram , sm , pk , m , smlen ) ; sc25519_from64bytes ( & schram , hram ) ; sc25519_from32bytes ( & scs , sm + 32 ) ; ge25519_double_scalarmult_vartime ( & get2 , & get1 , & schram , & ge25519_base , & scs ) ; ge25519_pack ( t2 , & get2 ) ; ret = crypto_verify_32 ( sm , t2 ) ; if ( ! ret ) { for ( i = 0 ; i < smlen - 64 ; i ++ ) { m [ i ] = sm [ i + 64 ] ; } * mlen = smlen - 64 ; } else { for ( i = 0 ; i < smlen - 64 ; i ++ ) { m [ i ] = 0 ; } } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int wmi_dev_probe ( struct device * dev ) { struct wmi_block * wblock = dev_to_wblock ( dev ) ; struct wmi_driver * wdriver = drv_to_wdrv ( dev -> driver ) ; int ret = 0 ; char * buf ; if ( ACPI_FAILURE ( wmi_method_enable ( wblock , true ) ) ) { dev_warn ( dev , \"failed to enable device -- probing anyway\\n\" ) ; } if ( wdriver -> probe ) { ret = wdriver -> probe ( dev_to_wdev ( dev ) , find_guid_context ( wblock , wdriver ) ) ; if ( ret != 0 ) { probe_failure } } if ( wdriver -> filter_callback ) { if ( ! wblock -> req_buf_size ) { dev_err ( & wblock -> dev . dev , \"Required buffer size not set\\n\" ) ; ret = - EINVAL ; probe_failure } wblock -> handler_data = kmalloc ( wblock -> req_buf_size , GFP_KERNEL ) ; if ( ! wblock -> handler_data ) { ret = - ENOMEM ; probe_failure } buf = kasprintf ( GFP_KERNEL , \"wmi/%s\" , wdriver -> driver . name ) ; if ( ! buf ) { ret = - ENOMEM ; probe_string_failure } wblock -> char_dev . minor = MISC_DYNAMIC_MINOR ; wblock -> char_dev . name = buf ; wblock -> char_dev . fops = & wmi_fops ; wblock -> char_dev . mode = 0444 ; ret = misc_register ( & wblock -> char_dev ) ; if ( ret ) { dev_warn ( dev , \"failed to register char dev: %d\\n\" , ret ) ; ret = - ENOMEM ; probe_misc_failure } } set_bit ( WMI_PROBED , & wblock -> flags ) ; return 0 ; probe_misc_failure probe_string_failure kfree ( wblock -> handler_data ) ; probe_failure if ( ACPI_FAILURE ( wmi_method_enable ( wblock , false ) ) ) { dev_warn ( dev , \"failed to disable device\\n\" ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int hdmi4_audio_config ( struct hdmi_core_data * core , struct hdmi_wp_data * wp , struct omap_dss_audio * audio , u32 pclk ) { struct hdmi_audio_format audio_format ; struct hdmi_audio_dma audio_dma ; struct hdmi_core_audio_config acore ; int n , cts , channel_count ; int fs_nr ; bool word_length_16b = false ; if ( ! audio || ! audio -> iec || ! audio -> cea || ! core ) { return - EINVAL ; } acore . iec60958_cfg = audio -> iec ; if ( ! ( audio -> iec -> status [ 4 ] & IEC958_AES4_CON_MAX_WORDLEN_24 ) ) { if ( audio -> iec -> status [ 4 ] & IEC958_AES4_CON_WORDLEN_20_16 ) { word_length_16b = true ; } } if ( word_length_16b ) { acore . i2s_cfg . justification = HDMI_AUDIO_JUSTIFY_LEFT ; } else { acore . i2s_cfg . justification = HDMI_AUDIO_JUSTIFY_RIGHT ; } acore . i2s_cfg . in_length_bits = audio -> iec -> status [ 4 ] & IEC958_AES4_CON_WORDLEN ; if ( audio -> iec -> status [ 4 ] & IEC958_AES4_CON_MAX_WORDLEN_24 ) { acore . i2s_cfg . in_length_bits ++ ; } acore . i2s_cfg . sck_edge_mode = HDMI_AUDIO_I2S_SCK_EDGE_RISING ; acore . i2s_cfg . vbit = HDMI_AUDIO_I2S_VBIT_FOR_PCM ; acore . i2s_cfg . direction = HDMI_AUDIO_I2S_MSB_SHIFTED_FIRST ; acore . i2s_cfg . shift = HDMI_AUDIO_I2S_FIRST_BIT_SHIFT ; switch ( audio -> iec -> status [ 3 ] & IEC958_AES3_CON_FS ) { case IEC958_AES3_CON_FS_32000 : fs_nr = 32000 ; break ; case IEC958_AES3_CON_FS_44100 : fs_nr = 44100 ; break ; case IEC958_AES3_CON_FS_48000 : fs_nr = 48000 ; break ; case IEC958_AES3_CON_FS_88200 : fs_nr = 88200 ; break ; case IEC958_AES3_CON_FS_96000 : fs_nr = 96000 ; break ; case IEC958_AES3_CON_FS_176400 : fs_nr = 176400 ; break ; case IEC958_AES3_CON_FS_192000 : fs_nr = 192000 ; break ; default : return - EINVAL ; } hdmi_compute_acr ( pclk , fs_nr , & n , & cts ) ; acore . n = n ; acore . cts = cts ; if ( dss_has_feature ( FEAT_HDMI_CTS_SWMODE ) ) { acore . aud_par_busclk = 0 ; acore . cts_mode = HDMI_AUDIO_CTS_MODE_SW ; acore . use_mclk = dss_has_feature ( FEAT_HDMI_AUDIO_USE_MCLK ) ; } else { acore . aud_par_busclk = ( ( ( 128 * 31 ) - 1 ) << 8 ) ; acore . cts_mode = HDMI_AUDIO_CTS_MODE_HW ; acore . use_mclk = true ; } if ( acore . use_mclk ) { acore . mclk_mode = HDMI_AUDIO_MCLK_128FS ; } channel_count = ( audio -> cea -> db1_ct_cc & CEA861_AUDIO_INFOFRAME_DB1CC ) + 1 ; switch ( channel_count ) { case 2 : audio_format . active_chnnls_msk = 0x03 ; break ; case 3 : audio_format . active_chnnls_msk = 0x07 ; break ; case 4 : audio_format . active_chnnls_msk = 0x0f ; break ; case 5 : audio_format . active_chnnls_msk = 0x1f ; break ; case 6 : audio_format . active_chnnls_msk = 0x3f ; break ; case 7 : audio_format . active_chnnls_msk = 0x7f ; break ; case 8 : audio_format . active_chnnls_msk = 0xff ; break ; default : return - EINVAL ; } if ( channel_count == 2 ) { audio_format . stereo_channels = HDMI_AUDIO_STEREO_ONECHANNEL ; acore . i2s_cfg . active_sds = HDMI_AUDIO_I2S_SD0_EN ; acore . layout = HDMI_AUDIO_LAYOUT_2CH ; } else { audio_format . stereo_channels = HDMI_AUDIO_STEREO_FOURCHANNELS ; acore . i2s_cfg . active_sds = HDMI_AUDIO_I2S_SD0_EN | HDMI_AUDIO_I2S_SD1_EN | HDMI_AUDIO_I2S_SD2_EN | HDMI_AUDIO_I2S_SD3_EN ; acore . layout = HDMI_AUDIO_LAYOUT_8CH ; audio -> cea -> db1_ct_cc = 7 ; } acore . en_spdif = false ; acore . fs_override = true ; acore . en_acr_pkt = true ; acore . en_dsd_audio = false ; acore . en_parallel_aud_input = true ; if ( word_length_16b ) { audio_dma . transfer_size = 0x10 ; } else { audio_dma . transfer_size = 0x20 ; } audio_dma . block_size = 0xC0 ; audio_dma . mode = HDMI_AUDIO_TRANSF_DMA ; audio_dma . fifo_threshold = 0x20 ; if ( word_length_16b ) { audio_format . samples_per_word = HDMI_AUDIO_ONEWORD_TWOSAMPLES ; audio_format . sample_size = HDMI_AUDIO_SAMPLE_16BITS ; audio_format . justification = HDMI_AUDIO_JUSTIFY_LEFT ; } else { audio_format . samples_per_word = HDMI_AUDIO_ONEWORD_ONESAMPLE ; audio_format . sample_size = HDMI_AUDIO_SAMPLE_24BITS ; audio_format . justification = HDMI_AUDIO_JUSTIFY_RIGHT ; } audio_format . type = HDMI_AUDIO_TYPE_LPCM ; audio_format . sample_order = HDMI_AUDIO_SAMPLE_LEFT_FIRST ; audio_format . en_sig_blk_strt_end = HDMI_AUDIO_BLOCK_SIG_STARTEND_ON ; hdmi_wp_audio_config_dma ( wp , & audio_dma ) ; hdmi_wp_audio_config_format ( wp , & audio_format ) ; hdmi_core_audio_config ( core , & acore ) ; hdmi_core_audio_infoframe_cfg ( core , audio -> cea ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void nfs_zap_caches_locked ( struct inode * inode ) { struct nfs_inode * nfsi = NFS_I ( inode ) ; int mode = inode -> i_mode ; nfsi -> attrtimeo = NFS_MINATTRTIMEO ( inode ) ; nfsi -> attrtimeo_timestamp = jiffies ; memset ( NFS_I ( inode ) -> cookieverf , 0 , sizeof ( NFS_I ( inode ) -> cookieverf ) ) ; if ( S_ISREG ( mode ) || S_ISDIR ( mode ) || S_ISLNK ( mode ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR | NFS_INO_INVALID_DATA | NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL | NFS_INO_REVAL_PAGECACHE ) ; } else { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR | NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL | NFS_INO_REVAL_PAGECACHE ) ; } nfs_zap_label_cache_locked ( nfsi ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void kvmppc_xics_free_icp ( struct kvm_vcpu * vcpu ) { if ( ! vcpu -> arch . icp ) { return ; } vcpu -> arch . icp = NULL ; vcpu -> arch . irq_type = KVMPPC_IRQ_DEFAULT ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int bus_scope_set_property ( Unit * u , const char * name , sd_bus_message * message , UnitWriteFlags flags , sd_bus_error * error ) { Scope * s = SCOPE ( u ) ; int r ; assert ( s ) ; assert ( name ) ; assert ( message ) ; r = bus_cgroup_set_property ( u , & s -> cgroup_context , name , message , flags , error ) ; if ( u -> load_state == UNIT_STUB ) { r = bus_scope_set_transient_property ( s , name , message , flags , error ) ; if ( r != 0 ) { return r ; } r = bus_kill_context_set_transient_property ( u , & s -> kill_context , name , message , flags , error ) ; if ( r != 0 ) { return r ; } if ( streq ( name , \"User\" ) ) { return bus_set_transient_user_relaxed ( u , name , & s -> user , message , flags , error ) ; } if ( streq ( name , \"Group\" ) ) { return bus_set_transient_user_relaxed ( u , name , & s -> group , message , flags , error ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __write_initial_superblock ( struct dm_pool_metadata * pmd ) { int r ; struct dm_block * sblock ; struct thin_disk_superblock * disk_super ; sector_t bdev_size = i_size_read ( pmd -> bdev -> bd_inode ) >> SECTOR_SHIFT ; if ( bdev_size > THIN_METADATA_MAX_SECTORS ) { bdev_size = THIN_METADATA_MAX_SECTORS ; } r = dm_sm_commit ( pmd -> data_sm ) ; r = save_sm_roots ( pmd ) ; if ( r < 0 ) { return r ; } r = dm_tm_pre_commit ( pmd -> tm ) ; if ( r < 0 ) { return r ; } r = superblock_lock_zero ( pmd , & sblock ) ; if ( r ) { return r ; } disk_super = dm_block_data ( sblock ) ; disk_super -> flags = 0 ; memset ( disk_super -> uuid , 0 , sizeof ( disk_super -> uuid ) ) ; disk_super -> magic = cpu_to_le64 ( THIN_SUPERBLOCK_MAGIC ) ; disk_super -> version = cpu_to_le32 ( THIN_VERSION ) ; disk_super -> time = 0 ; disk_super -> trans_id = 0 ; disk_super -> held_root = 0 ; copy_sm_roots ( pmd , disk_super ) ; disk_super -> data_mapping_root = cpu_to_le64 ( pmd -> root ) ; disk_super -> device_details_root = cpu_to_le64 ( pmd -> details_root ) ; disk_super -> metadata_block_size = cpu_to_le32 ( THIN_METADATA_BLOCK_SIZE ) ; disk_super -> metadata_nr_blocks = cpu_to_le64 ( bdev_size >> SECTOR_TO_BLOCK_SHIFT ) ; disk_super -> data_block_size = cpu_to_le32 ( pmd -> data_block_size ) ; return dm_tm_commit ( pmd -> tm , sblock ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool mac_hid_emumouse_filter ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) { unsigned int btn ; if ( type != EV_KEY ) { return false ; } if ( code == mouse_button2_keycode ) { btn = BTN_MIDDLE ; } if ( code == mouse_button3_keycode ) { btn = BTN_RIGHT ; } else { return false ; } input_report_key ( mac_hid_emumouse_dev , btn , value ) ; input_sync ( mac_hid_emumouse_dev , NULL ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool jshFlashGetPage ( uint32_t addr , uint32_t * startAddr , uint32_t * pageSize ) { if ( addr < FLASH_START ) { return false ; } * startAddr = ( uint32_t ) ( floor ( addr / FAKE_FLASH_BLOCKSIZE ) * FAKE_FLASH_BLOCKSIZE ) ; * pageSize = FAKE_FLASH_BLOCKSIZE ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int i2sbus_playback_open ( struct snd_pcm_substream * substream ) { struct i2sbus_dev * i2sdev = snd_pcm_substream_chip ( substream ) ; i2sdev -> out . substream = substream ; return i2sbus_pcm_open ( i2sdev , 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int look_for_signals ( CopyFlags copy_flags ) { int r ; r = pop_pending_signal ( copy_flags & COPY_SIGINT ?SIGINT : 0 , copy_flags & COPY_SIGTERM ?SIGTERM : 0 ) ; if ( r < 0 ) { return r ; } if ( r != 0 ) { return log_debug_errno ( SYNTHETIC_ERRNO ( EINTR ) , \"Got %s, cancelling copy operation.\" , signal_to_string ( r ) ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void eib_manage_keepalives ( eib_t * ss ) { eib_ka_vnics_t * elem ; eib_ka_vnics_t * nxt ; clock_t deadline ; int64_t lbolt64 ; int err ; kmutex_t ci_lock ; callb_cpr_t ci ; mutex_init ( & ci_lock , MUTEX_DRIVER , NULL ) ; CALLB_CPR_INIT ( & ci , & ci_lock , callb_generic_cpr , EIB_EVENTS_HDLR ) ; mutex_enter ( & ss -> ei_ka_vnics_lock ) ; periodic_keepalive deadline = ddi_get_lbolt ( ) + ss -> ei_gw_props -> pp_vnic_ka_ticks ; while ( ( ss -> ei_ka_vnics_event & ( EIB_KA_VNICS_DIE | EIB_KA_VNICS_TIMED_OUT ) ) == 0 ) { mutex_enter ( & ci_lock ) ; CALLB_CPR_SAFE_BEGIN ( & ci ) ; mutex_exit ( & ci_lock ) ; if ( cv_timedwait ( & ss -> ei_ka_vnics_cv , & ss -> ei_ka_vnics_lock , deadline ) == - 1 ) { ss -> ei_ka_vnics_event |= EIB_KA_VNICS_TIMED_OUT ; } mutex_enter ( & ci_lock ) ; CALLB_CPR_SAFE_END ( & ci , & ci_lock ) ; mutex_exit ( & ci_lock ) ; } if ( ss -> ei_ka_vnics_event & EIB_KA_VNICS_DIE ) { for ( elem = ss -> ei_ka_vnics ; elem ; elem = nxt ) { nxt = elem -> ka_next ; kmem_free ( elem , sizeof ( eib_ka_vnics_t ) ) ; } ss -> ei_ka_vnics = NULL ; mutex_exit ( & ss -> ei_ka_vnics_lock ) ; mutex_enter ( & ci_lock ) ; CALLB_CPR_EXIT ( & ci ) ; mutex_destroy ( & ci_lock ) ; return ; } ss -> ei_ka_vnics_event &= ~ EIB_KA_VNICS_TIMED_OUT ; if ( ss -> ei_ka_vnics == NULL ) { periodic_keepalive } mutex_enter ( & ss -> ei_vnic_lock ) ; lbolt64 = ddi_get_lbolt64 ( ) ; if ( ss -> ei_gw_last_heartbeat != 0 ) { if ( ( lbolt64 - ss -> ei_gw_last_heartbeat ) > ss -> ei_gw_props -> pp_gw_ka_ticks ) { EIB_DPRINTF_WARN ( ss -> ei_instance , \"eib_manage_keepalives: no keepalives from gateway \" \"0x%x for hca_guid=0x%llx, port=0x%x, \" \"last_gw_ka=0x%llx\" , ss -> ei_gw_props -> pp_gw_portid , ss -> ei_props -> ep_hca_guid , ss -> ei_props -> ep_port_num , ss -> ei_gw_last_heartbeat ) ; for ( elem = ss -> ei_ka_vnics ; elem ; elem = nxt ) { nxt = elem -> ka_next ; ss -> ei_zombie_vnics |= ( ( uint64_t ) 1 << elem -> ka_vnic -> vn_instance ) ; kmem_free ( elem , sizeof ( eib_ka_vnics_t ) ) ; } ss -> ei_ka_vnics = NULL ; ss -> ei_gw_unreachable = B_TRUE ; mutex_exit ( & ss -> ei_vnic_lock ) ; eib_mac_link_down ( ss , B_FALSE ) ; periodic_keepalive } } mutex_exit ( & ss -> ei_vnic_lock ) ; for ( elem = ss -> ei_ka_vnics ; elem ; elem = elem -> ka_next ) { ( void ) eib_fip_heartbeat ( ss , elem -> ka_vnic , & err ) ; } periodic_keepalive } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int seqiv_aead_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct aead_instance * inst ; int err ; inst = aead_geniv_alloc ( tmpl , tb ) ; if ( IS_ERR ( inst ) ) { return PTR_ERR ( inst ) ; } err = - EINVAL ; if ( inst -> alg . ivsize != sizeof ( u64 ) ) { free_inst } inst -> alg . encrypt = seqiv_aead_encrypt ; inst -> alg . decrypt = seqiv_aead_decrypt ; inst -> alg . init = aead_init_geniv ; inst -> alg . exit = aead_exit_geniv ; inst -> alg . base . cra_ctxsize = sizeof ( aead_geniv_ctx ) ; inst -> alg . base . cra_ctxsize += inst -> alg . ivsize ; err = aead_register_instance ( tmpl , inst ) ; if ( err ) { free_inst inst -> free ( inst , NULL ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "pnmscanner_eatwhitespace ( ) { gint state = 0 ; while ( ! ( s -> eof ) && ( state != - 1 ) ) { switch ( state ) { case 0 : if ( s -> cur == '#' ) { state = 1 ; pnmscanner_getchar ( s , NULL ) ; } if ( ! g_ascii_isspace ( s -> cur ) ) { state = - 1 ; } else { pnmscanner_getchar ( s ) ; } break ; case 1 : if ( s -> cur == '\\n' ) { state = 0 ; } pnmscanner_getchar ( s ) ; break ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static irqreturn_t qec_interrupt ( int irq , void * dev_id ) { struct sunqec * qecp = dev_id ; u32 qec_status ; int channel = 0 ; qec_status = sbus_readl ( qecp -> gregs + GLOB_STAT ) ; while ( channel < 4 ) { if ( qec_status & 0xf ) { struct sunqe * qep = qecp -> qes [ channel ] ; u32 qe_status ; qe_status = sbus_readl ( qep -> qcregs + CREG_STAT ) ; if ( qe_status & CREG_STAT_ERRORS ) { if ( qe_is_bolixed ( qep , qe_status ) ) { next } } if ( qe_status & CREG_STAT_RXIRQ ) { qe_rx ( qep ) ; } if ( netif_queue_stopped ( qep -> dev ) && ( qe_status & CREG_STAT_TXIRQ ) ) { spin_lock ( & qep -> lock ) ; qe_tx_reclaim ( qep ) ; if ( TX_BUFFS_AVAIL ( qep ) > 0 ) { netif_wake_queue ( qep -> dev , NULL ) ; sbus_writel ( 1 , qep -> qcregs + CREG_TIMASK ) ; } spin_unlock ( & qep -> lock ) ; } next } qec_status >>= 4 ; channel ++ ; } return IRQ_HANDLED ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static apr_status_t ftp_string_read ( conn_rec * c , apr_bucket_brigade * bb , char * buff , apr_size_t bufflen , int * eos , apr_size_t * outlen ) { apr_bucket * e ; apr_status_t rv ; char * pos = buff ; char * response ; int found = 0 ; apr_size_t len ; buff [ 0 ] = 0 ; * eos = 0 ; * outlen = 0 ; while ( ! found ) { if ( APR_SUCCESS != ( rv = ap_get_brigade ( c -> input_filters , bb , AP_MODE_GETLINE , APR_BLOCK_READ , 0 ) ) ) { return rv ; } while ( ! found ) { if ( * eos || APR_BRIGADE_EMPTY ( bb ) ) { return APR_ECONNABORTED ; } e = APR_BRIGADE_FIRST ( bb ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { * eos = 1 ; } else { if ( APR_SUCCESS != ( rv = apr_bucket_read ( e , ( const char * * ) & response , & len , APR_BLOCK_READ ) ) ) { return rv ; } if ( memchr ( response , APR_ASCII_LF , len ) ) { found = 1 ; } if ( len > ( ( bufflen - 1 ) - ( pos - buff ) ) ) { len = ( bufflen - 1 ) - ( pos - buff ) ; } if ( len > 0 ) { memcpy ( pos , response , len ) ; pos += len ; * outlen += len ; } } apr_bucket_delete ( e , NULL ) ; } * pos = '\\0' ; } return APR_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void setproctitle ( const char * fmt , ... ) { char buf [ SPT_MAXTITLE + 1 ] ; va_list ap ; char * nul ; int len , error ; if ( ! SPT . base ) { return ; } if ( fmt ) { va_start ( ap , fmt ) ; len = vsnprintf ( buf , sizeof buf , fmt , ap ) ; va_end ( ap ) ; } else { len = snprintf ( buf , sizeof buf , \"%s\" , SPT . arg0 ) ; } if ( len <= 0 ) { error = errno ; error } if ( ! SPT . reset ) { memset ( SPT . base , 0 , SPT . end - SPT . base ) ; } else { memset ( SPT . base , 0 , spt_min ( sizeof buf , SPT . end - SPT . base ) ) ; } len = spt_min ( len , spt_min ( sizeof buf , SPT . end - SPT . base ) - 1 ) ; memcpy ( SPT . base , buf , len ) ; nul = & SPT . base [ len ] ; if ( nul < SPT . nul ) { * SPT . nul = '.' ; } if ( nul == SPT . nul && & nul [ 1 ] < SPT . end ) { * SPT . nul = ' ' ; * ++ nul = '\\0' ; } return ; error SPT . error = error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void __static_key_deferred_flush ( void * key , struct delayed_work * work ) { STATIC_KEY_CHECK_USE ( key ) ; flush_delayed_work ( work , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "print_settings_save ( ) { GKeyFile * key_file = print_settings_key_file_from_settings ( data ) ; if ( gimp_image_is_valid ( data -> image ) ) { gdouble xres ; gdouble yres ; gimp_image_get_resolution ( data -> image , & xres , & yres ) ; g_key_file_set_integer ( key_file , \"image-setup\" , \"unit\" , data -> unit ) ; if ( ( data -> min_xres <= xres && ABS ( xres - data -> xres ) > 0.1 ) || ( data -> min_yres <= yres && ABS ( yres - data -> yres ) > 0.1 ) || ( data -> min_xres > xres && ABS ( data -> min_xres - data -> xres ) > 0.1 ) || ( data -> min_yres > yres && ABS ( data -> min_yres - data -> yres ) > 0.1 ) ) { g_key_file_set_double ( key_file , \"image-setup\" , \"x-resolution\" , data -> xres ) ; g_key_file_set_double ( key_file , \"image-setup\" , \"y-resolution\" , data -> yres ) ; } g_key_file_set_double ( key_file , \"image-setup\" , \"x-offset\" , data -> offset_x ) ; g_key_file_set_double ( key_file , \"image-setup\" , \"y-offset\" , data -> offset_y ) ; g_key_file_set_integer ( key_file , \"image-setup\" , \"center-mode\" , data -> center ) ; g_key_file_set_boolean ( key_file , \"image-setup\" , \"use-full-page\" , data -> use_full_page ) ; g_key_file_set_boolean ( key_file , \"image-setup\" , \"crop-marks\" , data -> draw_crop_marks ) ; print_utils_key_file_save_as_parasite ( key_file , data -> image , PRINT_SETTINGS_NAME ) ; } g_key_file_remove_key ( key_file , \"image-setup\" , \"x-resolution\" ) ; g_key_file_remove_key ( key_file , \"image-setup\" , \"y-resolution\" , NULL ) ; g_key_file_remove_key ( key_file , \"image-setup\" , \"x-offset\" , NULL ) ; g_key_file_remove_key ( key_file , \"image-setup\" , \"y-offset\" , NULL ) ; g_key_file_remove_key ( key_file , PRINT_SETTINGS_NAME , \"n-copies\" , NULL ) ; print_utils_key_file_save_as_rcfile ( key_file , PRINT_SETTINGS_NAME ) ; g_key_file_free ( key_file ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static size_t modpath_strlen ( const char * path , const char * origin_root ) { int len = 0 ; const char * s ; s = path ; len = 0 ; for ( s = path ; * s != '\\0' ; s ++ ) { if ( * s == '%' ) { s ++ ; switch ( * s ) { case 'i' : len += strlen ( isa_i_str ) ; break ; case 'I' : len += strlen ( isa_I_str ) ; break ; case 'o' : len += modpath_strlen ( MSG_ORIG ( MSG_STR_MODPATH ) , origin_root ) ; break ; case 'r' : len += strlen ( origin_root ) ; break ; case '%' : len ++ ; break ; default : elfedit_msg ( ELFEDIT_MSG_ERR , MSG_INTL ( MSG_ERR_BADPATHCODE ) , * s ) ; break ; } } else { len ++ ; } } return ( len ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __configfs_open_file ( struct inode * inode , struct file * file , int type ) { struct dentry * dentry = file -> f_path . dentry ; struct configfs_fragment * frag = to_frag ( file ) ; struct configfs_attribute * attr ; struct configfs_buffer * buffer ; int error ; error = - ENOMEM ; buffer = kzalloc ( sizeof ( configfs_buffer ) , GFP_KERNEL ) ; if ( ! buffer ) { out } error = - ENOENT ; down_read ( & frag -> frag_sem ) ; if ( unlikely ( frag -> frag_dead ) ) { out_free_buffer } error = - EINVAL ; buffer -> item = to_item ( dentry -> d_parent ) ; if ( ! buffer -> item ) { out_free_buffer } attr = to_attr ( dentry ) ; if ( ! attr ) { out_free_buffer } if ( type & CONFIGFS_ITEM_BIN_ATTR ) { buffer -> bin_attr = to_bin_attr ( dentry ) ; buffer -> cb_max_size = buffer -> bin_attr -> cb_max_size ; } else { buffer -> attr = attr ; } buffer -> owner = attr -> ca_owner ; error = - ENODEV ; if ( ! try_module_get ( buffer -> owner ) ) { out_free_buffer } error = - EACCES ; if ( ! buffer -> item -> ci_type ) { out_put_module } buffer -> ops = buffer -> item -> ci_type -> ct_item_ops ; if ( file -> f_mode & FMODE_WRITE ) { if ( ! ( inode -> i_mode & S_IWUGO ) ) { out_put_module } if ( ( type & CONFIGFS_ITEM_ATTR ) && ! attr -> store ) { out_put_module } if ( ( type & CONFIGFS_ITEM_BIN_ATTR ) && ! buffer -> bin_attr -> write ) { out_put_module } } if ( file -> f_mode & FMODE_READ ) { if ( ! ( inode -> i_mode & S_IRUGO ) ) { out_put_module } if ( ( type & CONFIGFS_ITEM_ATTR ) && ! attr -> show ) { out_put_module } if ( ( type & CONFIGFS_ITEM_BIN_ATTR ) && ! buffer -> bin_attr -> read ) { out_put_module } } mutex_init ( & buffer -> mutex ) ; buffer -> needs_read_fill = 1 ; buffer -> read_in_progress = false ; buffer -> write_in_progress = false ; file -> private_data = buffer ; up_read ( & frag -> frag_sem ) ; return 0 ; out_put_module module_put ( buffer -> owner ) ; out_free_buffer up_read ( & frag -> frag_sem ) ; out return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void h2_get_workers_config ( server_rec * s , int * pminw , int * pmaxw , apr_time_t * pidle_limit ) { int threads_per_child ; * pminw = h2_config_sgeti ( s , H2_CONF_MIN_WORKERS ) ; * pmaxw = h2_config_sgeti ( s , H2_CONF_MAX_WORKERS ) ; ap_mpm_query ( AP_MPMQ_MAX_THREADS , & threads_per_child ) ; if ( * pminw <= 0 ) { * pminw = threads_per_child ; } if ( * pmaxw <= 0 ) { * pmaxw = H2MAX ( 4 , 3 * ( * pminw ) / 2 ) ; } * pidle_limit = h2_config_sgeti64 ( s , H2_CONF_MAX_WORKER_IDLE_LIMIT ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int __mlx4_cq_alloc_icm ( struct mlx4_dev * dev , int * cqn ) { struct mlx4_priv * priv = mlx4_priv ( dev ) ; struct mlx4_cq_table * cq_table = & priv -> cq_table ; int err ; * cqn = mlx4_bitmap_alloc ( & cq_table -> bitmap ) ; err = mlx4_table_get ( dev , & cq_table -> table , * cqn , GFP_KERNEL ) ; if ( err ) { err_out } err = mlx4_table_get ( dev , & cq_table -> cmpt_table , * cqn , GFP_KERNEL ) ; if ( err ) { err_put } return 0 ; err_put mlx4_table_put ( dev , & cq_table -> table , * cqn ) ; err_out mlx4_bitmap_free ( & cq_table -> bitmap , * cqn , MLX4_NO_RR ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ppl_write_empty_header ( struct ppl_log * log ) { struct page * page ; struct ppl_header * pplhdr ; struct md_rdev * rdev = log -> rdev ; int ret = 0 ; pr_debug ( \"%s: disk: %d ppl_sector: %llu\\n\" , __func__ , rdev -> raid_disk , ( unsigned long long ) rdev -> ppl . sector ) ; page = alloc_page ( GFP_NOIO | __GFP_ZERO ) ; if ( ! page ) { return - ENOMEM ; } pplhdr = page_address ( page ) ; pplhdr -> signature = cpu_to_le32 ( log -> ppl_conf -> signature ) ; pplhdr -> checksum = cpu_to_le32 ( ~crc32c_le ( ~ 0 , pplhdr , PAGE_SIZE ) ) ; if ( ! sync_page_io ( rdev , rdev -> ppl . sector - rdev -> data_offset , PPL_HEADER_SIZE , page , REQ_OP_WRITE | REQ_FUA , 0 , false ) ) { md_error ( rdev -> mddev , rdev ) ; ret = - EIO ; } __free_page ( page ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int intel_create_dai ( struct sdw_cdns * cdns , struct snd_soc_dai_driver * dais , enum intel_pdi_type type , u32 num , u32 off , u32 max_ch ) { int i ; if ( num == 0 ) { return 0 ; } for ( i = off ; i < ( off + num ) ; i ++ ) { dais [ i ] . name = devm_kasprintf ( cdns -> dev , GFP_KERNEL , \"SDW%d Pin%d\" , cdns -> instance , i ) ; if ( type == INTEL_PDI_BD || type == INTEL_PDI_OUT ) { dais [ i ] . playback . channels_min = 1 ; dais [ i ] . playback . channels_max = max_ch ; dais [ i ] . playback . rates = SNDRV_PCM_RATE_48000 ; dais [ i ] . playback . formats = SNDRV_PCM_FMTBIT_S16_LE ; } if ( type == INTEL_PDI_BD || type == INTEL_PDI_IN ) { dais [ i ] . capture . channels_min = 1 ; dais [ i ] . capture . channels_max = max_ch ; dais [ i ] . capture . rates = SNDRV_PCM_RATE_48000 ; dais [ i ] . capture . formats = SNDRV_PCM_FMTBIT_S16_LE ; } dais [ i ] . ops = & intel_pcm_dai_ops ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MPIR_PROCDESC * MPIR_proctable ; int MPIR_proctable_size ; volatile int MPIR_debug_state ; volatile int MPIR_debug_gate ; int MPIR_being_debugged ; int MPIR_i_am_starter ; int MPIR_acquired_pre_main ; char * totalview_jobid ; char * totalview_stepid ; void MPIR_Breakpoint ( void ) { debug ( \"In MPIR_Breakpoint\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pmic_mpp_get ( struct gpio_chip * chip , unsigned pin ) { struct pmic_mpp_state * state = gpiochip_get_data ( chip ) ; struct pmic_mpp_pad * pad ; int ret ; pad = state -> ctrl -> desc -> pins [ pin ] . drv_data ; if ( pad -> input_enabled ) { ret = pmic_mpp_read ( state , pad , PMIC_MPP_REG_RT_STS ) ; pad -> out_value = ret & PMIC_MPP_REG_RT_STS_VAL_MASK ; } return ! ! pad -> out_value ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void match_kmalloc ( const char * fn , struct expression * expr , void * unused ) { char * name ; struct symbol * sym ; name = my_get_variable ( expr -> left , & sym ) ; set_state ( my_id , name , sym , & alloced ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned if_nametoindex_win ( const char * ifname ) { HMODULE library ; unsigned index = 0 ; if ( ( library = LoadLibrary ( TEXT ( \"Iphlpapi\" ) ) ) != NULL ) { if_nametoindex_funcptr_t if_nametoindex_funcptr ; if ( ( if_nametoindex_funcptr = ( if_nametoindex_funcptr_t ) GetProcAddress ( library , \"if_nametoindex\" ) ) != NULL ) { index = if_nametoindex_funcptr ( ifname ) ; } } return index ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void rbio_orig_end_io ( struct btrfs_raid_bio * rbio , int err ) { struct bio * cur = bio_list_get ( & rbio -> bio_list ) ; struct bio * next ; if ( rbio -> generic_bio_cnt ) { btrfs_bio_counter_sub ( rbio -> fs_info , rbio -> generic_bio_cnt ) ; } while ( cur ) { next = cur -> bi_next ; cur -> bi_next = NULL ; cur -> bi_error = err ; bio_endio ( cur ) ; cur = next ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int gk20a_instobj_new ( struct nvkm_instmem * base , u32 size , u32 align , bool zero , struct nvkm_memory * * pmemory ) { struct gk20a_instmem * imem = gk20a_instmem ( base ) ; struct nvkm_subdev * subdev = & imem -> base . subdev ; struct gk20a_instobj * node = NULL ; int ret ; nvkm_debug ( subdev , \"%s (%s): size: %x align: %x\\n\" , __func__ , imem -> domain ?\"IOMMU\" : \"DMA\" , size , align ) ; size = max ( roundup ( size , PAGE_SIZE ) , PAGE_SIZE ) ; align = max ( roundup ( align , PAGE_SIZE ) , PAGE_SIZE ) ; if ( imem -> domain ) { ret = gk20a_instobj_ctor_iommu ( imem , size >> PAGE_SHIFT , align , & node ) ; } else { ret = gk20a_instobj_ctor_dma ( imem , size >> PAGE_SHIFT , align , & node ) ; } * pmemory = node ?& node -> memory : NULL ; node -> imem = imem ; node -> mem . size = size >> 12 ; node -> mem . memtype = 0 ; node -> mem . page_shift = 12 ; nvkm_debug ( subdev , \"alloc size: 0x%x, align: 0x%x, gaddr: 0x%llx\\n\" , size , align , node -> mem . offset ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void show_gpci_data ( struct seq_file * m ) { struct hv_gpci_request_buffer * buf ; unsigned int affinity_score ; long ret ; buf = kmalloc ( sizeof ( * buf ) , GFP_KERNEL ) ; if ( buf == NULL ) { return ; } memset ( & buf -> params , 0 , sizeof ( buf -> params ) ) ; buf -> params . counter_request = cpu_to_be32 ( 0xB1 ) ; buf -> params . starting_index = cpu_to_be32 ( - 1 ) ; buf -> params . counter_info_version_in = 0x5 ; ret = plpar_hcall_norets ( H_GET_PERF_COUNTER_INFO , virt_to_phys ( buf ) , sizeof ( * buf ) ) ; if ( ret != H_SUCCESS ) { pr_debug ( \"hcall failed: H_GET_PERF_COUNTER_INFO: %ld, %x\\n\" , ret , be32_to_cpu ( buf -> params . detail_rc ) ) ; out } affinity_score = buf -> bytes [ 0xB ] ; seq_printf ( m , \"partition_affinity_score=%u\\n\" , affinity_score ) ; out } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int check_version ( int ver , char * fname ) { FILE * fp ; char line [ BUFSIZ ] ; char * p ; int version ; p = line ; while ( fgets ( p , BUFSIZ , fp ) ) { if ( strncmp ( p , VSTR , strlen ( VSTR ) ) == 0 ) { p += strlen ( VSTR ) ; if ( * p ) { version = atoi ( p ) ; } else { return ( 3 ) ; } ( void ) fclose ( fp ) ; return ( ( version != ver ) ?1 : 0 ) ; } p = line ; } return ( 3 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct page * get_err_page ( struct cxlflash_cfg * cfg ) { struct page * err_page = global . err_page ; struct device * dev = & cfg -> dev -> dev ; if ( unlikely ( ! err_page ) ) { err_page = alloc_page ( GFP_KERNEL ) ; if ( unlikely ( ! err_page ) ) { dev_err ( dev , \"%s: Unable to allocate err_page\\n\" , __func__ ) ; out } mutex_lock ( & global . mutex ) ; if ( likely ( ! global . err_page ) ) { global . err_page = err_page ; } else { __free_page ( err_page ) ; err_page = global . err_page ; } mutex_unlock ( & global . mutex ) ; } out dev_dbg ( dev , \"%s: returning err_page=%p\\n\" , __func__ , err_page ) ; return err_page ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cxl_attach_afu_directed_psl8 ( struct cxl_context * ctx , u64 wed , u64 amr ) { u32 pid ; int result ; cxl_assign_psn_space ( ctx ) ; ctx -> elem -> ctxtime = 0 ; ctx -> elem -> lpid = cpu_to_be32 ( mfspr ( SPRN_LPID ) ) ; ctx -> elem -> haurp = 0 ; ctx -> elem -> u . sdr = cpu_to_be64 ( mfspr ( SPRN_SDR1 ) ) ; pid = current -> pid ; if ( ctx -> kernel ) { pid = 0 ; } ctx -> elem -> common . pid = cpu_to_be32 ( pid ) ; ctx -> elem -> sr = cpu_to_be64 ( calculate_sr ( ctx ) ) ; ctx -> elem -> common . csrp = 0 ; ctx -> elem -> common . u . psl8 . aurp0 = 0 ; ctx -> elem -> common . u . psl8 . aurp1 = 0 ; cxl_prefault ( ctx , wed ) ; ctx -> elem -> common . u . psl8 . sstp0 = cpu_to_be64 ( ctx -> sstp0 ) ; ctx -> elem -> common . u . psl8 . sstp1 = cpu_to_be64 ( ctx -> sstp1 ) ; if ( ctx -> irqs . range [ 0 ] == 0 ) { ctx -> irqs . offset [ 0 ] = ctx -> afu -> native -> psl_hwirq ; ctx -> irqs . range [ 0 ] = 1 ; } update_ivtes_directed ( ctx ) ; ctx -> elem -> common . amr = cpu_to_be64 ( amr ) ; ctx -> elem -> common . wed = cpu_to_be64 ( wed ) ; if ( ( result = cxl_ops -> afu_check_and_enable ( ctx -> afu ) ) ) { return result ; } return add_process_element ( ctx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MOD_INIT ( ) { CommandAdd ( modinfo -> handle , \"SREPLY\" , cmd_sreply , MAXPARA , CMD_SERVER ) ; MARK_AS_OFFICIAL_MODULE ( modinfo , NULL ) ; return MOD_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void irdma_puda_send_buf ( struct irdma_puda_rsrc * rsrc , struct irdma_puda_buf * buf ) { struct irdma_puda_send_info info ; int ret = 0 ; cfs_time_t flags ; spin_lock_irqsave ( & rsrc -> bufpool_lock , flags ) ; if ( ! rsrc -> tx_wqe_avail_cnt || ( buf && ! list_empty ( & rsrc -> txpend ) ) ) { list_add_tail ( & buf -> list , & rsrc -> txpend ) ; spin_unlock_irqrestore ( & rsrc -> bufpool_lock , flags ) ; rsrc -> stats_sent_pkt_q ++ ; if ( rsrc -> type == IRDMA_PUDA_RSRC_TYPE_ILQ ) { ibdev_dbg ( to_ibdev ( rsrc -> dev ) , \"PUDA: adding to txpend\\n\" ) ; } return ; } rsrc -> tx_wqe_avail_cnt -- ; if ( ! buf ) { buf = irdma_puda_get_listbuf ( & rsrc -> txpend ) ; if ( ! buf ) { done } } info . scratch = buf ; info . paddr = buf -> mem . pa ; info . len = buf -> totallen ; info . tcplen = buf -> tcphlen ; info . ipv4 = buf -> ipv4 ; if ( rsrc -> dev -> hw_attrs . uk_attrs . hw_rev >= IRDMA_GEN_2 ) { info . ah_id = buf -> ah_id ; } else { info . maclen = buf -> maclen ; info . do_lpb = buf -> do_lpb ; } dma_sync_single_for_cpu ( rsrc -> dev -> hw -> device , buf -> mem . pa , buf -> mem . size , DMA_BIDIRECTIONAL ) ; ret = irdma_puda_send ( & rsrc -> qp , & info ) ; if ( ret ) { rsrc -> tx_wqe_avail_cnt ++ ; rsrc -> stats_sent_pkt_q ++ ; list_add ( & buf -> list , & rsrc -> txpend ) ; if ( rsrc -> type == IRDMA_PUDA_RSRC_TYPE_ILQ ) { ibdev_dbg ( to_ibdev ( rsrc -> dev ) , \"PUDA: adding to puda_send\\n\" ) ; } } else { rsrc -> stats_pkt_sent ++ ; } done spin_unlock_irqrestore ( & rsrc -> bufpool_lock , flags ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "off_t GFileGetSize ( char * name ) { struct stat buf ; long rc ; return ( buf . st_size ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int alps_init ( struct psmouse * psmouse ) { struct alps_data * priv = psmouse -> private ; struct input_dev * dev1 = psmouse -> dev ; int error ; error = priv -> hw_init ( psmouse ) ; if ( error ) { init_fail } __clear_bit ( EV_REL , dev1 -> evbit ) ; __clear_bit ( REL_X , dev1 -> relbit ) ; __clear_bit ( REL_Y , dev1 -> relbit ) ; dev1 -> evbit [ BIT_WORD ( EV_KEY ) ] |= BIT_MASK ( EV_KEY ) ; dev1 -> keybit [ BIT_WORD ( BTN_TOUCH ) ] |= BIT_MASK ( BTN_TOUCH ) ; dev1 -> keybit [ BIT_WORD ( BTN_TOOL_FINGER ) ] |= BIT_MASK ( BTN_TOOL_FINGER ) ; dev1 -> keybit [ BIT_WORD ( BTN_LEFT ) ] |= BIT_MASK ( BTN_LEFT ) | BIT_MASK ( BTN_RIGHT ) ; dev1 -> evbit [ BIT_WORD ( EV_ABS ) ] |= BIT_MASK ( EV_ABS ) ; priv -> set_abs_params ( priv , dev1 ) ; if ( priv -> flags & ALPS_WHEEL ) { dev1 -> evbit [ BIT_WORD ( EV_REL ) ] |= BIT_MASK ( EV_REL ) ; dev1 -> relbit [ BIT_WORD ( REL_WHEEL ) ] |= BIT_MASK ( REL_WHEEL ) ; } if ( priv -> flags & ( ALPS_FW_BK_1 | ALPS_FW_BK_2 ) ) { dev1 -> keybit [ BIT_WORD ( BTN_FORWARD ) ] |= BIT_MASK ( BTN_FORWARD ) ; dev1 -> keybit [ BIT_WORD ( BTN_BACK ) ] |= BIT_MASK ( BTN_BACK ) ; } if ( priv -> flags & ALPS_FOUR_BUTTONS ) { dev1 -> keybit [ BIT_WORD ( BTN_0 ) ] |= BIT_MASK ( BTN_0 ) ; dev1 -> keybit [ BIT_WORD ( BTN_1 ) ] |= BIT_MASK ( BTN_1 ) ; dev1 -> keybit [ BIT_WORD ( BTN_2 ) ] |= BIT_MASK ( BTN_2 ) ; dev1 -> keybit [ BIT_WORD ( BTN_3 ) ] |= BIT_MASK ( BTN_3 ) ; } if ( priv -> flags & ALPS_BUTTONPAD ) { set_bit ( INPUT_PROP_BUTTONPAD , dev1 -> propbit ) ; clear_bit ( BTN_RIGHT , dev1 -> keybit ) ; } else { dev1 -> keybit [ BIT_WORD ( BTN_MIDDLE ) ] |= BIT_MASK ( BTN_MIDDLE ) ; } if ( priv -> flags & ALPS_DUALPOINT ) { struct input_dev * dev2 ; dev2 = input_allocate_device ( ) ; if ( ! dev2 ) { psmouse_err ( psmouse , \"failed to allocate trackstick device\\n\" ) ; error = - ENOMEM ; init_fail } sprintf ( priv -> phys2 , \"%s/input1\" , psmouse -> ps2dev . serio -> phys ) ; dev2 -> phys = priv -> phys2 ; dev2 -> name = \"AlpsPS/2 ALPS DualPoint Stick\" ; dev2 -> id . bustype = BUS_I8042 ; dev2 -> id . vendor = 0x0002 ; dev2 -> id . product = PSMOUSE_ALPS ; dev2 -> id . version = priv -> proto_version ; dev2 -> dev . parent = & psmouse -> ps2dev . serio -> dev ; input_set_capability ( dev2 , EV_REL , REL_X ) ; input_set_capability ( dev2 , EV_REL , REL_Y ) ; if ( priv -> flags & ALPS_DUALPOINT_WITH_PRESSURE ) { input_set_capability ( dev2 , EV_ABS , ABS_PRESSURE ) ; input_set_abs_params ( dev2 , ABS_PRESSURE , 0 , 127 , 0 , 0 ) ; } input_set_capability ( dev2 , EV_KEY , BTN_LEFT ) ; input_set_capability ( dev2 , EV_KEY , BTN_RIGHT ) ; input_set_capability ( dev2 , EV_KEY , BTN_MIDDLE ) ; __set_bit ( INPUT_PROP_POINTER , dev2 -> propbit ) ; __set_bit ( INPUT_PROP_POINTING_STICK , dev2 -> propbit ) ; error = input_register_device ( dev2 ) ; if ( error ) { psmouse_err ( psmouse , \"failed to register trackstick device: %d\\n\" , error ) ; input_free_device ( dev2 ) ; init_fail } priv -> dev2 = dev2 ; } priv -> psmouse = psmouse ; INIT_DELAYED_WORK ( & priv -> dev3_register_work , alps_register_bare_ps2_mouse ) ; psmouse -> protocol_handler = alps_process_byte ; psmouse -> poll = alps_poll ; psmouse -> disconnect = alps_disconnect ; psmouse -> reconnect = alps_reconnect ; psmouse -> pktsize = priv -> proto_version == ALPS_PROTO_V4 ?8 : 6 ; psmouse -> resync_time = 0 ; psmouse -> resetafter = psmouse -> pktsize * 2 ; return 0 ; init_fail psmouse_reset ( psmouse ) ; kfree ( psmouse -> private ) ; psmouse -> private = NULL ; return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool nfp_nfdk_tx_xdp_buf ( struct nfp_net_dp * dp , struct nfp_net_rx_ring * rx_ring , struct nfp_net_tx_ring * tx_ring , struct nfp_net_rx_buf * rxbuf , unsigned int dma_off , unsigned int pkt_len , bool * completed ) { unsigned int dma_map_sz = dp -> fl_bufsz - NFP_NET_RX_BUF_NON_DATA ; unsigned int dma_len , type , cnt , dlen_type , tmp_dlen ; struct nfp_nfdk_tx_buf * txbuf ; struct nfp_nfdk_tx_desc * txd ; unsigned int n_descs ; dma_addr_t dma_addr ; int wr_idx ; if ( unlikely ( nfp_net_tx_full ( tx_ring , NFDK_TX_DESC_STOP_CNT ) ) ) { if ( ! * completed ) { nfp_nfdk_xdp_complete ( tx_ring ) ; * completed = true ; } if ( unlikely ( nfp_net_tx_full ( tx_ring , NFDK_TX_DESC_STOP_CNT ) ) ) { nfp_nfdk_rx_drop ( dp , rx_ring -> r_vec , rx_ring , rxbuf , NULL ) ; return false ; } } n_descs = nfp_nfdk_headlen_to_segs ( pkt_len ) ; if ( ( round_down ( tx_ring -> wr_p , NFDK_TX_DESC_BLOCK_CNT ) != round_down ( tx_ring -> wr_p + n_descs , NFDK_TX_DESC_BLOCK_CNT ) ) || ( ( u32 ) tx_ring -> data_pending + pkt_len > NFDK_TX_MAX_DATA_PER_BLOCK ) ) { unsigned int nop_slots = D_BLOCK_CPL ( tx_ring -> wr_p ) ; wr_idx = D_IDX ( tx_ring , tx_ring -> wr_p ) ; txd = & tx_ring -> ktxds [ wr_idx ] ; memset ( txd , 0 , array_size ( nop_slots , sizeof ( nfp_nfdk_tx_desc ) ) ) ; tx_ring -> data_pending = 0 ; tx_ring -> wr_p += nop_slots ; tx_ring -> wr_ptr_add += nop_slots ; } wr_idx = D_IDX ( tx_ring , tx_ring -> wr_p ) ; txbuf = & tx_ring -> ktxbufs [ wr_idx ] ; txbuf [ 0 ] . val = ( unsigned long ) rxbuf -> frag | NFDK_TX_BUF_INFO_SOP ; txbuf [ 1 ] . dma_addr = rxbuf -> dma_addr ; dma_sync_single_for_device ( dp -> dev , rxbuf -> dma_addr + dma_off , pkt_len , DMA_BIDIRECTIONAL ) ; txd = & tx_ring -> ktxds [ wr_idx ] ; dma_len = pkt_len ; dma_addr = rxbuf -> dma_addr + dma_off ; if ( dma_len <= NFDK_TX_MAX_DATA_PER_HEAD ) { type = NFDK_DESC_TX_TYPE_SIMPLE ; } else { type = NFDK_DESC_TX_TYPE_GATHER ; } dma_len -= 1 ; dlen_type = FIELD_PREP ( NFDK_DESC_TX_DMA_LEN_HEAD , dma_len > NFDK_DESC_TX_DMA_LEN_HEAD ?NFDK_DESC_TX_DMA_LEN_HEAD : dma_len ) | FIELD_PREP ( NFDK_DESC_TX_TYPE_HEAD , type ) ; txd -> dma_len_type = cpu_to_le16 ( dlen_type ) ; nfp_desc_set_dma_addr_48b ( txd , dma_addr ) ; tmp_dlen = dlen_type & NFDK_DESC_TX_DMA_LEN_HEAD ; dma_len -= tmp_dlen ; dma_addr += tmp_dlen + 1 ; txd ++ ; while ( dma_len > 0 ) { dma_len -= 1 ; dlen_type = FIELD_PREP ( NFDK_DESC_TX_DMA_LEN , dma_len ) ; txd -> dma_len_type = cpu_to_le16 ( dlen_type ) ; nfp_desc_set_dma_addr_48b ( txd , dma_addr ) ; dlen_type &= NFDK_DESC_TX_DMA_LEN ; dma_len -= dlen_type ; dma_addr += dlen_type + 1 ; txd ++ ; } ( txd - 1 ) -> dma_len_type = cpu_to_le16 ( dlen_type | NFDK_DESC_TX_EOP ) ; txd -> raw = 0 ; txd ++ ; cnt = txd - tx_ring -> ktxds - wr_idx ; tx_ring -> wr_p += cnt ; if ( tx_ring -> wr_p % NFDK_TX_DESC_BLOCK_CNT ) { tx_ring -> data_pending += pkt_len ; } else { tx_ring -> data_pending = 0 ; } tx_ring -> wr_ptr_add += cnt ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void evhttp_get_body ( struct evhttp_connection * evcon , struct evhttp_request * req ) { const char * xfer_enc ; if ( req -> kind == EVHTTP_REQUEST && ! evhttp_method_may_have_body ( req -> type ) ) { evhttp_connection_done ( evcon ) ; return ; } evcon -> state = EVCON_READING_BODY ; xfer_enc = evhttp_find_header ( req -> input_headers , \"Transfer-Encoding\" ) ; if ( xfer_enc != NULL && evutil_ascii_strcasecmp ( xfer_enc , \"chunked\" ) == 0 ) { req -> ntoread = - 1 ; } else { if ( evhttp_get_body_length ( req ) == - 1 ) { evhttp_connection_fail_ ( evcon , EVREQ_HTTP_INVALID_HEADER ) ; return ; } if ( req -> kind == EVHTTP_REQUEST && req -> ntoread < 1 ) { evhttp_connection_done ( evcon ) ; return ; } } if ( req -> kind == EVHTTP_REQUEST && REQ_VERSION_ATLEAST ( req , 1 , 1 ) ) { const char * expect ; expect = evhttp_find_header ( req -> input_headers , \"Expect\" ) ; if ( expect ) { if ( ! evutil_ascii_strcasecmp ( expect , \"100-continue\" ) ) { if ( req -> ntoread > 0 ) { if ( ( req -> evcon -> max_body_size <= EV_INT64_MAX ) && ( ev_uint64_t ) req -> ntoread > req -> evcon -> max_body_size ) { evhttp_send_error ( req , HTTP_ENTITYTOOLARGE , NULL ) ; return ; } } if ( ! evbuffer_get_length ( bufferevent_get_input ( evcon -> bufev ) ) ) { evhttp_send_continue ( evcon , req ) ; } } else { evhttp_send_error ( req , HTTP_EXPECTATIONFAILED , NULL ) ; return ; } } } evhttp_read_body ( evcon , req ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void axisdev88_init ( MachineState * machine ) { const char * kernel_filename = machine -> kernel_filename ; const char * kernel_cmdline = machine -> kernel_cmdline ; CRISCPU * cpu ; DeviceState * dev ; SysBusDevice * s ; DriveInfo * nand ; qemu_irq irq [ 30 ] , nmi [ 2 ] ; void * etraxfs_dmac ; struct etraxfs_dma_client * dma_eth ; int i ; MemoryRegion * address_space_mem = get_system_memory ( ) ; MemoryRegion * phys_intmem = g_new ( MemoryRegion , 1 ) ; cpu = CRIS_CPU ( cpu_create ( machine -> cpu_type ) ) ; memory_region_add_subregion ( address_space_mem , 0x40000000 , machine -> ram ) ; memory_region_init_ram ( phys_intmem , NULL , \"axisdev88.chipram\" , INTMEM_SIZE , & error_abort ) ; memory_region_add_subregion ( address_space_mem , 0x38000000 , phys_intmem ) ; nand = drive_get ( IF_MTD , 0 , 0 ) ; nand_state . nand = nand_init ( nand ?blk_by_legacy_dinfo ( nand ) : NULL , NAND_MFR_STMICRO , 0x39 ) ; memory_region_init_io ( & nand_state . iomem , NULL , & nand_ops , & nand_state , \"nand\" , 0x05000000 ) ; memory_region_add_subregion ( address_space_mem , 0x10000000 , & nand_state . iomem ) ; gpio_state . nand = & nand_state ; memory_region_init_io ( & gpio_state . iomem , NULL , & gpio_ops , & gpio_state , \"gpio\" , 0x5c ) ; memory_region_add_subregion ( address_space_mem , 0x3001a000 , & gpio_state . iomem ) ; dev = qdev_new ( \"etraxfs-pic\" ) ; s = SYS_BUS_DEVICE ( dev ) ; sysbus_realize_and_unref ( s , & error_fatal ) ; sysbus_mmio_map ( s , 0 , 0x3001c000 ) ; sysbus_connect_irq ( s , 0 , qdev_get_gpio_in ( DEVICE ( cpu ) , CRIS_CPU_IRQ ) ) ; sysbus_connect_irq ( s , 1 , qdev_get_gpio_in ( DEVICE ( cpu ) , CRIS_CPU_NMI ) ) ; for ( i = 0 ; i < 30 ; i ++ ) { irq [ i ] = qdev_get_gpio_in ( dev , i ) ; } nmi [ 0 ] = qdev_get_gpio_in ( dev , 30 ) ; nmi [ 1 ] = qdev_get_gpio_in ( dev , 31 ) ; etraxfs_dmac = etraxfs_dmac_init ( 0x30000000 , 10 ) ; for ( i = 0 ; i < 10 ; i ++ ) { etraxfs_dmac_connect ( etraxfs_dmac , i , irq + 7 + i , i & 1 ) ; } dma_eth = g_malloc0 ( sizeof dma_eth [ 0 ] * 4 ) ; etraxfs_eth_init ( & nd_table [ 0 ] , 0x30034000 , 1 , & dma_eth [ 0 ] , & dma_eth [ 1 ] ) ; if ( nb_nics > 1 ) { etraxfs_eth_init ( & nd_table [ 1 ] , 0x30036000 , 2 , & dma_eth [ 2 ] , & dma_eth [ 3 ] ) ; } etraxfs_dmac_connect_client ( etraxfs_dmac , 0 , & dma_eth [ 0 ] ) ; etraxfs_dmac_connect_client ( etraxfs_dmac , 1 , & dma_eth [ 1 ] ) ; if ( nb_nics > 1 ) { etraxfs_dmac_connect_client ( etraxfs_dmac , 6 , & dma_eth [ 2 ] ) ; etraxfs_dmac_connect_client ( etraxfs_dmac , 7 , & dma_eth [ 3 ] ) ; } sysbus_create_varargs ( \"etraxfs-timer\" , 0x3001e000 , irq [ 0x1b ] , nmi [ 1 ] , NULL ) ; sysbus_create_varargs ( \"etraxfs-timer\" , 0x3005e000 , irq [ 0x1b ] , nmi [ 1 ] , NULL ) ; for ( i = 0 ; i < 4 ; i ++ ) { etraxfs_ser_create ( 0x30026000 + i * 0x2000 , irq [ 0x14 + i ] , serial_hd ( i ) ) ; } if ( kernel_filename ) { li . image_filename = kernel_filename ; li . cmdline = kernel_cmdline ; li . ram_size = machine -> ram_size ; cris_load_image ( cpu , & li ) ; } if ( ! qtest_enabled ( ) ) { fprintf ( stderr , \"Kernel image must be specified\\n\" ) ; exit ( 1 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "irqreturn_t mtu3_ep0_isr ( struct mtu3 * mtu ) { void __iomem * mbase = mtu -> mac_base ; struct mtu3_request * mreq ; u32 int_status ; irqreturn_t ret = IRQ_NONE ; u32 csr ; u32 len ; int_status = mtu3_readl ( mbase , U3D_EPISR ) ; int_status &= mtu3_readl ( mbase , U3D_EPIER ) ; mtu3_writel ( mbase , U3D_EPISR , int_status ) ; if ( int_status & SETUPENDISR ) { mtu -> ep0_state = MU3D_EP0_STATE_SETUP ; } csr = mtu3_readl ( mbase , U3D_EP0CSR ) ; dev_dbg ( mtu -> dev , \"%s csr=0x%x\\n\" , __func__ , csr ) ; if ( csr & EP0_SENTSTALL ) { ep0_stall_set ( mtu -> ep0 , false , 0 ) ; csr = mtu3_readl ( mbase , U3D_EP0CSR ) ; ret = IRQ_HANDLED ; } dev_dbg ( mtu -> dev , \"ep0_state: %s\\n\" , decode_ep0_state ( mtu ) ) ; switch ( mtu -> ep0_state ) { case MU3D_EP0_STATE_TX : if ( ( csr & EP0_FIFOFULL ) == 0 ) { ep0_tx_state ( mtu ) ; ret = IRQ_HANDLED ; } break ; case MU3D_EP0_STATE_RX : if ( csr & EP0_RXPKTRDY ) { ep0_rx_state ( mtu ) ; ret = IRQ_HANDLED ; } break ; case MU3D_EP0_STATE_TX_END : mtu3_writel ( mbase , U3D_EP0CSR , ( csr & EP0_W1C_BITS ) | EP0_DATAEND ) ; mreq = next_ep0_request ( mtu ) ; if ( mreq ) { ep0_req_giveback ( mtu , & mreq -> request ) ; } mtu -> ep0_state = MU3D_EP0_STATE_SETUP ; ret = IRQ_HANDLED ; dev_dbg ( mtu -> dev , \"ep0_state: %s\\n\" , decode_ep0_state ( mtu ) ) ; break ; case MU3D_EP0_STATE_SETUP : if ( ! ( csr & EP0_SETUPPKTRDY ) ) { break ; } len = mtu3_readl ( mbase , U3D_RXCOUNT0 ) ; if ( len != 8 ) { dev_err ( mtu -> dev , \"SETUP packet len %d != 8 ?\\n\" , len ) ; break ; } ep0_handle_setup ( mtu ) ; ret = IRQ_HANDLED ; break ; default : ep0_stall_set ( mtu -> ep0 , true , 0 ) ; WARN_ON ( 1 ) ; break ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dpi_init_regulator ( struct dpi_data * dpi ) { struct regulator * vdds_dsi ; if ( dpi -> vdds_dsi_reg ) { return 0 ; } vdds_dsi = devm_regulator_get ( & dpi -> pdev -> dev , \"vdds_dsi\" ) ; if ( IS_ERR ( vdds_dsi ) ) { if ( PTR_ERR ( vdds_dsi ) != - EPROBE_DEFER ) { DSSERR ( \"can't get VDDS_DSI regulator\\n\" ) ; } return PTR_ERR ( vdds_dsi ) ; } dpi -> vdds_dsi_reg = vdds_dsi ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dw_pcie_ep_init ( struct dw_pcie_ep * ep ) { int ret ; void * addr ; u8 func_no ; struct resource * res ; struct pci_epc * epc ; struct dw_pcie * pci = to_dw_pcie_from_ep ( ep ) ; struct device * dev = pci -> dev ; struct platform_device * pdev = to_platform_device ( dev ) ; struct device_node * np = dev -> of_node ; const struct pci_epc_features * epc_features ; struct dw_pcie_ep_func * ep_func ; INIT_LIST_HEAD ( & ep -> func_list ) ; ret = dw_pcie_get_resources ( pci ) ; if ( ret ) { return ret ; } res = platform_get_resource_byname ( pdev , IORESOURCE_MEM , \"addr_space\" ) ; ep -> phys_base = res -> start ; ep -> addr_size = resource_size ( res ) ; dw_pcie_version_detect ( pci ) ; dw_pcie_iatu_detect ( pci ) ; ep -> ib_window_map = devm_bitmap_zalloc ( dev , pci -> num_ib_windows , GFP_KERNEL ) ; if ( ! ep -> ib_window_map ) { return - ENOMEM ; } ep -> ob_window_map = devm_bitmap_zalloc ( dev , pci -> num_ob_windows , GFP_KERNEL ) ; if ( ! ep -> ob_window_map ) { return - ENOMEM ; } addr = devm_kcalloc ( dev , pci -> num_ob_windows , sizeof ( phys_addr_t ) , GFP_KERNEL ) ; if ( ! addr ) { return - ENOMEM ; } ep -> outbound_addr = addr ; epc = devm_pci_epc_create ( dev , & epc_ops ) ; if ( IS_ERR ( epc ) ) { dev_err ( dev , \"Failed to create epc device\\n\" ) ; return PTR_ERR ( epc ) ; } ep -> epc = epc ; epc_set_drvdata ( epc , ep ) ; ret = of_property_read_u8 ( np , \"max-functions\" , & epc -> max_functions ) ; if ( ret < 0 ) { epc -> max_functions = 1 ; } for ( func_no = 0 ; func_no < epc -> max_functions ; func_no ++ ) { ep_func = devm_kzalloc ( dev , sizeof ( * ep_func ) , GFP_KERNEL ) ; if ( ! ep_func ) { return - ENOMEM ; } ep_func -> func_no = func_no ; ep_func -> msi_cap = dw_pcie_ep_find_capability ( ep , func_no , PCI_CAP_ID_MSI ) ; ep_func -> msix_cap = dw_pcie_ep_find_capability ( ep , func_no , PCI_CAP_ID_MSIX ) ; list_add_tail ( & ep_func -> list , & ep -> func_list ) ; } if ( ep -> ops -> ep_init ) { ep -> ops -> ep_init ( ep ) ; } ret = pci_epc_mem_init ( epc , ep -> phys_base , ep -> addr_size , ep -> page_size ) ; if ( ret < 0 ) { dev_err ( dev , \"Failed to initialize address space\\n\" ) ; return ret ; } ep -> msi_mem = pci_epc_mem_alloc_addr ( epc , & ep -> msi_mem_phys , epc -> mem -> window . page_size ) ; if ( ! ep -> msi_mem ) { ret = - ENOMEM ; dev_err ( dev , \"Failed to reserve memory for MSI/MSI-X\\n\" ) ; err_exit_epc_mem } ret = dw_pcie_edma_detect ( pci ) ; if ( ret ) { err_free_epc_mem } if ( ep -> ops -> get_features ) { epc_features = ep -> ops -> get_features ( ep ) ; if ( epc_features -> core_init_notifier ) { return 0 ; } } ret = dw_pcie_ep_init_complete ( ep ) ; if ( ret ) { err_remove_edma } return 0 ; err_remove_edma dw_pcie_edma_remove ( pci ) ; err_free_epc_mem pci_epc_mem_free_addr ( epc , ep -> msi_mem_phys , ep -> msi_mem , epc -> mem -> window . page_size ) ; err_exit_epc_mem pci_epc_mem_exit ( epc ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void wakeref_auto_timeout ( struct timer_list * t ) { struct intel_wakeref_auto * wf = from_timer ( wf , t , timer ) ; intel_wakeref_t wakeref ; unsigned long flags ; wakeref = fetch_and_zero ( & wf -> wakeref ) ; spin_unlock_irqrestore ( & wf -> lock , flags ) ; intel_runtime_pm_put ( wf -> rpm , wakeref ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( __ioremap ) ; void __iounmap ( void __iomem * addr ) { struct vm_struct * p ; if ( ( unsigned long ) addr > CONFIG_NIOS2_IO_REGION_BASE ) { return ; } p = remove_vm_area ( ( void * ) ( PAGE_MASK & ( unsigned long __force ) addr ) ) ; if ( ! p ) { pr_err ( \"iounmap: bad address %p\\n\" , addr ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tegra_bpmp_i2c_msg_xfer ( struct tegra_bpmp_i2c * i2c , struct mrq_i2c_request * request , struct mrq_i2c_response * response ) { struct tegra_bpmp_message msg ; int err ; request -> cmd = CMD_I2C_XFER ; request -> xfer . bus_id = i2c -> bus ; msg . mrq = MRQ_I2C ; msg . tx . data = request ; msg . tx . size = sizeof ( * request ) ; msg . rx . data = response ; msg . rx . size = sizeof ( * response ) ; if ( irqs_disabled ( ) ) { err = tegra_bpmp_transfer_atomic ( i2c -> bpmp , & msg ) ; } else { err = tegra_bpmp_transfer ( i2c -> bpmp , & msg ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int simplefb_clocks_get ( struct simplefb_par * par , struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct clk * clock ; int i ; if ( dev_get_platdata ( & pdev -> dev ) || ! np ) { return 0 ; } par -> clk_count = of_clk_get_parent_count ( np ) ; if ( ! par -> clk_count ) { return 0 ; } par -> clks = kcalloc ( par -> clk_count , sizeof ( clk * ) , GFP_KERNEL ) ; if ( ! par -> clks ) { return - ENOMEM ; } for ( i = 0 ; i < par -> clk_count ; i ++ ) { clock = of_clk_get ( np , i ) ; if ( IS_ERR ( clock ) ) { if ( PTR_ERR ( clock ) == - EPROBE_DEFER ) { while ( -- i >= 0 ) { if ( par -> clks [ i ] ) { clk_put ( par -> clks [ i ] ) ; } } return - EPROBE_DEFER ; } dev_err ( & pdev -> dev , \"%s: clock %d not found: %ld\\n\" , __func__ , i , PTR_ERR ( clock ) ) ; continue ; } par -> clks [ i ] = clock ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "fetch_inferior_registers ( ) { int tid ; tid = TIDGET ( inferior_ptid , NULL ) ; if ( tid == 0 ) { tid = PIDGET ( inferior_ptid ) ; } if ( regnum == - 1 || amd64_native_gregset_supplies_p ( regnum ) ) { elf_gregset_t regs ; if ( ptrace ( PTRACE_GETREGS , tid , 0 , ( long ) & regs ) < 0 ) { perror_with_name ( \"Couldn't get registers\" ) ; } amd64_supply_native_gregset ( current_regcache , & regs , - 1 ) ; if ( regnum != - 1 ) { return ; } } if ( regnum == - 1 || ! amd64_native_gregset_supplies_p ( regnum ) ) { elf_fpregset_t fpregs ; if ( ptrace ( PTRACE_GETFPREGS , tid , 0 , ( long ) & fpregs ) < 0 ) { perror_with_name ( \"Couldn't get floating point status\" ) ; } amd64_supply_fxsave ( current_regcache , - 1 , & fpregs ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mt7621_pcie_reset_ep_deassert ( struct mt7621_pcie * pcie ) { struct mt7621_pcie_port * port ; list_for_each_entry ( , , ) msleep ( PERST_DELAY_MS ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct irdma_ws_node * irdma_alloc_node ( struct irdma_sc_vsi * vsi , u8 user_pri , enum irdma_ws_node_type node_type , struct irdma_ws_node * parent ) { struct irdma_virt_mem ws_mem ; struct irdma_ws_node * node ; u16 node_index = 0 ; ws_mem . size = sizeof ( irdma_ws_node ) ; ws_mem . va = kzalloc ( ws_mem . size , GFP_KERNEL ) ; if ( ! ws_mem . va ) { return NULL ; } if ( parent ) { node_index = irdma_alloc_ws_node_id ( vsi -> dev ) ; if ( node_index == IRDMA_WS_NODE_INVALID ) { return NULL ; } } node = ws_mem . va ; node -> index = node_index ; node -> vsi_index = vsi -> vsi_idx ; INIT_LIST_HEAD ( & node -> child_list_head ) ; if ( node_type == WS_NODE_TYPE_LEAF ) { node -> type_leaf = true ; node -> traffic_class = vsi -> qos [ user_pri ] . traffic_class ; node -> user_pri = user_pri ; node -> rel_bw = vsi -> qos [ user_pri ] . rel_bw ; if ( ! node -> rel_bw ) { node -> rel_bw = 1 ; } node -> lan_qs_handle = vsi -> qos [ user_pri ] . lan_qos_handle ; node -> prio_type = IRDMA_PRIO_WEIGHTED_RR ; } else { node -> rel_bw = 1 ; node -> prio_type = IRDMA_PRIO_WEIGHTED_RR ; node -> enable = true ; } node -> parent = parent ; return node ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pwm_imx27_apply ( struct pwm_chip * chip , struct pwm_device * pwm , const struct pwm_state * state ) { unsigned long period_cycles , duty_cycles , prescale ; struct pwm_imx27_chip * imx = to_pwm_imx27_chip ( chip ) ; struct pwm_state cstate ; unsigned long long c ; unsigned long long clkrate ; int ret ; u32 cr ; pwm_get_state ( pwm , & cstate ) ; clkrate = clk_get_rate ( imx -> clk_per ) ; c = clkrate * state -> period ; do_div ( c , NSEC_PER_SEC ) ; period_cycles = c ; prescale = period_cycles / 0x10000 + 1 ; period_cycles /= prescale ; c = clkrate * state -> duty_cycle ; do_div ( c , NSEC_PER_SEC ) ; duty_cycles = c ; duty_cycles /= prescale ; if ( period_cycles > 2 ) { period_cycles -= 2 ; } else { period_cycles = 0 ; } if ( cstate . enabled ) { pwm_imx27_wait_fifo_slot ( chip , pwm ) ; } else { ret = pwm_imx27_clk_prepare_enable ( imx ) ; pwm_imx27_sw_reset ( chip ) ; } writel ( duty_cycles , imx -> mmio_base + MX3_PWMSAR ) ; writel ( period_cycles , imx -> mmio_base + MX3_PWMPR ) ; imx -> duty_cycle = duty_cycles ; cr = MX3_PWMCR_PRESCALER_SET ( prescale ) | MX3_PWMCR_STOPEN | MX3_PWMCR_DOZEN | MX3_PWMCR_WAITEN | FIELD_PREP ( MX3_PWMCR_CLKSRC , MX3_PWMCR_CLKSRC_IPG_HIGH ) | MX3_PWMCR_DBGEN ; if ( state -> polarity == PWM_POLARITY_INVERSED ) { cr |= FIELD_PREP ( MX3_PWMCR_POUTC , MX3_PWMCR_POUTC_INVERTED ) ; } if ( state -> enabled ) { cr |= MX3_PWMCR_EN ; } writel ( cr , imx -> mmio_base + MX3_PWMCR ) ; if ( ! state -> enabled ) { pwm_imx27_clk_disable_unprepare ( imx ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int exynos5_i2c_xfer ( struct i2c_adapter * adap , struct i2c_msg * msgs , int num ) { struct exynos5_i2c * i2c = adap -> algo_data ; int i , ret ; ret = clk_enable ( i2c -> pclk ) ; if ( ret ) { return ret ; } ret = clk_enable ( i2c -> clk ) ; if ( ret ) { err_pclk } for ( i = 0 ; i < num ; ++ i ) { ret = exynos5_i2c_xfer_msg ( i2c , msgs + i , i + 1 == num ) ; if ( ret ) { break ; } } clk_disable ( i2c -> clk , NULL ) ; err_pclk clk_disable ( i2c -> pclk ) ; return ret ?: num ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct clk * crg11_get ( struct of_phandle_args * clkspec , void * data ) { struct mb86s70_crg11 * crg11 = data ; struct clk_init_data init ; u32 cntrlr , domain , port ; struct crg_clk * crgclk ; struct clk * clk ; char clkp [ 20 ] ; if ( clkspec -> args_count != 3 ) { return ERR_PTR ( - EINVAL ) ; } cntrlr = clkspec -> args [ 0 ] ; domain = clkspec -> args [ 1 ] ; port = clkspec -> args [ 2 ] ; if ( port > 7 ) { snprintf ( clkp , 20 , \"UngatedCLK%d_%X\" , cntrlr , domain ) ; } else { snprintf ( clkp , 20 , \"CLK%d_%X_%d\" , cntrlr , domain , port ) ; } mutex_lock ( & crg11 -> lock ) ; clk = __clk_lookup ( clkp ) ; if ( clk ) { mutex_unlock ( & crg11 -> lock ) ; return clk ; } crgclk = kmalloc ( sizeof ( * crgclk ) , GFP_KERNEL ) ; if ( ! crgclk ) { mutex_unlock ( & crg11 -> lock ) ; return ERR_PTR ( - ENOMEM ) ; } init . name = clkp ; init . num_parents = 0 ; init . ops = & crg_port_ops ; init . flags = 0 ; crgclk -> hw . init = & init ; crgclk -> cntrlr = cntrlr ; crgclk -> domain = domain ; crgclk -> port = port ; clk = clk_register ( NULL , & crgclk -> hw ) ; if ( IS_ERR ( clk ) ) { pr_err ( \"%s:%d Error!\\n\" , __func__ , __LINE__ ) ; } else { pr_debug ( \"Registered %s\\n\" , clkp ) ; } clk_register_clkdev ( clk , clkp , NULL ) ; mutex_unlock ( & crg11 -> lock ) ; return clk ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static acpi_status aml_nfw_handler ( u32 function , acpi_physical_address address , u32 bit_width , u64 * value , void * handler_context , void * region_context ) { struct ia64_nfw_context * context = handler_context ; u8 * offset = ( u8 * ) context + address ; if ( address + ( bit_width >> 3 ) > sizeof ( ia64_nfw_context ) ) { return AE_BAD_PARAMETER ; } switch ( function ) { case ACPI_READ : if ( address == offsetof ( ia64_nfw_context , ret ) ) { aml_nfw_execute ( context ) ; } aml_nfw_read_arg ( offset , bit_width , value ) ; break ; case ACPI_WRITE : aml_nfw_write_arg ( offset , bit_width , value ) ; break ; } return AE_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mlx5e_macsec_init ( struct mlx5e_priv * priv ) { struct mlx5_core_dev * mdev = priv -> mdev ; struct mlx5e_macsec * macsec = NULL ; struct mlx5e_macsec_fs * macsec_fs ; int err ; if ( ! mlx5e_is_macsec_device ( priv -> mdev ) ) { mlx5_core_dbg ( mdev , \"Not a MACsec offload device\\n\" ) ; return 0 ; } macsec = kzalloc ( sizeof ( * macsec ) , GFP_KERNEL ) ; if ( ! macsec ) { return - ENOMEM ; } INIT_LIST_HEAD ( & macsec -> macsec_device_list_head ) ; mutex_init ( & macsec -> lock ) ; err = rhashtable_init ( & macsec -> sci_hash , & rhash_sci ) ; if ( err ) { mlx5_core_err ( mdev , \"MACsec offload: Failed to init SCI hash table, err=%d\\n\" , err ) ; err_hash } err = mlx5e_macsec_aso_init ( & macsec -> aso , priv -> mdev ) ; if ( err ) { mlx5_core_err ( mdev , \"MACsec offload: Failed to init aso, err=%d\\n\" , err ) ; err_aso } macsec -> wq = alloc_ordered_workqueue ( \"mlx5e_macsec_%s\" , 0 , priv -> netdev -> name ) ; if ( ! macsec -> wq ) { err = - ENOMEM ; err_wq } xa_init_flags ( & macsec -> sc_xarray , XA_FLAGS_ALLOC1 ) ; priv -> macsec = macsec ; macsec -> mdev = mdev ; macsec_fs = mlx5e_macsec_fs_init ( mdev , priv -> netdev ) ; if ( ! macsec_fs ) { err = - ENOMEM ; err_out } macsec -> macsec_fs = macsec_fs ; macsec -> nb . notifier_call = macsec_obj_change_event ; mlx5_notifier_register ( mdev , & macsec -> nb ) ; mlx5_core_dbg ( mdev , \"MACsec attached to netdevice\\n\" ) ; return 0 ; err_out destroy_workqueue ( macsec -> wq ) ; err_wq mlx5e_macsec_aso_cleanup ( & macsec -> aso , priv -> mdev ) ; err_aso rhashtable_destroy ( & macsec -> sci_hash ) ; err_hash priv -> macsec = NULL ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void mtk_register_reset_controller ( struct device_node * np , unsigned int num_regs , int regofs ) { struct mtk_reset * data ; int ret ; struct regmap * regmap ; regmap = syscon_node_to_regmap ( np ) ; if ( IS_ERR ( regmap ) ) { pr_err ( \"Cannot find regmap for %s: %ld\\n\" , np -> full_name , PTR_ERR ( regmap ) ) ; return ; } data = kzalloc ( sizeof ( * data ) , GFP_KERNEL ) ; if ( ! data ) { return ; } data -> regmap = regmap ; data -> regofs = regofs ; data -> rcdev . owner = THIS_MODULE ; data -> rcdev . nr_resets = num_regs * 32 ; data -> rcdev . ops = & mtk_reset_ops ; data -> rcdev . of_node = np ; ret = reset_controller_register ( & data -> rcdev ) ; if ( ret ) { pr_err ( \"could not register reset controller: %d\\n\" , ret ) ; return ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned int cpuworker_get_n_threads ( void ) { return threadpool_get_n_threads ( threadpool ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "cmsBool _cmsRegisterOptimizationPlugin ( cmsContext ContextID , cmsPluginBase * Data ) { cmsPluginOptimization * Plugin = ( cmsPluginOptimization * ) Data ; _cmsOptimizationPluginChunkType * ctx = ( _cmsOptimizationPluginChunkType * ) _cmsContextGetClientChunk ( ContextID , OptimizationPlugin ) ; _cmsOptimizationCollection * fl ; if ( Data == NULL ) { return TRUE ; } if ( Plugin -> OptimizePtr == NULL ) { return FALSE ; } fl = ( _cmsOptimizationCollection * ) _cmsPluginMalloc ( ContextID , sizeof ( _cmsOptimizationCollection ) ) ; if ( fl == NULL ) { return FALSE ; } fl -> OptimizePtr = Plugin -> OptimizePtr ; fl -> Next = ctx -> OptimizationCollection ; ctx -> OptimizationCollection = fl ; return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "DEF_TEST ( ) { c_avl_tree_t * tokens = c_avl_create ( ( int ( * ) ( const void * , const void * ) ) num_compare ) ; const char input [ ] \"testA1-testB2\" ; ; assert ( tokens != NULL ) ; int ret = snmp_agent_create_token ( input , 0 , 5 , tokens , NULL ) ; EXPECT_EQ_INT ( 0 , ret ) ; ret = snmp_agent_create_token ( input , 6 , 6 , tokens , NULL ) ; EXPECT_EQ_INT ( 0 , ret ) ; EXPECT_EQ_INT ( 2 , c_avl_size ( tokens ) ) ; token_t * token ; int * offset ; ret = c_avl_pick ( tokens , ( void * * ) & offset , ( void * * ) & token ) ; EXPECT_EQ_INT ( 0 , ret ) ; EXPECT_EQ_INT ( 6 , * offset ) ; EXPECT_EQ_STR ( \"-testB\" , token -> str ) ; sfree ( offset ) ; sfree ( token -> str ) ; ret = c_avl_pick ( tokens , ( void * * ) & offset , ( void * * ) & token ) ; EXPECT_EQ_INT ( 0 , ret ) ; EXPECT_EQ_INT ( 0 , * offset ) ; EXPECT_EQ_STR ( \"testA\" , token -> str ) ; sfree ( offset ) ; sfree ( token -> str ) ; sfree ( token ) ; ret = c_avl_pick ( tokens , ( void * * ) & offset , ( void * * ) & token ) ; OK ( ret != 0 ) ; c_avl_destroy ( tokens ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int u3_ht_read_config ( struct pci_bus * bus , unsigned int devfn , int offset , int len , u32 * val ) { struct pci_controller * hose ; void __iomem * addr ; int swap ; hose = pci_bus_to_host ( bus ) ; if ( hose == NULL ) { return PCIBIOS_DEVICE_NOT_FOUND ; } if ( offset >= 0x100 ) { return PCIBIOS_BAD_REGISTER_NUMBER ; } addr = u3_ht_cfg_access ( hose , bus -> number , devfn , offset , & swap ) ; switch ( u3_ht_skip_device ( hose , bus , devfn ) ) { case 0 : break ; case 1 : switch ( len ) { case 1 : * val = 0xff ; break ; case 2 : * val = 0xffff ; break ; default : * val = 0xfffffffful ; break ; } return PCIBIOS_SUCCESSFUL ; default : return PCIBIOS_DEVICE_NOT_FOUND ; } switch ( len ) { case 1 : * val = in_8 ( addr ) ; break ; case 2 : * val = swap ?in_le16 ( addr ) : in_be16 ( addr ) ; break ; default : * val = swap ?in_le32 ( addr ) : in_be32 ( addr ) ; break ; } return PCIBIOS_SUCCESSFUL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static const char * qemuConnectGetType ( virConnectPtr conn ) { if ( virConnectGetTypeEnsureACL ( conn ) < 0 ) { return in ; } return \"QEMU\" ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * _make_archive_name ( time_t period_start , time_t period_end , char * cluster_name , char * arch_dir , char * arch_type , uint32_t archive_period ) { char * name = NULL , * fullname = NULL ; struct tm time_tm ; uint32_t num = 2 ; localtime_r ( & period_start , & time_tm ) ; time_tm . tm_sec = 0 ; xstrfmtcat ( name , \"%s/%s_%s_archive_\" , arch_dir , cluster_name , arch_type ) ; if ( SLURMDB_PURGE_IN_HOURS ( archive_period ) ) { } if ( SLURMDB_PURGE_IN_DAYS ( archive_period ) ) { time_tm . tm_hour = 0 ; } else { time_tm . tm_hour = 0 ; time_tm . tm_mday = 1 ; } xstrfmtcat ( name , \"%4.4u-%2.2u-%2.2uT%2.2u:%2.2u:%2.2u_\" , ( time_tm . tm_year + 1900 ) , ( time_tm . tm_mon + 1 ) , time_tm . tm_mday , time_tm . tm_hour , time_tm . tm_min , time_tm . tm_sec ) ; localtime_r ( & period_end , & time_tm ) ; xstrfmtcat ( name , \"%4.4u-%2.2u-%2.2uT%2.2u:%2.2u:%2.2u\" , ( time_tm . tm_year + 1900 ) , ( time_tm . tm_mon + 1 ) , time_tm . tm_mday , time_tm . tm_hour , time_tm . tm_min , time_tm . tm_sec ) ; fullname = xstrdup ( name ) ; while ( ! access ( fullname , F_OK ) ) { xfree ( fullname ) ; xstrfmtcat ( fullname , \"%s.%u\" , name , num ++ ) ; } xfree ( name ) ; return fullname ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int icn8505_probe_acpi ( struct icn8505_data * icn8505 , struct device * dev ) { const char * subsys ; int error ; subsys = acpi_get_subsystem_id ( ACPI_HANDLE ( dev ) ) ; error = PTR_ERR_OR_ZERO ( subsys ) ; if ( error == - ENODATA ) { subsys = \"unknown\" ; } if ( error ) { return error ; } sprintf ( icn8505 -> firmware_name , \"chipone/icn8505-%s.fw\" , subsys ) ; kfree_const ( subsys ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sq_send ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st ; SyncQueueFrame dst ; int ts ; int ret ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( st -> tb . num > 0 && st -> tb . den > 0 ) ; if ( frame_null ( sq , frame ) ) { finish_stream ( sq , stream_idx ) ; return 0 ; } if ( st -> finished ) { return AVERROR_EOF ; } ret = objpool_get ( sq -> pool , ( void * * ) & dst ) ; if ( ret < 0 ) { return ret ; } frame_move ( sq , dst , frame ) ; ts = frame_ts ( sq , dst ) ; ret = av_fifo_write ( st -> fifo , & dst , 1 ) ; if ( ret < 0 ) { frame_move ( sq , frame , dst ) ; objpool_release ( sq -> pool , ( void * * ) & dst ) ; return ret ; } stream_update_ts ( sq , stream_idx , ts ) ; st -> frames_sent ++ ; if ( st -> frames_sent >= st -> frames_max ) { finish_stream ( sq , stream_idx ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) { cmsMLU * mlu ; cmsUInt32Number Count , RecLen , NumOfWchar ; cmsUInt32Number SizeOfHeader ; cmsUInt32Number Len , Offset ; cmsUInt32Number i ; wchar_t * Block ; cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; * nItems = 0 ; if ( ! _cmsReadUInt32Number ( io , & Count ) ) { return NULL ; } if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) { return NULL ; } if ( RecLen != 12 ) { cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , \"multiLocalizedUnicodeType of len != 12 is not supported.\" ) ; return NULL ; } mlu = cmsMLUalloc ( self -> ContextID , Count ) ; mlu -> UsedEntries = Count ; SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; LargestPosition = 0 ; for ( i = 0 ; i < Count ; i ++ ) { if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) { Error } if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) { Error } if ( ! _cmsReadUInt32Number ( io , & Len ) ) { Error } if ( ! _cmsReadUInt32Number ( io , & Offset ) ) { Error } if ( Offset & 1 ) { Error } if ( Offset < ( SizeOfHeader + 8 ) ) { Error } if ( ( ( Offset + Len ) < Len ) || ( ( Offset + Len ) > SizeOfTag + 8 ) ) { Error } BeginOfThisString = Offset - SizeOfHeader - 8 ; mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; EndOfThisString = BeginOfThisString + Len ; if ( EndOfThisString > LargestPosition ) { LargestPosition = EndOfThisString ; } } SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; if ( SizeOfTag == 0 ) { Block = NULL ; NumOfWchar = 0 ; } else { if ( SizeOfTag & 1 ) { Error } Block = ( wchar_t * ) _cmsCalloc ( self -> ContextID , 1 , SizeOfTag ) ; if ( Block == NULL ) { Error } NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) { _cmsFree ( self -> ContextID , Block ) ; Error } } mlu -> MemPool = Block ; mlu -> PoolSize = SizeOfTag ; mlu -> PoolUsed = SizeOfTag ; * nItems = 1 ; return ( void * ) mlu ; Error if ( mlu ) { cmsMLUfree ( mlu ) ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static s32 atl2_phy_init ( struct atl2_hw * hw ) { s32 ret_val ; u16 phy_val ; if ( hw -> phy_configured ) { return 0 ; } ATL2_WRITE_REGW ( hw , REG_PHY_ENABLE , 1 ) ; ATL2_WRITE_FLUSH ( hw ) ; msleep ( 1 ) ; atl2_write_phy_reg ( hw , MII_DBG_ADDR , 0 ) ; atl2_read_phy_reg ( hw , MII_DBG_DATA , & phy_val ) ; if ( phy_val & 0x1000 ) { phy_val &= ~ 0x1000 ; atl2_write_phy_reg ( hw , MII_DBG_DATA , phy_val ) ; } msleep ( 1 ) ; ret_val = atl2_write_phy_reg ( hw , 18 , 0xC00 ) ; ret_val = atl2_phy_setup_autoneg_adv ( hw ) ; if ( ret_val ) { return ret_val ; } ret_val = atl2_phy_commit ( hw ) ; if ( ret_val ) { return ret_val ; } hw -> phy_configured = true ; return ret_val ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mp2629_probe ( struct i2c_client * client ) { struct mp2629_data * ddata ; int ret ; ddata = devm_kzalloc ( & client -> dev , sizeof ( * ddata ) , GFP_KERNEL ) ; ddata -> dev = & client -> dev ; i2c_set_clientdata ( client , ddata ) ; ddata -> regmap = devm_regmap_init_i2c ( client , & mp2629_regmap_config ) ; if ( IS_ERR ( ddata -> regmap ) ) { dev_err ( ddata -> dev , \"Failed to allocate regmap\\n\" ) ; return PTR_ERR ( ddata -> regmap ) ; } ret = devm_mfd_add_devices ( ddata -> dev , PLATFORM_DEVID_AUTO , mp2629_cell , ARRAY_SIZE ( mp2629_cell ) , NULL , 0 , NULL ) ; if ( ret ) { dev_err ( ddata -> dev , \"Failed to register sub-devices %d\\n\" , ret ) ; } return ret ; } static const struct of_device_id mp2629_of_match [ ] { { . compatible = \"mps,mp2629\" } { } } ; ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool manager_is_lid_closed ( Manager * m ) { Button * b ; HASHMAP_FOREACH ( , ) return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int proxy_http_node_new ( struct proxy_node * * node , const struct uri * uri ) { int rc ; struct proxy_node * proxy ; proxy = ( proxy_node * ) safe_zalloc ( sizeof ( proxy_node ) ) ; proxy -> spec = & ProxySpecHttp ; rc = proxy_resolve ( uri -> host , ( sockaddr * ) & proxy -> ss , & proxy -> sslen , AF_UNSPEC ) ; if ( rc < 0 ) { * node = NULL ; return - 1 ; } if ( uri -> port == - 1 ) { proxy -> port = DEFAULT_PROXY_PORT_HTTP ; } else { proxy -> port = ( unsigned short ) uri -> port ; } rc = asprintf ( , \" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int lenovo_input_mapping_x1_tab_kbd ( struct hid_device * hdev , struct hid_input * hi , struct hid_field * field , struct hid_usage * usage , unsigned long * * bit , int * max ) { if ( usage -> hid == 0x000c0001 ) { switch ( usage -> usage_index ) { case 0 : map_key_clear ( KEY_BLUETOOTH ) ; return 1 ; case 1 : map_key_clear ( KEY_KEYBOARD ) ; return 1 ; case 2 : map_key_clear ( KEY_MACRO1 ) ; return 1 ; case 3 : map_key_clear ( KEY_SELECTIVE_SCREENSHOT ) ; return 1 ; case 8 : map_key_clear ( KEY_FN_ESC ) ; return 1 ; case 9 : map_key_clear ( KEY_MICMUTE ) ; return 1 ; case 10 : map_key_clear ( KEY_CONFIG ) ; return 1 ; case 13 : map_key_clear ( KEY_SWITCHVIDEOMODE ) ; return 1 ; case 14 : map_key_clear ( KEY_WLAN ) ; return 1 ; } } if ( usage -> hid == ( HID_UP_KEYBOARD | 0x009a ) ) { return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * pciide_machdep_compat_intr_establish ( struct device * dev , struct pci_attach_args * pa , int chan , int * func ( void * ) , void * arg ) { int irq ; void * cookie ; irq = PCIIDE_COMPAT_IRQ ( chan ) ; cookie = mac_intr_establish ( NULL , irq , IST_EDGE , IPL_BIO , func , arg , dev -> dv_xname ) ; return ( cookie ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int flac_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) { FlacEncodeContext * s ; int frame_bytes , out_bytes , ret ; s = avctx -> priv_data ; if ( ! frame ) { s -> max_framesize = s -> max_encoded_framesize ; av_md5_final ( s -> md5ctx , s -> md5sum ) ; write_streaminfo ( s , avctx -> extradata ) ; FF_DISABLE_DEPRECATION_WARNINGS if ( avctx -> side_data_only_packets && ! s -> flushed ) { FF_ENABLE_DEPRECATION_WARNINGS if ( ! s -> flushed ) { uint8_t * side_data = av_packet_new_side_data ( avpkt , AV_PKT_DATA_NEW_EXTRADATA , avctx -> extradata_size ) ; if ( ! side_data ) { return AVERROR ( ENOMEM ) ; } memcpy ( side_data , avctx -> extradata , avctx -> extradata_size ) ; avpkt -> pts = s -> next_pts ; * got_packet_ptr = 1 ; s -> flushed = 1 ; } return 0 ; } if ( frame -> nb_samples < s -> frame . blocksize ) { s -> max_framesize = ff_flac_get_max_frame_size ( frame -> nb_samples , s -> channels , avctx -> bits_per_raw_sample ) ; } init_frame ( s , frame -> nb_samples ) ; copy_samples ( s , frame -> data [ 0 ] ) ; channel_decorrelation ( s ) ; remove_wasted_bits ( s ) ; frame_bytes = encode_frame ( s ) ; if ( frame_bytes ( 0 || frame_bytes ) s -> max_framesize ) { frame_bytes = encode_frame ( s ) ; if ( frame_bytes < 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Bad frame count\\n\" ) ; return frame_bytes ; } } if ( ( ret = ff_alloc_packet ( avpkt , frame_bytes ) ) ) { av_log ( avctx , AV_LOG_ERROR , \"Error getting output packet\\n\" ) ; return ret ; } out_bytes = write_frame ( s , avpkt ) ; s -> frame_count ++ ; s -> sample_count += frame -> nb_samples ; if ( ( ret = update_md5_sum ( s , frame -> data [ 0 ] ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Error updating MD5 checksum\\n\" ) ; return ret ; } if ( out_bytes > s -> max_encoded_framesize ) { s -> max_encoded_framesize = out_bytes ; } if ( out_bytes < s -> min_framesize ) { s -> min_framesize = out_bytes ; } avpkt -> pts = frame -> pts ; avpkt -> duration = ff_samples_to_time_base ( avctx , frame -> nb_samples ) ; avpkt -> size = out_bytes ; s -> next_pts = avpkt -> pts + avpkt -> duration ; * got_packet_ptr = 1 ; return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { locale_t loc ; ( void ) setlocale ( LC_ALL , \"C\" ) ; priv_verify ( def ) ; ( void ) setlocale ( LC_ALL , \"zz_AA.UTF-8\" ) ; priv_verify ( trans ) ; ( void ) setlocale ( LC_ALL , \"C\" ) ; loc = newlocale ( LC_MESSAGES_MASK , \"zz_AA.UTF-8\" , NULL ) ; priv_verify ( def ) ; ( void ) uselocale ( loc ) ; priv_verify ( trans ) ; ( void ) uselocale ( LC_GLOBAL_LOCALE ) ; priv_verify ( def ) ; freelocale ( loc ) ; ( void ) setlocale ( LC_ALL , \"zz_AA.UTF-8\" ) ; loc = newlocale ( LC_MESSAGES_MASK , \"C\" , NULL ) ; assert ( loc != NULL ) ; priv_verify ( trans ) ; ( void ) uselocale ( loc ) ; priv_verify ( def ) ; ( void ) uselocale ( LC_GLOBAL_LOCALE ) ; priv_verify ( trans ) ; freelocale ( loc ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void GrowDataArrayTest ( void ) { static const CheckRange checkRanges [ ] { { 0 1 } { 0x720 2 } { 0x7a0 3 } { 0x8a0 4 } { 0x110000 5 } } ; ; static const char * const testName = \"grow-data\" ; UMutableCPTrie * mutableTrie ; int i ; UErrorCode errorCode ; errorCode = U_ZERO_ERROR ; mutableTrie = umutablecptrie_open ( 1 , 0xad , & errorCode ) ; if ( U_FAILURE ( errorCode ) ) { log_err ( \"error: umutablecptrie_open(%s) failed: %s\\n\" , testName , u_errorName ( errorCode ) ) ; return ; } for ( i = 0 ; i < 0x1000 ; ++ i ) { umutablecptrie_set ( mutableTrie , i , 2 , & errorCode ) ; } for ( i = 0x720 ; i < 0x1100 ; ++ i ) { umutablecptrie_set ( mutableTrie , i , 3 , & errorCode ) ; } for ( i = 0x7a0 ; i < 0x900 ; ++ i ) { umutablecptrie_set ( mutableTrie , i , 4 , & errorCode ) ; } for ( i = 0x8a0 ; i < 0x110000 ; ++ i ) { umutablecptrie_set ( mutableTrie , i , 5 , & errorCode ) ; } if ( U_FAILURE ( errorCode ) ) { log_err ( \"error: setting lots of values into a mutable trie (%s) failed - %s\\n\" , testName , u_errorName ( errorCode ) ) ; umutablecptrie_close ( mutableTrie ) ; return ; } mutableTrie = testTrieSerializeAllValueWidth ( testName , mutableTrie , false , checkRanges , UPRV_LENGTHOF ( checkRanges ) ) ; umutablecptrie_close ( mutableTrie ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int stk3310_set_state ( struct stk3310_data * data , u8 state ) { int ret ; struct i2c_client * client = data -> client ; mutex_lock ( & data -> lock ) ; ret = regmap_field_write ( data -> reg_state , state ) ; if ( ret < 0 ) { dev_err ( & client -> dev , \"failed to change sensor state\\n\" ) ; } if ( state != STK3310_STATE_STANDBY ) { data -> ps_enabled = ! ! ( state & STK3310_STATE_EN_PS ) ; data -> als_enabled = ! ! ( state & STK3310_STATE_EN_ALS ) ; } mutex_unlock ( & data -> lock ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __i915_sw_fence_await_sw_fence ( struct i915_sw_fence * fence , struct i915_sw_fence * signaler , wait_queue_entry_t * wq , gfp_t gfp ) { unsigned int pending ; unsigned long flags ; debug_fence_assert ( fence ) ; might_sleep_if ( gfpflags_allow_blocking ( gfp ) ) ; if ( i915_sw_fence_done ( signaler ) ) { i915_sw_fence_set_error_once ( fence , signaler -> error ) ; return 0 ; } debug_fence_assert ( signaler ) ; if ( unlikely ( i915_sw_fence_check_if_after ( fence , signaler ) ) ) { return - EINVAL ; } pending = I915_SW_FENCE_FLAG_FENCE ; if ( ! wq ) { wq = kmalloc ( sizeof ( * wq ) , gfp ) ; if ( ! wq ) { if ( ! gfpflags_allow_blocking ( gfp ) ) { return - ENOMEM ; } i915_sw_fence_wait ( signaler ) ; i915_sw_fence_set_error_once ( fence , signaler -> error ) ; return 0 ; } pending |= I915_SW_FENCE_FLAG_ALLOC ; } INIT_LIST_HEAD ( & wq -> entry ) ; wq -> flags = pending ; wq -> func = i915_sw_fence_wake ; wq -> private = fence ; i915_sw_fence_await ( fence , NULL ) ; spin_lock_irqsave ( & signaler -> wait . lock , flags ) ; if ( likely ( ! i915_sw_fence_done ( signaler ) ) ) { __add_wait_queue_entry_tail ( & signaler -> wait , wq ) ; pending = 1 ; } else { i915_sw_fence_wake ( wq , 0 , signaler -> error , NULL ) ; pending = 0 ; } spin_unlock_irqrestore ( & signaler -> wait . lock , flags ) ; return pending ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test ( void ) { a = returns_copy ( ) ; __smatch_user_rl ( a -> x , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t flash_read ( struct file * file , char __user * buf , size_t size , loff_t * ppos ) { ssize_t ret ; if ( flashdebug ) { printk ( KERN_DEBUG \"flash_read: flash_read: offset=0x%llx, \" \"buffer=%p, count=0x%zx.\\n\" , * ppos , buf , size ) ; } if ( mutex_lock_interruptible ( & nwflash_mutex ) ) { return - ERESTARTSYS ; } ret = simple_read_from_buffer ( buf , size , ppos , ( void * ) FLASH_BASE , gbFlashSize ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct usb_string_descriptor * usbd_get_string ( __u8 index ) { if ( index >= maxstrings ) { return in ; } return usb_strings [ index ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int otx2_dma_map_tso_skb ( struct otx2_nic * pfvf , struct otx2_snd_queue * sq , struct sk_buff * skb , int sqe , int hdr_len ) { int num_segs = skb_shinfo ( skb ) -> nr_frags + 1 ; struct sg_list * sg = & sq -> sg [ sqe ] ; u64 dma_addr ; int seg , len ; sg -> num_segs = 0 ; len = skb_headlen ( skb ) - hdr_len ; for ( seg = 0 ; seg < num_segs ; seg ++ ) { dma_addr = otx2_dma_map_skb_frag ( pfvf , skb , seg , & len ) ; if ( dma_mapping_error ( pfvf -> dev , dma_addr ) ) { unmap } sg -> dma_addr [ sg -> num_segs ] = dma_addr ; sg -> size [ sg -> num_segs ] = len ; sg -> num_segs ++ ; } return 0 ; unmap otx2_dma_unmap_skb_frags ( pfvf , sg ) ; return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void retire_ipc_sysctls ( struct ipc_namespace * ns ) { struct ctl_table * tbl ; tbl = ns -> ipc_sysctls -> ctl_table_arg ; unregister_sysctl_table ( ns -> ipc_sysctls , NULL ) ; retire_sysctl_set ( & ns -> ipc_set ) ; kfree ( tbl ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "rd_err_e validate_rdebug32 ( struct rd_agent * rap ) { struct ps_prochandle * php = rap -> rd_psp ; psaddr_t db_privp ; Rtld_db_priv db_priv ; db_privp = rap -> rd_rdebug ; if ( ps_pread ( php , db_privp , ( char * ) & db_priv , sizeof ( Rtld_db_priv ) ) != PS_OK ) { LOG ( ps_plog ( MSG_ORIG ( MSG_DB_READPRIVFAIL_1 ) , EC_ADDR ( db_privp ) ) ) ; return ( RD_DBERR ) ; } if ( ( db_priv . rtd_version < R_RTLDDB_VERSION1 ) || ( db_priv . rtd_version > R_RTLDDB_VERSION ) ) { LOG ( ps_plog ( MSG_ORIG ( MSG_DB_BADPVERS ) , db_priv . rtd_version , R_RTLDDB_VERSION ) ) ; return ( RD_NOCAPAB ) ; } if ( ps_pwrite ( php , db_privp , ( char * ) & db_priv , sizeof ( Rtld_db_priv ) ) != PS_OK ) { rap -> rd_flags |= RDF_FL_COREFILE ; } rap -> rd_rdebugvers = db_priv . rtd_version ; rap -> rd_rtlddbpriv = db_privp ; LOG ( ps_plog ( MSG_ORIG ( MSG_DB_VALIDRDEBUG ) , EC_ADDR ( rap -> rd_rdebug ) , R_RTLDDB_VERSION , rap -> rd_rdebugvers , rap -> rd_flags & RDF_FL_COREFILE ) ) ; return ( RD_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cg14_ioctl ( struct fb_info * info , unsigned int cmd , unsigned long arg ) { struct cg14_par * par = ( cg14_par * ) info -> par ; struct cg14_regs __iomem * regs = par -> regs ; struct mdi_cfginfo kmdi , __user * mdii ; unsigned long flags ; int cur_mode , mode , ret = 0 ; switch ( cmd ) { case MDI_RESET : spin_lock_irqsave ( & par -> lock , flags ) ; __cg14_reset ( par ) ; spin_unlock_irqrestore ( & par -> lock , flags ) ; break ; case MDI_GET_CFGINFO : spin_lock_irqsave ( & par -> lock , flags ) ; kmdi . mdi_type = FBTYPE_MDICOLOR ; kmdi . mdi_height = info -> var . yres ; kmdi . mdi_width = info -> var . xres ; kmdi . mdi_mode = par -> mode ; kmdi . mdi_pixfreq = 72 ; kmdi . mdi_size = par -> ramsize ; spin_unlock_irqrestore ( & par -> lock , flags ) ; mdii = ( mdi_cfginfo __user * ) arg ; if ( copy_to_user ( mdii , & kmdi , sizeof ( kmdi ) ) ) { ret = - EFAULT ; } break ; case MDI_SET_PIXELMODE : if ( get_user ( mode , ( int __user * ) arg ) ) { ret = - EFAULT ; break ; } spin_lock_irqsave ( & par -> lock , flags ) ; cur_mode = sbus_readb ( & regs -> mcr ) ; cur_mode &= ~ CG14_MCR_PIXMODE_MASK ; switch ( mode ) { case MDI_32_PIX : cur_mode |= ( CG14_MCR_PIXMODE_32 << CG14_MCR_PIXMODE_SHIFT ) ; break ; case MDI_16_PIX : cur_mode |= ( CG14_MCR_PIXMODE_16 << CG14_MCR_PIXMODE_SHIFT ) ; break ; case MDI_8_PIX : break ; default : ret = - ENOSYS ; break ; } if ( ! ret ) { sbus_writeb ( cur_mode , & regs -> mcr ) ; par -> mode = mode ; } spin_unlock_irqrestore ( & par -> lock , flags ) ; break ; default : ret = sbusfb_ioctl_helper ( cmd , arg , info , FBTYPE_MDICOLOR , 8 , info -> fix . smem_len ) ; break ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * argv [ ] ) { ( void ) argc ; ( void ) argv ; int number_failed ; Suite * s = basic_suite ( ) ; SRunner * sr = srunner_create ( s ) ; srunner_run_all ( sr , CK_NORMAL ) ; number_failed = srunner_ntests_failed ( sr ) ; return ( number_failed == 0 ) ?EXIT_SUCCESS : EXIT_FAILURE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct _cmsContext_struct * _cmsGetContext ( cmsContext ContextID ) { struct _cmsContext_struct * id = ( _cmsContext_struct * ) ContextID ; struct _cmsContext_struct * ctx ; for ( ctx = _cmsContextPoolHead ; ctx != NULL ; ctx = ctx -> Next ) { if ( id == ctx ) { return ctx ; } } return & globalContext ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int wc_CAAM_Sha512Hash ( wc_Sha512 * sha512 , const byte * in , word32 inSz , byte * digest ) { int ret ; if ( in != NULL ) { ret = wc_Sha512_Grow ( sha512 , in , inSz ) ; ret = _ShaUpdate ( sha512 , data , len , SHA512_DIGEST_SIZE , CAAM_SHA512 ) ; } if ( digest != NULL ) { int devId = sha512 -> devId ; void * heap = sha512 -> heap ; ret = _ShaFinal ( ( byte * ) sha512 -> digest , SHA512_DIGEST_SIZE , sha512 -> msg , sha512 -> used , digest , CAAM_SHA512 ) ; wc_Sha512Free ( sha512 ) ; wc_InitSha512_ex ( sha512 , heap , devId ) ; ret = _ShaFinal ( ( byte * ) sha512 -> digest , SHA512_DIGEST_SIZE , sha512 -> buffer , sha512 -> bufferLen , digest , CAAM_SHA512 ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void uhci_frame_timer ( void * opaque ) { UHCIState * s = opaque ; uint64_t t_now , t_last_run ; int i , frames ; const uint64_t frame_t = NANOSECONDS_PER_SECOND / FRAME_TIMER_FREQ ; s -> completions_only = false ; qemu_bh_cancel ( s -> bh ) ; if ( ! ( s -> cmd & UHCI_CMD_RS ) ) { trace_usb_uhci_schedule_stop ( ) ; timer_del ( s -> frame_timer ) ; uhci_async_cancel_all ( s , NULL ) ; s -> status |= UHCI_STS_HCHALTED ; return ; } t_last_run = s -> expire_time - frame_t ; t_now = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ; frames = ( t_now - t_last_run ) / frame_t ; if ( frames > s -> maxframes ) { int skipped = frames - s -> maxframes ; s -> expire_time += skipped * frame_t ; s -> frnum = ( s -> frnum + skipped ) & 0x7ff ; frames -= skipped ; } if ( frames > MAX_FRAMES_PER_TICK ) { frames = MAX_FRAMES_PER_TICK ; } for ( i = 0 ; i < frames ; i ++ ) { s -> frame_bytes = 0 ; trace_usb_uhci_frame_start ( s -> frnum ) ; uhci_async_validate_begin ( s ) ; uhci_process_frame ( s ) ; uhci_async_validate_end ( s ) ; s -> frnum = ( s -> frnum + 1 ) & 0x7ff ; s -> expire_time += frame_t ; } if ( s -> pending_int_mask ) { s -> status2 |= s -> pending_int_mask ; s -> status |= UHCI_STS_USBINT ; uhci_update_irq ( s ) ; } s -> pending_int_mask = 0 ; timer_mod ( s -> frame_timer , t_now + frame_t ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "size_t jam_protoport ( struct jambuf * buf , const ip_protoport * protoport ) { if ( protoport == NULL ) { return jam ( buf , \"<null-protoport>\" ) ; } if ( protoport -> ipproto == 0 ) { pexpect ( protoport -> has_port_wildcard == false ) ; pexpect ( protoport -> hport == 0 ) ; return jam_string ( buf , \"%any\" ) ; } size_t s = 0 ; s += jam ( buf , \"%s/\" , protocol_from_ipproto ( protoport -> ipproto ) -> name ) ; if ( protoport -> has_port_wildcard ) { pexpect ( protoport -> hport == 0 ) ; s += jam_string ( buf , \"%any\" ) ; } else { s += jam ( buf , \"%u\" , protoport -> hport ) ; } return s ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void test ( ) { struct platform platforms [ ] { { CS_ARCH_SYSZ CS_MODE_BIG_ENDIAN ( unsigned char * ) SYSZ_CODE sizeof ( SYSZ_CODE ) - 1 \"SystemZ\" } } ; ; uint64_t address = 0x1000 ; cs_insn * insn ; int i ; size_t count ; for ( i = 0 ; i < sizeof ( platforms ) / sizeof ( platforms [ 0 ] ) ; i ++ ) { cs_err err = cs_open ( platforms [ i ] . arch , platforms [ i ] . mode , & handle ) ; if ( err ) { printf ( \"Failed on cs_open() with error returned: %u\\n\" , err ) ; abort ( ) ; } cs_option ( handle , CS_OPT_DETAIL , CS_OPT_ON ) ; count = cs_disasm ( handle , platforms [ i ] . code , platforms [ i ] . size , address , 0 , & insn ) ; if ( count ) { int j ; printf ( \"****************\\n\" ) ; printf ( \"Platform: %s\\n\" , platforms [ i ] . comment ) ; print_string_hex ( \"Code:\" , platforms [ i ] . code , platforms [ i ] . size ) ; printf ( \"Disasm:\\n\" ) ; for ( j = 0 ; j < count ; j ++ ) { printf ( \"0x%\" PRIx64 \":\\t%s\\t%s\\n\" , insn [ j ] . address , insn [ j ] . mnemonic , insn [ j ] . op_str ) ; print_insn_detail ( & insn [ j ] ) ; } printf ( \"0x%\" PRIx64 \":\\n\" , insn [ j - 1 ] . address + insn [ j - 1 ] . size ) ; cs_free ( insn , count ) ; } else { printf ( \"****************\\n\" ) ; printf ( \"Platform: %s\\n\" , platforms [ i ] . comment ) ; print_string_hex ( \"Code:\" , platforms [ i ] . code , platforms [ i ] . size ) ; printf ( \"ERROR: Failed to disasm given code!\\n\" ) ; abort ( ) ; } printf ( \"\\n\" ) ; cs_close ( & handle ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pr_close_scoreboard ( int keep_mutex ) { if ( scoreboard_engine == FALSE ) { return 0 ; } if ( scoreboard_read_locked || scoreboard_write_locked ) { unlock_scoreboard ( ) ; } pr_trace_msg ( trace_channel , 4 , \"closing scoreboard fd %d\" , scoreboard_fd ) ; ( void ) close ( scoreboard_fd ) ; scoreboard_fd = - 1 ; if ( keep_mutex == FALSE ) { pr_trace_msg ( trace_channel , 4 , \"closing scoreboard mutex fd %d\" , scoreboard_mutex_fd ) ; ( void ) close ( scoreboard_mutex_fd ) ; scoreboard_mutex_fd = - 1 ; } scoreboard_opener = 0 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "m32r_in_small_data_p ( ) { tree section ; if ( TREE_CODE ( decl ) != VAR_DECL ) { return false ; } if ( lookup_attribute ( \"model\" , DECL_ATTRIBUTES ( decl ) ) ) { return false ; } section = DECL_SECTION_NAME ( decl ) ; if ( section ) { char * name = ( char * ) TREE_STRING_POINTER ( section ) ; if ( strcmp ( name , \".sdata\" ) == 0 || strcmp ( name , \".sbss\" ) == 0 ) { return true ; } } else { if ( ! TREE_READONLY ( decl ) && ! TARGET_SDATA_NONE ) { int size = int_size_in_bytes ( TREE_TYPE ( decl ) ) ; } } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int im_stretch3 ( IMAGE * in , IMAGE * out , double dx , double dy ) { StretchInfo * sin ; int i ; if ( in -> Coding != IM_CODING_NONE || in -> BandFmt != IM_BANDFMT_USHORT ) { im_error ( \"im_stretch3\" , \"%s\" , _ ( \"not uncoded unsigned short\" ) ) ; return ( - 1 ) ; } if ( dx < 0 || dx >= 1.0 || dy < 0 || dy >= 1.0 ) { im_error ( \"im_stretch3\" , \"%s\" , _ ( \"displacements out of range [0,1)\" ) ) ; return ( - 1 ) ; } if ( im_piocheck ( in , out ) ) { return ( - 1 ) ; } out -> Xsize = 34 * ( in -> Xsize / 33 ) + in -> Xsize % 33 - 3 ; out -> Ysize = in -> Ysize - 3 ; if ( im_demand_hint ( out , IM_FATSTRIP , in , NULL ) ) { return ( - 1 ) ; } if ( ! ( sin = IM_NEW ( out , StretchInfo ) ) ) { return ( - 1 ) ; } sin -> in = in ; sin -> dx = dx ; sin -> dy = dy ; for ( i = 0 ; i < 34 ; i ++ ) { double d = ( 34.0 - i ) / 34.0 ; double y0 = 2.0 * d * d - d - d * d * d ; double y1 = 1.0 - 2.0 * d * d + d * d * d ; double y2 = d + d * d - d * d * d ; double y3 = - d * d + d * d * d ; sin -> mask [ i ] [ 0 ] = IM_RINT ( y0 * 32768 ) ; sin -> mask [ i ] [ 1 ] = IM_RINT ( y1 * 32768 ) ; sin -> mask [ i ] [ 2 ] = IM_RINT ( y2 * 32768 ) ; sin -> mask [ i ] [ 3 ] = IM_RINT ( y3 * 32768 ) ; } sin -> xoff = ( dx * 33.0 ) + 0.5 ; sin -> yoff = ( dy * 33.0 ) + 0.5 ; if ( im_generate ( out , stretch_start , stretch_gen , stretch_stop , in , sin ) ) { return ( - 1 ) ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { int number_failed = 0 ; SRunner * sr ; rundebug ( ) ; sr = srunner_create ( dec_JobId_suite ( ) ) ; srunner_set_log ( sr , \"dec_JobId_suite.log\" ) ; srunner_run_all ( sr , CK_NORMAL ) ; number_failed = srunner_ntests_failed ( sr ) ; srunner_free ( sr ) ; return number_failed ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void match_alloc ( const char * fn , struct expression * expr , void * _arg ) { int arg_nr = PTR_INT ( _arg ) ; struct expression * arg_expr ; sval_t sval ; arg_expr = get_argument_from_call_expr ( expr -> args , arg_nr ) ; if ( sval . uvalue == 0 ) { return ; } if ( ! ( sval . uvalue & ~ GFP_ZONEMASK ) ) { sm_error ( \"no modifiers for allocation.\" ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static uint8_t rtc5t619_12hour_bin2bcd ( uint8_t hour ) { if ( ! hour ) { return 0x12 ; } if ( hour < 12 ) { return bin2bcd ( hour ) ; } return bin2bcd ( hour - 12 ) | HOUR_PMFLAG ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool mt7603_fill_txs ( struct mt7603_dev * dev , struct mt7603_sta * sta , struct ieee80211_tx_info * info , __le32 * txs_data ) { struct ieee80211_supported_band * sband ; struct mt7603_rate_set * rs ; int first_idx = 0 , last_idx ; u32 rate_set_tsf ; u32 final_rate ; u32 final_rate_flags ; bool rs_idx ; bool ack_timeout ; bool fixed_rate ; bool probe ; bool ampdu ; bool cck = false ; int count ; u32 txs ; int idx ; int i ; fixed_rate = info -> status . rates [ 0 ] . count ; probe = ! ! ( info -> flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE ) ; txs = le32_to_cpu ( txs_data [ 4 ] ) ; ampdu = ! fixed_rate && ( txs & MT_TXS4_AMPDU ) ; count = FIELD_GET ( MT_TXS4_TX_COUNT , txs ) ; last_idx = FIELD_GET ( MT_TXS4_LAST_TX_RATE , txs ) ; txs = le32_to_cpu ( txs_data [ 0 ] ) ; final_rate = FIELD_GET ( MT_TXS0_TX_RATE , txs ) ; ack_timeout = txs & MT_TXS0_ACK_TIMEOUT ; if ( txs & MT_TXS0_QUEUE_TIMEOUT ) { return false ; } if ( ! ack_timeout ) { info -> flags |= IEEE80211_TX_STAT_ACK ; } info -> status . ampdu_len = 1 ; info -> status . ampdu_ack_len = ! ! ( info -> flags & IEEE80211_TX_STAT_ACK ) ; if ( ampdu || ( info -> flags & IEEE80211_TX_CTL_AMPDU ) ) { info -> flags |= IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_CTL_AMPDU ; } first_idx = max_t ( int , 0 , last_idx - ( count - 1 ) / MT7603_RATE_RETRY ) ; if ( fixed_rate && ! probe ) { info -> status . rates [ 0 ] . count = count ; i = 0 ; out } rate_set_tsf = READ_ONCE ( sta -> rate_set_tsf ) ; rs_idx = ! ( ( u32 ) ( le32_get_bits ( txs_data [ 1 ] , MT_TXS1_F0_TIMESTAMP ) - rate_set_tsf ) < 1000000 ) ; rs_idx ^= rate_set_tsf & BIT ( 0 ) ; rs = & sta -> rateset [ rs_idx ] ; if ( ! first_idx && rs -> probe_rate . idx >= 0 ) { info -> status . rates [ 0 ] = rs -> probe_rate ; spin_lock_bh ( & dev -> mt76 . lock ) ; if ( sta -> rate_probe ) { mt7603_wtbl_set_rates ( dev , sta , NULL , sta -> rates ) ; sta -> rate_probe = false ; } spin_unlock_bh ( & dev -> mt76 . lock ) ; } else { info -> status . rates [ 0 ] = rs -> rates [ first_idx / 2 ] ; } info -> status . rates [ 0 ] . count = 0 ; for ( i = 0 , idx = first_idx ; count && idx <= last_idx ; idx ++ ) { struct ieee80211_tx_rate * cur_rate ; int cur_count ; cur_rate = & rs -> rates [ idx / 2 ] ; cur_count = min_t ( int , MT7603_RATE_RETRY , count ) ; count -= cur_count ; if ( idx && ( cur_rate -> idx != info -> status . rates [ i ] . idx || cur_rate -> flags != info -> status . rates [ i ] . flags ) ) { i ++ ; if ( i == ARRAY_SIZE ( info -> status . rates ) ) { i -- ; break ; } info -> status . rates [ i ] = * cur_rate ; info -> status . rates [ i ] . count = 0 ; } info -> status . rates [ i ] . count += cur_count ; } out final_rate_flags = info -> status . rates [ i ] . flags ; switch ( FIELD_GET ( MT_TX_RATE_MODE , final_rate ) ) { case MT_PHY_TYPE_CCK : cck = true ; fallthrough ; case MT_PHY_TYPE_OFDM : if ( dev -> mphy . chandef . chan -> band == NL80211_BAND_5GHZ ) { sband = & dev -> mphy . sband_5g . sband ; } else { sband = & dev -> mphy . sband_2g . sband ; } final_rate &= GENMASK ( 5 , 0 ) ; final_rate = mt76_get_rate ( & dev -> mt76 , sband , final_rate , cck ) ; final_rate_flags = 0 ; break ; case MT_PHY_TYPE_HT_GF : case MT_PHY_TYPE_HT : final_rate_flags |= IEEE80211_TX_RC_MCS ; final_rate &= GENMASK ( 5 , 0 ) ; if ( final_rate > 15 ) { return false ; } break ; default : return false ; } info -> status . rates [ i ] . idx = final_rate ; info -> status . rates [ i ] . flags = final_rate_flags ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { SRunner * sr ; int nf ; sr = srunner_create ( M_hash_u64str_suite ( ) ) ; if ( getenv ( \"CK_LOG_FILE_NAME\" ) == NULL ) { srunner_set_log ( sr , \"check_hash_u64str.log\" ) ; } srunner_run_all ( sr , CK_NORMAL ) ; nf = srunner_ntests_failed ( sr ) ; return nf == 0 ?EXIT_SUCCESS : EXIT_FAILURE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void list_eports_tcp ( void ) { unsigned short * port_list ; unsigned int number = 0 ; unsigned int i ; port_list = get_portmappings_in_range ( 0 , 65535 , IPPROTO_TCP , & number ) ; printf ( \"%u ports redirected (TCP) :\" , number ) ; for ( i = 0 ; i < number ; i ++ ) { printf ( \" %hu\" , port_list [ i ] ) ; } printf ( \"\\n\" ) ; port_list = get_portmappings_in_range ( 0 , 65535 , IPPROTO_UDP , & number ) ; printf ( \"%u ports redirected (UDP) :\" , number ) ; for ( i = 0 ; i < number ; i ++ ) { printf ( \" %hu\" , port_list [ i ] ) ; } printf ( \"\\n\" ) ; free ( port_list ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * check_compat_ports ( di_node_t node , char * phys_path , char * minor ) { char portid = * minor ; char port [ PATH_MAX ] ; char * devfs_path ; if ( portid ( 'a' || portid ) 'd' ) { return ( NULL ) ; } ( void ) snprintf ( port , sizeof ( port ) , \"term/%c\" , portid ) ; if ( devfsadm_read_link ( node , port , & devfs_path ) == DEVFSADM_SUCCESS && portcmp ( devfs_path , phys_path ) != 0 ) { return ( NULL ) ; } free ( devfs_path ) ; ( void ) snprintf ( port , sizeof ( port ) , \"cua/%c\" , portid ) ; if ( devfsadm_read_link ( node , port , & devfs_path ) == DEVFSADM_SUCCESS && portcmp ( devfs_path , phys_path ) != 0 ) { free ( devfs_path ) ; return ( NULL ) ; } free ( devfs_path ) ; port [ 0 ] = portid ; port [ 1 ] = '\\0' ; return ( s_strdup ( port ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * argv [ ] ) { const char * dataset = argv [ 1 ] ; const char * key = argv [ 2 ] ; char * pool = NULL ; nvlist_t * args = fnvlist_alloc ( ) ; nvlist_t * hidden_args = fnvlist_alloc ( ) ; nvlist_t * result = NULL ; int ret = 0 ; if ( argc != 3 ) { ( void ) fprintf ( stderr , \"Usage: %s dataset key\\n\" , argv [ 0 ] ) ; exit ( 2 ) ; } VERIFY0 ( libzfs_core_init ( ) ) ; pool = get_pool ( dataset ) ; fnvlist_add_string ( args , \"dataset\" , dataset ) ; fnvlist_add_string ( hidden_args , \"key\" , key ) ; fnvlist_add_nvlist ( args , ZPOOL_HIDDEN_ARGS , hidden_args ) ; ret = lzc_channel_program ( pool , prog , ZCP_DEFAULT_INSTRLIMIT , ZCP_DEFAULT_MEMLIMIT , args , & result ) ; ( void ) printf ( \"lzc_channel_program returned %d\" , ret ) ; if ( ret != 0 ) { ( void ) printf ( \" (%s)\" , strerror ( ret ) ) ; } ( void ) fputc ( '\\n' , stdout ) ; dump_nvlist ( result , 5 ) ; nvlist_free ( args ) ; nvlist_free ( hidden_args ) ; nvlist_free ( result ) ; libzfs_core_fini ( ) ; return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void vc4_perfmon_start ( struct vc4_dev * vc4 , struct vc4_perfmon * perfmon ) { unsigned int i ; u32 mask ; if ( WARN_ON_ONCE ( ! perfmon || vc4 -> active_perfmon ) ) { return ; } for ( i = 0 ; i < perfmon -> ncounters ; i ++ ) { V3D_WRITE ( V3D_PCTRS ( i ) , perfmon -> events [ i ] ) ; } mask = GENMASK ( perfmon -> ncounters - 1 , 0 ) ; V3D_WRITE ( V3D_PCTRC , mask ) ; V3D_WRITE ( V3D_PCTRE , V3D_PCTRE_EN | mask ) ; vc4 -> active_perfmon = perfmon ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nft_set_catchall_bind_check ( const struct nft_ctx * ctx , struct nft_set * set ) { u8 genmask = nft_genmask_next ( ctx -> net ) ; struct nft_set_elem_catchall * catchall ; struct nft_set_elem elem ; struct nft_set_ext * ext ; int ret = 0 ; list_for_each_entry_rcu ( , , ) { ext = nft_set_elem_ext ( set , catchall -> elem ) ; elem . priv = catchall -> elem ; ret = nft_setelem_data_validate ( ctx , set , & elem ) ; if ( ret < 0 ) { break ; } } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void * menu_item_destroy ( struct menu * m , struct menu_item * item , void * extra ) { if ( item -> key ) { free ( item -> key ) ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int img_spdif_out_runtime_suspend ( struct device * dev ) { struct img_spdif_out * spdif = dev_get_drvdata ( dev ) ; clk_disable_unprepare ( spdif -> clk_ref , NULL ) ; clk_disable_unprepare ( spdif -> clk_sys ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct dentry * i915_debugfs_params ( struct drm_i915_private * i915 ) { struct drm_minor * minor = i915 -> drm . primary ; struct i915_params * params = & i915 -> params ; struct dentry * dir ; dir = debugfs_create_dir ( \"i915_params\" , minor -> debugfs_root ) ; if ( IS_ERR ( dir ) ) { return dir ; } I915_PARAMS_FOR_EACH ( REGISTER , NULL ) ; return dir ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int upl_newbuf ( struct upl_softc * sc , struct upl_chain * c , struct mbuf * m ) { struct mbuf * m_new = NULL ; DPRINTFN ( 8 , ( \"%s: %s: enter\\n\" , sc -> sc_dev . dv_xname , __func__ ) ) ; if ( m == NULL ) { MGETHDR ( m_new , M_DONTWAIT , MT_DATA ) ; if ( m_new == NULL ) { printf ( \"%s: no memory for rx list \" \"-- packet dropped!\\n\" , sc -> sc_dev . dv_xname ) ; return ( ENOBUFS ) ; } MCLGET ( m_new , M_DONTWAIT ) ; if ( ! ( m_new -> m_flags & M_EXT ) ) { printf ( \"%s: no memory for rx list \" \"-- packet dropped!\\n\" , sc -> sc_dev . dv_xname ) ; return ( ENOBUFS ) ; } m_new -> m_len = m_new -> m_pkthdr . len = MCLBYTES ; } else { m_new = m ; m_new -> m_len = m_new -> m_pkthdr . len = MCLBYTES ; m_new -> m_data = m_new -> m_ext . ext_buf ; } c -> upl_mbuf = m_new ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int MMW_CheckOptical ( GGadget * g , GEvent * e ) { if ( e -> type == et_controlevent && e -> u . control . subtype == et_textchanged ) { MMW * mmw = GDrawGetUserData ( GGadgetGetWindow ( g ) ) ; char * top , * bottom , * def ; unichar_t * ut ; const unichar_t * ret = _GGadgetGetTitle ( g ) ; int di = ( GGadgetGetCid ( g ) - CID_AxisType ) / 100 ; char buf1 [ 20 ] , buf2 [ 20 ] , buf3 [ 20 ] ; if ( mmw -> old != NULL && di < mmw -> old -> axis_count && uc_strcmp ( ret , mmw -> old -> axes [ di ] ) == 0 ) { sprintf ( buf1 , \"%g\" , ( double ) mmw -> old -> axismaps [ di ] . designs [ 0 ] ) ; sprintf ( buf2 , \"%g\" , ( double ) mmw -> old -> axismaps [ di ] . designs [ mmw -> old -> axismaps [ di ] . points - 1 ] ) ; sprintf ( buf3 , \"%g\" , ( double ) mmw -> old -> axismaps [ di ] . def ) ; def = buf3 ; top = buf2 ; bottom = buf1 ; } if ( uc_strcmp ( ret , \"OpticalSize\" ) == 0 ) { top = \"72\" ; def = \"12\" ; bottom = \"6\" ; } if ( uc_strcmp ( ret , \"Slant\" ) == 0 ) { top = \"22\" ; def = \"0\" ; bottom = \"-22\" ; } if ( GGadgetIsChecked ( GWidgetGetControl ( mmw -> subwins [ mmw_counts ] , CID_Apple ) ) ) { top = \"2.0\" ; bottom = \"0.5\" ; def = \"1.0\" ; } else { top = \"999\" ; bottom = \"50\" ; def = \"400\" ; } ut = uc_copy ( top ) ; GGadgetSetTitle ( GWidgetGetControl ( GGadgetGetWindow ( g ) , GGadgetGetCid ( g ) - CID_AxisType + CID_AxisEnd ) , ut ) ; ut = uc_copy ( bottom ) ; GGadgetSetTitle ( GWidgetGetControl ( GGadgetGetWindow ( g ) , GGadgetGetCid ( g ) - CID_AxisType + CID_AxisBegin ) , ut ) ; free ( ut ) ; ut = uc_copy ( def ) ; GGadgetSetTitle ( GWidgetGetControl ( GGadgetGetWindow ( g ) , GGadgetGetCid ( g ) - CID_AxisType + CID_AxisDefault ) , ut ) ; free ( ut ) ; } return ( true ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int create_srq_cmd ( struct mlx5_core_dev * dev , struct mlx5_core_srq * srq , struct mlx5_srq_attr * in ) { u32 create_out [ MLX5_ST_SZ_DW ( create_srq_out ) ] { 0 } ; ; void * create_in ; void * srqc ; void * pas ; int pas_size ; int inlen ; int err ; pas_size = get_pas_size ( in ) ; inlen = MLX5_ST_SZ_BYTES ( create_srq_in ) + pas_size ; create_in = mlx5_vzalloc ( inlen ) ; srqc = MLX5_ADDR_OF ( create_srq_in , create_in , srq_context_entry ) ; pas = MLX5_ADDR_OF ( create_srq_in , create_in , pas ) ; set_srqc ( srqc , in ) ; memcpy ( pas , in -> pas , pas_size ) ; MLX5_SET ( create_srq_in , create_in , opcode , MLX5_CMD_OP_CREATE_SRQ ) ; err = mlx5_cmd_exec ( dev , create_in , inlen , create_out , sizeof ( create_out ) ) ; kvfree ( create_in ) ; if ( ! err ) { srq -> srqn = MLX5_GET ( create_srq_out , create_out , srqn ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long cpufreq_get_sysfs_value_from_table ( unsigned int cpu , const char * * table , unsigned int index , unsigned int size ) { cfs_time_t value ; unsigned int len ; char linebuf [ MAX_LINE_LEN ] ; char * endp ; if ( ! table || index >= size || ! table [ index ] ) { return 0 ; } len = sysfs_cpufreq_read_file ( cpu , table [ index ] , linebuf , sizeof ( linebuf ) ) ; if ( len == 0 ) { return 0 ; } value = strtoul ( linebuf , & endp , 0 ) ; if ( endp == linebuf || errno == ERANGE ) { return 0 ; } return value ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dozap ( section_info_table * info ) { Elf_Data * data ; info -> mdata = data = malloc ( sizeof ( Elf_Data ) ) ; if ( data == NULL ) { error_message ( MALLOC_ERROR , PLAIN_ERROR , NULL , prog ) ; mcs_exit ( FAILURE ) ; } * data = * info -> data ; if ( data -> d_buf == NULL ) { error_message ( MALLOC_ERROR , PLAIN_ERROR , NULL , prog ) ; mcs_exit ( FAILURE ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline bool cache_alloc_hsw_probe ( void ) { if ( boot_cpu_data . x86_vendor == X86_VENDOR_INTEL && boot_cpu_data . x86 == 6 && boot_cpu_data . x86_model == INTEL_FAM6_HASWELL_X ) { struct rdt_resource * r = & rdt_resources_all [ RDT_RESOURCE_L3 ] ; u32 l , h , max_cbm = BIT_MASK ( 20 ) - 1 ; if ( wrmsr_safe ( IA32_L3_CBM_BASE , max_cbm , 0 ) ) { return false ; } rdmsr ( IA32_L3_CBM_BASE , l , h ) ; r -> num_closid = 4 ; r -> default_ctrl = max_cbm ; r -> cache . cbm_len = 20 ; r -> cache . min_cbm_bits = 2 ; r -> capable = true ; r -> enabled = true ; return true ; } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct protoent * pr_bynumber ( struct irs_pr * , int ) static void pr_rewind ( struct irs_pr * ) static void pr_minimize ( struct irs_pr * ) static void free_proto ( struct protoent * pr ) struct irs_pr * irs_irp_pr ( struct irs_acc * this ) { struct irs_pr * pr ; struct pvt * pvt ; if ( ! ( pr = memget ( sizeof pr ) ) ) { errno = ENOMEM ; return ( NULL ) ; } memset ( pr , 0x0 , sizeof pr ) ; if ( ! ( pvt = memget ( sizeof pvt ) ) ) { memput ( pr , sizeof pr ) ; errno = ENOMEM ; return ( NULL ) ; } pvt -> girpdata = this -> private ; pr -> private = pvt ; pr -> close = pr_close ; pr -> byname = pr_byname ; pr -> bynumber = pr_bynumber ; pr -> next = pr_next ; pr -> rewind = pr_rewind ; pr -> minimize = pr_minimize ; return ( pr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static size_t strip_dname_origin ( uint8_t * dname , size_t dnamelen , size_t originlen , uint8_t * newdname , size_t maxnewdnamelen ) { int newdnamelen ; if ( dnamelen < originlen ) { return 0 ; } newdnamelen = dnamelen - originlen ; if ( newdnamelen + 1 > maxnewdnamelen ) { return 0 ; } memmove ( newdname , dname , newdnamelen ) ; newdname [ newdnamelen ] = 0 ; return newdnamelen + 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "virSCSIVHostDevice * virSCSIVHostDeviceListSteal ( virSCSIVHostDeviceList * list , virSCSIVHostDevice * dev ) { virSCSIVHostDevice * ret = NULL ; int i ; for ( i = 0 ; i < list -> count ; i ++ ) { if ( STREQ_NULLABLE ( list -> devs [ i ] -> name , dev -> name ) ) { ret = list -> devs [ i ] ; VIR_DELETE_ELEMENT ( list -> devs , i , list -> count ) ; break ; } } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int skl_tplg_mixer_dapm_post_pmd_event ( struct snd_soc_dapm_widget * w , struct skl * skl ) { struct skl_module_cfg * mconfig = w -> priv ; struct skl_pipe_module * w_module ; struct skl_module_cfg * src_module = NULL , * dst_module ; struct skl_sst * ctx = skl -> skl_sst ; struct skl_pipe * s_pipe = mconfig -> pipe ; struct skl_module_deferred_bind * modules , * tmp ; skl_tplg_free_pipe_mcps ( skl , mconfig ) ; skl_tplg_free_pipe_mem ( skl , mconfig ) ; list_for_each_entry ( , , ) { if ( list_empty ( & skl -> bind_list ) ) { break ; } src_module = w_module -> w -> priv ; list_for_each_entry_safe ( , , , ) { if ( modules -> dst == src_module ) { skl_unbind_modules ( ctx , modules -> src , modules -> dst ) ; } if ( modules -> src == src_module ) { list_del ( & modules -> node ) ; modules -> src = NULL ; modules -> dst = NULL ; kfree ( modules ) ; } } } list_for_each_entry ( , , ) { dst_module = w_module -> w -> priv ; if ( mconfig -> m_state >= SKL_MODULE_INIT_DONE ) { skl_tplg_free_pipe_mcps ( skl , dst_module ) ; } if ( src_module == NULL ) { src_module = dst_module ; continue ; } skl_unbind_modules ( ctx , src_module , dst_module ) ; src_module = dst_module ; } skl_delete_pipe ( ctx , mconfig -> pipe ) ; list_for_each_entry ( , , ) { src_module = w_module -> w -> priv ; src_module -> m_state = SKL_MODULE_UNINIT ; } return skl_tplg_unload_pipe_modules ( ctx , s_pipe ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static irqreturn_t bcm87xx_handle_interrupt ( struct phy_device * phydev ) { int irq_status ; irq_status = phy_read ( phydev , BCM87XX_LASI_STATUS ) ; if ( irq_status < 0 ) { phy_error ( phydev ) ; return IRQ_NONE ; } phy_trigger_machine ( phydev ) ; return IRQ_HANDLED ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int compare_i_st_st ( int nr ) { int f , c ; FPU_REG * st_ptr ; if ( ! NOT_EMPTY ( 0 ) || ! NOT_EMPTY ( nr ) ) { FPU_EFLAGS |= ( X86_EFLAGS_ZF | X86_EFLAGS_PF | X86_EFLAGS_CF ) ; EXCEPTION ( EX_StackUnder ) ; return ! ( control_word & CW_Invalid ) ; } partial_status &= ~ SW_C0 ; st_ptr = & st ( nr ) ; c = compare ( st_ptr , FPU_gettagi ( nr ) ) ; if ( c & COMP_NaN ) { FPU_EFLAGS |= ( X86_EFLAGS_ZF | X86_EFLAGS_PF | X86_EFLAGS_CF ) ; EXCEPTION ( EX_Invalid , NULL ) ; return ! ( control_word & CW_Invalid ) ; } switch ( c & 7 ) { case COMP_A_lt_B : f = X86_EFLAGS_CF ; break ; case COMP_A_eq_B : f = X86_EFLAGS_ZF ; break ; case COMP_A_gt_B : f = 0 ; break ; case COMP_No_Comp : f = X86_EFLAGS_ZF | X86_EFLAGS_PF | X86_EFLAGS_CF ; break ; default : EXCEPTION ( EX_INTERNAL | 0x122 ) ; f = 0 ; break ; } FPU_EFLAGS = ( FPU_EFLAGS & ~ ( X86_EFLAGS_ZF | X86_EFLAGS_PF | X86_EFLAGS_CF ) ) | f ; if ( c & COMP_Denormal ) { return denormal_operand ( ) < 0 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void log_info ( struct packet_object * po ) static pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER ; int set_loglevel ( int level , char * filename ) { char eci [ strlen ( filename ) + 5 ] ; char ecp [ strlen ( filename ) + 5 ] ; log_stop ( ) ; if ( level == LOG_STOP ) { DEBUG_MSG ( \"set_loglevel: stopping the log process\" ) ; return E_SUCCESS ; } DEBUG_MSG ( \"set_loglevel(%d, %s)\" , level , filename ) ; if ( EC_GBL_OPTIONS -> read ) { USER_MSG ( \"*********************************************************\\n\" ) ; USER_MSG ( \"WARNING: while reading form file we cannot determine     \\n\" ) ; USER_MSG ( \"if an host is local or not because the ip address of     \\n\" ) ; USER_MSG ( \"the NIC may have been changed from the time of the dump. \\n\" ) ; USER_MSG ( \"*********************************************************\\n\\n\" ) ; } snprintf ( eci , strlen ( filename ) + 5 , \"%s.eci\" , filename ) ; snprintf ( ecp , strlen ( filename ) + 5 , \"%s.ecp\" , filename ) ; memset ( & fdi , 0 , sizeof ( log_fd ) ) ; switch ( level ) { case LOG_PACKET : if ( EC_GBL_OPTIONS -> compress ) { fdp . type = LOG_COMPRESSED ; } else { fdp . type = LOG_UNCOMPRESSED ; } if ( log_open ( & fdp , ecp ) != E_SUCCESS ) { return - E_FATAL ; } log_write_header ( & fdp , LOG_PACKET ) ; hook_add ( HOOK_DISPATCHER , & log_packet ) ; case LOG_INFO : if ( EC_GBL_OPTIONS -> compress ) { fdi . type = LOG_COMPRESSED ; } else { fdi . type = LOG_UNCOMPRESSED ; } if ( log_open ( & fdi , eci ) != E_SUCCESS ) { return - E_FATAL ; } log_write_header ( & fdi , LOG_INFO ) ; hook_add ( HOOK_DISPATCHER , & log_info ) ; hook_add ( HOOK_PACKET_ARP , & log_info ) ; hook_add ( HOOK_PACKET_ICMP , & log_info ) ; hook_add ( HOOK_PROTO_DHCP_PROFILE , & log_info ) ; break ; } atexit ( log_stop ) ; return E_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mlx5vf_pci_save_device_inc_data ( struct mlx5vf_pci_core_device * mvdev ) { struct mlx5_vf_migration_file * migf = mvdev -> saving_migf ; struct mlx5_vhca_data_buffer * buf ; size_t length ; int ret ; ret = mlx5vf_cmd_query_vhca_migration_state ( mvdev , & length , MLX5VF_QUERY_INC | MLX5VF_QUERY_FINAL ) ; if ( ret ) { err } if ( migf -> buf && migf -> buf -> allocated_length >= length ) { buf = migf -> buf ; migf -> buf = NULL ; } else { buf = mlx5vf_get_data_buffer ( migf , length , DMA_FROM_DEVICE ) ; if ( IS_ERR ( buf ) ) { ret = PTR_ERR ( buf ) ; err } } ret = mlx5vf_cmd_save_vhca_state ( mvdev , migf , buf , true , false ) ; if ( ret ) { err_save } return 0 ; err_save mlx5vf_put_data_buffer ( buf ) ; err mlx5vf_mark_err ( migf ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GF_Err gf_dash_group_get_next_segment_location ( GF_DashClient * dash , u32 idx , u32 dependent_representation_index , const char * * url , u64 * start_range , u64 * end_range , s32 * switching_index , const char * * switching_url , u64 * switching_start_range , u64 * switching_end_range , const char * * original_url , Bool * has_next_segment , const char * * key_url , bin128 * key_IV , u64 * utc ) { GF_DASH_Group * group ; u32 index ; Bool has_dep_following ; * url = NULL ; if ( switching_url ) { * switching_url = NULL ; } if ( start_range ) { * start_range = 0 ; } if ( end_range ) { * end_range = 0 ; } if ( switching_start_range ) { * switching_start_range = 0 ; } if ( switching_end_range ) { * switching_end_range = 0 ; } if ( original_url ) { * original_url = NULL ; } if ( switching_index ) { * switching_index = - 1 ; } if ( has_next_segment ) { * has_next_segment = GF_FALSE ; } if ( utc ) { * utc = 0 ; } group = gf_list_get ( dash -> groups , idx ) ; if ( ! group ) { return GF_BAD_PARAM ; } if ( ! group -> nb_cached_segments ) { if ( group -> done ) { return GF_EOS ; } if ( ( dash -> low_latency_mode == GF_DASH_LL_EARLY_FETCH ) && group -> is_low_latency && dash -> is_rt_speed && ! dash -> time_in_tsb ) { group -> force_early_fetch = GF_TRUE ; } return GF_BUFFER_TOO_SMALL ; } has_dep_following = ( group -> cached [ 0 ] . flags & SEG_FLAG_DEP_FOLLOWING ) ?GF_TRUE : GF_FALSE ; index = 0 ; while ( dependent_representation_index ) { GF_Err err = GF_OK ; if ( has_dep_following ) { if ( index + 1 >= group -> nb_cached_segments ) { err = GF_BUFFER_TOO_SMALL ; } if ( ! ( group -> cached [ index ] . flags & SEG_FLAG_DEP_FOLLOWING ) ) { err = GF_BAD_PARAM ; } } else { GF_MPD_Representation * rep = gf_list_get ( group -> adaptation_set -> representations , group -> cached [ index ] . representation_index ) ; if ( index + 1 >= group -> nb_cached_segments ) { err = GF_BUFFER_TOO_SMALL ; } if ( ! rep -> playback . enhancement_rep_index_plus_one ) { err = GF_BAD_PARAM ; } if ( rep -> playback . enhancement_rep_index_plus_one != group -> cached [ index + 1 ] . representation_index + 1 ) { err = GF_BAD_PARAM ; } } if ( err ) { return err ; } index ++ ; dependent_representation_index -- ; } * url = group -> cached [ index ] . url ; if ( start_range ) { * start_range = group -> cached [ index ] . start_range ; } if ( end_range ) { * end_range = group -> cached [ index ] . end_range ; } if ( original_url ) { * original_url = group -> cached [ index ] . url ; } if ( key_url ) { * key_url = group -> cached [ index ] . key_url ; } if ( key_IV ) { memcpy ( ( * key_IV ) , group -> cached [ index ] . key_IV , sizeof ( bin128 ) ) ; } if ( utc ) { * utc = group -> cached [ index ] . utc_map ; } if ( ! group -> base_rep_index_plus_one && ( group -> cached [ index ] . representation_index != group -> prev_active_rep_index ) ) { GF_MPD_Representation * rep = gf_list_get ( group -> adaptation_set -> representations , group -> cached [ 0 ] . representation_index ) ; if ( switching_index ) { * switching_index = group -> cached [ 0 ] . representation_index ; } if ( switching_start_range ) { * switching_start_range = rep -> playback . init_start_range ; } if ( switching_end_range ) { * switching_end_range = rep -> playback . init_end_range ; } if ( switching_url ) { * switching_url = rep -> playback . cached_init_segment_url ; } } group -> force_segment_switch = 0 ; if ( has_next_segment ) { if ( group -> cached [ index ] . flags & SEG_FLAG_DEP_FOLLOWING ) { * has_next_segment = GF_TRUE ; } if ( ( index + 1 < group -> max_cached_segments ) && group -> cached [ index + 1 ] . url && group -> adaptation_set ) { GF_MPD_Representation * rep ; rep = gf_list_get ( group -> adaptation_set -> representations , group -> cached [ index ] . representation_index ) ; if ( rep && ( rep -> playback . enhancement_rep_index_plus_one == group -> cached [ index + 1 ] . representation_index + 1 ) ) { * has_next_segment = GF_TRUE ; } } if ( group -> has_pending_enhancement ) { * has_next_segment = GF_TRUE ; } } if ( group -> cached [ index ] . flags & SEG_FLAG_DISABLED ) { return GF_URL_REMOVED ; } return GF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _add_parity_units ( struct ore_io_state * ios , struct ore_striping_info * si , unsigned dev , unsigned first_dev , unsigned mirrors_p1 , unsigned devs_in_group , unsigned cur_len ) { unsigned do_parity ; int ret = 0 ; for ( do_parity = ios -> layout -> parity ; do_parity ; -- do_parity ) { struct ore_per_dev_state * per_dev ; per_dev = & ios -> per_dev [ dev - first_dev ] ; if ( ! per_dev -> length && ! per_dev -> offset ) { per_dev -> dev = dev ; per_dev -> offset = si -> obj_offset - si -> unit_off ; } ret = _ore_add_parity_unit ( ios , si , per_dev , cur_len , do_parity == 1 ) ; if ( do_parity != 1 ) { dev = ( ( dev + mirrors_p1 ) % devs_in_group ) + first_dev ; si -> cur_comp = ( si -> cur_comp + 1 ) % ios -> layout -> group_width ; } } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void add_foreign_final_paths ( PlannerInfo * root , RelOptInfo * input_rel , RelOptInfo * final_rel , FinalPathExtraData * extra ) { Query * parse = root -> parse ; PgFdwRelationInfo * ifpinfo = ( PgFdwRelationInfo * ) input_rel -> fdw_private ; PgFdwRelationInfo * fpinfo = ( PgFdwRelationInfo * ) final_rel -> fdw_private ; bool has_final_sort = false ; List * pathkeys = NIL ; PgFdwPathExtraData * fpextra ; bool save_use_remote_estimate = false ; double rows ; int width ; Cost startup_cost ; Cost total_cost ; List * fdw_private ; ForeignPath * final_path ; if ( parse -> commandType != CMD_SELECT ) { return ; } if ( parse -> hasTargetSRFs ) { return ; } fpinfo -> outerrel = input_rel ; fpinfo -> table = ifpinfo -> table ; fpinfo -> server = ifpinfo -> server ; fpinfo -> user = ifpinfo -> user ; merge_fdw_options ( fpinfo , ifpinfo , NULL ) ; if ( ! extra -> limit_needed ) { ListCell * lc ; Assert ( parse -> rowMarks ) ; Assert ( input_rel -> reloptkind == RELOPT_BASEREL || input_rel -> reloptkind == RELOPT_JOINREL || ( input_rel -> reloptkind == RELOPT_UPPER_REL && ifpinfo -> stage == UPPERREL_ORDERED && ( ifpinfo -> outerrel -> reloptkind == RELOPT_BASEREL || ifpinfo -> outerrel -> reloptkind == RELOPT_JOINREL ) ) ) ; ( lc input_rel -> pathlist ; ) { Path * path = ( Path * ) lfirst ( lc ) ; if ( IsA ( path , ForeignPath ) || ( IsA ( path , ProjectionPath ) && IsA ( ( ( ProjectionPath * ) path ) -> subpath , ForeignPath ) ) ) { final_path = create_foreign_upper_path ( root , path -> parent , path -> pathtarget , path -> rows , path -> startup_cost , path -> total_cost , path -> pathkeys , NULL , NULL ) ; add_path ( final_rel , ( Path * ) final_path ) ; fpinfo -> pushdown_safe = true ; return ; } } return ; } Assert ( extra -> limit_needed ) ; if ( input_rel -> reloptkind == RELOPT_UPPER_REL && ifpinfo -> stage == UPPERREL_ORDERED ) { input_rel = ifpinfo -> outerrel ; ifpinfo = ( PgFdwRelationInfo * ) input_rel -> fdw_private ; has_final_sort = true ; pathkeys = root -> sort_pathkeys ; } Assert ( input_rel -> reloptkind == RELOPT_BASEREL || input_rel -> reloptkind == RELOPT_JOINREL || ( input_rel -> reloptkind == RELOPT_UPPER_REL && ifpinfo -> stage == UPPERREL_GROUP_AGG ) ) ; if ( ifpinfo -> local_conds ) { return ; } if ( ! is_foreign_expr ( root , input_rel , ( Expr * ) parse -> limitOffset ) || ! is_foreign_expr ( root , input_rel , ( Expr * ) parse -> limitCount ) ) { return ; } fpinfo -> pushdown_safe = true ; fpextra = ( PgFdwPathExtraData * ) palloc0 ( sizeof ( PgFdwPathExtraData ) ) ; fpextra -> target = root -> upper_targets [ UPPERREL_FINAL ] ; fpextra -> has_final_sort = has_final_sort ; fpextra -> has_limit = extra -> limit_needed ; fpextra -> limit_tuples = extra -> limit_tuples ; fpextra -> count_est = extra -> count_est ; fpextra -> offset_est = extra -> offset_est ; if ( ! fpextra -> has_final_sort ) { save_use_remote_estimate = ifpinfo -> use_remote_estimate ; ifpinfo -> use_remote_estimate = false ; } estimate_path_cost_size ( root , input_rel , NIL , pathkeys , fpextra , & rows , & width , & startup_cost , & total_cost ) ; if ( ! fpextra -> has_final_sort ) { ifpinfo -> use_remote_estimate = save_use_remote_estimate ; } fdw_private = list_make2 ( makeBoolean ( has_final_sort ) , makeBoolean ( extra -> limit_needed ) ) ; final_path = create_foreign_upper_path ( root , input_rel , root -> upper_targets [ UPPERREL_FINAL ] , rows , startup_cost , total_cost , pathkeys , NULL , fdw_private ) ; add_path ( final_rel , ( Path * ) final_path ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "pcap_t * pcap_dpdk_create ( const char * device , char * ebuf , int * is_ours ) { pcap_t * p = NULL ; * is_ours = 0 ; * is_ours = ! strncmp ( device , \"dpdk:\" , 5 ) ; if ( ! * is_ours ) { return NULL ; } p = PCAP_CREATE_COMMON ( ebuf , pcap_dpdk ) ; p -> activate_op = pcap_dpdk_activate ; return p ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hid_polled_read ( hid_polled_handle_t hid_polled_input , uchar_t * * buffer ) { hid_state_t * hidp = ( hid_state_t * ) hid_polled_input ; uint_t num_bytes ; _NOTE ( NO_COMPETING_THREADS_NOW ) ; * buffer = hidp -> hid_polled_raw_buf ; _NOTE ( COMPETING_THREADS_NOW ) ; return ( num_bytes ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "G_DEFINE_TYPE ( VipsForeignLoadMagick7File , vips_foreign_load_magick7_file , vips_foreign_load_magick7_get_type ( ) ) ; static gboolean ismagick7 ( const char * filename ) { unsigned char buf [ 100 ] ; int len ; return ( ( len = vips__get_bytes ( filename , buf , 100 ) ) > 10 && magick_ismagick ( buf , len ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int DetectFiledataParseTest01 ( void ) { DetectEngineCtx * de_ctx = DetectEngineCtxInit ( ) ; FAIL_IF_NULL ( de_ctx ) ; de_ctx -> flags |= DE_QUIET ; Signature * s = DetectEngineAppendSig ( de_ctx , \"alert smtp any any ->any any \" \"(msg:\\\"test\\\"; file_data; content:\\\"abc\\\"; sid:1;)\" ) ; FAIL_IF_NULL ( s ) ; FAIL_IF_NOT_NULL ( s -> sm_lists [ DETECT_SM_LIST_PMATCH ] , NULL ) ; FAIL_IF_NULL ( s -> sm_lists [ g_file_data_buffer_id ] ) ; DetectEngineCtxFree ( de_ctx ) ; PASS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void bgx_poll_for_link ( struct work_struct * work ) { struct lmac * lmac ; u64 spu_link , smu_link ; lmac = container_of ( work , lmac , dwork . work ) ; if ( lmac -> is_sgmii ) { return ; } bgx_reg_modify ( lmac -> bgx , lmac -> lmacid , BGX_SPUX_STATUS1 , SPU_STATUS1_RCV_LNK ) ; bgx_poll_reg ( lmac -> bgx , lmac -> lmacid , BGX_SPUX_STATUS1 , SPU_STATUS1_RCV_LNK , false ) ; spu_link = bgx_reg_read ( lmac -> bgx , lmac -> lmacid , BGX_SPUX_STATUS1 ) ; smu_link = bgx_reg_read ( lmac -> bgx , lmac -> lmacid , BGX_SMUX_RX_CTL ) ; if ( ( spu_link & SPU_STATUS1_RCV_LNK ) && ! ( smu_link & SMU_RX_CTL_STATUS ) ) { lmac -> link_up = true ; if ( lmac -> lmac_type == BGX_MODE_XLAUI ) { lmac -> last_speed = SPEED_40000 ; } else { lmac -> last_speed = SPEED_10000 ; } lmac -> last_duplex = DUPLEX_FULL ; } else { lmac -> link_up = false ; lmac -> last_speed = SPEED_UNKNOWN ; lmac -> last_duplex = DUPLEX_UNKNOWN ; } if ( lmac -> last_link != lmac -> link_up ) { if ( lmac -> link_up ) { if ( bgx_xaui_check_link ( lmac ) ) { lmac -> link_up = false ; lmac -> last_speed = SPEED_UNKNOWN ; lmac -> last_duplex = DUPLEX_UNKNOWN ; } } lmac -> last_link = lmac -> link_up ; } queue_delayed_work ( lmac -> check_link , & lmac -> dwork , HZ * 2 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ath_mci_del_profile ( struct ath_common * common , struct ath_mci_profile * mci , struct ath_mci_profile_info * entry ) { if ( ! entry ) { return ; } DEC_PROF ( mci , entry ) ; list_del ( & entry -> list ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int adm8211_tx_raw ( struct ieee80211_hw * dev , struct sk_buff * skb , u16 plcp_signal , size_t hdrlen ) { struct adm8211_priv * priv = dev -> priv ; cfs_time_t flags ; dma_addr_t mapping ; unsigned int entry ; u32 flag ; mapping = dma_map_single ( & priv -> pdev -> dev , skb -> data , skb -> len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( & priv -> pdev -> dev , mapping ) ) { return - ENOMEM ; } spin_lock_irqsave ( & priv -> lock , flags ) ; if ( priv -> cur_tx - priv -> dirty_tx == priv -> tx_ring_size / 2 ) { flag = TDES1_CONTROL_IC | TDES1_CONTROL_LS | TDES1_CONTROL_FS ; } else { flag = TDES1_CONTROL_LS | TDES1_CONTROL_FS ; } if ( priv -> cur_tx - priv -> dirty_tx == priv -> tx_ring_size - 2 ) { ieee80211_stop_queue ( dev , 0 ) ; } entry = priv -> cur_tx % priv -> tx_ring_size ; priv -> tx_buffers [ entry ] . skb = skb ; priv -> tx_buffers [ entry ] . mapping = mapping ; priv -> tx_buffers [ entry ] . hdrlen = hdrlen ; priv -> tx_ring [ entry ] . buffer1 = cpu_to_le32 ( mapping ) ; if ( entry == priv -> tx_ring_size - 1 ) { flag |= TDES1_CONTROL_TER ; } priv -> tx_ring [ entry ] . length = cpu_to_le32 ( flag | skb -> len ) ; flag = TDES0_CONTROL_OWN | ( plcp_signal << 20 ) | 8 ; priv -> tx_ring [ entry ] . status = cpu_to_le32 ( flag ) ; priv -> cur_tx ++ ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; ADM8211_CSR_WRITE ( TDR , 0 ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tscs454_probe ( struct snd_soc_component * component ) { struct tscs454 * tscs454 = snd_soc_component_get_drvdata ( component ) ; int val ; int ret = 0 ; switch ( tscs454 -> sysclk_src_id ) { case PLL_INPUT_XTAL : val = FV_PLLISEL_XTAL ; break ; case PLL_INPUT_MCLK1 : val = FV_PLLISEL_MCLK1 ; break ; case PLL_INPUT_MCLK2 : val = FV_PLLISEL_MCLK2 ; break ; case PLL_INPUT_BCLK : val = FV_PLLISEL_BCLK ; break ; default : ret = - EINVAL ; dev_err ( component -> dev , \"Invalid sysclk src id (%d)\\n\" , ret ) ; return ret ; } ret = snd_soc_component_update_bits ( component , R_PLLCTL , FM_PLLCTL_PLLISEL , val ) ; if ( ret < 0 ) { dev_err ( component -> dev , \"Failed to set PLL input (%d)\\n\" , ret ) ; return ret ; } if ( tscs454 -> sysclk_src_id < PLL_INPUT_BCLK ) { ret = set_sysclk ( component ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int chipio_send ( struct hda_codec * codec , unsigned int reg , unsigned int data ) { unsigned int res ; unsigned long timeout = jiffies + msecs_to_jiffies ( 1000 ) ; { res = snd_hda_codec_read ( codec , WIDGET_CHIP_CTRL , 0 , reg , data ) ; msleep ( 20 ) ; } time_before ( jiffies , timeout ) ; return - EIO ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xencons_probe ( struct xenbus_device * dev , const struct xenbus_device_id * id ) { int ret , devid ; struct xencons_info * info ; unsigned long flags ; devid = dev -> nodename [ strlen ( dev -> nodename ) - 1 ] - '0' ; if ( devid == 0 ) { return - ENODEV ; } info = kzalloc ( sizeof ( xencons_info ) , GFP_KERNEL ) ; dev_set_drvdata ( & dev -> dev , info ) ; info -> xbdev = dev ; info -> vtermno = xenbus_devid_to_vtermno ( devid ) ; info -> intf = ( void * ) __get_free_page ( GFP_KERNEL | __GFP_ZERO ) ; if ( ! info -> intf ) { error_nomem } ret = xencons_connect_backend ( dev , info ) ; if ( ret < 0 ) { error } spin_lock_irqsave ( & xencons_lock , flags ) ; list_add_tail ( & info -> list , & xenconsoles ) ; spin_unlock_irqrestore ( & xencons_lock , flags ) ; return 0 ; error_nomem ret = - ENOMEM ; xenbus_dev_fatal ( dev , ret , \"allocating device memory\" ) ; error xencons_disconnect_backend ( info ) ; xencons_free ( info ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct tegra_clk_pll * _tegra_init_pll ( void __iomem * clk_base , void __iomem * pmc , struct tegra_clk_pll_params * pll_params , spinlock_t * lock ) { struct tegra_clk_pll * pll ; pll = kzalloc ( sizeof ( * pll ) , GFP_KERNEL ) ; pll -> clk_base = clk_base ; pll -> pmc = pmc ; pll -> params = pll_params ; pll -> lock = lock ; if ( ! pll_params -> div_nmp ) { pll_params -> div_nmp = & default_nmp ; } return pll ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int SearchMLUEntry ( cmsMLU * mlu , cmsUInt16Number LanguageCode , cmsUInt16Number CountryCode ) { cmsUInt32Number i ; for ( i = 0 ; i < mlu -> UsedEntries ; i ++ ) { if ( mlu -> Entries [ i ] . Country == CountryCode && mlu -> Entries [ i ] . Language == LanguageCode ) { return ( int ) i ; } } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void prune_movements ( int l ) { pointer p ; while ( down_ptr != null ) { if ( location ( down_ptr ) < l ) { break ; } p = down_ptr ; down_ptr = vlink ( p ) ; flush_node ( p , NULL ) ; } while ( right_ptr != null ) { if ( location ( right_ptr ) < l ) { return ; } p = right_ptr ; right_ptr = vlink ( p ) ; flush_node ( p ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sbus_esp_dma_error ( struct esp * esp ) { u32 csr = dma_read32 ( DMA_CSR ) ; return 0 ; } static const struct esp_driver_ops sbus_esp_ops = { . esp_write8 = sbus_esp_write8 . esp_read8 = sbus_esp_read8 . irq_pending = sbus_esp_irq_pending . reset_dma = sbus_esp_reset_dma . dma_drain = sbus_esp_dma_drain . dma_invalidate = sbus_esp_dma_invalidate . send_dma_cmd = sbus_esp_send_dma_cmd . dma_error = sbus_esp_dma_error } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int snd_sof_volume_info ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_info * uinfo ) { struct soc_mixer_control * sm = ( soc_mixer_control * ) kcontrol -> private_value ; struct snd_sof_control * scontrol = sm -> dobj . private ; unsigned int channels = scontrol -> num_channels ; int platform_max ; if ( ! sm -> platform_max ) { sm -> platform_max = sm -> max ; } platform_max = sm -> platform_max ; if ( platform_max == 1 && ! strstr ( kcontrol -> id . name , \" Volume\" ) ) { uinfo -> type = SNDRV_CTL_ELEM_TYPE_BOOLEAN ; } else { uinfo -> type = SNDRV_CTL_ELEM_TYPE_INTEGER ; } uinfo -> count = channels ; uinfo -> value . integer . max = platform_max - sm -> min ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dwc_pwm_probe ( struct pci_dev * pci , const struct pci_device_id * id ) { struct device * dev = & pci -> dev ; struct dwc_pwm * dwc ; int ret ; dwc = devm_kzalloc ( & pci -> dev , sizeof ( * dwc ) , GFP_KERNEL ) ; if ( ! dwc ) { return - ENOMEM ; } ret = pcim_enable_device ( pci ) ; if ( ret ) { dev_err ( & pci -> dev , \"Failed to enable device (%pe)\\n\" , ERR_PTR ( ret ) ) ; return ret ; } pci_set_master ( pci ) ; ret = pcim_iomap_regions ( pci , BIT ( 0 ) , pci_name ( pci ) ) ; if ( ret ) { dev_err ( & pci -> dev , \"Failed to iomap PCI BAR (%pe)\\n\" , ERR_PTR ( ret ) ) ; return ret ; } dwc -> base = pcim_iomap_table ( pci ) [ 0 ] ; if ( ! dwc -> base ) { dev_err ( & pci -> dev , \"Base address missing\\n\" ) ; return - ENOMEM ; } pci_set_drvdata ( pci , dwc ) ; dwc -> chip . dev = dev ; dwc -> chip . ops = & dwc_pwm_ops ; dwc -> chip . npwm = DWC_TIMERS_TOTAL ; ret = pwmchip_add ( & dwc -> chip ) ; if ( ret ) { return ret ; } pm_runtime_put ( dev ) ; pm_runtime_allow ( dev , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int efx_mcdi_mdio_write ( struct net_device * net_dev , int prtad , int devad , u16 addr , u16 value ) { struct efx_nic * efx = netdev_priv ( net_dev ) ; MCDI_DECLARE_BUF ( inbuf , MC_CMD_MDIO_WRITE_IN_LEN ) ; MCDI_DECLARE_BUF ( outbuf , MC_CMD_MDIO_WRITE_OUT_LEN ) ; size_t outlen ; int rc ; MCDI_SET_DWORD ( inbuf , MDIO_WRITE_IN_BUS , efx -> mdio_bus ) ; MCDI_SET_DWORD ( inbuf , MDIO_WRITE_IN_PRTAD , prtad ) ; MCDI_SET_DWORD ( inbuf , MDIO_WRITE_IN_DEVAD , devad ) ; MCDI_SET_DWORD ( inbuf , MDIO_WRITE_IN_ADDR , addr ) ; MCDI_SET_DWORD ( inbuf , MDIO_WRITE_IN_VALUE , value ) ; rc = efx_siena_mcdi_rpc ( efx , MC_CMD_MDIO_WRITE , inbuf , sizeof ( inbuf ) , outbuf , sizeof ( outbuf ) , & outlen ) ; if ( MCDI_DWORD ( outbuf , MDIO_WRITE_OUT_STATUS ) != MC_CMD_MDIO_STATUS_GOOD ) { return - EIO ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int eflg ; static int dflg ; static int rflg ; static int errflg ; static char * Fname ; static int Lineno ; static int Posno ; static int flag ; static jmp_buf to_eof ; int main ( int argc , char * argv [ ] ) { int ch ; while ( ( ch = getopt ( argc , argv , \"erd\" ) ) != - 1 ) { switch ( ch ) { case 'e' : if ( rflg ) { errflg ++ ; } else { eflg ++ ; } continue ; case 'r' : if ( eflg ) { errflg ++ ; } else { rflg ++ ; } continue ; case 'd' : if ( eflg ) { errflg ++ ; } else { dflg ++ ; } continue ; default : errflg ++ ; } } if ( optind == argc || errflg ) { usage ( ) ; } if ( ! rflg ) { for ( ; optind < argc ; optind ++ ) { extract ( argv [ optind ] ) ; } } else { if ( optind + 1 != argc ) { usage ( ) ; } replace ( argv [ optind ] , NULL ) ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool hda_readable_reg ( struct device * dev , unsigned int reg ) { struct hdac_device * codec = dev_to_hdac_dev ( dev ) ; unsigned int verb = get_verb ( reg ) ; switch ( verb ) { case AC_VERB_PARAMETERS : case AC_VERB_GET_CONNECT_LIST : case AC_VERB_GET_SUBSYSTEM_ID : return true ; case AC_VERB_GET_CONFIG_DEFAULT : case AC_VERB_GET_CONV : case AC_VERB_GET_CVT_CHAN_COUNT : return true ; } return hda_writeable_reg ( dev , reg ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void dt_buffered_destroy ( dtrace_hdl_t * dtp ) { free ( dtp -> dt_buffered_buf ) ; dtp -> dt_buffered_buf = NULL ; dtp -> dt_buffered_offs = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int libxlMakeNicList ( virDomainDef * def , libxl_domain_config * d_config ) { virDomainNetDef * * l_nics = def -> nets ; size_t nnics = def -> nnets ; libxl_device_nic * x_nics ; size_t i , nvnics = 0 ; int ret = - 1 ; x_nics = g_new0 ( libxl_device_nic , nnics ) ; for ( i = 0 ; i < nnics ; i ++ ) { libxl_device_nic_init ( & x_nics [ nvnics ] ) ; if ( libxlMakeNic ( def , l_nics [ i ] , & x_nics [ nvnics ] , false ) ) { out } if ( x_nics [ nvnics ] . devid < 0 ) { x_nics [ nvnics ] . devid = nvnics ; } nvnics ++ ; } ret = 0 ; out VIR_SHRINK_N ( x_nics , nnics , nnics - nvnics ) ; d_config -> nics = x_nics ; d_config -> num_nics = nvnics ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ucsi_acpi_dsm ( struct ucsi_acpi * ua , int func ) { union acpi_object * obj ; obj = acpi_evaluate_dsm ( ACPI_HANDLE ( ua -> dev ) , & ua -> guid , 1 , func , NULL ) ; if ( ! obj ) { dev_err ( ua -> dev , \"%s: failed to evaluate _DSM %d\\n\" , __func__ , func ) ; return - EIO ; } ACPI_FREE ( obj , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int atomisp_subdev_set_selection ( struct v4l2_subdev * sd , struct v4l2_subdev_pad_config * cfg , uint32_t which , uint32_t pad , uint32_t target , uint32_t flags , struct v4l2_rect * r ) { struct atomisp_sub_device * isp_sd = v4l2_get_subdevdata ( sd ) ; struct atomisp_device * isp = isp_sd -> isp ; struct v4l2_mbus_framefmt * ffmt [ ATOMISP_SUBDEV_PADS_NUM ] ; uint16_t vdev_pad = atomisp_subdev_source_pad ( sd -> devnode ) ; struct v4l2_rect * crop [ ATOMISP_SUBDEV_PADS_NUM ] , * comp [ ATOMISP_SUBDEV_PADS_NUM ] ; enum atomisp_input_stream_id stream_id ; unsigned int i ; int padding_w = pad_w ; unsigned int padding_h = pad_h ; stream_id = atomisp_source_pad_to_stream_id ( isp_sd , vdev_pad ) ; isp_get_fmt_rect ( sd , cfg , which , ffmt , crop , comp ) ; dev_dbg ( isp -> dev , \"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\\n\" , atomisp_pad_str [ pad ] , target == V4L2_SEL_TGT_CROP ?\"V4L2_SEL_TGT_CROP\" : \"V4L2_SEL_TGT_COMPOSE\" , r -> left , r -> top , r -> width , r -> height , which == V4L2_SUBDEV_FORMAT_TRY ?\"V4L2_SUBDEV_FORMAT_TRY\" : \"V4L2_SUBDEV_FORMAT_ACTIVE\" , flags ) ; r -> width = rounddown ( r -> width , ATOM_ISP_STEP_WIDTH ) ; r -> height = rounddown ( r -> height , ATOM_ISP_STEP_HEIGHT ) ; switch ( pad ) { case ATOMISP_SUBDEV_PAD_SINK : { unsigned int dvs_w , dvs_h ; crop [ pad ] -> width = ffmt [ pad ] -> width ; crop [ pad ] -> height = ffmt [ pad ] -> height ; if ( ! strncmp ( isp -> inputs [ isp_sd -> input_curr ] . camera -> name , \"ov2722\" , 6 ) && crop [ pad ] -> height == 1092 ) { padding_w = 12 ; padding_h = 12 ; } if ( isp -> inputs [ isp_sd -> input_curr ] . type == SOC_CAMERA ) { padding_w = 0 ; padding_h = 0 ; } if ( atomisp_subdev_format_conversion ( isp_sd , isp_sd -> capture_pad ) && crop [ pad ] -> width && crop [ pad ] -> height ) { crop [ pad ] -> width -= padding_w , crop [ pad ] -> height -= padding_h ; } if ( isp -> inputs [ isp_sd -> input_curr ] . type == SOC_CAMERA ) { isp_sd -> params . video_dis_en = 0 ; } if ( isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO && ! isp_sd -> continuous_mode -> val ) { crop [ pad ] -> width = roundup ( crop [ pad ] -> width * 5 / 6 , ATOM_ISP_STEP_WIDTH ) ; crop [ pad ] -> height = roundup ( crop [ pad ] -> height * 5 / 6 , ATOM_ISP_STEP_HEIGHT ) ; } crop [ pad ] -> width = min ( crop [ pad ] -> width , r -> width ) ; crop [ pad ] -> height = min ( crop [ pad ] -> height , r -> height ) ; if ( ! ( flags & V4L2_SEL_FLAG_KEEP_CONFIG ) ) { for ( i = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE ; i < ATOMISP_SUBDEV_PADS_NUM ; i ++ ) { struct v4l2_rect tmp = * crop [ pad ] ; atomisp_subdev_set_selection ( sd , cfg , which , i , V4L2_SEL_TGT_COMPOSE , flags , & tmp ) ; } } if ( which == V4L2_SUBDEV_FORMAT_TRY ) { break ; } if ( isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO && ! isp_sd -> continuous_mode -> val ) { dvs_w = rounddown ( crop [ pad ] -> width / 5 , ATOM_ISP_STEP_WIDTH ) ; dvs_h = rounddown ( crop [ pad ] -> height / 5 , ATOM_ISP_STEP_HEIGHT ) ; } if ( ! isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO ) { dvs_w = dvs_h = 12 ; } else { dvs_w = dvs_h = 0 ; } atomisp_css_video_set_dis_envelope ( isp_sd , dvs_w , dvs_h ) ; atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , crop [ pad ] -> width , crop [ pad ] -> height ) ; break ; } case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE : case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO : { if ( isp_sd -> vfpp -> val == ATOMISP_VFPP_DISABLE_LOWLAT ) { r -> width = crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width ; r -> height = crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height ; } if ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width == r -> width && crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height == r -> height ) { isp_sd -> params . yuv_ds_en = false ; } else { isp_sd -> params . yuv_ds_en = true ; } comp [ pad ] -> width = r -> width ; comp [ pad ] -> height = r -> height ; if ( r -> width == 0 || r -> height == 0 || crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width == 0 || crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height == 0 ) { break ; } if ( r -> width * crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height < crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width * r -> height ) { atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , rounddown ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height * r -> width / r -> height , ATOM_ISP_STEP_WIDTH ) , crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height ) ; } else { atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width , rounddown ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width * r -> height / r -> width , ATOM_ISP_STEP_WIDTH ) ) ; } break ; } case ATOMISP_SUBDEV_PAD_SOURCE_VF : case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW : comp [ pad ] -> width = r -> width ; comp [ pad ] -> height = r -> height ; break ; default : return - EINVAL ; } if ( pad != ATOMISP_SUBDEV_PAD_SINK ) { ffmt [ pad ] -> width = comp [ pad ] -> width ; ffmt [ pad ] -> height = comp [ pad ] -> height ; } if ( ! atomisp_subdev_get_rect ( sd , cfg , which , pad , target ) ) { return - EINVAL ; } * r = * atomisp_subdev_get_rect ( sd , cfg , which , pad , target ) ; dev_dbg ( isp -> dev , \"sel actual: l %d t %d w %d h %d\\n\" , r -> left , r -> top , r -> width , r -> height ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tcp_v6_conn_request ( struct sock * sk , struct sk_buff * skb ) { if ( skb -> protocol == htons ( ETH_P_IP ) ) { return tcp_v4_conn_request ( sk , skb ) ; } if ( ! ipv6_unicast_destination ( skb ) ) { drop } return tcp_conn_request ( & tcp6_request_sock_ops , & tcp_request_sock_ipv6_ops , sk , skb ) ; drop tcp_listendrop ( sk , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int post_one_send ( struct rxe_qp * qp , const struct ib_send_wr * ibwr , unsigned int mask , u32 length ) { int err ; struct rxe_sq * sq = & qp -> sq ; struct rxe_send_wqe * send_wqe ; unsigned long flags ; int full ; err = validate_send_wr ( qp , ibwr , mask , length ) ; spin_lock_irqsave ( & qp -> sq . sq_lock , flags ) ; full = queue_full ( sq -> queue , QUEUE_TYPE_FROM_ULP ) ; if ( unlikely ( full ) ) { spin_unlock_irqrestore ( & qp -> sq . sq_lock , flags ) ; return - ENOMEM ; } send_wqe = queue_producer_addr ( sq -> queue , QUEUE_TYPE_FROM_ULP ) ; init_send_wqe ( qp , ibwr , mask , length , send_wqe ) ; queue_advance_producer ( sq -> queue , QUEUE_TYPE_FROM_ULP ) ; spin_unlock_irqrestore ( & qp -> sq . sq_lock , flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "pid_t waitpid ( pid_t pid , int * status , int flags ) { register struct zombie * zp ; register struct zombie * pp ; register int p ; int s ; int n ; int oerrno ; Sig_handler_t handler ; static struct zombie * zombies ; pp = 0 ; zp = zombies ; while ( zp ) { if ( zp -> pid >= 0 && ( zp -> pid == pid || pid <= 0 ) ) { if ( pp ) { pp -> next = zp -> next ; } else { zombies = zp -> next ; } if ( status ) { * status = zp -> status ; } pid = zp -> pid ; return ( pid ) ; } } if ( pid > 0 && kill ( pid , 0 ) < 0 ) { return ( - 1 ) ; } for ( ; ; ) { oerrno = errno ; if ( flags & WNOHANG ) { caught = 0 ; handler = signal ( SIGCLD , catch ) ; if ( ! caught ) { signal ( SIGCLD , handler ) ; return ( 0 ) ; } handler = signal ( SIGALRM , catch ) ; n = alarm ( 1 ) ; } p = wait3 ( & s , flags , NiL ) ; if ( flags & WNOHANG ) { signal ( SIGCLD , handler ) ; } if ( flags & WNOHANG ) { if ( n == 0 && ! caught || n == 1 ) { alarm ( n ) ; } if ( n > 1 ) { alarm ( n - caught ) ; } signal ( SIGALRM , handler ) ; } if ( p == - 1 && errno == EINTR ) { errno = oerrno ; p = 0 ; s = 0 ; } if ( p == - 1 && errno == EINVAL && ( flags & ~ WNOHANG ) ) { p = wait3 ( & s , flags & WNOHANG , NiL ) ; } if ( p <= 0 ) { if ( p == 0 && status ) { * status = s ; } return ( p ) ; } if ( pid <= 0 || p == pid ) { if ( status ) { * status = s ; } return ( p ) ; } if ( ! ( zp = newof ( 0 , zombie , 1 , 0 ) ) ) { return ( - 1 ) ; } zp -> pid = p ; zp -> status = s ; zp -> next = zombies ; zombies = zp ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void * * umem_pool_alloc__ ( unsigned int size ) { void * * bufs ; bufs = xmalloc_pagealign ( size * sizeof bufs ) ; return bufs ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int InitSha512_256 ( wc_Sha512 * sha512 ) { sha512 -> digest [ 0 ] = W64LIT ( 0x22312194fc2bf72c ) ; sha512 -> digest [ 1 ] = W64LIT ( 0x9f555fa3c84c64c2 ) ; sha512 -> digest [ 2 ] = W64LIT ( 0x2393b86b6f53b151 ) ; sha512 -> digest [ 3 ] = W64LIT ( 0x963877195940eabd ) ; sha512 -> digest [ 4 ] = W64LIT ( 0x96283ee2a88effe3 ) ; sha512 -> digest [ 5 ] = W64LIT ( 0xbe5e1e2553863992 ) ; sha512 -> digest [ 6 ] = W64LIT ( 0x2b0199fc2c85b8aa ) ; sha512 -> digest [ 7 ] = W64LIT ( 0x0eb72ddc81c52ca2 ) ; sha512 -> buffLen = 0 ; sha512 -> loLen = 0 ; sha512 -> hiLen = 0 ; ! defined ( ) sha512 -> ctx . sha_type = SHA2_512 ; sha512 -> ctx . isfirstblock = 1 ; if ( sha512 -> ctx . mode == ESP32_SHA_HW ) { esp_sha_hw_unlock ( & ( sha512 -> ctx ) ) ; } sha512 -> ctx . mode = ESP32_SHA_INIT ; sha512 -> flags = 0 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ramoops_pstore_erase ( struct pstore_record * record ) { struct ramoops_context * cxt = record -> psi -> data ; struct persistent_ram_zone * prz ; switch ( record -> type ) { case PSTORE_TYPE_DMESG : prz = cxt -> dprzs [ record -> id ] ; break ; case PSTORE_TYPE_CONSOLE : prz = cxt -> cprz ; break ; case PSTORE_TYPE_FTRACE : if ( record -> id >= cxt -> max_ftrace_cnt ) { return - EINVAL ; } prz = cxt -> fprzs [ record -> id ] ; break ; case PSTORE_TYPE_PMSG : prz = cxt -> mprz ; break ; default : return - EINVAL ; } persistent_ram_free_old ( prz ) ; persistent_ram_zap ( prz ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void fuse_teardown ( struct fuse * fuse , char * mp ) { fuse_remove_signal_handlers ( fuse_get_session ( fuse ) ) ; fuse_unmount ( mp , fuse -> fc ) ; fuse_destroy ( fuse ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ff_nvdec_start_frame ( AVCodecContext * avctx , AVFrame * frame ) { NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; FrameDecodeData * fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; NVDECFrame * cf = NULL ; int ret ; ctx -> bitstream_len = 0 ; ctx -> nb_slices = 0 ; if ( fdd -> hwaccel_priv ) { return 0 ; } cf = av_mallocz ( sizeof ( * cf ) ) ; if ( ! cf ) { return AVERROR ( ENOMEM ) ; } cf -> decoder_ref = av_buffer_ref ( ctx -> decoder_ref ) ; if ( ! cf -> decoder_ref ) { ret = AVERROR ( ENOMEM ) ; fail } cf -> idx_ref = av_buffer_pool_get ( ctx -> decoder_pool ) ; if ( ! cf -> idx_ref ) { av_log ( avctx , AV_LOG_ERROR , \"No decoder surfaces left\\n\" ) ; ret = AVERROR ( ENOMEM ) ; fail } cf -> ref_idx = cf -> idx = * ( unsigned int * ) cf -> idx_ref -> data ; fdd -> hwaccel_priv = cf ; fdd -> hwaccel_priv_free = nvdec_fdd_priv_free ; fdd -> post_process = nvdec_retrieve_data ; return 0 ; fail return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int qed_sp_fcoe_func_start ( struct qed_hwfn * p_hwfn , enum spq_mode comp_mode , struct qed_spq_comp_cb * p_comp_addr ) { struct qed_fcoe_pf_params * fcoe_pf_params = NULL ; struct fcoe_init_ramrod_params * p_ramrod = NULL ; struct fcoe_init_func_ramrod_data * p_data ; struct fcoe_conn_context * p_cxt = NULL ; struct qed_spq_entry * p_ent = NULL ; struct qed_sp_init_data init_data ; struct qed_cxt_info cxt_info ; u32 dummy_cid ; int rc = 0 ; u16 tmp ; u8 i ; init_data . cid = qed_spq_get_cid ( p_hwfn ) ; init_data . opaque_fid = p_hwfn -> hw_info . opaque_fid ; init_data . comp_mode = comp_mode ; init_data . p_comp_data = p_comp_addr ; rc = qed_sp_init_request ( p_hwfn , & p_ent , FCOE_RAMROD_CMD_ID_INIT_FUNC , PROTOCOLID_FCOE , & init_data ) ; if ( rc ) { return rc ; } p_ramrod = & p_ent -> ramrod . fcoe_init ; p_data = & p_ramrod -> init_ramrod_data ; fcoe_pf_params = & p_hwfn -> pf_params . fcoe_pf_params ; p_data -> mtu = cpu_to_le16 ( fcoe_pf_params -> mtu ) ; tmp = cpu_to_le16 ( fcoe_pf_params -> sq_num_pbl_pages ) ; p_data -> sq_num_pages_in_pbl = tmp ; rc = qed_cxt_acquire_cid ( p_hwfn , PROTOCOLID_FCOE , & dummy_cid ) ; if ( rc ) { return rc ; } cxt_info . iid = dummy_cid ; rc = qed_cxt_get_cid_info ( p_hwfn , & cxt_info ) ; if ( rc ) { DP_NOTICE ( p_hwfn , \"Cannot find context info for dummy cid=%d\\n\" , dummy_cid ) ; return rc ; } p_cxt = cxt_info . p_cxt ; SET_FIELD ( p_cxt -> tstorm_ag_context . flags3 , TSTORM_FCOE_CONN_AG_CTX_DUMMY_TIMER_CF_EN , 1 ) ; fcoe_pf_params -> dummy_icid = ( u16 ) dummy_cid ; tmp = cpu_to_le16 ( fcoe_pf_params -> num_tasks ) ; p_data -> func_params . num_tasks = tmp ; p_data -> func_params . log_page_size = fcoe_pf_params -> log_page_size ; p_data -> func_params . debug_mode = fcoe_pf_params -> debug_mode ; DMA_REGPAIR_LE ( p_data -> q_params . glbl_q_params_addr , fcoe_pf_params -> glbl_q_params_addr ) ; tmp = cpu_to_le16 ( fcoe_pf_params -> cq_num_entries ) ; p_data -> q_params . cq_num_entries = tmp ; tmp = cpu_to_le16 ( fcoe_pf_params -> cmdq_num_entries ) ; p_data -> q_params . cmdq_num_entries = tmp ; tmp = fcoe_pf_params -> num_cqs ; p_data -> q_params . num_queues = ( u8 ) tmp ; tmp = ( u16 ) p_hwfn -> hw_info . resc_start [ QED_CMDQS_CQS ] ; p_data -> q_params . queue_relative_offset = ( u8 ) tmp ; for ( i = 0 ; i < fcoe_pf_params -> num_cqs ; i ++ ) { tmp = cpu_to_le16 ( p_hwfn -> sbs_info [ i ] -> igu_sb_id ) ; p_data -> q_params . cq_cmdq_sb_num_arr [ i ] = tmp ; } p_data -> q_params . cq_sb_pi = fcoe_pf_params -> gl_rq_pi ; p_data -> q_params . cmdq_sb_pi = fcoe_pf_params -> gl_cmd_pi ; p_data -> q_params . bdq_resource_id = ( u8 ) RESC_START ( p_hwfn , QED_BDQ ) ; DMA_REGPAIR_LE ( p_data -> q_params . bdq_pbl_base_address [ BDQ_ID_RQ ] , fcoe_pf_params -> bdq_pbl_base_addr [ BDQ_ID_RQ ] ) ; p_data -> q_params . bdq_pbl_num_entries [ BDQ_ID_RQ ] = fcoe_pf_params -> bdq_pbl_num_entries [ BDQ_ID_RQ ] ; tmp = fcoe_pf_params -> bdq_xoff_threshold [ BDQ_ID_RQ ] ; p_data -> q_params . bdq_xoff_threshold [ BDQ_ID_RQ ] = cpu_to_le16 ( tmp ) ; tmp = fcoe_pf_params -> bdq_xon_threshold [ BDQ_ID_RQ ] ; p_data -> q_params . bdq_xon_threshold [ BDQ_ID_RQ ] = cpu_to_le16 ( tmp ) ; DMA_REGPAIR_LE ( p_data -> q_params . bdq_pbl_base_address [ BDQ_ID_IMM_DATA ] , fcoe_pf_params -> bdq_pbl_base_addr [ BDQ_ID_IMM_DATA ] ) ; p_data -> q_params . bdq_pbl_num_entries [ BDQ_ID_IMM_DATA ] = fcoe_pf_params -> bdq_pbl_num_entries [ BDQ_ID_IMM_DATA ] ; tmp = fcoe_pf_params -> bdq_xoff_threshold [ BDQ_ID_IMM_DATA ] ; p_data -> q_params . bdq_xoff_threshold [ BDQ_ID_IMM_DATA ] = cpu_to_le16 ( tmp ) ; tmp = fcoe_pf_params -> bdq_xon_threshold [ BDQ_ID_IMM_DATA ] ; p_data -> q_params . bdq_xon_threshold [ BDQ_ID_IMM_DATA ] = cpu_to_le16 ( tmp ) ; tmp = fcoe_pf_params -> rq_buffer_size ; p_data -> q_params . rq_buffer_size = cpu_to_le16 ( tmp ) ; if ( fcoe_pf_params -> is_target ) { SET_FIELD ( p_data -> q_params . q_validity , SCSI_INIT_FUNC_QUEUES_RQ_VALID , 1 ) ; if ( p_data -> q_params . bdq_pbl_num_entries [ BDQ_ID_IMM_DATA ] ) { SET_FIELD ( p_data -> q_params . q_validity , SCSI_INIT_FUNC_QUEUES_IMM_DATA_VALID , 1 ) ; } SET_FIELD ( p_data -> q_params . q_validity , SCSI_INIT_FUNC_QUEUES_CMD_VALID , 1 ) ; } else { SET_FIELD ( p_data -> q_params . q_validity , SCSI_INIT_FUNC_QUEUES_RQ_VALID , 1 ) ; } rc = qed_spq_post ( p_hwfn , p_ent , NULL ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t pmbus_set_sensor ( struct device * dev , struct device_attribute * devattr , const char * buf , size_t count ) { struct i2c_client * client = to_i2c_client ( dev -> parent ) ; struct pmbus_data * data = i2c_get_clientdata ( client ) ; struct pmbus_sensor * sensor = to_pmbus_sensor ( devattr ) ; ssize_t rv = count ; long val = 0 ; int ret ; u16 regval ; mutex_lock ( & data -> update_lock ) ; regval = pmbus_data2reg ( data , sensor , val ) ; ret = _pmbus_write_word_data ( client , sensor -> page , sensor -> reg , regval ) ; if ( ret < 0 ) { rv = ret ; } else { sensor -> data = regval ; } mutex_unlock ( & data -> update_lock ) ; return rv ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void parse_conf_file ( char * name , vact_t action , boolean_t first_parse ) { char * file_buf , * cline , * line , * lend ; cinfo_t * cip ; int linc , cnt ; size_t llen ; int dontcare ; if ( first_parse ) { ( void ) S3_helper ( \"S3-support-enable\" , \"S3-support-disable\" , PM_ENABLE_S3 , PM_DISABLE_S3 , \"S3-support\" , \"default\" , & dontcare , - 1 ) ; } file_buf = get_conf_data ( name ) ; mesg ( MDEBUG , \"\\nnow parsing \\\"%s\\\"...\\n\" , name ) ; lineno = 1 ; line = file_buf ; while ( ( lend = find_line_end ( line , & linc ) ) != NULL ) { while ( line < lend ) { if ( * line != ' ' && * line != '\\t' ) { break ; } line ++ ; } if ( ( llen = ( lend - line ) ) != 0 ) { if ( ( cline = malloc ( llen + 1 ) ) == NULL ) { mesg ( MEXIT , \"cannot alloc %u bytes \" \"for line copy\\n\" , llen ) ; } ( void ) memcpy ( cline , line , llen ) ; * ( cline + llen ) = '\\0' ; } else { cline = NULL ; } if ( llen == 0 ) { mesg ( MDEBUG , \"\\nline %d, blank...\\n\" , lineno ) ; } if ( * line == '#' ) { mesg ( MDEBUG , \"\\nline %d, comment...\\n\" , lineno ) ; } if ( ( cnt = build_args ( cline , cline + llen ) ) != 0 ) { if ( ( cip = get_cinfo ( ) ) == NULL ) { mesg ( MEXIT , \"unrecognized keyword \\\"%s\\\"\\n\" , LINEARG ( 0 ) ) ; } if ( cnt != cip -> argc && ( cip -> any == 0 || cnt < cip -> argc ) ) { mesg ( MEXIT , \"found %d args, expect %d%s\\n\" , cnt , cip -> argc , cip -> any ?\"+\" : \"\" ) ; } if ( action ) { * action ( line , llen + 1 , cip ) ; } if ( cip -> status -> perm && ( def_src || cip -> alt ) ) { if ( * cip -> handler ( ) != OKUP ) { cip -> status -> update = NOUP ; } } else { mesg ( MDEBUG , \"==>handler skipped: %s_perm %d, \" \"def_src %d, alt %d\\n\" , cip -> status -> set , cip -> status -> perm , def_src , cip -> alt ) ; } } if ( cline ) { free ( cline ) ; } line = lend + 1 ; lineno += linc ; } lineno = 0 ; if ( verify ) { int ret = ioctl ( pm_fd , PM_GET_PM_STATE , NULL ) ; if ( ret < 0 ) { mesg ( MDEBUG , \"Cannot get PM state: %s\\n\" , strerror ( errno ) ) ; } switch ( ret ) { case PM_SYSTEM_PM_ENABLED : mesg ( MDEBUG , \"Autopm Enabled\\n\" ) ; break ; case PM_SYSTEM_PM_DISABLED : mesg ( MDEBUG , \"Autopm Disabled\\n\" ) ; break ; } ret = ioctl ( pm_fd , PM_GET_S3_SUPPORT_STATE , NULL ) ; if ( ret < 0 ) { mesg ( MDEBUG , \"Cannot get PM state: %s\\n\" , strerror ( errno ) ) ; } switch ( ret ) { case PM_S3_SUPPORT_ENABLED : mesg ( MDEBUG , \"S3 support Enabled\\n\" ) ; break ; case PM_S3_SUPPORT_DISABLED : mesg ( MDEBUG , \"S3 support Disabled\\n\" ) ; break ; } ret = ioctl ( pm_fd , PM_GET_AUTOS3_STATE , NULL ) ; if ( ret < 0 ) { mesg ( MDEBUG , \"Cannot get PM state: %s\\n\" , strerror ( errno ) ) ; } switch ( ret ) { case PM_AUTOS3_ENABLED : mesg ( MDEBUG , \"AutoS3 Enabled\\n\" ) ; break ; case PM_AUTOS3_DISABLED : mesg ( MDEBUG , \"AutoS3  Disabled\\n\" ) ; break ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int virNetDevBridgeCmd ( const char * brname , u_long op , void * arg , size_t argsize ) { struct ifdrv ifd ; VIR_AUTOCLOSE s = - 1 ; if ( ( s = socket ( AF_LOCAL , SOCK_DGRAM , 0 ) ) < 0 ) { virReportSystemError ( errno , \"%s\" , _ ( \"Cannot open network interface control socket\" ) ) ; return - 1 ; } if ( virStrcpyStatic ( ifd . ifd_name , brname ) < 0 ) { virReportSystemError ( ERANGE , _ ( \"Network interface name '%s' is too long\" ) , brname ) ; return - 1 ; } ifd . ifd_cmd = op ; ifd . ifd_len = argsize ; ifd . ifd_data = arg ; return ioctl ( s , SIOCSDRVSPEC , & ifd ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "opj_sparse_array_int32_t * opj_sparse_array_int32_create ( OPJ_UINT32 width , OPJ_UINT32 height , OPJ_UINT32 block_width , OPJ_UINT32 block_height ) { opj_sparse_array_int32_t * sa ; if ( width == 0 || height == 0 || block_width == 0 || block_height == 0 ) { return NULL ; } if ( block_width > ( ( OPJ_UINT32 ) ~ 0U ) / block_height / sizeof ( OPJ_INT32 ) ) { return NULL ; } sa = ( opj_sparse_array_int32_t * ) opj_calloc ( 1 , sizeof ( opj_sparse_array_int32_t ) ) ; sa -> width = width ; sa -> height = height ; sa -> block_width = block_width ; sa -> block_height = block_height ; sa -> block_count_hor = opj_uint_ceildiv ( width , block_width ) ; sa -> block_count_ver = opj_uint_ceildiv ( height , block_height ) ; if ( sa -> block_count_hor > ( ( OPJ_UINT32 ) ~ 0U ) / sa -> block_count_ver ) { return NULL ; } sa -> data_blocks = ( OPJ_INT32 * * ) opj_calloc ( sizeof ( OPJ_INT32 * ) , ( size_t ) sa -> block_count_hor * sa -> block_count_ver ) ; if ( sa -> data_blocks == NULL ) { opj_free ( sa ) ; return NULL ; } return sa ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int berlin_pwm_suspend ( struct device * dev ) { struct berlin_pwm_chip * bpc = dev_get_drvdata ( dev ) ; unsigned int i ; for ( i = 0 ; i < bpc -> chip . npwm ; i ++ ) { struct berlin_pwm_channel * channel ; channel = pwm_get_chip_data ( & bpc -> chip . pwms [ i ] ) ; if ( ! channel ) { continue ; } channel -> enable = berlin_pwm_readl ( bpc , i , BERLIN_PWM_ENABLE ) ; channel -> ctrl = berlin_pwm_readl ( bpc , i , BERLIN_PWM_CONTROL ) ; channel -> duty = berlin_pwm_readl ( bpc , i , BERLIN_PWM_DUTY ) ; channel -> tcnt = berlin_pwm_readl ( bpc , i , BERLIN_PWM_TCNT ) ; } clk_disable_unprepare ( bpc -> clk , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "enum nx_pclkmode nx_dpc_get_clock_pclk_mode ( u32 module_index ) { const u32 pclkmode_pos = 3 ; return nx_pclkmode_dynamic ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cert_verify_callback ( int preverify_ok , X509_STORE_CTX * ctx ) { X509 * err_cert ; int err , depth ; char * err_str ; if ( ! preverify_ok ) { err = X509_STORE_CTX_get_error ( ctx ) ; depth = X509_STORE_CTX_get_error_depth ( ctx ) ; err_cert = X509_STORE_CTX_get_current_cert ( ctx ) ; err_str = X509_NAME_oneline ( X509_get_subject_name ( err_cert ) , NULL , 0 ) ; error ( \"Cert Chain verify error:num=%d:%s:depth=%d:%s\" , err , X509_verify_cert_error_string ( err ) , depth , err_str ) ; } if ( ! preverify_ok && err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT ) { preverify_ok = 1 ; error ( \"Self Signed Certificate Accepted as the agent was built with ACLK_SSL_ALLOW_SELF_SIGNED\" ) ; } return preverify_ok ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct radeon_agp_head * radeon_agp_head_init ( struct drm_device * dev ) { struct pci_dev * pdev = to_pci_dev ( dev -> dev ) ; struct radeon_agp_head * head = NULL ; head = kmalloc ( sizeof ( * head ) , GFP_KERNEL ) ; if ( ! head ) { return NULL ; } head -> bridge = agp_find_bridge ( pdev ) ; if ( ! head -> bridge ) { head -> bridge = agp_backend_acquire ( pdev ) ; if ( ! head -> bridge ) { kfree ( head ) ; return NULL ; } agp_copy_info ( head -> bridge , & head -> agp_info ) ; agp_backend_release ( head -> bridge ) ; } else { agp_copy_info ( head -> bridge , & head -> agp_info ) ; } if ( head -> agp_info . chipset == NOT_SUPPORTED ) { kfree ( head ) ; return NULL ; } INIT_LIST_HEAD ( & head -> memory ) ; head -> cant_use_aperture = head -> agp_info . cant_use_aperture ; head -> page_mask = head -> agp_info . page_mask ; head -> base = head -> agp_info . aper_base ; return head ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mutex_vector_tryenter ( mutex_impl_t * lp ) { int s ; if ( MUTEX_TYPE_ADAPTIVE ( lp ) ) { return ( 0 ) ; } if ( ! MUTEX_TYPE_SPIN ( lp ) ) { mutex_panic ( \"mutex_tryenter: bad mutex\" , lp ) ; return ( 0 ) ; } s = splr ( lp -> m_spin . m_minspl ) ; if ( lock_try ( & lp -> m_spin . m_spinlock ) ) { lp -> m_spin . m_oldspl = ( ushort_t ) s ; return ( 1 ) ; } splx ( s , NULL ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int strv_push ( char * * * l , char * value ) { char * * c ; unsigned n , m ; if ( ! value ) { return 0 ; } n = strv_length ( * l ) ; m = n + 2 ; c = realloc ( * l , sizeof ( char * ) * m ) ; if ( ! c ) { return - ENOMEM ; } c [ n ] = value ; c [ n + 1 ] = NULL ; * l = c ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "__u16 ip6_tnl_parse_tlv_enc_lim ( struct sk_buff * skb , __u8 * raw ) { const struct ipv6hdr * ipv6h = ( const ipv6hdr * ) raw ; unsigned int nhoff = raw - skb -> data ; unsigned int off = nhoff + sizeof ( * ipv6h ) ; u8 next , nexthdr = ipv6h -> nexthdr ; while ( ipv6_ext_hdr ( nexthdr ) && nexthdr != NEXTHDR_NONE ) { struct ipv6_opt_hdr * hdr ; u16 optlen ; hdr = ( ipv6_opt_hdr * ) ( skb -> data + off ) ; if ( nexthdr == NEXTHDR_FRAGMENT ) { struct frag_hdr * frag_hdr = ( frag_hdr * ) hdr ; if ( frag_hdr -> frag_off ) { break ; } optlen = 8 ; } if ( nexthdr == NEXTHDR_AUTH ) { optlen = ipv6_authlen ( hdr ) ; } else { optlen = ipv6_optlen ( hdr ) ; } next = hdr -> nexthdr ; if ( nexthdr == NEXTHDR_DEST ) { u16 i = 2 ; if ( ! pskb_may_pull ( skb , off + optlen ) ) { break ; } while ( 1 ) { struct ipv6_tlv_tnl_enc_lim * tel ; if ( i + sizeof ( * tel ) > optlen ) { break ; } tel = ( ipv6_tlv_tnl_enc_lim * ) ( skb -> data + off + i ) ; if ( tel -> type == IPV6_TLV_TNL_ENCAP_LIMIT && tel -> length == 1 ) { return i + off - nhoff ; } if ( tel -> type ) { i += tel -> length + 2 ; } else { i ++ ; } } } nexthdr = next ; off += optlen ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void compl_do_reset ( struct usb_ep * ep , struct usb_request * req ) { g_dnl_unregister ( ) ; do_reset ( 0 , 0 , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "BOOL freerdp_client_load_addins ( rdpChannels * channels , rdpSettings * settings ) { ChannelToLoad dynChannels [ ] { { 0 AINPUT_CHANNEL_NAME NULL } { FreeRDP_AudioCapture \"audin\" NULL } { FreeRDP_AudioPlayback RDPSND_CHANNEL_NAME NULL } { FreeRDP_MultiTouchInput \"rdpei\" NULL } { FreeRDP_SupportGraphicsPipeline \"rdpgfx\" NULL } { FreeRDP_SupportEchoChannel \"echo\" NULL } { FreeRDP_SupportSSHAgentChannel \"sshagent\" NULL } { FreeRDP_SupportDisplayControl DISP_CHANNEL_NAME NULL } { FreeRDP_SupportGeometryTracking \"geometry\" NULL } { FreeRDP_SupportSSHAgentChannel \"sshagent\" NULL } { FreeRDP_SupportSSHAgentChannel \"sshagent\" NULL } { FreeRDP_SupportVideoOptimized \"video\" NULL } } ; ; ChannelToLoad staticChannels [ ] { { FreeRDP_AudioPlayback RDPSND_CHANNEL_NAME NULL } { FreeRDP_RedirectClipboard CLIPRDR_SVC_CHANNEL_NAME NULL } { FreeRDP_EncomspVirtualChannel ENCOMSP_SVC_CHANNEL_NAME settings } { FreeRDP_RemdeskVirtualChannel REMDESK_SVC_CHANNEL_NAME settings } { FreeRDP_RemoteApplicationMode RAIL_SVC_CHANNEL_NAME settings } } ; ; size_t i ; for ( i = 0 ; i < ARRAYSIZE ( dynChannels ) ; i ++ ) { if ( ( dynChannels [ i ] . settingId == 0 ) || freerdp_settings_get_bool ( settings , dynChannels [ i ] . settingId ) ) { const char * p [ ] { dynChannels [ i ] . channelName } ; ; if ( ! freerdp_client_add_dynamic_channel ( settings , ARRAYSIZE ( p ) , p ) ) { return FALSE ; } } } if ( ( freerdp_static_channel_collection_find ( settings , RDPSND_CHANNEL_NAME ) ) || ( freerdp_dynamic_channel_collection_find ( settings , RDPSND_CHANNEL_NAME ) ) || ( freerdp_dynamic_channel_collection_find ( settings , \"tsmf\" ) ) ) { settings -> DeviceRedirection = TRUE ; settings -> AudioPlayback = TRUE ; } if ( freerdp_dynamic_channel_collection_find ( settings , \"audin\" ) ) { settings -> AudioCapture = TRUE ; } if ( freerdp_settings_get_bool ( settings , FreeRDP_NetworkAutoDetect ) || settings -> SupportHeartbeatPdu || settings -> SupportMultitransport ) { settings -> DeviceRedirection = TRUE ; } if ( settings -> DrivesToRedirect && ( strlen ( settings -> DrivesToRedirect ) != 0 ) ) { char * value ; char * tok ; char * context = NULL ; value = _strdup ( settings -> DrivesToRedirect ) ; if ( ! value ) { return FALSE ; } tok = strtok_s ( value , \";\" , & context ) ; if ( ! tok ) { WLog_ERR ( TAG , \"DrivesToRedirect contains invalid data: '%s'\" , settings -> DrivesToRedirect ) ; return FALSE ; } while ( tok ) { BOOL success ; const char * name = NULL ; const char * drive = tok ; char * subcontext = NULL ; char * start = strtok_s ( tok , \"(\" , & subcontext ) ; char * end = strtok_s ( NULL , \")\" , & subcontext ) ; if ( start && end ) { name = end ; } if ( freerdp_path_valid ( name , NULL ) && freerdp_path_valid ( drive , NULL ) ) { success = freerdp_client_add_drive ( settings , name , NULL ) ; if ( success ) { success = freerdp_client_add_drive ( settings , drive , NULL ) ; } } else { success = freerdp_client_add_drive ( settings , drive , name ) ; } if ( ! success ) { free ( value ) ; return FALSE ; } tok = strtok_s ( NULL , \";\" , & context ) ; } free ( value ) ; if ( ! freerdp_settings_set_bool ( settings , FreeRDP_DeviceRedirection , TRUE ) ) { return FALSE ; } settings -> DeviceRedirection = TRUE ; } if ( settings -> RedirectDrives ) { if ( ! freerdp_device_collection_find ( settings , \"drive\" ) ) { const char * params [ ] { \"drive\" \"media\" \"*\" } ; ; if ( ! freerdp_client_add_device_channel ( settings , ARRAYSIZE ( params ) , params ) ) { return FALSE ; } } } if ( settings -> RedirectDrives || settings -> RedirectHomeDrive || settings -> RedirectSerialPorts || settings -> RedirectSmartCards || settings -> RedirectPrinters ) { settings -> DeviceRedirection = TRUE ; } if ( settings -> RedirectHomeDrive ) { if ( ! freerdp_device_collection_find ( settings , \"drive\" ) ) { const char * params [ ] { \"drive\" \"home\" \"%\" } ; ; if ( ! freerdp_client_add_device_channel ( settings , ARRAYSIZE ( params ) , params ) ) { return FALSE ; } } } if ( settings -> DeviceRedirection ) { if ( ! freerdp_client_load_static_channel_addin ( channels , settings , RDPDR_SVC_CHANNEL_NAME , settings ) ) { return FALSE ; } if ( ! freerdp_static_channel_collection_find ( settings , RDPSND_CHANNEL_NAME ) && ! freerdp_dynamic_channel_collection_find ( settings , RDPSND_CHANNEL_NAME ) ) { const char * params [ ] { RDPSND_CHANNEL_NAME \"sys:fake\" } ; ; if ( ! freerdp_client_add_static_channel ( settings , ARRAYSIZE ( params ) , params ) ) { return FALSE ; } if ( ! freerdp_client_add_dynamic_channel ( settings , ARRAYSIZE ( params ) , params ) ) { return FALSE ; } } } if ( settings -> RedirectSmartCards ) { if ( ! freerdp_device_collection_find_type ( settings , RDPDR_DTYP_SMARTCARD ) ) { RDPDR_DEVICE * smartcard = freerdp_device_new ( RDPDR_DTYP_SMARTCARD , 0 , NULL ) ; if ( ! smartcard ) { return FALSE ; } if ( ! freerdp_device_collection_add ( settings , smartcard ) ) { freerdp_device_free ( smartcard ) ; return FALSE ; } } } if ( settings -> RedirectPrinters ) { if ( ! freerdp_device_collection_find_type ( settings , RDPDR_DTYP_PRINT ) ) { RDPDR_DEVICE * printer = freerdp_device_new ( RDPDR_DTYP_PRINT , 0 , NULL ) ; if ( ! printer ) { return FALSE ; } if ( ! freerdp_device_collection_add ( settings , printer ) ) { freerdp_device_free ( printer ) ; return FALSE ; } } } if ( settings -> LyncRdpMode ) { settings -> EncomspVirtualChannel = TRUE ; settings -> RemdeskVirtualChannel = TRUE ; settings -> CompressionEnabled = FALSE ; } if ( settings -> RemoteAssistanceMode ) { settings -> EncomspVirtualChannel = TRUE ; settings -> RemdeskVirtualChannel = TRUE ; settings -> NlaSecurity = FALSE ; } for ( i = 0 ; i < ARRAYSIZE ( staticChannels ) ; i ++ ) { if ( ( staticChannels [ i ] . settingId == 0 ) || freerdp_settings_get_bool ( settings , staticChannels [ i ] . settingId ) ) { if ( staticChannels [ i ] . args ) { if ( ! freerdp_client_load_static_channel_addin ( channels , settings , staticChannels [ i ] . channelName , staticChannels [ i ] . args ) ) { return FALSE ; } } else { const char * p [ ] { staticChannels [ i ] . channelName } ; ; if ( ! freerdp_client_add_static_channel ( settings , ARRAYSIZE ( p ) , p ) ) { return FALSE ; } } } } if ( settings -> RDP2TCPArgs ) { if ( ! freerdp_client_load_static_channel_addin ( channels , settings , RDP2TCP_DVC_CHANNEL_NAME , settings -> RDP2TCPArgs ) ) { return FALSE ; } } for ( i = 0 ; i < settings -> StaticChannelCount ; i ++ ) { ADDIN_ARGV * _args = settings -> StaticChannelArray [ i ] ; if ( ! freerdp_client_load_static_channel_addin ( channels , settings , _args -> argv [ 0 ] , _args ) ) { return FALSE ; } } if ( freerdp_settings_get_uint32 ( settings , FreeRDP_DynamicChannelCount ) > 0 ) { if ( ! freerdp_settings_set_bool ( settings , FreeRDP_SupportDynamicChannels , TRUE ) ) { return FALSE ; } } if ( freerdp_settings_get_bool ( settings , FreeRDP_SupportDynamicChannels ) ) { if ( ! freerdp_client_load_static_channel_addin ( channels , settings , DRDYNVC_SVC_CHANNEL_NAME , settings ) ) { return FALSE ; } } return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void qpack_encoder_stream_handle_input ( h2o_http3_conn_t * conn , struct st_h2o_http3_ingress_unistream_t * stream , const uint8_t * * src , const uint8_t * src_end , int is_eos ) { if ( src == NULL || is_eos ) { h2o_quic_close_connection ( & conn -> super , H2O_HTTP3_ERROR_CLOSED_CRITICAL_STREAM , NULL ) ; return ; } while ( * src != src_end ) { int64_t * unblocked_stream_ids ; int num_unblocked ; int ret ; const char * err_desc = NULL ; if ( ( ret = h2o_qpack_decoder_handle_input ( conn -> qpack . dec , & unblocked_stream_ids , & num_unblocked , src , src_end , & err_desc ) ) != 0 ) { h2o_quic_close_connection ( & conn -> super , ret , err_desc ) ; break ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gimp_label_int_widget_get_widget ( ) { GimpLabelIntWidgetPrivate * priv ; g_return_val_if_fail ( GIMP_IS_LABEL_INT_WIDGET ( widget ) , NULL ) ; priv = gimp_label_int_widget_get_instance_private ( widget , NULL ) ; return priv -> widget ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pnp_add_card ( struct pnp_card * card ) { int error ; struct list_head * pos , * temp ; card -> dev . bus = NULL ; card -> dev . release = & pnp_release_card ; error = device_register ( & card -> dev ) ; if ( error ) { dev_err ( & card -> dev , \"could not register (err=%d)\\n\" , error ) ; return error ; } pnp_interface_attach_card ( card ) ; mutex_lock ( & pnp_lock ) ; list_add_tail ( & card -> global_list , & pnp_cards ) ; list_add_tail ( & card -> protocol_list , & card -> protocol -> cards ) ; mutex_unlock ( & pnp_lock ) ; list_for_each ( , ) { struct pnp_dev * dev = card_to_pnp_dev ( pos ) ; __pnp_add_device ( dev ) ; } list_for_each_safe ( , , ) { struct pnp_card_driver * drv = list_entry ( pos , pnp_card_driver , global_list ) ; card_probe ( card , drv ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int smssdio_probe ( struct sdio_func * func , const struct sdio_device_id * id ) { int ret ; int board_id ; struct smssdio_device * smsdev ; struct smsdevice_params_t params ; board_id = id -> driver_data ; smsdev = kzalloc ( sizeof ( smssdio_device ) , GFP_KERNEL ) ; smsdev -> func = func ; memset ( & params , 0 , sizeof ( smsdevice_params_t ) ) ; params . device = & func -> dev ; params . buffer_size = 0x5000 ; params . num_buffers = 22 ; params . context = smsdev ; snprintf ( params . devpath , sizeof ( params . devpath ) , \"sdio\\\\%s\" , sdio_func_id ( func ) ) ; params . sendrequest_handler = smssdio_sendrequest ; params . device_type = sms_get_board ( board_id ) -> type ; if ( params . device_type != SMS_STELLAR ) { params . flags |= SMS_DEVICE_FAMILY2 ; } else { ret = - ENODEV ; free } ret = smscore_register_device ( & params , & smsdev -> coredev , GFP_DMA , NULL ) ; if ( ret < 0 ) { free } smscore_set_board_id ( smsdev -> coredev , board_id ) ; sdio_claim_host ( func ) ; ret = sdio_enable_func ( func ) ; if ( ret ) { release } ret = sdio_set_block_size ( func , SMSSDIO_BLOCK_SIZE ) ; if ( ret ) { disable } ret = sdio_claim_irq ( func , smssdio_interrupt ) ; if ( ret ) { disable } sdio_set_drvdata ( func , smsdev ) ; sdio_release_host ( func ) ; ret = smscore_start_device ( smsdev -> coredev ) ; if ( ret < 0 ) { reclaim } return 0 ; reclaim sdio_claim_host ( func ) ; sdio_release_irq ( func ) ; disable sdio_disable_func ( func ) ; release sdio_release_host ( func ) ; smscore_unregister_device ( smsdev -> coredev ) ; free kfree ( smsdev ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cfag12864bfb_remove ( struct platform_device * device ) { struct fb_info * info = platform_get_drvdata ( device ) ; if ( info ) { unregister_framebuffer ( info ) ; } return 0 ; } static struct platform_driver cfag12864bfb_driver = { . probe = cfag12864bfb_probe . remove = cfag12864bfb_remove . driver = { . name = CFAG12864BFB_NAME } } ; static struct platform_device * cfag12864bfb_device ; static int __init cfag12864bfb_init ( void ) { int ret = - EINVAL ; if ( ! cfag12864b_isinited ( ) ) { printk ( \": ERROR: \" \"cfag12864b is not initialized\\n\" ) none } if ( cfag12864b_enable ( ) ) { printk ( \": ERROR: \" \"can't enable cfag12864b refreshing (being used)\\n\" ) return - ENODEV ; } ret = platform_driver_register ( & cfag12864bfb_driver ) ; if ( ! ret ) { cfag12864bfb_device = platform_device_alloc ( CFAG12864BFB_NAME , 0 ) ; if ( cfag12864bfb_device ) { ret = platform_device_add ( cfag12864bfb_device ) ; } else { ret = - ENOMEM ; } if ( ret ) { platform_device_put ( cfag12864bfb_device ) ; platform_driver_unregister ( & cfag12864bfb_driver ) ; } } none return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sunxi_sram_claim ( struct device * dev ) { const struct sunxi_sram_data * sram_data ; struct sunxi_sram_desc * sram_desc ; unsigned int device ; u32 val , mask ; if ( IS_ERR ( base ) ) { return - EPROBE_DEFER ; } sram_data = sunxi_sram_of_parse ( dev -> of_node , & device ) ; if ( IS_ERR ( sram_data ) ) { return PTR_ERR ( sram_data ) ; } sram_desc = to_sram_desc ( sram_data ) ; spin_lock ( & sram_lock ) ; if ( sram_desc -> claimed ) { spin_unlock ( & sram_lock ) ; return - EBUSY ; } mask = GENMASK ( sram_data -> offset + sram_data -> width - 1 , sram_data -> offset ) ; val = readl ( base + sram_data -> reg ) ; val &= ~ mask ; writel ( val | ( ( device << sram_data -> offset ) & mask ) , base + sram_data -> reg ) ; spin_unlock ( & sram_lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool cpu_thread_is_idle ( CPUState * cpu ) { if ( cpu -> stop || ! cpu_work_list_empty ( cpu ) ) { return false ; } if ( ! cpu -> halted || cpu_has_work ( cpu ) || kvm_halt_in_kernel ( ) || whpx_apic_in_platform ( ) ) { return false ; } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void uwsgi_tuntap_peer_destroy ( struct uwsgi_tuntap_router * uttr , struct uwsgi_tuntap_peer * uttp ) { struct uwsgi_tuntap_peer * prev = uttp -> prev ; struct uwsgi_tuntap_peer * next = uttp -> next ; if ( prev ) { prev -> next = next ; } if ( next ) { next -> prev = prev ; } if ( uttp == uttr -> peers_head ) { uttr -> peers_head = next ; } if ( uttp == uttr -> peers_tail ) { uttr -> peers_tail = prev ; } free ( uttp -> buf ) ; if ( uttp -> rules ) { free ( uttp -> rules ) ; } close ( uttp -> fd ) ; free ( uttp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int foreach_stop_cb_positive_ret ( const git_oid * oid , void * data ) { int * nobj = data ; ( * nobj ) ++ ; GIT_UNUSED ( oid , NULL ) ; return ( * nobj == 1000 ) ?321 : 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int write_commit_graph_file ( struct write_commit_graph_context * ctx ) { uint32_t i ; int fd ; struct hashfile * f ; struct lock_file lk = LOCK_INIT ; const unsigned hashsz = the_hash_algo -> rawsz ; struct strbuf progress_title = STRBUF_INIT ; struct chunkfile * cf ; unsigned char file_hash [ GIT_MAX_RAWSZ ] ; if ( ctx -> split ) { struct strbuf tmp_file = STRBUF_INIT ; strbuf_addf ( & tmp_file , \"%s/info/commit-graphs/tmp_graph_XXXXXX\" , ctx -> odb -> path ) ; ctx -> graph_name = strbuf_detach ( & tmp_file , NULL ) ; } else { ctx -> graph_name = get_commit_graph_filename ( ctx -> odb ) ; } if ( safe_create_leading_directories ( ctx -> graph_name ) ) { UNLEAK ( ctx -> graph_name ) ; error ( _ ( \"unable to create leading directories of %s\" ) , ctx -> graph_name ) ; return - 1 ; } if ( ctx -> split ) { char * lock_name = get_commit_graph_chain_filename ( ctx -> odb ) ; hold_lock_file_for_update_mode ( & lk , lock_name , LOCK_DIE_ON_ERROR , 0444 ) ; fd = git_mkstemp_mode ( ctx -> graph_name , 0444 ) ; if ( fd < 0 ) { error ( _ ( \"unable to create temporary graph layer\" ) ) ; return - 1 ; } if ( adjust_shared_perm ( ctx -> graph_name ) ) { error ( _ ( \"unable to adjust shared permissions for '%s'\" ) , ctx -> graph_name ) ; return - 1 ; } f = hashfd ( fd , ctx -> graph_name ) ; } else { hold_lock_file_for_update_mode ( & lk , ctx -> graph_name , LOCK_DIE_ON_ERROR , 0444 ) ; fd = get_lock_file_fd ( & lk ) ; f = hashfd ( fd , get_lock_file_path ( & lk ) ) ; } cf = init_chunkfile ( f ) ; add_chunk ( cf , GRAPH_CHUNKID_OIDFANOUT , GRAPH_FANOUT_SIZE , write_graph_chunk_fanout ) ; add_chunk ( cf , GRAPH_CHUNKID_OIDLOOKUP , hashsz * ctx -> commits . nr , write_graph_chunk_oids ) ; add_chunk ( cf , GRAPH_CHUNKID_DATA , ( hashsz + 16 ) * ctx -> commits . nr , write_graph_chunk_data ) ; if ( ctx -> write_generation_data ) { add_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA , sizeof ( uint32_t ) * ctx -> commits . nr , write_graph_chunk_generation_data ) ; } if ( ctx -> num_generation_data_overflows ) { add_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA_OVERFLOW , sizeof ( timestamp_t ) * ctx -> num_generation_data_overflows , write_graph_chunk_generation_data_overflow ) ; } if ( ctx -> num_extra_edges ) { add_chunk ( cf , GRAPH_CHUNKID_EXTRAEDGES , 4 * ctx -> num_extra_edges , write_graph_chunk_extra_edges ) ; } if ( ctx -> changed_paths ) { add_chunk ( cf , GRAPH_CHUNKID_BLOOMINDEXES , sizeof ( uint32_t ) * ctx -> commits . nr , write_graph_chunk_bloom_indexes ) ; add_chunk ( cf , GRAPH_CHUNKID_BLOOMDATA , sizeof ( uint32_t ) * 3 + ctx -> total_bloom_filter_data_size , write_graph_chunk_bloom_data ) ; } if ( ctx -> num_commit_graphs_after > 1 ) { add_chunk ( cf , GRAPH_CHUNKID_BASE , hashsz * ( ctx -> num_commit_graphs_after - 1 ) , write_graph_chunk_base ) ; } hashwrite_be32 ( f , GRAPH_SIGNATURE ) ; hashwrite_u8 ( f , GRAPH_VERSION ) ; hashwrite_u8 ( f , oid_version ( the_hash_algo ) ) ; hashwrite_u8 ( f , get_num_chunks ( cf ) ) ; hashwrite_u8 ( f , ctx -> num_commit_graphs_after - 1 ) ; if ( ctx -> report_progress ) { strbuf_addf ( & progress_title , Q_ ( \"Writing out commit graph in %d pass\" , \"Writing out commit graph in %d passes\" , get_num_chunks ( cf ) ) , get_num_chunks ( cf ) ) ; ctx -> progress = start_delayed_progress ( progress_title . buf , get_num_chunks ( cf ) * ctx -> commits . nr ) ; } write_chunkfile ( cf , ctx ) ; stop_progress ( & ctx -> progress ) ; strbuf_release ( & progress_title ) ; if ( ctx -> split && ctx -> base_graph_name && ctx -> num_commit_graphs_after > 1 ) { char * new_base_hash = xstrdup ( oid_to_hex ( & ctx -> new_base_graph -> oid ) ) ; char * new_base_name = get_split_graph_filename ( ctx -> new_base_graph -> odb , new_base_hash ) ; free ( ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 2 ] ) ; free ( ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 2 ] ) ; ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 2 ] = new_base_name ; ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 2 ] = new_base_hash ; } close_commit_graph ( ctx -> r -> objects ) ; finalize_hashfile ( f , file_hash , FSYNC_COMPONENT_COMMIT_GRAPH , CSUM_HASH_IN_STREAM | CSUM_FSYNC ) ; free_chunkfile ( cf ) ; if ( ctx -> split ) { FILE * chainf = fdopen_lock_file ( & lk , \"w\" ) ; char * final_graph_name ; int result ; close ( fd ) ; if ( ! chainf ) { error ( _ ( \"unable to open commit-graph chain file\" ) ) ; return - 1 ; } if ( ctx -> base_graph_name ) { const char * dest ; int idx = ctx -> num_commit_graphs_after - 1 ; if ( ctx -> num_commit_graphs_after > 1 ) { idx -- ; } dest = ctx -> commit_graph_filenames_after [ idx ] ; if ( strcmp ( ctx -> base_graph_name , dest ) ) { result = rename ( ctx -> base_graph_name , dest ) ; if ( result ) { error ( _ ( \"failed to rename base commit-graph file\" ) ) ; return - 1 ; } } } else { char * graph_name = get_commit_graph_filename ( ctx -> odb ) ; unlink ( graph_name ) ; free ( graph_name ) ; } ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 1 ] = xstrdup ( hash_to_hex ( file_hash ) ) ; final_graph_name = get_split_graph_filename ( ctx -> odb , ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 1 ] ) ; ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 1 ] = final_graph_name ; result = rename ( ctx -> graph_name , final_graph_name ) ; for ( i = 0 ; i < ctx -> num_commit_graphs_after ; i ++ ) { fprintf ( get_lock_file_fp ( & lk ) , \"%s\\n\" , ctx -> commit_graph_hash_after [ i ] ) ; } if ( result ) { error ( _ ( \"failed to rename temporary commit-graph file\" ) ) ; return - 1 ; } } commit_lock_file ( & lk ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int esp_sbus_probe ( struct platform_device * op ) { struct device_node * dma_node = NULL ; struct device_node * dp = op -> dev . of_node ; struct platform_device * dma_of = NULL ; int hme = 0 ; if ( dp -> parent && ( ! strcmp ( dp -> parent -> name , \"espdma\" ) || ! strcmp ( dp -> parent -> name , \"dma\" ) ) ) { dma_node = dp -> parent ; } if ( ! strcmp ( dp -> name , \"SUNW,fas\" ) ) { dma_node = op -> dev . of_node ; hme = 1 ; } if ( dma_node ) { dma_of = of_find_device_by_node ( dma_node ) ; } return esp_sbus_probe_one ( op , dma_of , hme ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct hubbub * dcn31_hubbub_create ( struct dc_context * ctx ) { int i ; struct dcn20_hubbub * hubbub3 = kzalloc ( sizeof ( dcn20_hubbub ) , GFP_KERNEL ) ; if ( ! hubbub3 ) { return in ; } hubbub31_construct ( hubbub3 , ctx , & hubbub_reg , & hubbub_shift , & hubbub_mask , dcn3_16_ip . det_buffer_size_kbytes , dcn3_16_ip . pixel_chunk_size_kbytes , dcn3_16_ip . config_return_buffer_size_in_kbytes ) ; for ( i = 0 ; i < res_cap_dcn31 . num_vmid ; i ++ ) { struct dcn20_vmid * vmid = & hubbub3 -> vmid [ i ] ; vmid -> ctx = ctx ; vmid -> regs = & vmid_regs [ i ] ; vmid -> shifts = & vmid_shifts ; vmid -> masks = & vmid_masks ; } return & hubbub3 -> base ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static u32 read_vco ( struct gk104_clk * clk , u32 dsrc ) { struct nvkm_device * device = clk -> base . subdev . device ; u32 ssrc = nvkm_rd32 ( device , dsrc ) ; return read_pll ( clk , 0x00e820 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void komeda_crtc_reset ( struct drm_crtc * crtc ) { struct komeda_crtc_state * state ; if ( crtc -> state ) { __drm_atomic_helper_crtc_destroy_state ( crtc -> state ) ; } kfree ( to_kcrtc_st ( crtc -> state ) ) ; crtc -> state = NULL ; state = kmalloc ( sizeof ( * state ) , GFP_KERNEL ) ; if ( state ) { __drm_atomic_helper_crtc_reset ( crtc , & state -> base ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool arch_uprobe_skip_sstep ( struct arch_uprobe * auprobe , struct pt_regs * regs ) { if ( ( psw_bits ( regs -> psw ) . eaba == PSW_BITS_AMODE_24BIT ) || ( ( psw_bits ( regs -> psw ) . eaba == PSW_BITS_AMODE_31BIT ) && ! is_compat_task ( ) ) ) { regs -> psw . addr = __rewind_psw ( regs -> psw , UPROBE_SWBP_INSN_SIZE ) ; do_report_trap ( regs , SIGILL , ILL_ILLADR ) ; return true ; } if ( probe_is_insn_relative_long ( auprobe -> insn ) ) { handle_insn_ril ( auprobe , regs ) ; return true ; } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bcm54140_get_downshift ( struct phy_device * phydev , u8 * data ) { int val ; val = bcm_phy_read_rdb ( phydev , BCM54140_RDB_C_MISC_CTRL ) ; if ( ! ( val & BCM54140_RDB_C_MISC_CTRL_WS_EN ) ) { * data = DOWNSHIFT_DEV_DISABLE ; return 0 ; } val = bcm_phy_read_rdb ( phydev , BCM54140_RDB_SPARE2 ) ; if ( val < 0 ) { return val ; } if ( val & BCM54140_RDB_SPARE2_WS_RTRY_DIS ) { * data = 1 ; } else { * data = FIELD_GET ( BCM54140_RDB_SPARE2_WS_RTRY_LIMIT , val ) + 2 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static BOOL poll_libusb_events ( UDEVMAN * udevman ) { int rc = LIBUSB_SUCCESS ; struct timeval tv = { 0 500 } ; if ( libusb_try_lock_events ( udevman -> context ) == 0 ) { if ( libusb_event_handling_ok ( udevman -> context ) ) { rc = libusb_handle_events_locked ( udevman -> context , & tv ) ; if ( rc != LIBUSB_SUCCESS ) { WLog_WARN ( TAG , \"libusb_handle_events_locked %d\" , rc ) ; } } libusb_unlock_events ( udevman -> context , NULL ) ; } else { libusb_lock_event_waiters ( udevman -> context ) ; if ( libusb_event_handler_active ( udevman -> context ) ) { rc = libusb_wait_for_event ( udevman -> context , & tv ) ; if ( rc < LIBUSB_SUCCESS ) { WLog_WARN ( TAG , \"libusb_wait_for_event %d\" , rc ) ; } } libusb_unlock_event_waiters ( udevman -> context ) ; } return rc > 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void t1_cmap_std_init ( T1_CMapStd cmap , FT_Int is_expert ) { T1_Face face = ( T1_Face ) FT_CMAP_FACE ( cmap ) ; FT_Service_PsCMaps psnames = ( FT_Service_PsCMaps ) face -> psnames ; cmap -> num_glyphs = ( FT_UInt ) face -> type1 . num_glyphs ; cmap -> glyph_names = ( const char * const * ) face -> type1 . glyph_names ; cmap -> sid_to_string = psnames -> adobe_std_strings ; cmap -> code_to_sid = is_expert ?psnames -> adobe_expert_encoding : psnames -> adobe_std_encoding ; FT_ASSERT ( cmap -> code_to_sid , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct device_node * pcibios_get_phb_of_node ( struct pci_bus * bus ) { struct device_node * np ; for_each_node_by_type ( , \"pci\" ) { const void * prop ; unsigned int bus_min ; prop = of_get_property ( np , \"bus-range\" , NULL ) ; bus_min = be32_to_cpup ( prop ) ; if ( bus -> number == bus_min ) { return np ; } } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool equality_ops_are_compatible ( Oid opno1 , Oid opno2 ) { bool result ; CatCList * catlist ; int i ; catlist = SearchSysCacheList1 ( AMOPOPID , ObjectIdGetDatum ( opno1 ) ) ; result = false ; for ( i = 0 ; i < catlist -> n_members ; i ++ ) { HeapTuple op_tuple = & catlist -> members [ i ] -> tuple ; Form_pg_amop op_form = ( Form_pg_amop ) GETSTRUCT ( op_tuple ) ; if ( op_form -> amopmethod == BTREE_AM_OID || op_form -> amopmethod == HASH_AM_OID ) { if ( op_in_opfamily ( opno2 , op_form -> amopfamily ) ) { result = true ; break ; } } } ReleaseSysCacheList ( catlist ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void omap_mcbsp_dai_shutdown ( struct snd_pcm_substream * substream , struct snd_soc_dai * cpu_dai ) { struct omap_mcbsp * mcbsp = snd_soc_dai_get_drvdata ( cpu_dai ) ; int tx = ( substream -> stream == SNDRV_PCM_STREAM_PLAYBACK ) ; int stream1 = tx ?SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE ; int stream2 = tx ?SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; if ( mcbsp -> latency [ stream2 ] ) { cpu_latency_qos_update_request ( & mcbsp -> pm_qos_req , mcbsp -> latency [ stream2 ] ) ; } if ( mcbsp -> latency [ stream1 ] ) { cpu_latency_qos_remove_request ( & mcbsp -> pm_qos_req ) ; } mcbsp -> latency [ stream1 ] = 0 ; if ( ! snd_soc_dai_active ( cpu_dai ) ) { mcbsp -> configured = 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "TEE_Result versal_soc_version ( uint8_t * version ) { struct versal_sip_payload p = { } ; const uint32_t version_shift = 12 ; if ( versal_sip_call ( VERSAL_SIP_SVC | PM_GET_CHIPID , 0 , 0 , 0 , 0 , & p ) ) { return TEE_ERROR_GENERIC ; } * version = p . data [ 2 ] >> version_shift ; return TEE_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void cifs_crypto_secmech_release ( struct TCP_Server_Info * server ) { if ( server -> secmech . cmacaes ) { server -> secmech . cmacaes = NULL ; } if ( server -> secmech . hmacsha256 ) { crypto_free_shash ( server -> secmech . hmacsha256 ) ; server -> secmech . hmacsha256 = NULL ; } if ( server -> secmech . md5 ) { crypto_free_shash ( server -> secmech . md5 ) ; server -> secmech . md5 = NULL ; } if ( server -> secmech . hmacmd5 ) { crypto_free_shash ( server -> secmech . hmacmd5 ) ; server -> secmech . hmacmd5 = NULL ; } if ( server -> secmech . ccmaesencrypt ) { crypto_free_aead ( server -> secmech . ccmaesencrypt ) ; server -> secmech . ccmaesencrypt = NULL ; } if ( server -> secmech . ccmaesdecrypt ) { crypto_free_aead ( server -> secmech . ccmaesdecrypt ) ; server -> secmech . ccmaesdecrypt = NULL ; } kfree ( server -> secmech . sdesccmacaes ) ; server -> secmech . sdesccmacaes = NULL ; kfree ( server -> secmech . sdeschmacsha256 ) ; server -> secmech . sdeschmacsha256 = NULL ; kfree ( server -> secmech . sdeschmacmd5 ) ; server -> secmech . sdeschmacmd5 = NULL ; kfree ( server -> secmech . sdescmd5 ) ; server -> secmech . sdescmd5 = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { int p ; p = getpid ( ) ; signal ( SIGALRM , sighandler ) ; kill ( p , SIGALRM ) ; printf ( \"passed\\n\" ) ; return EXIT_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct a2l_data * addr2line_init ( const char * path ) { bfd * abfd ; struct a2l_data * a2l = NULL ; abfd = bfd_openr ( path , NULL ) ; if ( ! bfd_check_format ( abfd , bfd_object ) ) { out } a2l = zalloc ( sizeof ( * a2l ) ) ; if ( a2l == NULL ) { out } a2l -> abfd = abfd ; a2l -> input = strdup ( path ) ; if ( a2l -> input == NULL ) { out } if ( slurp_symtab ( abfd , a2l ) ) { out } return a2l ; out if ( a2l ) { zfree ( ( char * * ) & a2l -> input ) ; free ( a2l ) ; } bfd_close ( abfd ) ; return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int match_prepare_for_sleep ( sd_bus_message * message , void * userdata , sd_bus_error * ret_error ) { Manager * m = ASSERT_PTR ( userdata ) ; Link * link ; int b , r ; assert ( message ) ; r = sd_bus_message_read ( message , \"b\" , & b ) ; if ( r < 0 ) { bus_log_parse_error ( r , NULL ) ; return 0 ; } if ( b ) { return 0 ; } log_debug ( \"Coming back from suspend, reconfiguring all connections...\" ) ; HASHMAP_FOREACH ( , ) { r = link_reconfigure ( link , true ) ; if ( r < 0 ) { log_link_warning_errno ( link , r , \"Failed to reconfigure interface: %m\" ) ; link_enter_failed ( link ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xhci_mtk_ssusb_init ( struct mtk_xhci * mtk ) { u32 value ; setbits_le32 ( mtk -> ippc + IPPC_IP_PW_CTRL0 , CTRL0_IP_SW_RST ) ; udelay ( 1 ) ; clrbits_le32 ( mtk -> ippc + IPPC_IP_PW_CTRL0 , CTRL0_IP_SW_RST ) ; value = readl ( mtk -> ippc + IPPC_IP_XHCI_CAP ) ; mtk -> num_u3ports = CAP_U3_PORT_NUM ( value , NULL ) ; mtk -> num_u2ports = CAP_U2_PORT_NUM ( value ) ; dev_info ( mtk -> dev , \"u2p:%d, u3p:%d\\n\" , mtk -> num_u2ports , mtk -> num_u3ports ) ; return xhci_mtk_host_enable ( mtk ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { RUN_TEST ( simple ) ; RUN_TEST ( percentile , NULL ) ; RUN_TEST ( get_rate ) ; END_TEST ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static enum drm_mode_status cdn_dp_connector_mode_valid ( struct drm_connector * connector , struct drm_display_mode * mode ) { struct cdn_dp_device * dp = connector_to_dp ( connector ) ; struct drm_display_info * display_info = & dp -> connector . display_info ; u32 requested , actual , rate , sink_max , source_max = 0 ; u8 lanes , bpc ; switch ( display_info -> bpc ) { case 10 : bpc = 10 ; break ; case 6 : bpc = 6 ; break ; default : bpc = 8 ; break ; } requested = mode -> clock * bpc * 3 / 1000 ; source_max = dp -> lanes ; sink_max = drm_dp_max_lane_count ( dp -> dpcd ) ; lanes = min ( source_max , sink_max ) ; source_max = drm_dp_bw_code_to_link_rate ( CDN_DP_MAX_LINK_RATE ) ; sink_max = drm_dp_max_link_rate ( dp -> dpcd ) ; rate = min ( source_max , sink_max ) ; actual = rate * lanes / 100 ; actual = actual * 8 / 10 ; if ( requested > actual ) { DRM_DEV_DEBUG_KMS ( dp -> dev , \"requested=%d, actual=%d, clock=%d\\n\" , requested , actual , mode -> clock ) ; return MODE_CLOCK_HIGH ; } return MODE_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "const struct comedi_lrange range_bipolar10 = { 1 { BIP_RANGE ( 10 ) } } ; EXPORT_SYMBOL_GPL ( range_bipolar10 ) ; const struct comedi_lrange range_bipolar5 = { 1 { BIP_RANGE ( 5 ) } } ; EXPORT_SYMBOL_GPL ( range_bipolar5 ) ; const struct comedi_lrange range_bipolar2_5 = { 1 { BIP_RANGE ( 2.5 ) } } ; EXPORT_SYMBOL_GPL ( range_bipolar2_5 ) ; const struct comedi_lrange range_unipolar10 = { 1 { UNI_RANGE ( 10 ) } } ; EXPORT_SYMBOL_GPL ( range_unipolar10 ) ; const struct comedi_lrange range_unipolar5 = { 1 { UNI_RANGE ( 5 ) } } ; EXPORT_SYMBOL_GPL ( range_unipolar5 ) ; const struct comedi_lrange range_unipolar2_5 = { 1 { UNI_RANGE ( 2.5 ) } } ; EXPORT_SYMBOL_GPL ( range_unipolar2_5 ) ; const struct comedi_lrange range_0_20mA = { 1 { RANGE_mA ( 0 , 20 ) } } ; EXPORT_SYMBOL_GPL ( range_0_20mA ) ; const struct comedi_lrange range_4_20mA = { 1 { RANGE_mA ( 4 , 20 ) } } ; EXPORT_SYMBOL_GPL ( range_4_20mA ) ; const struct comedi_lrange range_0_32mA = { 1 { RANGE_mA ( 0 , 32 ) } } ; EXPORT_SYMBOL_GPL ( range_0_32mA ) ; const struct comedi_lrange range_unknown = { 1 { { 0 1000000 UNIT_none } } } ; EXPORT_SYMBOL_GPL ( range_unknown ) ; int do_rangeinfo_ioctl ( struct comedi_device * dev , struct comedi_rangeinfo * it ) { int subd , chan ; const struct comedi_lrange * lr ; struct comedi_subdevice * s ; subd = ( it -> range_type >> 24 ) & 0xf ; chan = ( it -> range_type >> 16 ) & 0xff ; if ( subd >= dev -> n_subdevices ) { return - EINVAL ; } s = & dev -> subdevices [ subd ] ; if ( s -> range_table ) { lr = s -> range_table ; } if ( s -> range_table_list ) { if ( chan >= s -> n_chan ) { return - EINVAL ; } lr = s -> range_table_list [ chan ] ; } else { return - EINVAL ; } if ( RANGE_LENGTH ( it -> range_type ) != lr -> length ) { dev_dbg ( dev -> class_dev , \"wrong length %d should be %d (0x%08x)\\n\" , RANGE_LENGTH ( it -> range_type ) , lr -> length , it -> range_type ) ; return - EINVAL ; } if ( copy_to_user ( it -> range_ptr , lr -> range , sizeof ( comedi_krange ) * lr -> length ) ) { return - EFAULT ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void resource_location ( pe_resource_t * rsc , const pe_node_t * node , int score , const char * tag , pe_working_set_t * data_set ) { if ( node != NULL ) { resource_node_score ( rsc , node , score , tag ) ; } if ( data_set != NULL ) { GList * gIter = data_set -> nodes ; for ( ; gIter != NULL ; gIter = gIter -> next ) { pe_node_t * node_iter = ( pe_node_t * ) gIter -> data ; resource_node_score ( rsc , node_iter , score , tag ) ; } } else { GHashTableIter iter ; pe_node_t * node_iter = NULL ; g_hash_table_iter_init ( & iter , rsc -> allowed_nodes ) ; while ( g_hash_table_iter_next ( & iter , NULL , ( void * * ) & node_iter ) ) { resource_node_score ( rsc , node_iter , score , tag ) ; } } if ( node == NULL && score == - INFINITY ) { if ( rsc -> allocated_to ) { crm_info ( \"Deallocating %s from %s\" , rsc -> id , pe__node_name ( rsc -> allocated_to ) ) ; rsc -> allocated_to = NULL ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void hs_cmd_unoffer ( struct sourceinfo * si , int parc , char * parv [ ] ) { char * host = parv [ 0 ] ; struct hsoffered * l ; mowgli_node_t * n ; if ( ! host ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , \"UNOFFER\" ) ; command_fail ( si , fault_needmoreparams , _ ( \"Syntax: UNOFFER<vhost>\" ) ) ; return ; } l = hs_offer_find ( host , NULL ) ; if ( l == NULL ) { command_fail ( si , fault_nosuch_target , _ ( \"vhost \\2%s\\2 not found in vhost offer database.\" ) , host ) ; return ; } logcommand ( si , CMDLOG_ADMIN , \"UNOFFER: \\2%s\\2\" , host ) ; while ( l != NULL ) { mowgli_node_delete ( & l -> node , & hs_offeredlist ) ; strshare_unref ( l -> creator ) ; sfree ( l ) ; l = hs_offer_find ( host , NULL ) ; } command_success_nodata ( si , _ ( \"You have unoffered vhost \\2%s\\2.\" ) , host ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ibmasm_register_uart ( struct service_processor * sp ) { struct uart_8250_port uart ; void __iomem * iomem_base ; iomem_base = sp -> base_address + SCOUT_COM_B_BASE ; if ( 0 == readl ( iomem_base + UART_SCR ) ) { dev_info ( sp -> dev , \"IBM SP UART not registered, owned by service processor\\n\" ) ; sp -> serial_line = - 1 ; return ; } uart . port . irq = sp -> irq ; uart . port . uartclk = 3686400 ; uart . port . flags = UPF_SHARE_IRQ ; uart . port . iotype = UPIO_MEM ; uart . port . membase = iomem_base ; sp -> serial_line = serial8250_register_8250_port ( & uart ) ; if ( sp -> serial_line < 0 ) { dev_err ( sp -> dev , \"Failed to register serial port\\n\" ) ; return ; } enable_uart_interrupts ( sp -> base_address ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void _recursive_rmdir ( const char * dirnm ) int create_apid_dir ( uint64_t apid , uid_t uid , gid_t gid ) { int rc = 0 ; char * apid_dir = NULL ; apid_dir = xstrdup_printf ( LEGACY_SPOOL_DIR \"%\" PRIu64 , apid ) ; rc = mkdir ( apid_dir , 0700 ) ; if ( rc ) { CRAY_ERR ( \"mkdir %s failed: %m\" , apid_dir ) ; return SLURM_ERROR ; } rc = chown ( apid_dir , uid , gid ) ; if ( rc ) { CRAY_ERR ( \"chown %s, %u, %u failed: %m\" , apid_dir , uid , gid ) ; xfree ( apid_dir ) ; return SLURM_ERROR ; } if ( apid != SLURM_ID_HASH_LEGACY ( apid ) ) { char * oldapid_dir = xstrdup_printf ( LEGACY_SPOOL_DIR \"%\" PRIu64 , SLURM_ID_HASH_LEGACY ( apid ) ) ; if ( symlink ( apid_dir , oldapid_dir ) ) { CRAY_ERR ( \"symlink %s, %s failed: %m\" , apid_dir , oldapid_dir ) ; xfree ( apid_dir ) ; xfree ( oldapid_dir ) ; return SLURM_ERROR ; } xfree ( oldapid_dir ) ; } xfree ( apid_dir ) ; return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { char buf [ 32 ] ; char * fileout , * textstr ; l_int32 n , i , same , maxd , ntext , border , lossless , display , showtext ; l_float32 scalefact ; L_BMF * bmf ; PIX * pix1 , * pix2 , * pix3 , * pix4 , * pixd ; PIXA * pixa , * pixad ; if ( argc != 4 && argc != 8 ) { lept_stderr ( \"Syntax error in displaypixa:\\n\" \"   displaypixa filein fileout showtext\\n\" \"   displaypixa filein scalefact border\" \" lossless disp fileout showtext\\n\" ) ; return 1 ; } setLeptDebugOK ( 1 ) ; pixa = pixaReadBoth ( argv [ 1 ] ) ; pixaCountText ( pixa , & ntext ) ; if ( argc == 4 ) { fileout = argv [ 2 ] ; showtext = atoi ( argv [ 3 ] ) ; } if ( argc == 4 && ( showtext == 0 || ntext == 0 ) ) { pixaVerifyDepth ( pixa , & same , & maxd ) ; pixd = pixaDisplayTiledInRows ( pixa , maxd , 1400 , 1.0 , 0 , 10 , 0 ) ; pixDisplay ( pixd , 100 , 100 ) ; if ( pixGetDepth ( pixd ) == 1 ) { pixWrite ( fileout , pixd , IFF_PNG ) ; } else { pixWrite ( fileout , pixd , IFF_JFIF_JPEG ) ; } pixDestroy ( & pixd ) ; pixaDestroy ( & pixa ) ; return 0 ; } if ( argc == 4 ) { n = pixaGetCount ( pixa ) ; bmf = bmfCreate ( NULL , 10 ) ; pixad = pixaCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { pix1 = pixaGetPix ( pixa , i , L_CLONE ) ; pix2 = pixConvertTo32 ( pix1 ) ; pix3 = pixAddBorderGeneral ( pix2 , 10 , 10 , 5 , 5 , 0xffffff00 ) ; textstr = pixGetText ( pix1 ) ; if ( textstr && strlen ( textstr ) > 0 ) { sprintf ( buf , \"%s\" , textstr ) ; pix4 = pixAddSingleTextblock ( pix3 , bmf , buf , 0xff000000 , L_ADD_BELOW , NULL ) ; } else { pix4 = pixClone ( pix3 ) ; } pixaAddPix ( pixad , pix4 , L_INSERT ) ; pixDestroy ( & pix1 ) ; pixDestroy ( & pix2 ) ; pixDestroy ( & pix3 ) ; } bmfDestroy ( & bmf ) ; pixaVerifyDepth ( pixad , & same , & maxd ) ; pixd = pixaDisplayTiledInRows ( pixad , maxd , 1400 , 1.0 , 0 , 10 , 0 ) ; pixDisplay ( pixd , 100 , 100 ) ; if ( pixGetDepth ( pixd ) == 1 ) { pixWrite ( fileout , pixd , IFF_PNG ) ; } else { pixWrite ( fileout , pixd , IFF_JFIF_JPEG ) ; } pixDestroy ( & pixd ) ; pixaDestroy ( & pixa ) ; pixaDestroy ( & pixad ) ; return 0 ; } scalefact = atof ( argv [ 2 ] ) ; border = atoi ( argv [ 3 ] ) ; lossless = atoi ( argv [ 4 ] ) ; display = atoi ( argv [ 5 ] ) ; fileout = argv [ 6 ] ; showtext = atoi ( argv [ 7 ] ) ; if ( showtext && ntext == 0 ) { L_INFO ( \"No text found in any of the pix\\n\" , __func__ ) ; } bmf = ( showtext && ntext > 0 ) ?bmfCreate ( NULL , 10 ) : NULL ; n = pixaGetCount ( pixa ) ; pixad = pixaCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { pix1 = pixaGetPix ( pixa , i , L_CLONE ) ; pix2 = pixConvertTo32 ( pix1 ) ; pix3 = pixAddBorderGeneral ( pix2 , 10 , 10 , 5 , 5 , 0xffffff00 ) ; textstr = pixGetText ( pix1 ) ; if ( bmf && textstr && strlen ( textstr ) > 0 ) { snprintf ( buf , sizeof ( buf ) , \"%s\" , textstr ) ; pix4 = pixAddSingleTextblock ( pix3 , bmf , buf , 0xff000000 , L_ADD_BELOW , NULL ) ; } else { pix4 = pixClone ( pix3 ) ; } pixaAddPix ( pixad , pix4 , L_INSERT ) ; pixDestroy ( & pix1 ) ; pixDestroy ( & pix2 ) ; pixDestroy ( & pix3 ) ; } bmfDestroy ( & bmf ) ; pixaVerifyDepth ( pixad , & same , & maxd ) ; pixd = pixaDisplayTiledInRows ( pixad , maxd , 1400 , scalefact , 0 , 10 , border ) ; if ( display ) { pixDisplay ( pixd , 20 , 20 ) ; } if ( pixGetDepth ( pixd ) == 1 || lossless ) { pixWrite ( fileout , pixd , IFF_PNG ) ; } else { pixWrite ( fileout , pixd , IFF_JFIF_JPEG ) ; } pixDestroy ( & pixd ) ; pixaDestroy ( & pixa ) ; pixaDestroy ( & pixad ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void avic_vm_destroy ( struct kvm * kvm ) { unsigned long flags ; struct kvm_svm * kvm_svm = to_kvm_svm ( kvm ) ; if ( kvm_svm -> avic_logical_id_table_page ) { __free_page ( kvm_svm -> avic_logical_id_table_page ) ; } if ( kvm_svm -> avic_physical_id_table_page ) { __free_page ( kvm_svm -> avic_physical_id_table_page ) ; } spin_lock_irqsave ( & svm_vm_data_hash_lock , flags ) ; hash_del ( & kvm_svm -> hnode ) ; spin_unlock_irqrestore ( & svm_vm_data_hash_lock , flags ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void __usbhsg_recip_send_complete ( struct usb_ep * ep , struct usb_request * req ) { struct usbhsg_request * ureq = usbhsg_req_to_ureq ( req ) ; usb_ep_free_request ( ep , req ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void openrisc_cpu_set_pc ( CPUState * cs , vaddr value ) { OpenRISCCPU * cpu = OPENRISC_CPU ( cs ) ; cpu -> env . pc = value ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t proc_fault_inject_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct task_struct * task ; char buffer [ PROC_NUMBUF ] ; int make_it_fail ; int rv ; if ( ! capable ( CAP_SYS_RESOURCE ) ) { return - EPERM ; } if ( count > sizeof ( buffer ) - 1 ) { count = sizeof ( buffer ) - 1 ; } if ( copy_from_user ( buffer , buf , count ) ) { return - EFAULT ; } rv = kstrtoint ( strstrip ( buffer ) , 0 , & make_it_fail ) ; if ( rv < 0 ) { return rv ; } if ( make_it_fail ( 0 || make_it_fail ) 1 ) { return - EINVAL ; } task = get_proc_task ( file_inode ( file ) ) ; if ( ! task ) { return - ESRCH ; } task -> make_it_fail = make_it_fail ; put_task_struct ( task ) ; return count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nv50_pior_output_dp_lnk_ctl ( struct nvkm_output_dp * outp , int nr , int bw , bool ef ) { int ret = nvkm_i2c_aux_lnk_ctl ( outp -> aux , nr , bw , ef ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static HB_Error Lookup_ContextPos2 ( GPOS_Instance * gpi , HB_ContextPosFormat2 * cpf2 , HB_Buffer buffer , HB_UShort flags , HB_UShort context_length , int nesting_level ) { HB_UShort index , property ; HB_Error error ; HB_UShort i , j , k , known_classes ; HB_UShort * classes ; HB_UShort * cl ; HB_GPOSHeader * gpos = gpi -> gpos ; HB_PosClassSet * pcs ; HB_PosClassRule * pr ; HB_GDEFHeader * gdef ; gdef = gpos -> gdef ; if ( CHECK_Property ( gdef , IN_CURITEM ( ) , flags , & property ) ) { return error ; } error = _HB_OPEN_Coverage_Index ( & cpf2 -> Coverage , IN_CURGLYPH ( ) , & index ) ; if ( error ) { return error ; } if ( ALLOC_ARRAY ( classes , cpf2 -> MaxContextLength , HB_UShort ) ) { return error ; } error = _HB_OPEN_Get_Class ( & cpf2 -> ClassDef , IN_CURGLYPH ( ) , & classes [ 0 ] , NULL ) ; if ( error && error != HB_Err_Not_Covered ) { End } known_classes = 0 ; pcs = & cpf2 -> PosClassSet [ classes [ 0 ] ] ; if ( ! pcs ) { error = ERR ( HB_Err_Invalid_SubTable ) ; End } for ( k = 0 ; k < pcs -> PosClassRuleCount ; k ++ ) { pr = & pcs -> PosClassRule [ k ] ; if ( context_length != 0xFFFF && context_length < pr -> GlyphCount ) { next_posclassrule } if ( buffer -> in_pos + pr -> GlyphCount > buffer -> in_length ) { next_posclassrule } cl = pr -> Class ; for ( i = 1 , j = buffer -> in_pos + 1 ; i < pr -> GlyphCount ; i ++ , j ++ ) { while ( CHECK_Property ( gdef , IN_ITEM ( j ) , flags , & property ) ) { if ( error && error != HB_Err_Not_Covered ) { End } if ( j + pr -> GlyphCount - i == ( HB_Int ) buffer -> in_length ) { next_posclassrule } j ++ ; } if ( i > known_classes ) { error = _HB_OPEN_Get_Class ( & cpf2 -> ClassDef , IN_GLYPH ( j ) , & classes [ i ] , NULL ) ; if ( error && error != HB_Err_Not_Covered ) { End } known_classes = i ; } if ( cl [ i - 1 ] != classes [ i ] ) { next_posclassrule } } error = Do_ContextPos ( gpi , pr -> GlyphCount , pr -> PosCount , pr -> PosLookupRecord , buffer , nesting_level ) ; End next_posclassrule } error = HB_Err_Not_Covered ; End FREE ( classes ) ; return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int svcauth_gss_set_client ( struct svc_rqst * rqstp ) { struct gss_svc_data * svcdata = rqstp -> rq_auth_data ; struct rsc * rsci = svcdata -> rsci ; struct rpc_gss_wire_cred * gc = & svcdata -> clcred ; int stat ; rqstp -> rq_gssclient = find_gss_auth_domain ( rsci -> mechctx , gc -> gc_svc ) ; if ( rqstp -> rq_gssclient == NULL ) { return SVC_DENIED ; } stat = svcauth_unix_set_client ( rqstp , NULL ) ; if ( stat == SVC_DROP || stat == SVC_CLOSE ) { return stat ; } return SVC_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mm_receive_fd ( int socket ) { struct msghdr msg ; { struct cmsghdr hdr ; char buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; } , cmsgbuf char ch ; struct cmsghdr * cmsg ; struct iovec vec ; ssize_t n ; int fd ; bzero ( & msg , sizeof msg ) ; vec . iov_base = & ch ; vec . iov_len = 1 ; msg . msg_iov = & vec ; msg . msg_control = & cmsgbuf . buf ; msg . msg_controllen = sizeof ( cmsgbuf . buf ) ; if ( ( n = recvmsg ( socket , & msg , 0 ) ) == - 1 ) { log_error ( \"mm_receive_fd: recvmsg\" ) ; return - 1 ; } if ( n != 1 ) { log_error ( \"mm_receive_fd: recvmsg: expected received 1 got %zd\" , n ) ; return - 1 ; } cmsg = CMSG_FIRSTHDR ( & msg ) ; if ( cmsg == NULL ) { log_error ( \"mm_receive_fd: no message header\" ) ; return - 1 ; } if ( cmsg -> cmsg_type != SCM_RIGHTS ) { log_error ( \"mm_receive_fd: expected type %d got %d\" , SCM_RIGHTS , cmsg -> cmsg_type ) ; return - 1 ; } fd = ( * ( int * ) CMSG_DATA ( cmsg ) ) ; return fd ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "extern int onigenc_mb2_code_to_mbc ( OnigEncoding enc , OnigCodePoint code , UChar * buf ) { UChar * p = buf ; if ( ( code & 0xff00 ) != 0 ) { * p ++ = ( UChar ) ( ( code >> 8 ) & 0xff ) ; } * p ++ = ( UChar ) ( code & 0xff ) ; return ( int ) ( p - buf ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int uhidread ( dev_t dev , struct uio * uio , int flag ) { struct uhid_softc * sc ; int error ; sc -> sc_refcnt ++ ; error = uhid_do_read ( sc , uio , flag ) ; if ( -- sc -> sc_refcnt < 0 ) { usb_detach_wakeup ( & sc -> sc_hdev . sc_dev ) ; } return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nft_parse_compat ( const struct nlattr * attr , u16 * proto , bool * inv ) { struct nlattr * tb [ NFTA_RULE_COMPAT_MAX + 1 ] ; u32 flags ; int err ; err = nla_parse_nested ( tb , NFTA_RULE_COMPAT_MAX , attr , nft_rule_compat_policy , NULL ) ; if ( err < 0 ) { return err ; } flags = ntohl ( nla_get_be32 ( tb [ NFTA_RULE_COMPAT_FLAGS ] ) ) ; if ( flags & ~ NFT_RULE_COMPAT_F_MASK ) { return - EINVAL ; } if ( flags & NFT_RULE_COMPAT_F_INV ) { * inv = true ; } * proto = ntohl ( nla_get_be32 ( tb [ NFTA_RULE_COMPAT_PROTO ] ) ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ff_configure_buffers_for_index ( AVFormatContext * s , int64_t time_tolerance ) { int pos_delta = 0 ; int64_t skip = 0 ; const char * proto = avio_find_protocol_name ( s -> url ) ; FFIOContext * ctx ; av_assert0 ( time_tolerance >= 0 ) ; if ( ! proto ) { av_log ( s , AV_LOG_INFO , \"Protocol name not provided, cannot determine if input is local or \" \"a network protocol, buffers and access patterns cannot be configured \" \"optimally without knowing the protocol\\n\" ) ; } if ( proto && ! ( strcmp ( proto , \"file\" ) && strcmp ( proto , \"pipe\" ) && strcmp ( proto , \"cache\" ) ) ) { return ; } for ( unsigned ist1 = 0 ; ist1 < s -> nb_streams ; ist1 ++ ) { AVStream * const st1 = s -> streams [ ist1 ] ; FFStream * const sti1 = ffstream ( st1 ) ; for ( unsigned ist2 = 0 ; ist2 < s -> nb_streams ; ist2 ++ ) { AVStream * const st2 = s -> streams [ ist2 ] ; FFStream * const sti2 = ffstream ( st2 ) ; if ( ist1 == ist2 ) { continue ; } for ( int i1 = 0 , i2 = 0 ; i1 < sti1 -> nb_index_entries ; i1 ++ ) { const AVIndexEntry * const e1 = & sti1 -> index_entries [ i1 ] ; int64_t e1_pts = av_rescale_q ( e1 -> timestamp , st1 -> time_base , AV_TIME_BASE_Q ) ; skip = FFMAX ( skip , e1 -> size ) ; for ( ; i2 < sti2 -> nb_index_entries ; i2 ++ ) { const AVIndexEntry * const e2 = & sti2 -> index_entries [ i2 ] ; int64_t e2_pts = av_rescale_q ( e2 -> timestamp , st2 -> time_base , AV_TIME_BASE_Q ) ; if ( e2_pts < e1_pts || e2_pts - ( uint64_t ) e1_pts < time_tolerance ) { continue ; } pos_delta = FFMAX ( pos_delta , e1 -> pos - e2 -> pos ) ; break ; } } } } pos_delta *= 2 ; ctx = ffiocontext ( s -> pb ) ; if ( s -> pb -> buffer_size < pos_delta && pos_delta < ( 1 << 24 ) ) { av_log ( s , AV_LOG_VERBOSE , \"Reconfiguring buffers to size %\" PRId64 \"\\n\" , pos_delta ) ; if ( ffio_realloc_buf ( s -> pb , pos_delta ) ) { av_log ( s , AV_LOG_ERROR , \"Realloc buffer fail.\\n\" ) ; return ; } ctx -> short_seek_threshold = FFMAX ( ctx -> short_seek_threshold , pos_delta / 2 ) ; } if ( skip < ( 1 << 23 ) ) { ctx -> short_seek_threshold = FFMAX ( ctx -> short_seek_threshold , skip ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool DetectQuicHashValidateCallback ( const Signature * s , const char * * sigerror ) { const SigMatch * sm = s -> init_data -> smlists [ g_buffer_id ] ; for ( ; sm != NULL ; sm = sm -> next ) { const DetectContentData * cd = ( DetectContentData * ) sm -> ctx ; if ( cd -> flags & DETECT_CONTENT_NOCASE ) { * sigerror = BUFFER_NAME \" should not be used together with \" \"nocase, since the rule is automatically \" \"lowercased anyway which makes nocase redundant.\" ; SCLogWarning ( \"rule %u: %s\" , s -> id , * sigerror ) ; } if ( cd -> content_len != 32 ) { * sigerror = \"Invalid length of the specified\" BUFFER_NAME \" (should \" \"be 32 characters long). This rule will therefore \" \"never match.\" ; SCLogWarning ( \"rule %u: %s\" , s -> id , * sigerror ) ; return FALSE ; } for ( size_t i = 0 ; i < cd -> content_len ; ++ i ) { if ( ! isxdigit ( cd -> content [ i ] ) ) { * sigerror = \"Invalid \" BUFFER_NAME \" string (should be string of hexadecimal characters).\" \"This rule will therefore never match.\" ; SCLogWarning ( \"rule %u: %s\" , s -> id , * sigerror ) ; return FALSE ; } } } return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "u32 sd_read32 ( struct intf_hdl * pintfhdl , u32 addr , s32 * err ) { struct adapter * padapter ; struct dvobj_priv * psdiodev ; struct sdio_data * psdio ; u32 v = 0 ; struct sdio_func * func ; bool claim_needed ; padapter = pintfhdl -> padapter ; psdiodev = pintfhdl -> pintf_dev ; psdio = & psdiodev -> intf_data ; if ( padapter -> bSurpriseRemoved ) { return v ; } func = psdio -> func ; claim_needed = rtw_sdio_claim_host_needed ( func ) ; if ( claim_needed ) { sdio_claim_host ( func ) ; } v = sdio_readl ( func , addr , err ) ; if ( claim_needed ) { sdio_release_host ( func ) ; } if ( err && * err ) { int i ; * err = 0 ; for ( i = 0 ; i < SD_IO_TRY_CNT ; i ++ ) { if ( claim_needed ) { sdio_claim_host ( func ) ; } v = sdio_readl ( func , addr , err ) ; if ( claim_needed ) { sdio_release_host ( func ) ; } if ( * err == 0 ) { rtw_reset_continual_io_error ( psdiodev ) ; break ; } else { if ( ( - ESHUTDOWN == * err ) || ( - ENODEV == * err ) ) { padapter -> bSurpriseRemoved = true ; } if ( rtw_inc_and_chk_continual_io_error ( psdiodev ) == true ) { padapter -> bSurpriseRemoved = true ; break ; } } } } return v ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int uwsgi_apply_final_transformations ( struct wsgi_request * wsgi_req ) { struct uwsgi_transformation * ut = wsgi_req -> transformations ; wsgi_req -> transformed_chunk_len = 0 ; char * t_buf = NULL ; size_t t_len = 0 ; uint8_t flushed = 0 ; int found_nostream = 0 ; while ( ut ) { if ( ! found_nostream ) { if ( ! ut -> can_stream ) { found_nostream = 1 ; } else { if ( ! ut -> chunk ) { return 0 ; } t_buf = ut -> chunk -> buf ; t_len = ut -> chunk -> pos ; next } } if ( ! ut -> chunk ) { if ( t_len > 0 ) { ut -> chunk = uwsgi_buffer_new ( t_len ) ; } else { ut -> chunk = uwsgi_buffer_new ( uwsgi . page_size ) ; } } if ( t_len > 0 ) { if ( uwsgi_buffer_append ( ut -> chunk , t_buf , t_len ) ) { return - 1 ; } } ut -> round ++ ; if ( ut -> func ( wsgi_req , ut ) ) { return - 1 ; } if ( ut -> flushed ) { flushed = 1 ; } t_buf = ut -> chunk -> buf ; t_len = ut -> chunk -> pos ; next ut = ut -> next ; } if ( ! flushed ) { wsgi_req -> transformed_chunk = t_buf ; wsgi_req -> transformed_chunk_len = t_len ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsetenv ( ) { size_t len ; char * * ep ; if ( name == NULL || * name == '\\0' || strchr ( name , '=' ) != NULL ) { return - 1 ; } len = strlen ( name ) ; LOCK ; ep = __environ ; while ( * ep != NULL ) { if ( ! strncmp ( * ep , name , len ) && ( * ep ) [ len ] == '=' ) { char * * dp = ep ; { dp [ 0 ] = dp [ 1 ] ; } * dp ++ ; } else { ++ ep ; } } UNLOCK ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ext4_file_mmap ( struct file * file , struct vm_area_struct * vma ) { struct inode * inode = file -> f_mapping -> host ; struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; struct dax_device * dax_dev = sbi -> s_daxdev ; if ( ! daxdev_mapping_supported ( vma , dax_dev ) ) { return - EOPNOTSUPP ; } file_accessed ( file ) ; if ( IS_DAX ( file_inode ( file ) ) ) { vma -> vm_ops = & ext4_dax_vm_ops ; vm_flags_set ( vma , VM_HUGEPAGE ) ; } else { vma -> vm_ops = & ext4_file_vm_ops ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static long __gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file_inode ( file ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_alloc_parms ap = { . aflags = 0 } ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes , max_blks ; int error ; const loff_t pos = offset ; const loff_t count = len ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) { bytes = UINT_MAX ; } bytes &= bsize_mask ; if ( bytes == 0 ) { bytes = sdp -> sd_sb . sb_bsize ; } gfs2_size_hint ( file , offset , len ) ; gfs2_write_calc_reserv ( ip , PAGE_SIZE , & data_blocks , & ind_blocks ) ; ap . min_target = data_blocks + ind_blocks ; while ( len > 0 ) { if ( len < bytes ) { bytes = len ; } if ( ! gfs2_write_alloc_required ( ip , offset , bytes ) ) { len -= bytes ; offset += bytes ; continue ; } max_bytes = ( len > max_chunk_size ) ?max_chunk_size : len ; gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; ap . target = data_blocks + ind_blocks ; error = gfs2_quota_lock_check ( ip , & ap ) ; max_blks = UINT_MAX ; if ( ap . allowed ) { max_blks = ap . allowed ; } error = gfs2_inplace_reserve ( ip , & ap ) ; if ( error ) { out_qunlock } if ( ip -> i_res . rs_reserved < max_blks ) { max_blks = ip -> i_res . rs_reserved ; } calc_max_reserv ( ip , & max_bytes , & data_blocks , & ind_blocks , max_blks ) ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip , data_blocks + ind_blocks ) ; if ( gfs2_is_jdata ( ip ) ) { rblocks += data_blocks ?data_blocks : 1 ; } error = gfs2_trans_begin ( sdp , rblocks , PAGE_SIZE >> inode -> i_blkbits ) ; if ( error ) { out_trans_fail } error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) { out_trans_fail } len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && ( pos + count ) > inode -> i_size ) { i_size_write ( inode , pos + count ) ; } file_update_time ( file ) ; mark_inode_dirty ( inode ) ; if ( ( file -> f_flags & O_DSYNC ) || IS_SYNC ( file -> f_mapping -> host ) ) { return vfs_fsync_range ( file , pos , pos + count - 1 , ( file -> f_flags & __O_SYNC ) ?0 : 1 ) ; } return 0 ; out_trans_fail gfs2_inplace_release ( ip ) ; out_qunlock gfs2_quota_unlock ( ip ) ; return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sctp_is_any ( struct sock * sk , const union sctp_addr * addr ) { unsigned short fam = 0 ; struct sctp_af * af ; if ( addr -> sa . sa_family != AF_UNSPEC ) { fam = addr -> sa . sa_family ; } if ( sk ) { fam = sk -> sk_family ; } af = sctp_get_af_specific ( fam , NULL ) ; if ( ! af ) { return 0 ; } return af -> is_any ( addr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void png_simple_error_callback ( png_structp png_save_ptr , png_const_charp error_msg ) { GError * * error ; error = png_get_error_ptr ( png_save_ptr , NULL ) ; if ( error && * error == NULL ) { g_set_error ( error , GDK_PIXBUF_ERROR , GDK_PIXBUF_ERROR_FAILED , _ ( \"Fatal error in PNG image file: %s\" ) , error_msg ) ; } longjmp ( png_jmpbuf ( png_save_ptr ) , 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fsl7450_stop ( void ) { pmc_stop_ctrs ( ) ; mb ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "value llvm_string_of_llvalue ( LLVMValueRef M ) { char * ValueCStr = LLVMPrintValueToString ( M ) ; value ValueStr = caml_copy_string ( ValueCStr ) ; LLVMDisposeMessage ( ValueCStr , NULL ) ; return ValueStr ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t st_taps_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t size ) { struct omap_mcbsp * mcbsp = dev_get_drvdata ( dev ) ; struct omap_mcbsp_st_data * st_data = mcbsp -> st_data ; int val , tmp , status , i = 0 ; spin_lock_irq ( & mcbsp -> lock ) ; st_data -> nr_taps = 0 ; { status = sscanf ( buf , \"%d%n\" , & val , & tmp ) ; if ( status < 0 || status == 0 ) { size = - EINVAL ; out } if ( val ( - 32768 || val ) 32767 ) { size = - EINVAL ; out } st_data -> taps [ i ++ ] = val ; buf += tmp ; if ( * buf != ',' ) { break ; } buf ++ ; } 1 ; st_data -> nr_taps = i ; out spin_unlock_irq ( & mcbsp -> lock ) ; return size ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "discard_pending_stack_adjust ( ) { stack_pointer_delta -= pending_stack_adjust ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int bytgpio_match ( struct device * parent , void * match , void * aux ) { struct acpi_attach_args * aaa = aux ; struct cfdata * cf = match ; return acpi_matchhids ( aaa , bytgpio_hids , cf -> cf_driver -> cd_name ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static __poll_t mbox_test_message_poll ( struct file * filp , struct poll_table_struct * wait ) { struct mbox_test_device * tdev = filp -> private_data ; poll_wait ( filp , & tdev -> waitq , wait ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int msm_hdmi_phy_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct hdmi_phy * phy ; int ret ; phy = devm_kzalloc ( dev , sizeof ( * phy ) , GFP_KERNEL ) ; phy -> cfg = ( hdmi_phy_cfg * ) of_device_get_match_data ( dev ) ; if ( ! phy -> cfg ) { return - ENODEV ; } phy -> mmio = msm_ioremap ( pdev , \"hdmi_phy\" ) ; if ( IS_ERR ( phy -> mmio ) ) { DRM_DEV_ERROR ( dev , \"%s: failed to map phy base\\n\" , __func__ ) ; return - ENOMEM ; } phy -> pdev = pdev ; ret = msm_hdmi_phy_resource_init ( phy ) ; if ( ret ) { return ret ; } pm_runtime_enable ( & pdev -> dev ) ; ret = msm_hdmi_phy_resource_enable ( phy ) ; if ( ret ) { return ret ; } ret = msm_hdmi_phy_pll_init ( pdev , phy -> cfg -> type ) ; if ( ret ) { DRM_DEV_ERROR ( dev , \"couldn't init PLL\\n\" ) ; msm_hdmi_phy_resource_disable ( phy ) ; return ret ; } msm_hdmi_phy_resource_disable ( phy ) ; platform_set_drvdata ( pdev , phy ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int fru_get_segments ( section_hdl_t section , segment_t * segment , int maxseg , door_cred_t * cred ) { int count ; hash_obj_t * sec_object ; hash_obj_t * seg_object ; section_obj_t * sec_obj ; sec_object = lookup_handle_object ( section , SECTION_TYPE ) ; sec_obj = sec_object -> u . sec_obj ; if ( sec_obj == NULL ) { return ( - 1 ) ; } if ( sec_obj -> num_of_segment > maxseg ) { return ( - 1 ) ; } seg_object = sec_object -> u . sec_obj -> seg_obj_list ; if ( seg_object == NULL ) { return ( - 1 ) ; } for ( count = 0 ; count < sec_obj -> num_of_segment ; count ++ ) { segment -> handle = seg_object -> obj_hdl ; ( void ) memcpy ( segment -> name , seg_object -> u . seg_obj -> segment . name , SEG_NAME_LEN ) ; segment -> descriptor = seg_object -> u . seg_obj -> segment . descriptor ; segment -> offset = seg_object -> u . seg_obj -> segment . offset ; segment -> length = seg_object -> u . seg_obj -> segment . length ; seg_object = seg_object -> u . seg_obj -> next ; segment ++ ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ice_read_sr_word_aq ( struct ice_hw * hw , u16 offset , u16 * data ) { u32 bytes = sizeof ( u16 ) ; int data_local ; int status ; status = ice_read_flat_nvm ( hw , offset * sizeof ( u16 ) , & bytes , ( __force u8 * ) & data_local , true ) ; if ( status ) { return status ; } * data = le16_to_cpu ( data_local ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "Page PageGetTempPage ( Page page ) { Size pageSize ; Page temp ; pageSize = PageGetPageSize ( page , NULL ) ; temp = ( Page ) palloc ( pageSize ) ; return temp ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int evhttp_set_flags ( struct evhttp * http , int flags ) { int avail_flags = 0 ; avail_flags |= EVHTTP_SERVER_LINGERING_CLOSE ; http -> flags &= ~ avail_flags ; http -> flags |= flags ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void addGpgProvide ( Header h , const char * n , const char * v ) { rpmsenseFlags pflags = ( RPMSENSE_KEYRING | RPMSENSE_EQUAL ) ; char * nsn = rstrscat ( NULL , \"gpg(\" , n , \")\" , NULL ) ; headerPutString ( h , RPMTAG_PROVIDENAME , nsn ) ; headerPutString ( h , RPMTAG_PROVIDEVERSION , v ) ; headerPutUint32 ( h , RPMTAG_PROVIDEFLAGS , & pflags , 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mvpp2_dbgfs_flow_type_show ( struct seq_file * s , void * unused ) { struct mvpp2_dbgfs_flow_entry * entry = s -> private ; const struct mvpp2_cls_flow * f ; const char * flow_name ; f = mvpp2_cls_flow_get ( entry -> flow ) ; switch ( f -> flow_type ) { case IPV4_FLOW : flow_name = \"ipv4\" ; break ; case IPV6_FLOW : flow_name = \"ipv6\" ; break ; case TCP_V4_FLOW : flow_name = \"tcp4\" ; break ; case TCP_V6_FLOW : flow_name = \"tcp6\" ; break ; case UDP_V4_FLOW : flow_name = \"udp4\" ; break ; case UDP_V6_FLOW : flow_name = \"udp6\" ; break ; default : flow_name = \"other\" ; } seq_printf ( s , \"%s\\n\" , flow_name ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char children_doc [ ] \"This is a tuple of child nodes. For most nodes this will be\\n\" \"empty. If this node represents a block instead of a single line of the \" \"config\\n\" \"file it will contain all nodes in this block.\\n\" ; ; static PyObject * Config_new ( PyTypeObject * type , PyObject * args , PyObject * kwds ) { Config * self ; self = ( Config * ) type -> tp_alloc ( type , 0 ) ; if ( self == NULL ) { return NULL ; } self -> parent = NULL ; self -> key = NULL ; self -> values = NULL ; return ( PyObject * ) self ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tegra210_dmic_hw_params ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * params , struct snd_soc_dai * dai ) { struct tegra210_dmic * dmic = snd_soc_dai_get_drvdata ( dai ) ; unsigned int srate , clk_rate , channels ; struct tegra_cif_conf cif_conf ; unsigned long long gain_q23 = DEFAULT_GAIN_Q23 ; int err ; channels = params_channels ( params ) ; cif_conf . audio_ch = channels ; switch ( dmic -> ch_select ) { case DMIC_CH_SELECT_LEFT : case DMIC_CH_SELECT_RIGHT : cif_conf . client_ch = 1 ; break ; case DMIC_CH_SELECT_STEREO : cif_conf . client_ch = 2 ; break ; default : dev_err ( dai -> dev , \"invalid DMIC client channels\\n\" ) ; return - EINVAL ; } srate = params_rate ( params ) ; clk_rate = ( DMIC_OSR_FACTOR << dmic -> osr_val ) * srate ; err = clk_set_rate ( dmic -> clk_dmic , clk_rate ) ; if ( err ) { dev_err ( dai -> dev , \"can't set DMIC clock rate %u, err: %d\\n\" , clk_rate , err ) ; return err ; } regmap_update_bits ( dmic -> regmap , TEGRA210_DMIC_CTRL , TEGRA210_DMIC_CTRL_LRSEL_POLARITY_MASK | TEGRA210_DMIC_CTRL_OSR_MASK | TEGRA210_DMIC_CTRL_CHANNEL_SELECT_MASK , ( dmic -> lrsel << LRSEL_POL_SHIFT ) | ( dmic -> osr_val << OSR_SHIFT ) | ( ( dmic -> ch_select + 1 ) << CH_SEL_SHIFT ) ) ; if ( dmic -> boost_gain ) { gain_q23 = div_u64 ( gain_q23 * dmic -> boost_gain , 100 ) ; } regmap_write ( dmic -> regmap , TEGRA210_DMIC_LP_FILTER_GAIN , ( unsigned int ) gain_q23 ) ; switch ( params_format ( params ) ) { case SNDRV_PCM_FORMAT_S16_LE : cif_conf . audio_bits = TEGRA_ACIF_BITS_16 ; break ; case SNDRV_PCM_FORMAT_S32_LE : cif_conf . audio_bits = TEGRA_ACIF_BITS_32 ; break ; default : dev_err ( dai -> dev , \"unsupported format!\\n\" ) ; return - EOPNOTSUPP ; } cif_conf . client_bits = TEGRA_ACIF_BITS_24 ; cif_conf . mono_conv = dmic -> mono_to_stereo ; cif_conf . stereo_conv = dmic -> stereo_to_mono ; tegra_set_cif ( dmic -> regmap , TEGRA210_DMIC_TX_CIF_CTRL , & cif_conf ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int set_tx_tail ( struct ldc_channel * lp , unsigned long tail ) { unsigned long orig_tail = lp -> tx_tail ; int limit = 1000 ; lp -> tx_tail = tail ; while ( limit -- > 0 ) { unsigned long err ; err = sun4v_ldc_tx_set_qtail ( lp -> id , tail ) ; if ( err != HV_EWOULDBLOCK ) { lp -> tx_tail = orig_tail ; return - EINVAL ; } udelay ( 1 ) ; } lp -> tx_tail = orig_tail ; return - EBUSY ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int xfs_inobt_get_rec ( struct xfs_btree_cur * cur , xfs_inobt_rec_incore_t * irec , int * stat ) { union xfs_btree_rec * rec ; int error ; error = xfs_btree_get_rec ( cur , & rec , stat ) ; irec -> ir_startino = be32_to_cpu ( rec -> inobt . ir_startino ) ; if ( xfs_sb_version_hassparseinodes ( & cur -> bc_mp -> m_sb ) ) { irec -> ir_holemask = be16_to_cpu ( rec -> inobt . ir_u . sp . ir_holemask ) ; irec -> ir_count = rec -> inobt . ir_u . sp . ir_count ; irec -> ir_freecount = rec -> inobt . ir_u . sp . ir_freecount ; } else { irec -> ir_holemask = XFS_INOBT_HOLEMASK_FULL ; irec -> ir_count = XFS_INODES_PER_CHUNK ; irec -> ir_freecount = be32_to_cpu ( rec -> inobt . ir_u . f . ir_freecount ) ; } irec -> ir_free = be64_to_cpu ( rec -> inobt . ir_free ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int lfopen ( struct open_file * f , ... ) { struct hppa_dev * dp = f -> f_devdata ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int npcm_timer_probe ( struct udevice * dev ) { struct timer_dev_priv * uc_priv = dev_get_uclass_priv ( dev ) ; struct npcm_timer_priv * priv = dev_get_priv ( dev ) ; enum input_clock_type type = dev_get_driver_data ( dev ) ; struct clk clk ; int ret ; priv -> base = dev_read_addr_ptr ( dev ) ; uc_priv -> clock_rate = NPCM_TIMER_CLOCK_RATE ; if ( type == INPUT_CLOCK_NON_FIXED ) { ret = clk_get_by_index ( dev , 0 , & clk ) ; if ( ret < 0 ) { return ret ; } ret = clk_set_rate ( & clk , NPCM_TIMER_INPUT_RATE ) ; if ( ret < 0 ) { return ret ; } } writel ( 0 , priv -> base + TCR0 ) ; writel ( NPCM_TIMER_MAX_VAL , priv -> base + TICR0 ) ; writel ( TCR_EN | TCR_MODE_PERIODIC | TCR_PRESCALE , priv -> base + TCR0 ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct ia_css_host_data * ia_css_host_data_allocate ( size_t size ) { struct ia_css_host_data * me ; me = kmalloc ( sizeof ( ia_css_host_data ) , GFP_KERNEL ) ; if ( ! me ) { return NULL ; } me -> size = ( uint32_t ) size ; me -> address = sh_css_malloc ( size ) ; if ( ! me -> address ) { return NULL ; } return me ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int bzrtp_sendGoClear ( bzrtpContext_t * zrtpContext , uint32_t selfSSRC ) { bzrtpChannelContext_t * zrtpChannelContext = getChannelContext ( zrtpContext , selfSSRC ) ; if ( zrtpChannelContext == NULL && zrtpChannelContext -> isSecure ) { return BZRTP_ERROR_INVALIDCONTEXT ; } bzrtpEvent_t goClearEvent ; goClearEvent . eventType = BZRTP_EVENT_GOCLEAR ; goClearEvent . bzrtpPacketStringLength = 0 ; goClearEvent . bzrtpPacket = NULL ; goClearEvent . zrtpContext = zrtpContext ; goClearEvent . zrtpChannelContext = zrtpChannelContext ; if ( zrtpChannelContext -> stateMachine != NULL ) { return zrtpChannelContext -> stateMachine ( goClearEvent ) ; } return 0 ; return BZRTP_ERROR_GOCLEARDISABLED ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int traverse_level_nondir ( struct fs_traverse * ftp , traverse_state_t * tsp , struct fst_node * pnp , dent_arg_t * darg ) { int pl ; int rv ; struct fst_node en ; longlong_t cookie_verf ; fs_dent_info_t * dent ; struct dirent * buf ; size_t len = 0 ; int fd ; rv = 0 ; pl = strlen ( pnp -> tn_path ) ; buf = ndmp_malloc ( MAX_DENT_BUF_SIZE ) ; fd = open ( tsp -> ts_fh . fh_fpath , O_RDONLY ) ; if ( fd == - 1 ) { free ( buf ) ; return ( errno ) ; } while ( rv == 0 ) { long i , n_entries ; darg -> da_end = 0 ; n_entries = 0 ; rv = fs_getdents ( fd , buf , & len , pnp -> tn_path , & tsp -> ts_dpos , & cookie_verf , & n_entries , darg ) ; if ( rv < 0 ) { traverse_stats . fss_readdir_err ++ ; NDMP_LOG ( LOG_DEBUG , \"Error %d on readdir(%s) pos %d\" , rv , pnp -> tn_path , tsp -> ts_dpos ) ; if ( STOP_ONERR ( ftp ) ) { break ; } rv = SKIP_ENTRY ; continue ; } else { if ( rv > 0 ) { rv = 0 ; } else { break ; } } dent = ( fs_dent_info_t * ) darg -> da_buf ; for ( i = 0 ; i < n_entries ; i ++ , dent = ( fs_dent_info_t * ) ( ( char * ) dent + dent -> fd_len ) ) { if ( VERBOSE ( ftp ) ) { NDMP_LOG ( LOG_DEBUG , \"i %u dname: \\\"%s\\\"\" , dent -> fd_fh . fh_fid , dent -> fd_name ) ; } if ( ( pl + strlen ( dent -> fd_name ) ) > PATH_MAX ) { traverse_stats . fss_longpath_err ++ ; NDMP_LOG ( LOG_ERR , \"Path %s/%s is too long.\" , pnp -> tn_path , dent -> fd_name ) ; if ( STOP_ONLONG ( ftp ) ) { rv = - ENAMETOOLONG ; } free ( dent -> fd_fh . fh_fpath ) ; continue ; } if ( ! S_ISDIR ( dent -> fd_attr . st_mode ) ) { traverse_stats . fss_nondir_calls ++ ; en . tn_path = dent -> fd_name ; en . tn_fh = & dent -> fd_fh ; en . tn_st = & dent -> fd_attr ; rv = CALLBACK ( pnp , & en ) ; dent -> fd_fh . fh_fpath = NULL ; if ( rv < 0 ) { break ; } if ( rv == FST_SKIP ) { traverse_stats . fss_nondir_skipped ++ ; break ; } } } } free ( buf ) ; ( void ) close ( fd ) ; return ( rv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pmic_mpp_write_mode_ctl ( struct pmic_mpp_state * state , struct pmic_mpp_pad * pad ) { unsigned int mode ; unsigned int sel ; int val ; unsigned int en ; switch ( pad -> function ) { case PMIC_MPP_ANALOG : if ( pad -> input_enabled && pad -> output_enabled ) { mode = PMIC_MPP_MODE_ANALOG_BIDIR ; } if ( pad -> input_enabled ) { mode = PMIC_MPP_MODE_ANALOG_INPUT ; } else { mode = PMIC_MPP_MODE_ANALOG_OUTPUT ; } break ; case PMIC_MPP_DIGITAL : if ( pad -> input_enabled && pad -> output_enabled ) { mode = PMIC_MPP_MODE_DIGITAL_BIDIR ; } if ( pad -> input_enabled ) { mode = PMIC_MPP_MODE_DIGITAL_INPUT ; } else { mode = PMIC_MPP_MODE_DIGITAL_OUTPUT ; } break ; case PMIC_MPP_SINK : default : mode = PMIC_MPP_MODE_CURRENT_SINK ; break ; } if ( pad -> dtest ) { sel = PMIC_MPP_SELECTOR_DTEST_FIRST + pad -> dtest - 1 ; } if ( pad -> paired ) { sel = PMIC_MPP_SELECTOR_PAIRED ; } else { sel = PMIC_MPP_SELECTOR_NORMAL ; } en = ! ! pad -> out_value ; val = mode << PMIC_MPP_REG_MODE_DIR_SHIFT | sel << PMIC_MPP_REG_MODE_FUNCTION_SHIFT | en ; return pmic_mpp_write ( state , pad , PMIC_MPP_REG_MODE_CTL , val ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static netdev_tx_t ioc3_start_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct ioc3_private * ip = netdev_priv ( dev ) ; struct ioc3_etxd * desc ; unsigned long data ; unsigned int len ; int produce ; u32 w0 = 0 ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { const struct iphdr * ih = ip_hdr ( skb ) ; const int proto = ntohs ( ih -> protocol ) ; unsigned int csoff ; u32 csum , ehsum ; u16 * eh ; eh = ( u16 * ) skb -> data ; ehsum = eh [ 0 ] + eh [ 1 ] + eh [ 2 ] + eh [ 3 ] + eh [ 4 ] + eh [ 5 ] + eh [ 6 ] ; csum = csum_tcpudp_nofold ( ih -> saddr , ih -> daddr , ih -> tot_len - ( ih -> ihl << 2 ) , proto , csum_fold ( ehsum ) ) ; csum = ( csum & 0xffff ) + ( csum >> 16 ) ; csum = ( csum & 0xffff ) + ( csum >> 16 ) ; csoff = ETH_HLEN + ( ih -> ihl << 2 ) ; if ( proto == IPPROTO_UDP ) { csoff += offsetof ( udphdr , check ) ; udp_hdr ( skb ) -> check = csum ; } if ( proto == IPPROTO_TCP ) { csoff += offsetof ( tcphdr , check ) ; tcp_hdr ( skb ) -> check = csum ; } w0 = ETXD_DOCHECKSUM | ( csoff << ETXD_CHKOFF_SHIFT ) ; } spin_lock_irq ( & ip -> ioc3_lock ) ; data = ( unsigned long ) skb -> data ; len = skb -> len ; produce = ip -> tx_pi ; desc = & ip -> txr [ produce ] ; if ( len <= 104 ) { skb_copy_from_linear_data ( skb , desc -> data , skb -> len ) ; if ( len < ETH_ZLEN ) { len = ETH_ZLEN ; } desc -> cmd = cpu_to_be32 ( len | ETXD_INTWHENDONE | ETXD_D0V | w0 ) ; desc -> bufcnt = cpu_to_be32 ( len ) ; } if ( ( data ^ ( data + len - 1 ) ) & 0x4000 ) { unsigned long b2 = ( data | 0x3fffUL ) + 1UL ; unsigned long s1 = b2 - data ; unsigned long s2 = data + len - b2 ; dma_addr_t d1 , d2 ; desc -> cmd = cpu_to_be32 ( len | ETXD_INTWHENDONE | ETXD_B1V | ETXD_B2V | w0 ) ; desc -> bufcnt = cpu_to_be32 ( ( s1 << ETXD_B1CNT_SHIFT ) | ( s2 << ETXD_B2CNT_SHIFT ) ) ; d1 = dma_map_single ( ip -> dma_dev , skb -> data , s1 , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( ip -> dma_dev , d1 ) ) { drop_packet } d2 = dma_map_single ( ip -> dma_dev , ( void * ) b2 , s1 , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( ip -> dma_dev , d2 ) ) { dma_unmap_single ( ip -> dma_dev , d1 , len , DMA_TO_DEVICE ) ; drop_packet } desc -> p1 = cpu_to_be64 ( ioc3_map ( d1 , PCI64_ATTR_PREF ) ) ; desc -> p2 = cpu_to_be64 ( ioc3_map ( d2 , PCI64_ATTR_PREF ) ) ; } else { dma_addr_t d ; desc -> cmd = cpu_to_be32 ( len | ETXD_INTWHENDONE | ETXD_B1V | w0 ) ; desc -> bufcnt = cpu_to_be32 ( len << ETXD_B1CNT_SHIFT ) ; d = dma_map_single ( ip -> dma_dev , skb -> data , len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( ip -> dma_dev , d ) ) { drop_packet } desc -> p1 = cpu_to_be64 ( ioc3_map ( d , PCI64_ATTR_PREF ) ) ; } mb ( ) ; ip -> tx_skbs [ produce ] = skb ; produce = ( produce + 1 ) & TX_RING_MASK ; ip -> tx_pi = produce ; writel ( produce << 7 , & ip -> regs -> etpir ) ; ip -> txqlen ++ ; if ( ip -> txqlen >= ( TX_RING_ENTRIES - 1 ) ) { netif_stop_queue ( dev ) ; } spin_unlock_irq ( & ip -> ioc3_lock ) ; return NETDEV_TX_OK ; drop_packet dev_kfree_skb_any ( skb ) ; dev -> stats . tx_dropped ++ ; spin_unlock_irq ( & ip -> ioc3_lock ) ; return NETDEV_TX_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tosa_mci_init ( struct device * dev , irq_handler_t tosa_detect_int , void * data ) { int err ; err = gpio_request ( TOSA_GPIO_nSD_INT , \"SD Int\" ) ; if ( err ) { printk ( KERN_ERR \"tosa_mci_init: can't request SD_PWR gpio\\n\" ) ; err_gpio_int } err = gpio_direction_input ( TOSA_GPIO_nSD_INT ) ; if ( err ) { err_gpio_int_dir } return 0 ; err_gpio_int_dir err_gpio_int return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int wsm_remove_key ( struct cw1200_common * priv , const struct wsm_remove_key * arg ) { int ret ; struct wsm_buf * buf = & priv -> wsm_cmd_buf ; wsm_cmd_lock ( priv , NULL ) ; WSM_PUT8 ( buf , arg -> index ) ; WSM_PUT8 ( buf , 0 ) ; WSM_PUT16 ( buf , 0 ) ; ret = wsm_cmd_send ( priv , buf , NULL , WSM_REMOVE_KEY_REQ_ID , WSM_CMD_TIMEOUT ) ; wsm_cmd_unlock ( priv ) ; return ret ; nomem wsm_cmd_unlock ( priv ) ; return - ENOMEM ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int arch_prepare_optimized_kprobe ( struct optimized_kprobe * op , struct kprobe * orig ) { kprobe_opcode_t * code ; unsigned long rel_chk ; unsigned long val ; unsigned long stack_protect = sizeof ( pt_regs ) ; code = get_optinsn_slot ( ) ; if ( ! code ) { return - ENOMEM ; } rel_chk = ( unsigned long ) ( ( long ) code - ( long ) orig -> addr + 8 ) & 0xfe000003 ; if ( ( rel_chk != 0 ) && ( rel_chk != 0xfe000000 ) ) { free_optinsn_slot ( code , 0 ) ; return - ERANGE ; } memcpy ( code , ( unsigned long * ) optprobe_template_entry , TMPL_END_IDX * sizeof ( kprobe_opcode_t ) ) ; BUG_ON ( orig -> ainsn . stack_space < 0 ) ; stack_protect += orig -> ainsn . stack_space ; BUG_ON ( stack_protect > 255 ) ; code [ TMPL_SUB_SP ] = __opcode_to_mem_arm ( 0xe24dd000 | stack_protect ) ; code [ TMPL_ADD_SP ] = __opcode_to_mem_arm ( 0xe28d3000 | stack_protect ) ; val = ( unsigned long ) op ; code [ TMPL_VAL_IDX ] = val ; val = ( unsigned long ) optimized_callback ; code [ TMPL_CALL_IDX ] = val ; orig -> ainsn . kprobe_direct_exec = false ; if ( can_kprobe_direct_exec ( orig -> ainsn . register_usage_flags ) ) { kprobe_opcode_t final_branch = arm_gen_branch ( ( unsigned long ) ( & code [ TMPL_RESTORE_END ] ) , ( unsigned long ) ( op -> kp . addr ) + 4 ) ; if ( final_branch != 0 ) { code [ TMPL_RESTORE_BEGIN ] = __opcode_to_mem_arm ( 0xe89d7fff ) ; code [ TMPL_RESTORE_ORIGN_INSN ] = __opcode_to_mem_arm ( orig -> opcode ) ; code [ TMPL_RESTORE_END ] = __opcode_to_mem_arm ( final_branch ) ; orig -> ainsn . kprobe_direct_exec = true ; } } flush_icache_range ( ( unsigned long ) code , ( unsigned long ) ( & code [ TMPL_END_IDX ] ) ) ; op -> optinsn . insn = code ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void set_clock_mux ( struct uart_port * up , struct brcmuart_priv * priv , u32 baud ) { u32 percent ; u32 best_percent = UINT_MAX ; u32 quot ; u32 best_quot = 1 ; u32 rate ; int best_index = - 1 ; u64 hires_rate ; u64 hires_baud ; u64 hires_err ; int rc ; int i ; int real_baud ; if ( priv -> baud_mux_clk == NULL ) { return ; } for ( i = 0 ; i < ARRAY_SIZE ( priv -> real_rates ) ; i ++ ) { if ( priv -> real_rates [ i ] == 0 ) { continue ; } rate = priv -> real_rates [ i ] / 16 ; quot = DIV_ROUND_CLOSEST ( rate , baud ) ; hires_rate = ( u64 ) rate * 10000 ; hires_baud = ( u64 ) baud * 10000 ; hires_err = div_u64 ( hires_rate , ( u64 ) quot ) ; if ( hires_err > hires_baud ) { hires_err = ( hires_err - hires_baud ) ; } else { hires_err = ( hires_baud - hires_err ) ; } percent = ( unsigned long ) DIV_ROUND_CLOSEST_ULL ( hires_err , baud ) ; dev_dbg ( up -> dev , \"Baud rate: %u, MUX Clk: %u, Error: %u.%u%%\\n\" , baud , priv -> real_rates [ i ] , percent / 100 , percent % 100 ) ; if ( percent < best_percent ) { best_percent = percent ; best_index = i ; best_quot = quot ; } } if ( best_index == - 1 ) { dev_err ( up -> dev , \"Error, %d BAUD rate is too fast.\\n\" , baud ) ; return ; } rate = priv -> real_rates [ best_index ] ; rc = clk_set_rate ( priv -> baud_mux_clk , rate ) ; if ( rc ) { dev_err ( up -> dev , \"Error selecting BAUD MUX clock\\n\" ) ; } if ( best_percent > 300 ) { dev_err ( up -> dev , \"Error, baud: %d has %u.%u%% error\\n\" , baud , percent / 100 , percent % 100 ) ; } real_baud = rate / 16 / best_quot ; dev_dbg ( up -> dev , \"Selecting BAUD MUX rate: %u\\n\" , rate ) ; dev_dbg ( up -> dev , \"Requested baud: %u, Actual baud: %u\\n\" , baud , real_baud ) ; i = NSEC_PER_SEC / real_baud / 10 ; i += ( i / 2 ) ; priv -> char_wait = ns_to_ktime ( i ) ; up -> uartclk = rate ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int snapper_get_mix ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int idx = ( int ) kcontrol -> private_value ; struct snd_pmac * chip = snd_kcontrol_chip ( kcontrol ) ; struct pmac_tumbler * mix ; ucontrol -> value . integer . value [ 0 ] = mix -> mix_vol [ idx ] [ 0 ] ; ucontrol -> value . integer . value [ 1 ] = mix -> mix_vol [ idx ] [ 1 ] ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int isc_enum_framesizes ( struct file * file , void * fh , struct v4l2_frmsizeenum * fsize ) { struct isc_device * isc = video_drvdata ( file ) ; int ret = - EINVAL ; int i ; for ( i = 0 ; i < isc -> num_user_formats ; i ++ ) { if ( isc -> user_formats [ i ] -> fourcc == fsize -> pixel_format ) { ret = 0 ; } } for ( i = 0 ; i < isc -> controller_formats_size ; i ++ ) { if ( isc -> controller_formats [ i ] . fourcc == fsize -> pixel_format ) { ret = 0 ; } } if ( ret ) { return ret ; } fsize -> type = V4L2_FRMSIZE_TYPE_CONTINUOUS ; fsize -> stepwise . min_width = 16 ; fsize -> stepwise . max_width = isc -> max_width ; fsize -> stepwise . min_height = 16 ; fsize -> stepwise . max_height = isc -> max_height ; fsize -> stepwise . step_width = 1 ; fsize -> stepwise . step_height = 1 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { ff_dlog ( NULL , \"overread %d, state:%\" PRIX32 \" next:%d index:%d o_index:%d\\n\" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; ff_dlog ( NULL , \"%X %X %X %X\\n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , * buf_size + pc -> index + AV_INPUT_BUFFER_PADDING_SIZE ) ; pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! new_buffer ) { return AVERROR ( ENOMEM ) ; } pc -> buffer = new_buffer ; if ( next > - AV_INPUT_BUFFER_PADDING_SIZE ) { memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + AV_INPUT_BUFFER_PADDING_SIZE ) ; } pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = pc -> state << 8 | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = pc -> state64 << 8 | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { ff_dlog ( NULL , \"overread %d, state:%\" PRIX32 \" next:%d index:%d o_index:%d\\n\" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; ff_dlog ( NULL , \"%X %X %X %X\\n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void sys_close ( ) { close ( sockfd , NULL ) ; if ( loop_slave >= 0 ) { close ( loop_slave ) ; close ( loop_master ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void checkasm_check_av_tx ( void ) { declare_func ( , , , , ) void * in = av_malloc ( 16384 * 2 * 8 ) ; void * out_ref = av_malloc ( 16384 * 2 * 8 ) ; void * out_new = av_malloc ( 16384 * 2 * 8 ) ; randomize_complex ( in , 16384 , AVComplexFloat , SCALE_NOOP ) ; CHECK_TEMPLATE ( \"float_fft\" , AV_TX_FLOAT_FFT , 0 , AVComplexFloat , float , check_lens , ! float_near_abs_eps_array ( out_ref , out_new , EPS , len * 2 ) ) ; CHECK_TEMPLATE ( \"float_imdct\" , AV_TX_FLOAT_MDCT , 1 , float , float , check_lens , ! float_near_abs_eps_array ( out_ref , out_new , EPS , len ) ) ; randomize_complex ( in , 16384 , AVComplexDouble , SCALE_NOOP ) ; CHECK_TEMPLATE ( \"double_fft\" , AV_TX_DOUBLE_FFT , 0 , AVComplexDouble , double , check_lens , ! double_near_abs_eps_array ( out_ref , out_new , EPS , len * 2 ) ) ; av_free ( in ) ; av_free ( out_new ) ; if ( ! init ) { init = 1 ; atexit ( free_tx_refs ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void uwsgi_free_transformations ( struct wsgi_request * wsgi_req ) { struct uwsgi_transformation * ut = wsgi_req -> transformations ; while ( ut ) { struct uwsgi_transformation * current_ut = ut ; if ( current_ut -> chunk ) { uwsgi_buffer_destroy ( current_ut -> chunk ) ; } if ( current_ut -> ub ) { uwsgi_buffer_destroy ( current_ut -> ub ) ; } if ( current_ut -> fd > - 1 ) { close ( current_ut -> fd ) ; } ut = ut -> next ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int acpi_video_bus_DOS ( struct acpi_video_bus * video , int bios_flag , int lcd_flag ) { acpi_status status ; if ( bios_flag ( 0 || bios_flag ) 3 || lcd_flag ( 0 || lcd_flag ) 1 ) { return - EINVAL ; } video -> dos_setting = ( lcd_flag << 2 ) | bios_flag ; status = acpi_execute_simple_method ( video -> device -> handle , \"_DOS\" , ( lcd_flag << 2 ) | bios_flag ) ; if ( ACPI_FAILURE ( status ) ) { return - EIO ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int check_insn_config_length ( struct comedi_insn * insn , unsigned int * data ) { switch ( data [ 0 ] ) { case INSN_CONFIG_DIO_OUTPUT : case INSN_CONFIG_DIO_INPUT : case INSN_CONFIG_DISARM : case INSN_CONFIG_RESET : if ( insn -> n == 1 ) { return 0 ; } break ; case INSN_CONFIG_ARM : case INSN_CONFIG_DIO_QUERY : case INSN_CONFIG_BLOCK_SIZE : case INSN_CONFIG_FILTER : case INSN_CONFIG_SERIAL_CLOCK : case INSN_CONFIG_BIDIRECTIONAL_DATA : case INSN_CONFIG_ALT_SOURCE : case INSN_CONFIG_SET_COUNTER_MODE : case INSN_CONFIG_8254_READ_STATUS : case INSN_CONFIG_SET_ROUTING : case INSN_CONFIG_GET_ROUTING : case INSN_CONFIG_GET_PWM_STATUS : case INSN_CONFIG_PWM_SET_PERIOD : case INSN_CONFIG_PWM_GET_PERIOD : if ( insn -> n == 2 ) { return 0 ; } break ; case INSN_CONFIG_SET_GATE_SRC : case INSN_CONFIG_GET_GATE_SRC : case INSN_CONFIG_SET_CLOCK_SRC : case INSN_CONFIG_GET_CLOCK_SRC : case INSN_CONFIG_SET_OTHER_SRC : case INSN_CONFIG_GET_COUNTER_STATUS : case INSN_CONFIG_PWM_SET_H_BRIDGE : case INSN_CONFIG_PWM_GET_H_BRIDGE : case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE : if ( insn -> n == 3 ) { return 0 ; } break ; case INSN_CONFIG_PWM_OUTPUT : case INSN_CONFIG_ANALOG_TRIG : if ( insn -> n == 5 ) { return 0 ; } break ; case INSN_CONFIG_DIGITAL_TRIG : if ( insn -> n == 6 ) { return 0 ; } break ; default : pr_warn ( \"No check for data length of config insn id %i is implemented\\n\" , data [ 0 ] ) ; pr_warn ( \"Add a check to %s in %s\\n\" , __func__ , __FILE__ ) ; pr_warn ( \"Assuming n=%i is correct\\n\" , insn -> n ) ; return 0 ; } return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _abort_conn_close ( eio_obj_t * obj , List objs ) { close ( obj -> fd , NULL ) ; return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int qe_tint ( struct qe_softc * sc ) { struct ifnet * ifp = & sc -> sc_arpcom . ac_if ; unsigned int bix , txflags ; bix = sc -> sc_rb . rb_tdtail ; for ( ; ; ) { if ( sc -> sc_rb . rb_td_nbusy <= 0 ) { break ; } txflags = sc -> sc_rb . rb_txd [ bix ] . xd_flags ; if ( txflags & QEC_XD_OWN ) { break ; } ifq_clr_oactive ( & ifp -> if_snd ) ; if ( ++ bix == QEC_XD_RING_MAXSIZE ) { bix = 0 ; } -- sc -> sc_rb . rb_td_nbusy ; } if ( sc -> sc_rb . rb_td_nbusy == 0 ) { ifp -> if_timer = 0 ; } if ( sc -> sc_rb . rb_tdtail != bix ) { sc -> sc_rb . rb_tdtail = bix ; if ( ifq_is_oactive ( & ifp -> if_snd ) ) { ifq_clr_oactive ( & ifp -> if_snd ) ; qestart ( ifp , NULL ) ; } } return ( 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void handle_cap_flag_space ( u8 * * datap , uint index ) { struct tpm_nv_data_public pub ; pub . nv_index = __cpu_to_be32 ( index ) ; pub . pcr_info_read . pcr_selection . size_of_select = __cpu_to_be16 ( sizeof ( pub . pcr_info_read . pcr_selection . pcr_select ) ) ; pub . permission . attributes = __cpu_to_be32 ( 1 ) ; pub . pcr_info_write = pub . pcr_info_read ; memcpy ( * datap , & pub , sizeof ( pub ) ) ; * datap += sizeof ( pub ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ccp_sha_export ( struct ahash_request * req , void * out ) { struct ccp_sha_req_ctx * rctx = ahash_request_ctx ( req ) ; struct ccp_sha_exp_ctx state ; state . type = rctx -> type ; state . msg_bits = rctx -> msg_bits ; state . first = rctx -> first ; memcpy ( state . ctx , rctx -> ctx , sizeof ( state . ctx ) ) ; state . buf_count = rctx -> buf_count ; memcpy ( state . buf , rctx -> buf , sizeof ( state . buf ) ) ; memcpy ( out , & state , sizeof ( state ) ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hvc_tile_probe ( struct platform_device * pdev ) { struct hvc_struct * hp ; int tile_hvc_irq ; tile_hvc_irq = irq_alloc_hwirq ( - 1 ) ; tile_irq_activate ( tile_hvc_irq , TILE_IRQ_PERCPU ) ; hp = hvc_alloc ( 0 , tile_hvc_irq , & hvc_tile_get_put_ops , 128 ) ; if ( IS_ERR ( hp ) ) { irq_free_hwirq ( tile_hvc_irq ) ; return PTR_ERR ( hp ) ; } dev_set_drvdata ( & pdev -> dev , hp ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static const char * tpm_emulator_strerror ( uint32_t tpm_result ) { int i ; for ( i = 0 ; i < ARRAY_SIZE ( tpm_errors ) ; i ++ ) { if ( tpm_errors [ i ] . tpm_result == tpm_result ) { return tpm_errors [ i ] . string ; } } return \"\" ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool fabricd_initial_sync_is_complete ( struct isis_area * area ) { struct fabricd * f = area -> fabricd ; return f -> initial_sync_state == FABRICD_SYNC_COMPLETE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ip_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { int err ; err = do_ip_setsockopt ( sk , level , optname , optval , optlen ) ; if ( err == - ENOPROTOOPT && optname != IP_HDRINCL && optname != IP_IPSEC_POLICY && optname != IP_XFRM_POLICY && ! ip_mroute_opt ( optname ) ) { lock_sock ( sk ) ; err = nf_setsockopt ( sk , PF_INET , optname , optval , optlen ) ; release_sock ( sk ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * slurpFile ( const char * datadir , const char * path , size_t * filesize ) { int fd ; char * buffer ; struct stat statbuf ; char fullpath [ MAXPGPATH ] ; int len ; int r ; sprintf ( fullpath , \"%s/%s\" , datadir , path ) ; if ( ( fd = open ( fullpath , O_RDONLY | PG_BINARY , 0 ) ) == - 1 ) { pg_fatal ( \"could not open file \\\"%s\\\" for reading: %m\" , fullpath ) ; } if ( fstat ( fd , & statbuf ) < 0 ) { pg_fatal ( \"could not open file \\\"%s\\\" for reading: %m\" , fullpath ) ; } len = statbuf . st_size ; buffer = pg_malloc ( len + 1 ) ; r = read ( fd , buffer , len ) ; if ( r != len ) { if ( r < 0 ) { pg_fatal ( \"could not read file \\\"%s\\\": %m\" , fullpath ) ; } else { pg_fatal ( \"could not read file \\\"%s\\\": read %d of %zu\" , fullpath , r , ( Size ) len ) ; } } close ( fd ) ; buffer [ len ] = '\\0' ; if ( filesize ) { * filesize = len ; } return buffer ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool io_resubmit_prep ( struct io_kiocb * req ) { struct io_async_rw * io = req -> async_data ; iov_iter_restore ( & io -> s . iter , & io -> s . iter_state ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ov9282_init_controls ( struct ov9282 * ov9282 ) { struct v4l2_ctrl_handler * ctrl_hdlr = & ov9282 -> ctrl_handler ; const struct ov9282_mode * mode = ov9282 -> cur_mode ; struct v4l2_fwnode_device_properties props ; u32 hblank_min ; u32 lpfr ; int ret ; ret = v4l2_ctrl_handler_init ( ctrl_hdlr , 10 ) ; ctrl_hdlr -> lock = & ov9282 -> mutex ; lpfr = mode -> vblank + mode -> height ; ov9282 -> exp_ctrl = v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_EXPOSURE , OV9282_EXPOSURE_MIN , lpfr - OV9282_EXPOSURE_OFFSET , OV9282_EXPOSURE_STEP , OV9282_EXPOSURE_DEFAULT ) ; ov9282 -> again_ctrl = v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_ANALOGUE_GAIN , OV9282_AGAIN_MIN , OV9282_AGAIN_MAX , OV9282_AGAIN_STEP , OV9282_AGAIN_DEFAULT ) ; v4l2_ctrl_cluster ( 2 , & ov9282 -> exp_ctrl ) ; ov9282 -> vblank_ctrl = v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_VBLANK , mode -> vblank_min , mode -> vblank_max , 1 , mode -> vblank ) ; v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_VFLIP , 0 , 1 , 1 , 1 ) ; v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_HFLIP , 0 , 1 , 1 , 1 ) ; ov9282 -> pixel_rate = v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_PIXEL_RATE , OV9282_PIXEL_RATE_10BIT , OV9282_PIXEL_RATE_10BIT , 1 , OV9282_PIXEL_RATE_10BIT ) ; ov9282 -> link_freq_ctrl = v4l2_ctrl_new_int_menu ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_LINK_FREQ , ARRAY_SIZE ( link_freq ) - 1 , mode -> link_freq_idx , link_freq ) ; if ( ov9282 -> link_freq_ctrl ) { ov9282 -> link_freq_ctrl -> flags |= V4L2_CTRL_FLAG_READ_ONLY ; } hblank_min = mode -> hblank_min [ ov9282 -> noncontinuous_clock ?0 : 1 ] ; ov9282 -> hblank_ctrl = v4l2_ctrl_new_std ( ctrl_hdlr , & ov9282_ctrl_ops , V4L2_CID_HBLANK , hblank_min , OV9282_TIMING_HTS_MAX - mode -> width , 1 , hblank_min ) ; ret = v4l2_fwnode_device_parse ( ov9282 -> dev , & props ) ; if ( ! ret ) { v4l2_ctrl_new_fwnode_properties ( ctrl_hdlr , & ov9282_ctrl_ops , & props ) ; } if ( ctrl_hdlr -> error || ret ) { dev_err ( ov9282 -> dev , \"control init failed: %d\" , ctrl_hdlr -> error ) ; v4l2_ctrl_handler_free ( ctrl_hdlr ) ; return ctrl_hdlr -> error ; } ov9282 -> sd . ctrl_handler = ctrl_hdlr ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void br_vlan_notify ( const struct net_bridge * br , const struct net_bridge_port * p , u16 vid , u16 vid_range , int cmd ) { struct net_bridge_vlan_group * vg ; struct net_bridge_vlan * v = NULL ; struct br_vlan_msg * bvm ; struct nlmsghdr * nlh ; struct sk_buff * skb ; int err = - ENOBUFS ; struct net * net ; u16 flags = 0 ; int ifindex ; ASSERT_RTNL ( ) ; if ( p ) { ifindex = p -> dev -> ifindex ; vg = nbp_vlan_group ( p ) ; net = dev_net ( p -> dev ) ; } else { ifindex = br -> dev -> ifindex ; vg = br_vlan_group ( br ) ; net = dev_net ( br -> dev ) ; } skb = nlmsg_new ( rtnl_vlan_nlmsg_size ( ) , GFP_KERNEL ) ; if ( ! skb ) { out_err } err = - EMSGSIZE ; nlh = nlmsg_put ( skb , 0 , 0 , cmd , sizeof ( * bvm ) , 0 ) ; if ( ! nlh ) { out_err } bvm = nlmsg_data ( nlh ) ; bvm -> family = AF_BRIDGE ; bvm -> ifindex = ifindex ; switch ( cmd ) { case RTM_NEWVLAN : v = br_vlan_find ( vg , vid ) ; if ( ! v || ! br_vlan_should_use ( v ) ) { out_kfree } flags = v -> flags ; if ( br_get_pvid ( vg ) == v -> vid ) { flags |= BRIDGE_VLAN_INFO_PVID ; } break ; case RTM_DELVLAN : break ; default : out_kfree } if ( ! br_vlan_fill_vids ( skb , vid , vid_range , v , p , flags , false ) ) { out_err } nlmsg_end ( skb , nlh ) ; rtnl_notify ( skb , net , 0 , RTNLGRP_BRVLAN , NULL , GFP_KERNEL ) ; return ; out_err rtnl_set_sk_err ( net , RTNLGRP_BRVLAN , err ) ; out_kfree kfree_skb ( skb ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int auto_solaris_part ( struct dk_label * label ) { int status , i , fd ; struct mboot mboot ; char * mbr ; struct ipart ip ; char * bootptr ; char pbuf [ MAXPATHLEN ] ; uint32_t relsec , numsec ; int pno , rval , ext_part_found = 0 ; ext_part_t * epp ; ( void ) get_pname ( & pbuf [ 0 ] ) ; if ( ( fd = open_disk ( pbuf , O_RDONLY ) ) < 0 ) { err_print ( \"Error: can't open selected disk '%s'.\\n\" , pbuf ) ; return ( - 1 ) ; } mbr = malloc ( cur_blksz ) ; if ( mbr == NULL ) { err_print ( \"No memory available.\\n\" ) ; return ( - 1 ) ; } status = read ( fd , mbr , cur_blksz ) ; if ( status != cur_blksz ) { err_print ( \"Bad read of fdisk partition.\\n\" ) ; return ( - 1 ) ; } ( void ) memcpy ( & mboot , mbr , sizeof ( mboot ) ) ; ( void ) extpart_init ( & epp ) ; for ( i = 0 ; i < FD_NUMPART ; i ++ ) { int ipc ; ipc = i * sizeof ( ipart ) ; bootptr = & mboot . parts [ ipc ] ; ( void ) fill_ipart ( bootptr , & ip ) ; if ( fdisk_is_dos_extended ( ip . systid ) && ( ext_part_found == 0 ) ) { ext_part_found = 1 ; rval = fdisk_get_solaris_part ( epp , & pno , & relsec , & numsec ) ; if ( rval == FDISK_SUCCESS ) { if ( ( label -> dkl_nhead != 0 ) && ( label -> dkl_nsect != 0 ) ) { label -> dkl_pcyl = numsec / ( label -> dkl_nhead * label -> dkl_nsect ) ; label -> dkl_ncyl = label -> dkl_pcyl - label -> dkl_acyl ; } solaris_offset = relsec ; } continue ; } if ( ( ip . systid == SUNIXOS && ( fdisk_is_linux_swap ( epp , lel ( ip . relsect ) , NULL ) != 0 ) ) || ip . systid == SUNIXOS2 || ip . systid == EFI_PMBR ) { if ( ip . systid == SUNIXOS || ip . systid == SUNIXOS2 || ip . systid == EFI_PMBR ) { if ( ( label -> dkl_nhead != 0 ) && ( label -> dkl_nsect != 0 ) ) { label -> dkl_pcyl = lel ( ip . numsect ) / ( label -> dkl_nhead * label -> dkl_nsect ) ; label -> dkl_ncyl = label -> dkl_pcyl - label -> dkl_acyl ; } else { err_print ( \"Critical label fields aren't \" \"non-zero:\\n\" \"\\tlabel->dkl_nhead = %d; \" \"label->dkl_nsect = \" \"%d\\n\" , label -> dkl_nhead , label -> dkl_nsect ) ; } solaris_offset = lel ( ip . relsect ) ; break ; } } libfdisk_fini ( & epp ) ; ( void ) close ( fd ) ; free ( mbr ) ; return ( 0 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _atomic_dec_and_raw_lock ( atomic_t * atomic , raw_spinlock_t * lock ) { if ( atomic_add_unless ( atomic , - 1 , 1 ) ) { return 0 ; } raw_spin_lock ( lock ) ; raw_spin_unlock ( lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sl3516_ce_pm_init ( struct sl3516_ce_dev * ce ) { int err ; pm_runtime_use_autosuspend ( ce -> dev ) ; pm_runtime_set_autosuspend_delay ( ce -> dev , 2000 ) ; err = pm_runtime_set_suspended ( ce -> dev ) ; pm_runtime_enable ( ce -> dev ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct hid_blacklist * usbhid_exists_dquirk ( const u16 idVendor , const u16 idProduct ) { struct quirks_list_struct * q ; struct hid_blacklist * bl_entry ; list_for_each_entry ( , , ) { if ( q -> hid_bl_item . idVendor == idVendor && q -> hid_bl_item . idProduct == idProduct ) { bl_entry = & q -> hid_bl_item ; break ; } } if ( bl_entry != NULL ) { dbg_hid ( \"Found dynamic quirk 0x%x for USB HID vendor 0x%hx prod 0x%hx\\n\" , bl_entry -> quirks , bl_entry -> idVendor , bl_entry -> idProduct ) ; } return bl_entry ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sharpsl_attach_chip ( struct nand_chip * chip ) { if ( chip -> ecc . engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST ) { return 0 ; } chip -> ecc . size = 256 ; chip -> ecc . bytes = 3 ; chip -> ecc . hwctl = sharpsl_nand_enable_hwecc ; chip -> ecc . calculate = sharpsl_nand_calculate_ecc ; chip -> ecc . correct = rawnand_sw_hamming_correct ; return 0 ; } static const struct nand_controller_ops sharpsl_ops = { . attach_chip = sharpsl_attach_chip } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static rpmRC systemd_inhibit_init ( rpmPlugin plugin , rpmts ts ) { int st ; if ( lstat ( \"/run/systemd/system/\" , & st ) == 0 ) { if ( S_ISDIR ( st . st_mode ) ) { return RPMRC_OK ; } } return RPMRC_NOTFOUND ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int snd_harmony_capture_trigger ( struct snd_pcm_substream * ss , int cmd ) { struct snd_harmony * h = snd_pcm_substream_chip ( ss ) ; spin_lock ( & h -> lock ) ; switch ( cmd ) { case SNDRV_PCM_TRIGGER_START : h -> st . capturing = 1 ; harmony_write ( h , HARMONY_PNXTADD , h -> sdma . addr ) ; harmony_write ( h , HARMONY_RNXTADD , h -> cbuf . addr ) ; harmony_unmute ( h ) ; harmony_enable_interrupts ( h ) ; break ; case SNDRV_PCM_TRIGGER_STOP : h -> st . capturing = 0 ; harmony_mute ( h ) ; harmony_write ( h , HARMONY_RNXTADD , h -> gdma . addr ) ; harmony_disable_interrupts ( h ) ; break ; case SNDRV_PCM_TRIGGER_PAUSE_PUSH : case SNDRV_PCM_TRIGGER_PAUSE_RELEASE : case SNDRV_PCM_TRIGGER_SUSPEND : default : spin_unlock ( & h -> lock ) ; snd_BUG ( ) ; return - EINVAL ; } spin_unlock ( & h -> lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ts_get_pendown_state ( struct device * dev ) { int val = 0 ; gpio_free ( GPIO_FN_INTC_IRQ0 ) ; gpio_request ( GPIO_PTZ0 , NULL ) ; gpio_direction_input ( GPIO_PTZ0 ) ; val = gpio_get_value ( GPIO_PTZ0 ) ; gpio_free ( GPIO_PTZ0 ) ; gpio_request ( GPIO_FN_INTC_IRQ0 ) ; return val ?0 : 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void vsw_hio_free_share ( vsw_share_t * vsharep ) { vsw_t * vswp = vsharep -> vs_vswp ; vsw_port_t * portp = vsharep -> vs_portp ; D1 ( vswp , \"%s:enter\\n\" , __func__ ) ; WRITE_ENTER ( & portp -> maccl_rwlock ) ; mac_share_unbind ( portp -> p_mch ) ; RW_EXIT ( & portp -> maccl_rwlock ) ; vsharep -> vs_state = VSW_SHARE_FREE ; vsharep -> vs_macaddr = 0 ; DERR ( vswp , \"Share freed for ldc_id=0x%lx Cookie=0x%lX\" , vsharep -> vs_ldcid , vsharep -> vs_cookie ) ; D1 ( vswp , \"%s:exit\\n\" , __func__ ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void espattach ( struct esp_softc * esc , struct ncr53c9x_glue * gluep ) { struct ncr53c9x_softc * sc = & esc -> sc_ncr53c9x ; void * icookie ; unsigned int uid = 0 ; sc -> sc_glue = gluep ; sc -> sc_freq /= 1000000 ; sc -> sc_cfg1 = sc -> sc_id | NCRCFG1_PARENB ; sc -> sc_cfg2 = NCRCFG2_SCSI2 | NCRCFG2_RPE ; sc -> sc_cfg3 = NCRCFG3_CDB ; NCR_WRITE_REG ( sc , NCR_CFG2 , sc -> sc_cfg2 ) ; if ( ( NCR_READ_REG ( sc , NCR_CFG2 ) & ~ NCRCFG2_RSVD ) != ( NCRCFG2_SCSI2 | NCRCFG2_RPE ) ) { sc -> sc_rev = NCR_VARIANT_ESP100 ; } else { sc -> sc_cfg2 = NCRCFG2_SCSI2 ; NCR_WRITE_REG ( sc , NCR_CFG2 , sc -> sc_cfg2 ) ; sc -> sc_cfg3 = 0 ; NCR_WRITE_REG ( sc , NCR_CFG3 , sc -> sc_cfg3 ) ; sc -> sc_cfg3 = ( NCRCFG3_CDB | NCRCFG3_FCLK ) ; NCR_WRITE_REG ( sc , NCR_CFG3 , sc -> sc_cfg3 ) ; if ( NCR_READ_REG ( sc , NCR_CFG3 ) != ( NCRCFG3_CDB | NCRCFG3_FCLK ) ) { sc -> sc_rev = NCR_VARIANT_ESP100A ; } else { sc -> sc_cfg2 |= NCRCFG2_FE ; sc -> sc_cfg3 = 0 ; NCR_WRITE_REG ( sc , NCR_CFG3 , sc -> sc_cfg3 ) ; sc -> sc_rev = NCR_VARIANT_ESP200 ; uid = NCR_READ_REG ( sc , NCR_UID ) ; if ( ( ( uid & 0xf8 ) >> 3 ) == 0x0a ) { sc -> sc_rev = NCR_VARIANT_FAS366 ; } } } printf ( \"espattach: revision %d, uid 0x%x\\n\" , sc -> sc_rev , uid ) ; sc -> sc_minsync = 1000 / sc -> sc_freq ; switch ( sc -> sc_rev ) { case NCR_VARIANT_ESP100 : sc -> sc_maxxfer = 64 * 1024 ; break ; case NCR_VARIANT_ESP100A : sc -> sc_maxxfer = 64 * 1024 ; sc -> sc_minsync = ncr53c9x_cpb2stp ( sc , 5 ) ; break ; case NCR_VARIANT_ESP200 : case NCR_VARIANT_FAS366 : sc -> sc_maxxfer = 16 * 1024 * 1024 ; break ; } icookie = bus_intr_establish ( esc -> sc_bustag , esc -> sc_pri , IPL_BIO , 0 , ncr53c9x_intr , sc , sc -> sc_dev . dv_xname ) ; if ( sc -> sc_rev != NCR_VARIANT_FAS366 ) { sc -> sc_features |= NCR_F_DMASELECT ; } ncr53c9x_attach ( sc ) ; } int esp_sbus_debug = 0 ; static { char * r_name ; int r_flag ; } , esp__read_regnames [ ] { } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mount_cgroups ( const char * dest , CGroupUnified unified_requested , bool userns , uid_t uid_shift , uid_t uid_range , const char * selinux_apifs_context , bool use_cgns ) { if ( use_cgns ) { return mount_legacy_cgns_supported ( dest , unified_requested , userns , uid_shift , uid_range , selinux_apifs_context ) ; } return mount_legacy_cgns_unsupported ( dest , unified_requested , userns , uid_shift , uid_range , selinux_apifs_context ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int evp_md_create_signature ( hx509_context context , const struct signature_alg * sig_alg , const hx509_private_key signer , const AlgorithmIdentifier * alg , const heim_octet_string * data , AlgorithmIdentifier * signatureAlgorithm , heim_octet_string * sig ) { size_t sigsize = EVP_MD_size ( sig_alg -> evp_md ( ) ) ; EVP_MD_CTX * ctx ; memset ( sig , 0 , sizeof ( * sig ) ) ; if ( signatureAlgorithm ) { int ret ; ret = _hx509_set_digest_alg ( signatureAlgorithm , sig_alg -> sig_oid , \"\\x05\\x00\" , 2 ) ; if ( ret ) { return ret ; } } sig -> data = malloc ( sigsize ) ; if ( sig -> data == NULL ) { return ENOMEM ; } sig -> length = sigsize ; ctx = EVP_MD_CTX_create ( ) ; EVP_DigestInit_ex ( ctx , sig_alg -> evp_md ( ) , NULL ) ; EVP_DigestUpdate ( ctx , data -> data , data -> length ) ; EVP_DigestFinal_ex ( ctx , sig -> data , NULL ) ; EVP_MD_CTX_destroy ( ctx ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int operation_new ( Manager * manager , Machine * machine , pid_t child , sd_bus_message * message , int errno_fd , Operation * * ret ) { Operation * o ; int r ; assert ( manager ) ; assert ( child > 1 ) ; assert ( message ) ; assert ( errno_fd >= 0 ) ; o = new0 ( Operation , 1 ) ; o -> extra_fd = - EBADF ; r = sd_event_add_child ( manager -> event , & o -> event_source , child , WEXITED , operation_done , o ) ; if ( r < 0 ) { free ( o ) ; return r ; } o -> pid = child ; o -> message = sd_bus_message_ref ( message ) ; o -> errno_fd = errno_fd ; LIST_PREPEND ( operations , manager -> operations , o ) ; manager -> n_operations ++ ; o -> manager = manager ; if ( machine ) { LIST_PREPEND ( operations_by_machine , machine -> operations , o ) ; o -> machine = machine ; } log_debug ( \"Started new operation \" PID_FMT \".\" , child ) ; if ( ret ) { * ret = o ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void M_ini_writer_tree_prune ( M_ini_t * ini ) { size_t i ; size_t len ; void * section ; const char * sect_name ; M_hash_strvp_enum_t * sectenum ; M_list_str_t * prune_sections ; prune_sections = M_list_str_create ( M_LIST_STR_NONE ) ; M_ini_writer_tree_prune_section_kvs ( NULL , ini -> elements , ini -> kvs ) ; M_hash_strvp_enumerate ( ini -> sections , & sectenum ) ; while ( M_hash_strvp_enumerate_next ( ini -> sections , sectenum , & sect_name , & section ) ) { M_ini_writer_tree_prune_section_kvs ( sect_name , section , ini -> kvs ) ; if ( M_ini_writer_tree_prune_section_has_kv ( section ) ) { M_list_str_insert ( prune_sections , sect_name ) ; } } M_hash_strvp_enumerate_free ( sectenum ) ; len = M_list_str_len ( prune_sections ) ; for ( i = 0 ; i < len ; i ++ ) { M_hash_strvp_remove ( ini -> sections , M_list_str_at ( prune_sections , i ) , M_TRUE ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "JsVar * jswrap_number_toFixed ( JsVar * parent , int decimals ) { if ( decimals < 0 ) { decimals = 0 ; } if ( decimals > 20 ) { decimals = 20 ; } int buf [ JS_NUMBER_BUFFER_SIZE ] ; ftoa_bounded_extra ( jsvGetFloat ( parent ) , buf , sizeof ( buf ) , 10 , decimals ) ; return jsvNewFromString ( buf ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t srf08_write_sensitivity ( struct srf08_data * data , unsigned int val ) { struct i2c_client * client = data -> client ; int ret , i ; u8 regval ; for ( i = 0 ; i < ARRAY_SIZE ( srf08_sensitivity ) ; i ++ ) { if ( val == srf08_sensitivity [ i ] ) { regval = i ; break ; } } mutex_lock ( & data -> lock ) ; ret = i2c_smbus_write_byte_data ( client , SRF08_WRITE_MAX_GAIN , regval ) ; if ( ret < 0 ) { dev_err ( & client -> dev , \"write_sensitivity - err: %d\\n\" , ret ) ; mutex_unlock ( & data -> lock ) ; return ret ; } data -> sensitivity = val ; mutex_unlock ( & data -> lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nfs_ssc_unregister ( const struct nfs_ssc_client_ops * ops ) { nfs_ssc_client_tbl . ssc_nfs_ops = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void process_by_rank_dsk ( struct ddr_priv * priv , int if_num , int rank_mask , struct deskew_data * dskdat ) { union cvmx_lmcx_config lmc_config ; int rankx , lane , bit ; int byte_limit ; struct deskew_data dsksum , dskcnt ; u16 deskew ; lmc_config . u64 = lmc_rd ( priv , CVMX_LMCX_CONFIG ( if_num ) ) ; byte_limit = ( ( lmc_config . s . mode32b ) ?4 : 8 ) + lmc_config . s . ecc_ena ; memset ( ( void * ) & dskcnt , 0 , sizeof ( dskcnt ) ) ; for ( rankx = 0 ; rankx < 4 ; rankx ++ ) { if ( ! ( rank_mask & ( 1 << rankx ) ) ) { continue ; } for ( lane = 0 ; lane < byte_limit ; lane ++ ) { for ( bit = 0 ; bit < 8 ; ++ bit ) { deskew = dskdat [ rankx ] . bytes [ lane ] . bits [ bit ] ; if ( deskew & 6 ) { continue ; } dsksum . bytes [ lane ] . bits [ bit ] += deskew & ~ 7 ; dskcnt . bytes [ lane ] . bits [ bit ] += 1 ; } } } for ( lane = 0 ; lane < byte_limit ; lane ++ ) { for ( bit = 0 ; bit < 8 ; ++ bit ) { int div = dskcnt . bytes [ lane ] . bits [ bit ] ; if ( div > 0 ) { dsksum . bytes [ lane ] . bits [ bit ] /= div ; dsksum . bytes [ lane ] . bits [ bit ] &= ~ 7 ; dsksum . bytes [ lane ] . bits [ bit ] |= 1 ; } else { dsksum . bytes [ lane ] . bits [ bit ] = ( 64 << 3 ) | 1 ; } } } display_deskew_settings ( priv , if_num , & dsksum , 3 ) ; override_deskew_settings ( priv , if_num , & dsksum ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { struct timespec raw ; long tick , max , interval , err ; struct timex tx1 ; err = 0 ; setbuf ( stdout , NULL ) ; if ( clock_gettime ( CLOCK_MONOTONIC_RAW , & raw ) ) { printf ( \"ERR: NO CLOCK_MONOTONIC_RAW\\n\" ) ; return - 1 ; } printf ( \"Each iteration takes about 15 seconds\\n\" ) ; systick = sysconf ( _SC_CLK_TCK ) ; systick = USEC_PER_SEC / sysconf ( _SC_CLK_TCK ) ; max = systick / 10 ; interval = max / 4 ; for ( tick = ( systick - max ) ; tick < ( systick + max ) ; tick += interval ) { if ( check_tick_adj ( tick ) ) { err = 1 ; break ; } } tx1 . modes = ADJ_TICK ; tx1 . modes |= ADJ_OFFSET ; tx1 . modes |= ADJ_FREQUENCY ; tx1 . offset = 0 ; tx1 . freq = 0 ; tx1 . tick = systick ; adjtimex ( & tx1 ) ; return ksft_exit_pass ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ep0_queue ( struct bdc_ep * ep , struct bdc_req * req ) { struct bdc * bdc ; int ret ; bdc = ep -> bdc ; dev_dbg ( bdc -> dev , \"%s()\\n\" , __func__ ) ; req -> usb_req . actual = 0 ; req -> usb_req . status = - EINPROGRESS ; req -> epnum = ep -> ep_num ; if ( bdc -> delayed_status ) { bdc -> delayed_status = false ; if ( bdc -> ep0_state == WAIT_FOR_STATUS_START ) { ep0_queue_status_stage ( bdc , NULL ) ; bdc -> ep0_state = WAIT_FOR_STATUS_XMIT ; return 0 ; } } else { if ( req -> usb_req . length == 0 ) { return 0 ; } } ret = usb_gadget_map_request ( & bdc -> gadget , & req -> usb_req , ep -> dir ) ; if ( ret ) { dev_err ( bdc -> dev , \"dma mapping failed %s\\n\" , ep -> name ) ; return ret ; } return bdc_queue_xfr ( bdc , req ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ensure_users_exist ( void ) { ensure_user_exists ( ROOT_UGID ) ; ensure_user_exists ( RESTRICTED_PARENT_UGID ) ; ensure_user_exists ( ALLOWED_CHILD1_UGID ) ; ensure_user_exists ( ALLOWED_CHILD2_UGID ) ; ensure_user_exists ( NO_POLICY_UGID , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void snd_wm8776_activate_ctl ( struct snd_wm8776 * wm , const char * ctl_name , bool active ) { struct snd_card * card = wm -> card ; struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; struct snd_ctl_elem_id elem_id ; unsigned int index_offset ; strscpy ( elem_id . name , ctl_name , sizeof ( elem_id . name ) ) ; elem_id . iface = SNDRV_CTL_ELEM_IFACE_MIXER ; kctl = snd_ctl_find_id ( card , & elem_id ) ; if ( ! kctl ) { return ; } index_offset = snd_ctl_get_ioff ( kctl , & kctl -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( active ) { vd -> access &= ~ SNDRV_CTL_ELEM_ACCESS_INACTIVE ; } else { vd -> access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE ; } snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_INFO , & kctl -> id ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tm6000_audio_init ( struct tm6000_core * dev ) { struct snd_card * card ; struct snd_tm6000_card * chip ; int rc ; static int devnr ; char component [ 14 ] ; struct snd_pcm * pcm ; if ( ! dev ) { return 0 ; } if ( devnr >= SNDRV_CARDS ) { return - ENODEV ; } if ( ! enable [ devnr ] ) { return - ENOENT ; } rc = snd_card_new ( & dev -> udev -> dev , index [ devnr ] , \"tm6000\" , THIS_MODULE , 0 , & card ) ; if ( rc < 0 ) { snd_printk ( KERN_ERR \"cannot create card instance %d\\n\" , devnr ) ; return rc ; } strcpy ( card -> driver , \"tm6000-alsa\" ) ; strcpy ( card -> shortname , \"TM5600/60x0\" ) ; sprintf ( card -> longname , \"TM5600/60x0 Audio at bus %d device %d\" , dev -> udev -> bus -> busnum , dev -> udev -> devnum ) ; sprintf ( component , \"USB%04x:%04x\" , le16_to_cpu ( dev -> udev -> descriptor . idVendor ) , le16_to_cpu ( dev -> udev -> descriptor . idProduct ) ) ; snd_component_add ( card , component ) ; chip = kzalloc ( sizeof ( snd_tm6000_card ) , GFP_KERNEL ) ; if ( ! chip ) { rc = - ENOMEM ; error } chip -> core = dev ; chip -> card = card ; dev -> adev = chip ; spin_lock_init ( & chip -> reg_lock ) ; rc = snd_pcm_new ( card , \"TM6000 Audio\" , 0 , 0 , 1 , & pcm ) ; if ( rc < 0 ) { error_chip } pcm -> info_flags = 0 ; pcm -> private_data = chip ; strcpy ( pcm -> name , \"Trident TM5600/60x0\" ) ; snd_pcm_set_ops ( pcm , SNDRV_PCM_STREAM_CAPTURE , & snd_tm6000_pcm_ops ) ; INIT_WORK ( & dev -> wq_trigger , audio_trigger ) ; rc = snd_card_register ( card ) ; if ( rc < 0 ) { error_chip } dprintk ( 1 , \"Registered audio driver for %s\\n\" , card -> longname ) ; return 0 ; error_chip dev -> adev = NULL ; error snd_card_free ( card ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "uint64_t cpu_freq ( struct cpu_info * ci ) { uint64_t last_count , count ; count = cpu_freq_ctr ( ci ) ; last_count = rdtsc ( ) ; delay ( 100000 ) ; count = rdtsc ( ) ; return ( ( count - last_count ) * 10 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int truemotion2rt_decode_header ( AVCodecContext * avctx , AVPacket * avpkt ) { TrueMotion2RTContext * s = avctx -> priv_data ; int header_size ; uint8_t header_buffer [ 128 ] { 0 } ; ; const uint8_t * buf = avpkt -> data ; int size = avpkt -> size ; int width , height ; int ret , i ; if ( size < 1 ) { av_log ( avctx , AV_LOG_ERROR , \"input packet too small (%d)\\n\" , size ) ; return AVERROR_INVALIDDATA ; } header_size = ( ( buf [ 0 ] >> 5 ) | ( buf [ 0 ] << 3 ) ) & 0x7f ; if ( header_size < 10 ) { av_log ( avctx , AV_LOG_ERROR , \"invalid header size (%d)\\n\" , header_size ) ; return AVERROR_INVALIDDATA ; } if ( header_size + 1 > size ) { av_log ( avctx , AV_LOG_ERROR , \"input packet too small (%d)\\n\" , size ) ; return AVERROR_INVALIDDATA ; } for ( i = 1 ; i < header_size ; i ++ ) { header_buffer [ i - 1 ] = buf [ i ] ^ buf [ i + 1 ] ; } s -> delta_size = header_buffer [ 1 ] ; s -> hscale = 1 + ! ! header_buffer [ 3 ] ; height = AV_RL16 ( header_buffer + 5 ) ; width = AV_RL16 ( header_buffer + 7 ) ; ret = ff_set_dimensions ( avctx , width , height ) ; if ( ret < 0 ) { return ret ; } av_log ( avctx , AV_LOG_DEBUG , \"Header size: %d\\n\" , header_size ) ; return header_size ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int write_clone_read ( void ) { int parent_tid , child_tid ; pid_t parent , waiting ; int ret , status ; parent = getpid ( ) ; set_tpidr2 ( parent ) ; ret = sys_clone ( CLONE_SETTLS , 0 , & parent_tid , 0 , & child_tid ) ; if ( ret == - 1 ) { putstr ( \"# clone() failed\\n\" ) ; putnum ( errno , NULL ) ; putstr ( \"\\n\" ) ; return 0 ; } if ( ret == 0 ) { if ( get_tpidr2 ( ) != 0 ) { putstr ( \"# TPIDR2 non-zero in child: \" ) ; putnum ( get_tpidr2 ( ) ) ; putstr ( \"\\n\" ) ; exit ( 0 ) ; } if ( gettid ( ) == 0 ) { putstr ( \"# Child TID==0\\n\" ) ; } set_tpidr2 ( gettid ( ) ) ; if ( get_tpidr2 ( ) == gettid ( ) ) { exit ( 1 ) ; } else { putstr ( \"# Failed to set TPIDR2 in child\\n\" ) ; exit ( 0 ) ; } } for ( ; ; ) { waiting = wait4 ( ret , & status , __WCLONE , NULL ) ; if ( waiting < 0 ) { if ( errno == EINTR ) { continue ; } putstr ( \"# wait4() failed: \" ) ; putnum ( errno ) ; putstr ( \"\\n\" ) ; return 0 ; } if ( waiting != ret ) { putstr ( \"# wait4() returned wrong PID \" ) ; putnum ( waiting ) ; putstr ( \"\\n\" ) ; return 0 ; } if ( ! WIFEXITED ( status ) ) { putstr ( \"# child did not exit\\n\" ) ; return 0 ; } if ( parent != get_tpidr2 ( ) ) { putstr ( \"# TPIDR2 corrupted in parent\\n\" ) ; return 0 ; } return WEXITSTATUS ( status ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void hi3xxx_set_cpu_jump ( int cpu , void * jump_addr ) { cpu = cpu_logical_map ( cpu , NULL ) ; if ( ! cpu || ! ctrl_base ) { return ; } writel_relaxed ( __pa_symbol ( jump_addr ) , ctrl_base + ( ( cpu - 1 ) << 2 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static u64 process_durations ( int n ) { int i ; struct reader_task * rt ; char buf1 [ 64 ] ; char * buf ; int sum = 0 ; buf = kmalloc ( 800 + 64 , GFP_KERNEL ) ; if ( ! buf ) { return 0 ; } buf [ 0 ] = 0 ; sprintf ( buf , \"Experiment #%d (Format:<THREAD-NUM>:<Total loop time in ns>)\" , exp_idx ) ; for ( i = 0 ; i < n && ! torture_must_stop ( ) ; i ++ ) { rt = & ( reader_tasks [ i ] ) ; sprintf ( buf1 , \"%d: %llu\\t\" , i , rt -> last_duration_ns ) ; if ( i % 5 == 0 ) { strcat ( buf , \"\\n\" ) ; } if ( strlen ( buf ) >= 800 ) { pr_alert ( \"%s\" , buf ) ; buf [ 0 ] = 0 ; } strcat ( buf , buf1 ) ; sum += rt -> last_duration_ns ; } pr_alert ( \"%s\\n\" , buf ) ; kfree ( buf ) ; return sum ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t zend_stream_read ( zend_file_handle * file_handle , char * buf , size_t len ) { if ( file_handle -> handle . stream . isatty ) { int c = '*' ; int n ; for ( n = 0 ; n < len && ( c = zend_stream_getc ( file_handle ) ) != EOF && c != '\\n' ; ++ n ) { buf [ n ] = ( char ) c ; } if ( c == '\\n' ) { buf [ n ++ ] = ( char ) c ; } return n ; } return file_handle -> handle . stream . reader ( file_handle -> handle . stream . handle , buf , len ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "FIXTURE_TEARDOWN ( ) { close ( self -> netlink_fd ) ; close ( self -> unix_fd , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "print_target_help ( ) { unsigned int i ; static bool displayed = false ; displayed = true ; for ( i = 0 ; i < cl_options_count ; i ++ ) { if ( ( cl_options [ i ] . flags & ( CL_TARGET | CL_UNDOCUMENTED ) ) == CL_TARGET ) { printf ( _ ( \"\\nTarget specific options:\\n\" ) ) ; print_filtered_help ( CL_TARGET ) ; break ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int set_non_blocking ( int fd ) { int flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) { return 0 ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void pkey_rsa_cleanup ( EVP_PKEY_CTX * ctx ) { RSA_PKEY_CTX * rctx = ctx -> data ; if ( rctx ) { BN_free ( rctx -> pub_exp ) ; free ( rctx -> oaep_label ) ; free ( rctx ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GF_Err mhas_dmx_configure_pid ( GF_Filter * filter , GF_FilterPid * pid , Bool is_remove ) { const GF_PropertyValue * p ; GF_MHASDmxCtx * ctx = gf_filter_get_udta ( filter ) ; if ( is_remove ) { ctx -> ipid = NULL ; if ( ctx -> opid ) { gf_filter_pid_remove ( ctx -> opid ) ; ctx -> opid = NULL ; } return GF_OK ; } if ( ! gf_filter_pid_check_caps ( pid ) ) { return GF_NOT_SUPPORTED ; } p = gf_filter_pid_get_property ( pid , GF_PROP_PID_TIMESCALE ) ; if ( p ) { ctx -> timescale = p -> value . uint ; if ( ! ctx -> ipid ) { p = gf_filter_pid_get_property ( pid , GF_PROP_PID_UNFRAMED ) ; if ( p && p -> value . boolean ) { ctx -> nosync = GF_TRUE ; } } } ctx -> ipid = pid ; p = gf_filter_pid_get_property_str ( pid , \"nocts\" ) ; if ( p && p -> value . boolean ) { ctx -> recompute_cts = GF_TRUE ; } else { ctx -> recompute_cts = GF_FALSE ; } if ( ctx -> timescale && ! ctx -> opid ) { ctx -> opid = gf_filter_pid_new ( filter , NULL ) ; gf_filter_pid_copy_properties ( ctx -> opid , ctx -> ipid ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_UNFRAMED , NULL ) ; } if ( ctx -> timescale ) { ctx -> copy_props = GF_TRUE ; } return GF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static enum cfg_task_t chp_cfg_fetch_task ( struct chp_id * chpid ) { enum cfg_task_t t = cfg_none ; chp_id_for_each ( ) { t = cfg_get_task ( * chpid ) ; } return t ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cxgbe_devo_attach ( dev_info_t * dip , ddi_attach_cmd_t cmd ) { struct port_info_stub * pi ; mac_register_t * mac ; mac_handle_t mh ; int rc ; if ( cmd != DDI_ATTACH ) { return ( DDI_FAILURE ) ; } pi = ddi_get_parent_data ( dip ) ; if ( pi == NULL ) { return ( DDI_FAILURE ) ; } mac = mac_alloc ( MAC_VERSION ) ; if ( mac == NULL ) { cmn_err ( CE_WARN , \"%s%d: failed to allocate version %d mac.\" , ddi_driver_name ( pi -> dip ) , ddi_get_instance ( pi -> dip ) , MAC_VERSION ) ; return ( DDI_FAILURE ) ; } mac -> m_type_ident = MAC_PLUGIN_IDENT_ETHER ; mac -> m_driver = pi ; mac -> m_dip = dip ; mac -> m_src_addr = pi -> hw_addr ; mac -> m_callbacks = pi -> mc ; mac -> m_max_sdu = pi -> mtu ; mac -> m_priv_props = pi -> props ; mac -> m_margin = 22 ; if ( ! mac -> m_callbacks -> mc_unicst ) { cmn_err ( CE_NOTE , \"%s%d: Multiple Rings Enabled\" , ddi_driver_name ( pi -> dip ) , ddi_get_instance ( pi -> dip ) ) ; mac -> m_v12n = MAC_VIRT_LEVEL1 ; } else { cmn_err ( CE_NOTE , \"%s%d: Multiple Rings Disbled\" , ddi_driver_name ( pi -> dip ) , ddi_get_instance ( pi -> dip ) ) ; } rc = mac_register ( mac , & mh ) ; mac_free ( mac ) ; if ( rc != 0 ) { cmn_err ( CE_WARN , \"%s%d: failed to register version %d mac.\" , ddi_driver_name ( pi -> dip ) , ddi_get_instance ( pi -> dip ) , MAC_VERSION ) ; return ( DDI_FAILURE ) ; } pi -> mh = mh ; mac_link_update ( mh , LINK_STATE_UNKNOWN ) ; ddi_report_dev ( dip , NULL ) ; return ( DDI_SUCCESS ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static kadm5_ret_t kadm_connect ( kadm5_client_context * ctx ) { kadm5_ret_t ret ; krb5_principal server = NULL ; krb5_ccache cc = NULL ; rk_socket_t s = rk_INVALID_SOCKET ; struct addrinfo * ai , * a ; struct addrinfo hints ; int free_ai = 0 ; int error ; int kadmin_port = 0 ; const char * admin_server = NULL ; char portstr [ NI_MAXSERV ] ; const char * hostname , * slash ; char * service_name = NULL ; krb5_context context = ctx -> context ; int writable = 0 ; if ( ctx -> ac ) { krb5_auth_con_free ( context , ctx -> ac ) ; } ctx -> ac = NULL ; if ( ! ctx -> want_write ) { admin_server = ctx -> readonly_admin_server ; kadmin_port = ctx -> readonly_kadmind_port ; } if ( admin_server == NULL ) { admin_server = ctx -> admin_server ; writable = 1 ; } if ( kadmin_port < 1 ) { kadmin_port = ctx -> kadmind_port ; } memset ( & hints , 0 , sizeof ( hints ) ) ; hints . ai_socktype = SOCK_STREAM ; hints . ai_protocol = IPPROTO_TCP ; snprintf ( portstr , sizeof ( portstr ) , \"%u\" , ntohs ( kadmin_port ) ) ; hostname = admin_server ; slash = strchr ( hostname , '/' ) ; if ( slash != NULL ) { hostname = slash + 1 ; } error = getaddrinfo ( hostname , portstr , & hints , & ai ) ; if ( error ) { ret = KADM5_BAD_SERVER_NAME ; out } free_ai = 1 ; for ( a = ai ; a != NULL ; a = a -> ai_next ) { s = socket ( a -> ai_family , a -> ai_socktype , a -> ai_protocol ) ; if ( s < 0 ) { continue ; } if ( connect ( s , a -> ai_addr , a -> ai_addrlen ) < 0 ) { krb5_warn ( context , errno , \"connect(%s)\" , hostname ) ; rk_closesocket ( s , NULL ) ; s = rk_INVALID_SOCKET ; continue ; } break ; } if ( a == NULL ) { krb5_set_error_message ( context , ret = KADM5_FAILURE , \"failed to contact %s\" , hostname ) ; out } ret = _kadm5_c_get_cred_cache ( context , ctx -> client_name , ctx -> service_name , NULL , ctx -> prompter , ctx -> keytab , ctx -> ccache , & cc ) ; if ( ret ) { out } if ( ctx -> realm ) { error = asprintf ( & service_name , \"%s@%s\" , KADM5_ADMIN_SERVICE , ctx -> realm ) ; } else { error = asprintf ( & service_name , \"%s\" , KADM5_ADMIN_SERVICE ) ; } if ( error == - 1 || service_name == NULL ) { ret = krb5_enomem ( context ) ; out } ret = krb5_parse_name ( context , service_name , & server ) ; if ( ret ) { out } ret = krb5_sendauth ( context , & ctx -> ac , & s , KADMIN_APPL_VERSION , NULL , server , AP_OPTS_MUTUAL_REQUIRED , NULL , NULL , cc , NULL , NULL , NULL ) ; if ( ret == 0 ) { krb5_data params ; kadm5_config_params p ; memset ( & p , 0 , sizeof ( p ) ) ; if ( ctx -> realm ) { p . mask |= KADM5_CONFIG_REALM ; p . realm = ctx -> realm ; } ret = _kadm5_marshal_params ( context , & p , & params ) ; if ( ret == 0 ) { ret = krb5_write_priv_message ( context , ctx -> ac , & s , & params ) ; krb5_data_free ( & params ) ; } } if ( ret == 0 ) { ctx -> sock = s ; ctx -> connected_to_writable = ! ! writable ; } out free ( service_name ) ; krb5_cc_close ( context , cc ) ; krb5_free_principal ( context , server ) ; if ( free_ai ) { freeaddrinfo ( ai ) ; } if ( ret ) { if ( s != rk_INVALID_SOCKET ) { rk_closesocket ( s ) ; } krb5_auth_con_free ( context , ctx -> ac ) ; ctx -> ac = NULL ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct nlattr * find_dump_kind ( const struct nlmsghdr * n ) { struct nlattr * tb1 , * tb2 [ TCA_ACT_MAX + 1 ] ; struct nlattr * tb [ TCA_ACT_MAX_PRIO + 1 ] ; struct nlattr * nla [ TCAA_MAX + 1 ] ; struct nlattr * kind ; if ( nlmsg_parse ( n , sizeof ( tcamsg ) , nla , TCAA_MAX , NULL , NULL ) < 0 ) { return NULL ; } tb1 = nla [ TCA_ACT_TAB ] ; if ( nla_parse ( tb , TCA_ACT_MAX_PRIO , nla_data ( tb1 ) , NLMSG_ALIGN ( nla_len ( tb1 ) ) , NULL , NULL ) < 0 ) { return NULL ; } if ( tb [ 1 ] == NULL ) { return NULL ; } if ( nla_parse_nested ( tb2 , TCA_ACT_MAX , tb [ 1 ] , NULL , NULL ) < 0 ) { return NULL ; } kind = tb2 [ TCA_ACT_KIND ] ; return kind ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fpm_worker_pool_cleanup ( int which , void * arg ) { struct fpm_worker_pool_s * wp , * wp_next ; for ( wp = fpm_worker_all_pools ; wp ; wp = wp_next ) { wp_next = wp -> next ; fpm_worker_pool_config_free ( wp -> config ) ; fpm_children_free ( wp -> children ) ; if ( ( which & FPM_CLEANUP_CHILD ) == 0 && fpm_globals . parent_pid == getpid ( ) ) { fpm_scoreboard_free ( wp ) ; } } fpm_worker_all_pools = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rds_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; if ( sock -> type != SOCK_SEQPACKET || protocol ) { return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , AF_RDS , GFP_ATOMIC , & rds_proto , kern ) ; return __rds_create ( sock , sk , protocol ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int master_xfer ( struct i2c_adapter * adapter , struct i2c_msg * msg , int num ) { struct ttusb * ttusb = i2c_get_adapdata ( adapter ) ; int i ; int inc ; if ( mutex_lock_interruptible ( & ttusb -> semi2c ) < 0 ) { return - EAGAIN ; } while ( i < num ) { u8 addr , snd_len , rcv_len , * snd_buf , * rcv_buf ; int err ; if ( num > i + 1 && ( msg [ i + 1 ] . flags & I2C_M_RD ) ) { addr = msg [ i ] . addr ; snd_buf = msg [ i ] . buf ; snd_len = msg [ i ] . len ; rcv_buf = msg [ i + 1 ] . buf ; rcv_len = msg [ i + 1 ] . len ; inc = 2 ; } else { addr = msg [ i ] . addr ; snd_buf = msg [ i ] . buf ; snd_len = msg [ i ] . len ; rcv_buf = NULL ; rcv_len = 0 ; inc = 1 ; } err = ttusb_i2c_msg ( ttusb , addr , snd_buf , snd_len , rcv_buf , rcv_len ) ; if ( err < rcv_len ) { dprintk ( \"i == %i\\n\" , i ) ; break ; } i += inc ; } mutex_unlock ( & ttusb -> semi2c ) ; return i ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static BOOL autodetect_send_bandwidth_measure_stop ( rdpAutoDetect * autodetect , RDP_TRANSPORT_TYPE transport , UINT16 payloadLength , UINT16 sequenceNumber , UINT16 requestType ) { wStream * s ; WINPR_ASSERT ( autodetect ) ; WINPR_ASSERT ( autodetect -> context ) ; s = rdp_message_channel_pdu_init ( autodetect -> context -> rdp , NULL ) ; if ( ! s ) { return FALSE ; } WLog_VRB ( AUTODETECT_TAG , \"sending Bandwidth Measure Stop PDU ->payloadLength=%\" PRIu16 \"\" , payloadLength ) ; payloadLength &= ~ 3 ; Stream_Write_UINT8 ( s , requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME ?0x08 : 0x06 ) ; Stream_Write_UINT8 ( s , TYPE_ID_AUTODETECT_REQUEST ) ; Stream_Write_UINT16 ( s , sequenceNumber ) ; Stream_Write_UINT16 ( s , requestType ) ; if ( requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME ) { Stream_Write_UINT16 ( s , payloadLength ) ; if ( payloadLength > 0 ) { if ( ! Stream_EnsureRemainingCapacity ( s , payloadLength ) ) { WLog_ERR ( AUTODETECT_TAG , \"Failed to ensure %\" PRIuz \" bytes in stream\" , payloadLength ) ; Stream_Release ( s ) ; return FALSE ; } winpr_RAND ( Stream_Pointer ( s ) , payloadLength ) ; Stream_Seek ( s , payloadLength ) ; } } return rdp_send_message_channel_pdu ( autodetect -> context -> rdp , s , SEC_AUTODETECT_REQ ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int acpi_mdiobus_register ( struct mii_bus * mdio , struct fwnode_handle * fwnode ) { struct fwnode_handle * child ; u32 addr ; int ret ; mdio -> phy_mask = GENMASK ( 31 , 0 ) ; ret = mdiobus_register ( mdio ) ; ACPI_COMPANION_SET ( & mdio -> dev , to_acpi_device_node ( fwnode ) ) ; fwnode_for_each_child_node ( , ) { ret = acpi_get_local_address ( ACPI_HANDLE_FWNODE ( child ) , & addr ) ; if ( ret || addr >= PHY_MAX_ADDR ) { continue ; } ret = fwnode_mdiobus_register_phy ( mdio , child , addr ) ; if ( ret == - ENODEV ) { dev_err ( & mdio -> dev , \"MDIO device at address %d is missing.\\n\" , addr ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool ttm_range_man_intersects ( struct ttm_resource_manager * man , struct ttm_resource * res , const struct ttm_place * place , size_t size ) { struct drm_mm_node * node = & to_ttm_range_mgr_node ( res ) -> mm_nodes [ 0 ] ; u32 num_pages = PFN_UP ( size ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void plat_build_mem_nodes ( prom_memlist_t * list , size_t nelems ) { int slice ; pfn_t basepfn ; pgcnt_t npgs ; mem_node_pfn_shift = PFN_SLICE_SHIFT ; mem_node_physalign = ( 1ull << PA_SLICE_SHIFT ) ; npgs = 1ull << PFN_SLICE_SHIFT ; for ( slice = 0 ; slice < DAK_MAX_SLICE ; slice ++ ) { basepfn = ( uint64_t ) slice << PFN_SLICE_SHIFT ; mem_node_add_slice ( basepfn , basepfn + npgs - 1 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int tor_ersatz_socketpair ( int family , int type , int protocol , tor_socket_t fd [ 2 ] ) { tor_socket_t listener = TOR_INVALID_SOCKET ; tor_socket_t connector = TOR_INVALID_SOCKET ; tor_socket_t acceptor = TOR_INVALID_SOCKET ; struct sockaddr_storage accepted_addr_ss ; struct sockaddr_storage connect_addr_ss ; struct sockaddr * connect_addr = ( sockaddr * ) & connect_addr_ss ; struct sockaddr * accepted_addr = ( sockaddr * ) & accepted_addr_ss ; socklen_t size ; int saved_errno = - 1 ; int ersatz_domain = AF_INET ; socklen_t addrlen = sizeof ( sockaddr_in ) ; memset ( & accepted_addr_ss , 0 , sizeof ( accepted_addr_ss ) ) ; if ( protocol || family != AF_UNIX ) { return - WSAEAFNOSUPPORT ; return - EAFNOSUPPORT ; } if ( ! fd ) { return - EINVAL ; } listener = get_local_listener ( ersatz_domain , type ) ; if ( ! SOCKET_OK ( listener ) ) { int first_errno = socket_errno ( ) ; if ( first_errno == SOCKET_EPROTONOSUPPORT ) { ersatz_domain = AF_INET6 ; addrlen = sizeof ( sockaddr_in6 ) ; listener = get_local_listener ( ersatz_domain , type ) ; } if ( ! SOCKET_OK ( listener ) ) { return - first_errno ; } } connector = socket ( ersatz_domain , type , 0 ) ; if ( ! SOCKET_OK ( connector ) ) { tidy_up_and_fail } size = sizeof ( connect_addr_ss ) ; if ( getsockname ( listener , connect_addr , & size ) == - 1 ) { tidy_up_and_fail } if ( size != addrlen ) { abort_tidy_up_and_fail } if ( connect ( connector , connect_addr , size ) == - 1 ) { tidy_up_and_fail } size = sizeof ( accepted_addr_ss ) ; acceptor = accept ( listener , accepted_addr , & size ) ; if ( ! SOCKET_OK ( acceptor ) ) { tidy_up_and_fail } if ( size != addrlen ) { abort_tidy_up_and_fail } if ( getsockname ( connector , connect_addr , & size ) == - 1 ) { tidy_up_and_fail } if ( ! sockaddr_eq ( accepted_addr , connect_addr ) ) { abort_tidy_up_and_fail } closesocket ( listener ) ; fd [ 0 ] = connector ; fd [ 1 ] = acceptor ; return 0 ; abort_tidy_up_and_fail saved_errno = WSAECONNABORTED ; saved_errno = ECONNABORTED ; tidy_up_and_fail if ( saved_errno < 0 ) { saved_errno = errno ; } if ( SOCKET_OK ( listener ) ) { closesocket ( listener ) ; } if ( SOCKET_OK ( connector ) ) { closesocket ( connector ) ; } if ( SOCKET_OK ( acceptor ) ) { closesocket ( acceptor ) ; } return - saved_errno ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xilinx_dpdma_debugfs_desc_done_irq_write ( char * args ) { char * arg ; int ret ; u32 id ; arg = strsep ( & args , \" \" ) ; if ( ! arg || strncasecmp ( arg , \"start\" , 5 ) ) { return - EINVAL ; } arg = strsep ( & args , \" \" ) ; ret = kstrtou32 ( arg , 0 , & id ) ; if ( ret < 0 ) { return ret ; } if ( id ( ZYNQMP_DPDMA_VIDEO0 || id ) ZYNQMP_DPDMA_AUDIO1 ) { return - EINVAL ; } dpdma_debugfs . testcase = DPDMA_TC_INTR_DONE ; dpdma_debugfs . xilinx_dpdma_irq_done_count = 0 ; dpdma_debugfs . chan_id = id ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mbedtls_test_cleanup ( const struct testcase_t * testcase , void * ptr ) { int ret = basic_test_cleanup ( testcase , ptr ) ; if ( ! ret ) { return ret ; } test_is_done = 0 ; n_connected = 0 ; got_close = 0 ; got_error = 0 ; got_timeout = 0 ; renegotiate_at = - 1 ; stop_when_connected = 0 ; pending_connect_events = 0 ; exit_base = NULL ; mbedtls_x509_crt_free ( the_cert ) ; mbedtls_pk_free ( the_key ) ; free ( the_key ) ; if ( the_mbedtls_conf [ 0 ] ) { mbedtls_ssl_config_free ( the_mbedtls_conf [ 0 ] ) ; free ( the_mbedtls_conf [ 0 ] ) ; the_mbedtls_conf [ 0 ] = NULL ; } if ( the_mbedtls_conf [ 1 ] ) { mbedtls_ssl_config_free ( the_mbedtls_conf [ 1 ] ) ; free ( the_mbedtls_conf [ 1 ] ) ; the_mbedtls_conf [ 1 ] = NULL ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int opendq ( struct ufsvfs * ufsvfsp , struct vnode * vp , struct cred * cr ) { struct inode * qip ; struct dquot * dqp ; int error ; int quotaon = 0 ; if ( secpolicy_fs_quota ( cr , ufsvfsp -> vfs_vfs ) != 0 ) { return ( EPERM ) ; } VN_HOLD ( vp ) ; if ( vp -> v_type != VREG ) { return ( EACCES ) ; } rw_enter ( & ufsvfsp -> vfs_dqrwlock , RW_WRITER ) ; ASSERT ( ( ufsvfsp -> vfs_qflags & MQ_ENABLED ) || ( ufsvfsp -> vfs_qinod == 0 ) ) ; if ( ( ufsvfsp -> vfs_qflags & MQ_ENABLED ) != 0 ) { if ( VTOI ( vp ) != ufsvfsp -> vfs_qinod ) { cmn_err ( CE_WARN , \"Previous quota file still in use.\" \" Disable quotas on %s before enabling.\\n\" , VTOI ( vp ) -> i_fs -> fs_fsmnt ) ; VN_RELE ( vp ) ; rw_exit ( & ufsvfsp -> vfs_dqrwlock ) ; return ( 0 ) ; } ( void ) quotasync ( ufsvfsp , 0 ) ; VN_RELE ( vp ) ; quotaon ++ ; qip = ufsvfsp -> vfs_qinod ; } else { int qlen ; ufsvfsp -> vfs_qinod = VTOI ( vp ) ; qip = ufsvfsp -> vfs_qinod ; qlen = qip -> i_fs -> fs_bsize * NDADDR ; rw_enter ( & qip -> i_contents , RW_WRITER ) ; if ( qip -> i_size < qlen ) { if ( ufs_itrunc ( qip , ( u_offset_t ) qlen , ( int ) 0 , cr ) != 0 ) { cmn_err ( CE_WARN , \"opendq failed to remove frags\" \" from quota file\\n\" ) ; } rw_exit ( & qip -> i_contents ) ; ( void ) VOP_PUTPAGE ( vp , ( offset_t ) 0 , ( size_t ) qip -> i_size , B_INVAL , kcred , NULL ) ; } else { rw_exit ( & qip -> i_contents ) ; } TRANS_MATA_IGET ( ufsvfsp , qip ) ; } error = getdiskquota ( ( uid_t ) 0 , ufsvfsp , 1 , & dqp ) ; if ( error == 0 ) { mutex_enter ( & dqp -> dq_lock ) ; ufsvfsp -> vfs_btimelimit = ( dqp -> dq_btimelimit ?dqp -> dq_btimelimit : DQ_BTIMELIMIT ) ; ufsvfsp -> vfs_ftimelimit = ( dqp -> dq_ftimelimit ?dqp -> dq_ftimelimit : DQ_FTIMELIMIT ) ; ufsvfsp -> vfs_qflags = MQ_ENABLED ; vfs_setmntopt ( ufsvfsp -> vfs_vfs , MNTOPT_QUOTA , NULL , 0 ) ; dqput ( dqp ) ; mutex_exit ( & dqp -> dq_lock ) ; } if ( ! quotaon ) { ufsvfsp -> vfs_qflags = 0 ; ufsvfsp -> vfs_qinod = NULL ; VN_RELE ( ITOV ( qip ) ) ; } if ( ufsvfsp -> vfs_qflags & MQ_ENABLED ) { ( void ) ufs_scan_inodes ( 0 , opendq_scan_inode , ufsvfsp , ufsvfsp ) ; } rw_exit ( & ufsvfsp -> vfs_dqrwlock ) ; return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void set_promote_secondaries_devconf ( interface_t * ifp ) { sysctl_opts_t promote_secondaries_sysctl [ ] { { IPV4_DEVCONF_PROMOTE_SECONDARIES 1 } { 0 0 } } ; ; netlink_set_interface_flags ( ifp -> ifindex , promote_secondaries_sysctl ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int smrt_getcap ( struct scsi_address * sa , char * cap , int whom ) { _NOTE ( ) struct scsi_device * sd ; smrt_target_t * smtg ; smrt_t * smrt ; int index ; sd = scsi_address_device ( sa ) ; VERIFY ( sd != NULL ) ; smtg = scsi_device_hba_private_get ( sd ) ; VERIFY ( smtg != NULL ) ; smrt = smtg -> smtg_ctlr ; VERIFY ( smrt != NULL ) ; if ( ( index = scsi_hba_lookup_capstr ( cap ) ) == DDI_FAILURE ) { return ( - 1 ) ; } switch ( index ) { case SCSI_CAP_CDB_LEN : return ( CISS_CDBLEN ) ; case SCSI_CAP_DMA_MAX : if ( smrt -> smrt_dma_attr . dma_attr_maxxfer > INT_MAX ) { return ( INT_MAX ) ; } return ( ( int ) smrt -> smrt_dma_attr . dma_attr_maxxfer ) ; case SCSI_CAP_SECTOR_SIZE : return ( ( int ) smrt -> smrt_dma_attr . dma_attr_granular ) ; case SCSI_CAP_INTERCONNECT_TYPE : if ( smtg -> smtg_physical ) { return ( INTERCONNECT_SAS ) ; } else { return ( INTERCONNECT_PARALLEL ) ; } case SCSI_CAP_DISCONNECT : case SCSI_CAP_SYNCHRONOUS : case SCSI_CAP_WIDE_XFER : case SCSI_CAP_ARQ : case SCSI_CAP_UNTAGGED_QING : case SCSI_CAP_TAGGED_QING : return ( 1 ) ; case SCSI_CAP_INITIATOR_ID : case SCSI_CAP_RESET_NOTIFICATION : return ( 0 ) ; default : return ( - 1 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int avi_sync ( AVFormatContext * s , int exit_early ) { AVIContext * avi = s -> priv_data ; AVIOContext * pb = s -> pb ; int n ; unsigned int d [ 8 ] ; unsigned int size ; int64_t i , sync ; start_sync for ( i = sync = avio_tell ( pb ) ; ! avio_feof ( pb ) ; i ++ ) { int j ; for ( j = 0 ; j < 7 ; j ++ ) { d [ j ] = d [ j + 1 ] ; } d [ 7 ] = avio_r8 ( pb ) ; size = d [ 4 ] + ( d [ 5 ] << 8 ) + ( d [ 6 ] << 16 ) + ( d [ 7 ] << 24 ) ; n = get_stream_idx ( d + 2 ) ; ff_tlog ( s , \"%X %X %X %X %X %X %X %X %\" PRId64 \" %u %d\\n\" , d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] , d [ 6 ] , d [ 7 ] , i , size , n ) ; if ( i * ( avi -> io_fsize > 0 ) + ( uint64_t ) size > avi -> fsize || d [ 0 ] > 127 ) { continue ; } if ( ( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'n' && d [ 2 ] == 'd' && d [ 3 ] == 'x' ) ) { avio_skip ( pb , size ) ; start_sync } if ( d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T' ) { avio_skip ( pb , 4 ) ; start_sync } n = get_stream_idx ( d ) ; if ( ! ( ( i - avi -> last_pkt_pos ) & 1 ) && get_stream_idx ( d + 1 ) < s -> nb_streams ) { continue ; } if ( d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams ) { avio_skip ( pb , size ) ; start_sync } if ( d [ 2 ] == 'w' && d [ 3 ] == 'c' && n < s -> nb_streams ) { avio_skip ( pb , 16 * 3 + 8 ) ; start_sync } if ( avi -> dv_demux && n != 0 ) { continue ; } if ( n < s -> nb_streams ) { AVStream * st ; AVIStream * ast ; st = s -> streams [ n ] ; ast = st -> priv_data ; if ( ! ast ) { av_log ( s , AV_LOG_WARNING , \"Skipping foreign stream %d packet\\n\" , n ) ; continue ; } if ( s -> nb_streams >= 2 ) { AVStream * st1 = s -> streams [ 1 ] ; AVIStream * ast1 = st1 -> priv_data ; if ( ast1 && d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count ) ) { n = 1 ; st = st1 ; ast = ast1 ; av_log ( s , AV_LOG_WARNING , \"Invalid stream + prefix combination, assuming audio.\\n\" ) ; } } if ( d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4 ) { int k = avio_r8 ( pb ) ; int last = ( k + avio_r8 ( pb ) - 1 ) & 0xFF ; avio_rl16 ( pb ) ; for ( ; k <= last ; k ++ ) { ast -> pal [ k ] = 0xFFU << 24 | avio_rb32 ( pb ) >> 8 ; } ast -> has_pal = 1 ; start_sync } if ( ( ( ast -> prefix_count ( 5 || sync + 9 ) i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix ) { if ( exit_early ) { return 0 ; } if ( d [ 2 ] * 256 + d [ 3 ] == ast -> prefix ) { ast -> prefix_count ++ ; } else { ast -> prefix = d [ 2 ] * 256 + d [ 3 ] ; ast -> prefix_count = 0 ; } if ( ! avi -> dv_demux && ( ( st -> discard >= AVDISCARD_DEFAULT && size == 0 ) || st -> discard >= AVDISCARD_ALL ) ) { ast -> frame_offset += get_duration ( ast , size ) ; avio_skip ( pb , size ) ; start_sync } avi -> stream_index = n ; ast -> packet_size = size + 8 ; ast -> remaining = size ; if ( size ) { FFStream * const sti = ffstream ( st ) ; uint64_t pos = avio_tell ( pb ) - 8 ; if ( ! sti -> index_entries || ! sti -> nb_index_entries || sti -> index_entries [ sti -> nb_index_entries - 1 ] . pos < pos ) { av_add_index_entry ( st , pos , ast -> frame_offset , size , 0 , AVINDEX_KEYFRAME ) ; } } return 0 ; } } } if ( pb -> error ) { return pb -> error ; } return AVERROR_EOF ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void wait_for_dump_helpers ( struct file * file ) { struct pipe_inode_info * pipe = file -> private_data ; pipe_lock ( pipe , NULL ) ; pipe -> readers ++ ; pipe -> writers -- ; wake_up_interruptible_sync ( & pipe -> rd_wait ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; pipe_unlock ( pipe ) ; wait_event_interruptible ( pipe -> rd_wait , pipe -> readers == 1 ) ; pipe_lock ( pipe ) ; pipe -> readers -- ; pipe -> writers ++ ; pipe_unlock ( pipe ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sparx5_xtr_grp ( struct sparx5 * sparx5 , u8 grp , bool byte_swap ) { bool eof_flag = false , pruned_flag = false , abort_flag = false ; struct net_device * netdev ; struct sparx5_port * port ; struct frame_info fi ; int i , byte_cnt = 0 ; struct sk_buff * skb ; u32 ifh [ IFH_LEN ] ; u32 * rxbuf ; for ( i = 0 ; i < IFH_LEN ; i ++ ) { ifh [ i ] = spx5_rd ( sparx5 , QS_XTR_RD ( grp ) ) ; } sparx5_ifh_parse ( ifh , & fi ) ; port = fi . src_port < SPX5_PORTS ?sparx5 -> ports [ fi . src_port ] : NULL ; if ( ! port || ! port -> ndev ) { dev_err ( sparx5 -> dev , \"Data on inactive port %d\\n\" , fi . src_port ) ; sparx5_xtr_flush ( sparx5 , grp ) ; return ; } netdev = port -> ndev ; skb = netdev_alloc_skb ( netdev , netdev -> mtu + ETH_HLEN ) ; if ( ! skb ) { sparx5_xtr_flush ( sparx5 , grp ) ; dev_err ( sparx5 -> dev , \"No skb allocated\\n\" ) ; netdev -> stats . rx_dropped ++ ; return ; } rxbuf = ( u32 * ) skb -> data ; while ( ! eof_flag ) { u32 val = spx5_rd ( sparx5 , QS_XTR_RD ( grp ) ) ; u32 cmp = val ; if ( byte_swap ) { cmp = ntohl ( ( __force __be32 ) val ) ; } switch ( cmp ) { case XTR_NOT_READY : break ; case XTR_ABORT : abort_flag = true ; eof_flag = true ; break ; case XTR_EOF_0 : case XTR_EOF_1 : case XTR_EOF_2 : case XTR_EOF_3 : if ( ! byte_swap ) { val = ntohl ( ( __force __be32 ) val ) ; } byte_cnt -= ( 4 - XTR_VALID_BYTES ( val ) ) ; eof_flag = true ; break ; case XTR_PRUNED : eof_flag = true ; pruned_flag = true ; fallthrough ; case XTR_ESCAPE : * rxbuf = spx5_rd ( sparx5 , QS_XTR_RD ( grp ) ) ; byte_cnt += 4 ; rxbuf ++ ; break ; default : * rxbuf = val ; byte_cnt += 4 ; rxbuf ++ ; } } if ( abort_flag || pruned_flag || ! eof_flag ) { netdev_err ( netdev , \"Discarded frame: abort:%d pruned:%d eof:%d\\n\" , abort_flag , pruned_flag , eof_flag ) ; netdev -> stats . rx_dropped ++ ; return ; } if ( test_bit ( port -> portno , sparx5 -> bridge_mask ) ) { skb -> offload_fwd_mark = 1 ; } skb_put ( skb , byte_cnt - ETH_FCS_LEN ) ; eth_skb_pad ( skb ) ; sparx5_ptp_rxtstamp ( sparx5 , skb , fi . timestamp ) ; skb -> protocol = eth_type_trans ( skb , netdev ) ; netdev -> stats . rx_bytes += skb -> len ; netdev -> stats . rx_packets ++ ; netif_rx ( skb ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void pw_copy ( int ffd , int tfd , const struct passwd * pw , const struct passwd * opw ) { struct passwd tpw ; FILE * from , * to ; int done ; char * p , * ep , buf [ 8192 ] ; char * master = pw_file ( _PATH_MASTERPASSWD ) ; if ( ! master ) { pw_error ( NULL , 0 , 1 ) ; } if ( ! ( from = fdopen ( ffd , \"r\" ) ) ) { pw_error ( master , 1 , 1 ) ; } if ( ! ( to = fdopen ( tfd , \"w\" ) ) ) { pw_error ( pw_lck ?pw_lck : NULL , pw_lck ?1 : 0 , 1 ) ; } for ( done = 0 ; fgets ( buf , ( int ) sizeof ( buf ) , from ) ; ) { if ( ( ep = strchr ( buf , '\\n' ) ) == NULL ) { warnx ( \"%s: line too long\" , master ) ; pw_error ( NULL , 0 , 1 ) ; } if ( done ) { if ( fputs ( buf , to ) ) { fail } continue ; } if ( ! ( p = strchr ( buf , ':' ) ) ) { warnx ( \"%s: corrupted entry\" , master ) ; pw_error ( NULL , 0 , 1 ) ; } * p = '\\0' ; if ( strcmp ( buf , opw ?opw -> pw_name : pw -> pw_name ) ) { * p = ':' ; if ( fputs ( buf , to ) ) { fail } continue ; } if ( opw != NULL ) { * p = ':' ; * ep = '\\0' ; if ( ! pw_scan ( buf , & tpw , NULL ) ) { pw_error ( NULL , 0 , 1 ) ; } if ( ! pw_equal ( & tpw , opw ) ) { warnx ( \"%s: inconsistent entry\" , master ) ; pw_error ( NULL , 0 , 1 ) ; } } if ( pw_write_entry ( to , pw ) == - 1 ) { fail } done = 1 ; } if ( ! done && pw_write_entry ( to , pw ) == - 1 ) { fail } if ( ferror ( to ) || fflush ( to ) ) { fail pw_error ( NULL , 0 , 1 ) ; } ( void ) fclose ( to ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void auxtrace_synth_error ( struct auxtrace_error_event * auxtrace_error , int type , int code , int cpu , pid_t pid , pid_t tid , u64 ip , const char * msg ) { size_t size ; auxtrace_error -> header . type = PERF_RECORD_AUXTRACE_ERROR ; auxtrace_error -> type = type ; auxtrace_error -> code = code ; auxtrace_error -> cpu = cpu ; auxtrace_error -> pid = pid ; auxtrace_error -> tid = tid ; auxtrace_error -> ip = ip ; strlcpy ( auxtrace_error -> msg , msg , MAX_AUXTRACE_ERROR_MSG ) ; size = ( void * ) auxtrace_error -> msg - ( void * ) auxtrace_error + strlen ( auxtrace_error -> msg ) + 1 ; auxtrace_error -> header . size = PERF_ALIGN ( size , sizeof ( u64 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int oxygen_pci_probe ( struct pci_dev * pci , int index , char * id , struct module * owner , const struct pci_device_id * ids , int * get_model ( struct oxygen * chip , const struct pci_device_id * id ) ) { struct snd_card * card ; struct oxygen * chip ; const struct pci_device_id * pci_id ; int err ; err = snd_card_new ( & pci -> dev , index , id , owner , sizeof ( * chip ) , & card ) ; if ( err < 0 ) { return err ; } chip = card -> private_data ; chip -> card = card ; chip -> pci = pci ; chip -> irq = - 1 ; spin_lock_init ( & chip -> reg_lock ) ; INIT_WORK ( & chip -> spdif_input_bits_work , oxygen_spdif_input_bits_changed ) ; INIT_WORK ( & chip -> gpio_work , oxygen_gpio_changed ) ; init_waitqueue_head ( & chip -> ac97_waitqueue ) ; err = pci_enable_device ( pci ) ; if ( err < 0 ) { err_card } err = pci_request_regions ( pci , DRIVER ) ; if ( err < 0 ) { dev_err ( card -> dev , \"cannot reserve PCI resources\\n\" ) ; err_pci_enable } if ( ! ( pci_resource_flags ( pci , 0 ) & IORESOURCE_IO ) || pci_resource_len ( pci , 0 ) < OXYGEN_IO_SIZE ) { dev_err ( card -> dev , \"invalid PCI I/O range\\n\" ) ; err = - ENXIO ; err_pci_regions } chip -> addr = pci_resource_start ( pci , 0 ) ; pci_id = oxygen_search_pci_id ( chip , ids ) ; if ( ! pci_id ) { err = - ENODEV ; err_pci_regions } oxygen_restore_eeprom ( chip , pci_id ) ; err = get_model ( chip , pci_id ) ; if ( err < 0 ) { err_pci_regions } if ( chip -> model . model_data_size ) { chip -> model_data = kzalloc ( chip -> model . model_data_size , GFP_KERNEL ) ; if ( ! chip -> model_data ) { err = - ENOMEM ; err_pci_regions } } pci_set_master ( pci ) ; card -> private_free = oxygen_card_free ; configure_pcie_bridge ( pci ) ; oxygen_init ( chip ) ; chip -> model . init ( chip ) ; err = request_irq ( pci -> irq , oxygen_interrupt , IRQF_SHARED , KBUILD_MODNAME , chip ) ; if ( err < 0 ) { dev_err ( card -> dev , \"cannot grab interrupt %d\\n\" , pci -> irq ) ; err_card } chip -> irq = pci -> irq ; strcpy ( card -> driver , chip -> model . chip ) ; strcpy ( card -> shortname , chip -> model . shortname ) ; sprintf ( card -> longname , \"%s at %#lx, irq %i\" , chip -> model . longname , chip -> addr , chip -> irq ) ; strcpy ( card -> mixername , chip -> model . chip ) ; snd_component_add ( card , chip -> model . chip ) ; err = oxygen_pcm_init ( chip ) ; if ( err < 0 ) { err_card } err = oxygen_mixer_init ( chip ) ; if ( err < 0 ) { err_card } if ( chip -> model . device_config & ( MIDI_OUTPUT | MIDI_INPUT ) ) { unsigned int info_flags = MPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK ; if ( chip -> model . device_config & MIDI_OUTPUT ) { info_flags |= MPU401_INFO_OUTPUT ; } if ( chip -> model . device_config & MIDI_INPUT ) { info_flags |= MPU401_INFO_INPUT ; } err = snd_mpu401_uart_new ( card , 0 , MPU401_HW_CMIPCI , chip -> addr + OXYGEN_MPU401 , info_flags , - 1 , & chip -> midi ) ; if ( err < 0 ) { err_card } } oxygen_proc_init ( chip ) ; spin_lock_irq ( & chip -> reg_lock ) ; if ( chip -> model . device_config & CAPTURE_1_FROM_SPDIF ) { chip -> interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT ; } if ( chip -> has_ac97_0 | chip -> has_ac97_1 ) { chip -> interrupt_mask |= OXYGEN_INT_AC97 ; } oxygen_write16 ( chip , OXYGEN_INTERRUPT_MASK , chip -> interrupt_mask ) ; spin_unlock_irq ( & chip -> reg_lock ) ; err = snd_card_register ( card ) ; if ( err < 0 ) { err_card } pci_set_drvdata ( pci , card ) ; return 0 ; err_pci_regions pci_release_regions ( pci ) ; err_pci_enable pci_disable_device ( pci ) ; err_card snd_card_free ( card ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mlx5_hv_vhca_init ( struct mlx5_hv_vhca * hv_vhca ) { struct mlx5_hv_vhca_agent * agent ; int err ; err = mlx5_hv_register_invalidate ( hv_vhca -> dev , hv_vhca , mlx5_hv_vhca_invalidate ) ; if ( err ) { return err ; } agent = mlx5_hv_vhca_control_agent_create ( hv_vhca ) ; if ( IS_ERR_OR_NULL ( agent ) ) { mlx5_hv_unregister_invalidate ( hv_vhca -> dev ) ; return IS_ERR_OR_NULL ( agent ) ; } hv_vhca -> agents [ MLX5_HV_VHCA_AGENT_CONTROL ] = agent ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool aa_label_is_subset ( struct aa_label * set , struct aa_label * sub ) { struct label_it i = { } ; AA_BUG ( ! set ) ; AA_BUG ( ! sub ) ; return __aa_label_next_not_in_set ( & i , set , sub ) == NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "_Float128 mpfr_get_float128 ( mpfr_srcptr x , mpfr_rnd_t rnd_mode ) { if ( MPFR_UNLIKELY ( MPFR_IS_SINGULAR ( x ) ) ) { return ( _Float128 ) mpfr_get_d ( x , rnd_mode ) ; } else { _Float128 r ; _Float128 m ; mpfr_exp_t e ; mpfr_exp_t sh ; const int emin = - 16381 ; const int esub = emin - IEEE_FLOAT128_MANT_DIG ; int sign ; sign = MPFR_SIGN ( x ) ; e = MPFR_GET_EXP ( x , NULL ) ; if ( MPFR_UNLIKELY ( e <= esub ) ) { if ( MPFR_IS_LIKE_RNDZ ( rnd_mode , sign < 0 ) || ( rnd_mode == MPFR_RNDN && ( e < esub || mpfr_powerof2_raw ( x ) ) ) ) { return sign < 0 ?- 0.0 : 0.0 ; } r = 1.0 ; sh = esub ; } else { mpfr_t y ; mp_limb_t * yp ; int prec , i ; MPFR_SAVE_EXPO_DECL ( expo ) ; MPFR_SAVE_EXPO_MARK ( expo ) ; prec = e < emin ?e - esub : IEEE_FLOAT128_MANT_DIG ; MPFR_ASSERTD ( prec >= MPFR_PREC_MIN ) ; mpfr_init2 ( y , prec ) ; mpfr_set ( y , x , rnd_mode ) ; sh = MPFR_GET_EXP ( y ) ; MPFR_SET_EXP ( y , 0 ) ; MPFR_SET_POS ( y ) ; yp = MPFR_MANT ( y ) ; r = 0.0 ; for ( i = 0 ; i < MPFR_LIMB_SIZE ( y ) ; i ++ ) { r += yp [ i ] ; r *= 1 / ( 2 * ( _Float128 ) MPFR_LIMB_HIGHBIT ) ; } mpfr_clear ( y ) ; MPFR_SAVE_EXPO_FREE ( expo ) ; } MPFR_ASSERTD ( r > 0 ) ; if ( sh != 0 ) { while ( r < 1.0 ) { r += r ; sh -- ; } if ( sh > 0 ) { m = 2.0 ; } else { m = 0.5 ; sh = - sh ; } for ( ; ; ) { if ( sh % 2 ) { r = r * m ; } sh >>= 1 ; if ( sh == 0 ) { break ; } m = m * m ; } } if ( sign < 0 ) { r = - r ; } return r ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int AAS_UpdatePortal ( int areanum , int clusternum ) { int portalnum ; aas_portal_t * portal ; aas_cluster_t * cluster ; for ( portalnum = 1 ; portalnum < ( * aasworld ) . numportals ; portalnum ++ ) { if ( ( * aasworld ) . portals [ portalnum ] . areanum == areanum ) { break ; } } if ( portalnum == ( * aasworld ) . numportals ) { AAS_Error ( \"no portal of area %d\\n\" , areanum ) ; return qtrue ; } portal = & ( * aasworld ) . portals [ portalnum ] ; if ( portal -> backcluster == clusternum ) { return qtrue ; } if ( ! portal -> frontcluster ) { portal -> frontcluster = clusternum ; } if ( ! portal -> backcluster ) { portal -> backcluster = clusternum ; } else { Log_Write ( \"portal using area %d is separating more than two clusters\\r\\n\" , areanum ) ; ( * aasworld ) . areasettings [ areanum ] . contents &= ~ AREACONTENTS_CLUSTERPORTAL ; return qfalse ; } if ( ( * aasworld ) . portalindexsize >= AAS_MAX_PORTALINDEXSIZE ) { AAS_Error ( \"AAS_MAX_PORTALINDEXSIZE\\n\" ) ; return qtrue ; } ( * aasworld ) . areasettings [ areanum ] . cluster = - portalnum ; cluster = & ( * aasworld ) . clusters [ clusternum ] ; ( * aasworld ) . portalindex [ cluster -> firstportal + cluster -> numportals ] = portalnum ; ( * aasworld ) . portalindexsize ++ ; cluster -> numportals ++ ; return qtrue ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static TEE_Result get_info_from_device_tree ( struct ls_dspi_data * dspi_data ) { const fdt32_t * bus_num = NULL ; const fdt32_t * chip_select_num = NULL ; int size = 0 ; int node = 0 ; vaddr_t ctrl_base = 0 ; void * fdt = NULL ; fdt = get_dt ( ) ; if ( ! fdt ) { EMSG ( \"Unable to get DTB, DSPI init failed\\n\" ) ; return TEE_ERROR_ITEM_NOT_FOUND ; } node = 0 ; while ( node != - FDT_ERR_NOTFOUND ) { node = fdt_node_offset_by_compatible ( fdt , node , \"fsl,lx2160a-dspi\" ) ; if ( ! ( _fdt_get_status ( fdt , node ) & DT_STATUS_OK_SEC ) ) { continue ; } bus_num = fdt_getprop ( fdt , node , \"bus-num\" , NULL ) ; if ( bus_num && dspi_data -> slave_bus == ( unsigned int ) fdt32_to_cpu ( * bus_num ) ) { if ( dt_map_dev ( fdt , node , & ctrl_base , & size , DT_MAP_AUTO ) < 0 ) { EMSG ( \"Unable to get virtual address\" ) ; return TEE_ERROR_GENERIC ; } break ; } } dspi_data -> base = ctrl_base ; dspi_data -> bus_clk_hz = DSPI_CLK ; chip_select_num = fdt_getprop ( fdt , node , \"spi-num-chipselects\" , NULL ) ; if ( chip_select_num ) { dspi_data -> num_chipselect = ( int ) fdt32_to_cpu ( * chip_select_num ) ; } else { return TEE_ERROR_ITEM_NOT_FOUND ; } dspi_data -> speed_hz = DSPI_DEFAULT_SCK_FREQ ; return TEE_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long cpuidle_disable = IDLE_NO_OVERRIDE ; EXPORT_SYMBOL ( cpuidle_disable ) ; static int __init powersave_off ( char * arg ) { cpuidle_disable = IDLE_POWERSAVE_OFF ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sethostid ( long hostid ) { const int mib [ 2 ] { CTL_KERN KERN_HOSTID } ; ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hp_mic_jack_mode_info ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_info * uinfo ) { struct hda_codec * codec = snd_kcontrol_chip ( kcontrol ) ; hda_nid_t nid = kcontrol -> private_value ; int out_jacks = get_out_jack_num_items ( codec , nid ) ; int in_jacks = get_in_jack_num_items ( codec , nid ) ; const char * text = NULL ; int idx ; uinfo -> type = SNDRV_CTL_ELEM_TYPE_ENUMERATED ; uinfo -> count = 1 ; uinfo -> value . enumerated . items = out_jacks + in_jacks ; if ( uinfo -> value . enumerated . item >= uinfo -> value . enumerated . items ) { uinfo -> value . enumerated . item = uinfo -> value . enumerated . items - 1 ; } idx = uinfo -> value . enumerated . item ; if ( idx < out_jacks ) { if ( out_jacks > 1 ) { text = out_jack_texts [ idx ] ; } else { text = \"Headphone Out\" ; } } else { idx -= out_jacks ; if ( in_jacks > 1 ) { int vref_caps = get_vref_caps ( codec , nid ) ; text = vref_texts [ get_vref_idx ( vref_caps , idx ) ] ; } else { text = \"Mic In\" ; } } strcpy ( uinfo -> value . enumerated . name , text ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ishtp_bus_remove_all_clients ( struct ishtp_device * ishtp_dev , bool warm_reset ) { struct ishtp_cl_device * cl_device , * n ; struct ishtp_cl * cl ; unsigned long flags ; spin_lock_irqsave ( & ishtp_dev -> cl_list_lock , flags ) ; list_for_each_entry ( , , ) { cl -> state = ISHTP_CL_DISCONNECTED ; wake_up_interruptible ( & cl -> wait_ctrl_res ) ; ishtp_cl_flush_queues ( cl ) ; ishtp_cl_free_rx_ring ( cl ) ; ishtp_cl_free_tx_ring ( cl ) ; } spin_unlock_irqrestore ( & ishtp_dev -> cl_list_lock , flags ) ; ishtp_cl_free_dma_buf ( ishtp_dev ) ; spin_lock_irqsave ( & ishtp_dev -> device_list_lock , flags ) ; list_for_each_entry_safe ( , , , ) { cl_device -> fw_client = NULL ; if ( warm_reset && cl_device -> reference_count ) { continue ; } list_del ( & cl_device -> device_link ) ; spin_unlock_irqrestore ( & ishtp_dev -> device_list_lock , flags ) ; ishtp_bus_remove_device ( cl_device ) ; spin_lock_irqsave ( & ishtp_dev -> device_list_lock , flags ) ; } spin_unlock_irqrestore ( & ishtp_dev -> device_list_lock , flags ) ; spin_lock_irqsave ( & ishtp_dev -> fw_clients_lock , flags ) ; ishtp_dev -> fw_clients = NULL ; ishtp_dev -> fw_clients_num = 0 ; ishtp_dev -> fw_client_presentation_num = 0 ; ishtp_dev -> fw_client_index = 0 ; bitmap_zero ( ishtp_dev -> fw_clients_map , ISHTP_CLIENTS_MAX ) ; spin_unlock_irqrestore ( & ishtp_dev -> fw_clients_lock , flags ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void irp_close ( struct irs_acc * this ) { struct irp_p * irp = ( irp_p * ) this -> private ; if ( irp != NULL ) { memput ( irp , sizeof irp ) ; } memput ( this , sizeof this ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MOD_INIT ( ) { CommandAdd ( modinfo -> handle , MSG_SENDUMODE , cmd_sendumode , MAXPARA , CMD_SERVER ) ; CommandAdd ( modinfo -> handle , MSG_SMO , cmd_sendumode , MAXPARA , CMD_SERVER ) ; MARK_AS_OFFICIAL_MODULE ( modinfo , NULL ) ; return MOD_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void entry_to_msi_msg ( struct hv_interrupt_entry * entry , struct msi_msg * msg ) { msg -> address_lo = entry -> msi_entry . address . as_uint32 ; msg -> data = entry -> msi_entry . data . as_uint32 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int eventmgr_early_init ( struct pp_instance * handle ) { struct pp_eventmgr * eventmgr ; if ( handle == NULL ) { return - EINVAL ; } eventmgr = kmalloc ( sizeof ( pp_eventmgr ) , GFP_KERNEL ) ; if ( eventmgr == NULL ) { return - ENOMEM ; } eventmgr -> hwmgr = handle -> hwmgr ; handle -> eventmgr = eventmgr ; eventmgr -> platform_descriptor = & ( eventmgr -> hwmgr -> platform_descriptor ) ; eventmgr -> pp_eventmgr_init = pem_init ; eventmgr -> pp_eventmgr_fini = pem_fini ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static scfga_ret_t quiesce_confirm ( apid_t * apidp , msgid_t cmd_msg , prompt_t * prp , int * okp , int * quiesce , int * l_errnop ) { char * buf = NULL , * hbap = NULL , * cq1 = NULL , * cq2 = NULL ; char * cp ; size_t len = 0 ; int i = 0 , append_newline ; scfga_ret_t ret ; assert ( apidp -> path != NULL ) ; assert ( apidp -> hba_phys != NULL ) ; * quiesce = quiesce_required ( apidp , l_errnop ) ; if ( * quiesce == - 1 ) { return ( SCFGA_ERR ) ; } if ( * quiesce == 0 ) { return ( SCFGA_OK ) ; } ret = make_hba_logid ( apidp -> hba_phys , & hbap , & i ) ; if ( ret != SCFGA_OK ) { if ( ( hbap = get_node_path ( apidp -> hba_phys ) ) == NULL ) { * l_errnop = errno ; return ( SCFGA_LIB_ERR ) ; } } assert ( hbap != NULL ) ; append_newline = 0 ; cq1 = cfga_str ( append_newline , CONF_QUIESCE_1 , hbap , 0 ) ; cq2 = cfga_str ( append_newline , CONF_QUIESCE_2 , 0 ) ; len = strlen ( cq1 ) + strlen ( cq2 ) + 1 ; if ( ( buf = calloc ( 1 , len ) ) == NULL ) { * l_errnop = errno ; ret = SCFGA_LIB_ERR ; S_FREE ( cq1 , NULL ) ; S_FREE ( cq2 ) ; out } ( void ) strcpy ( buf , cq1 ) ; ( void ) strcat ( buf , cq2 ) ; S_FREE ( cq1 ) ; S_FREE ( cq2 ) ; if ( ( cp = strrchr ( apidp -> path , ':' ) ) != NULL ) { * cp = '\\0' ; } cfga_msg ( prp -> msgp , cmd_msg , apidp -> path , 0 ) ; if ( cp != NULL ) { * cp = ':' ; } assert ( prp -> confp != NULL && prp -> confp -> confirm != NULL ) ; * okp = prp -> confp -> confirm ( prp -> confp -> appdata_ptr , buf ) ; ret = SCFGA_OK ; out S_FREE ( buf ) ; S_FREE ( hbap ) ; return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool SiSInitPtr ( struct SiS_Private * SiS_Pr ) { if ( SiS_Pr -> ChipType < SIS_315H ) { InitTo300Pointer ( SiS_Pr , NULL ) ; return false ; } else { InitTo310Pointer ( SiS_Pr ) ; return false ; } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void r592_detect_timer ( struct timer_list * t ) { struct r592_device * dev = from_timer ( dev , t , detect_timer ) ; r592_update_card_detect ( dev ) ; memstick_detect_change ( dev -> host , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gfs2_sb_in ( struct gfs2_sbd * sdp , const void * buf ) { struct gfs2_sb_host * sb = & sdp -> sd_sb ; struct super_block * s = sdp -> sd_vfs ; const struct gfs2_sb * str = buf ; sb -> sb_magic = be32_to_cpu ( str -> sb_header . mh_magic ) ; sb -> sb_type = be32_to_cpu ( str -> sb_header . mh_type ) ; sb -> sb_fs_format = be32_to_cpu ( str -> sb_fs_format , NULL ) ; sb -> sb_multihost_format = be32_to_cpu ( str -> sb_multihost_format ) ; sb -> sb_bsize = be32_to_cpu ( str -> sb_bsize ) ; sb -> sb_bsize_shift = be32_to_cpu ( str -> sb_bsize_shift ) ; sb -> sb_master_dir . no_addr = be64_to_cpu ( str -> sb_master_dir . no_addr ) ; sb -> sb_master_dir . no_formal_ino = be64_to_cpu ( str -> sb_master_dir . no_formal_ino ) ; sb -> sb_root_dir . no_addr = be64_to_cpu ( str -> sb_root_dir . no_addr ) ; sb -> sb_root_dir . no_formal_ino = be64_to_cpu ( str -> sb_root_dir . no_formal_ino ) ; memcpy ( sb -> sb_lockproto , str -> sb_lockproto , GFS2_LOCKNAME_LEN ) ; memcpy ( sb -> sb_locktable , str -> sb_locktable , GFS2_LOCKNAME_LEN ) ; memcpy ( & s -> s_uuid , str -> sb_uuid , 16 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pkey_ec_ctrl ( EVP_PKEY_CTX * ctx , int type , int p1 , void * p2 ) { EC_PKEY_CTX * dctx = ctx -> data ; EC_GROUP * group ; switch ( type ) { case EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID : group = EC_GROUP_new_by_curve_name ( p1 ) ; if ( group == NULL ) { ECerror ( EC_R_INVALID_CURVE ) ; return 0 ; } EC_GROUP_free ( dctx -> gen_group ) ; dctx -> gen_group = group ; return 1 ; case EVP_PKEY_CTRL_EC_PARAM_ENC : if ( ! dctx -> gen_group ) { ECerror ( EC_R_NO_PARAMETERS_SET ) ; return 0 ; } EC_GROUP_set_asn1_flag ( dctx -> gen_group , p1 ) ; return 1 ; case EVP_PKEY_CTRL_EC_ECDH_COFACTOR : if ( p1 == - 2 ) { if ( dctx -> cofactor_mode != - 1 ) { return dctx -> cofactor_mode ; } else { EC_KEY * ec_key = ctx -> pkey -> pkey . ec ; return EC_KEY_get_flags ( ec_key ) & EC_FLAG_COFACTOR_ECDH ?1 : 0 ; } } if ( p1 ( - 1 || p1 ) 1 ) { return - 2 ; } dctx -> cofactor_mode = p1 ; if ( p1 != - 1 ) { EC_KEY * ec_key = ctx -> pkey -> pkey . ec ; if ( ! ec_key -> group ) { return - 2 ; } if ( BN_is_one ( & ec_key -> group -> cofactor ) ) { return 1 ; } if ( ! dctx -> co_key ) { dctx -> co_key = EC_KEY_dup ( ec_key ) ; if ( ! dctx -> co_key ) { return 0 ; } } if ( p1 ) { EC_KEY_set_flags ( dctx -> co_key , EC_FLAG_COFACTOR_ECDH ) ; } else { EC_KEY_clear_flags ( dctx -> co_key , EC_FLAG_COFACTOR_ECDH ) ; } } else { EC_KEY_free ( dctx -> co_key ) ; dctx -> co_key = NULL ; } return 1 ; case EVP_PKEY_CTRL_EC_KDF_TYPE : if ( p1 == - 2 ) { return dctx -> kdf_type ; } if ( p1 != EVP_PKEY_ECDH_KDF_NONE && p1 != EVP_PKEY_ECDH_KDF_X9_63 ) { return - 2 ; } dctx -> kdf_type = p1 ; return 1 ; case EVP_PKEY_CTRL_EC_KDF_MD : dctx -> kdf_md = p2 ; return 1 ; case EVP_PKEY_CTRL_GET_EC_KDF_MD : * ( const EVP_MD * * ) p2 = dctx -> kdf_md ; return 1 ; case EVP_PKEY_CTRL_EC_KDF_OUTLEN : if ( p1 <= 0 ) { return - 2 ; } dctx -> kdf_outlen = ( size_t ) p1 ; return 1 ; case EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN : * ( int * ) p2 = dctx -> kdf_outlen ; return 1 ; case EVP_PKEY_CTRL_EC_KDF_UKM : dctx -> kdf_ukm = p2 ; if ( p2 ) { dctx -> kdf_ukmlen = p1 ; } else { dctx -> kdf_ukmlen = 0 ; } return 1 ; case EVP_PKEY_CTRL_GET_EC_KDF_UKM : * ( unsigned char * * ) p2 = dctx -> kdf_ukm ; return dctx -> kdf_ukmlen ; case EVP_PKEY_CTRL_MD : if ( EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_sha1 && EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_ecdsa_with_SHA1 && EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_sha224 && EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_sha256 && EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_sha384 && EVP_MD_type ( ( const EVP_MD * ) p2 ) != NID_sha512 ) { ECerror ( EC_R_INVALID_DIGEST_TYPE ) ; return 0 ; } dctx -> md = p2 ; return 1 ; case EVP_PKEY_CTRL_GET_MD : * ( const EVP_MD * * ) p2 = dctx -> md ; return 1 ; case EVP_PKEY_CTRL_PEER_KEY : case EVP_PKEY_CTRL_DIGESTINIT : case EVP_PKEY_CTRL_PKCS7_SIGN : case EVP_PKEY_CTRL_CMS_SIGN : return 1 ; default : return - 2 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct multi_pack_index * lookup_multi_pack_index ( struct repository * r , const char * object_dir ) { struct multi_pack_index * result = NULL ; struct multi_pack_index * cur ; char * obj_dir_real = real_pathdup ( object_dir , 1 ) ; struct strbuf cur_path_real = STRBUF_INIT ; find_odb ( r , obj_dir_real ) ; for ( cur = get_multi_pack_index ( r ) ; cur ; cur = cur -> next ) { strbuf_realpath ( & cur_path_real , cur -> object_dir , 1 ) ; if ( ! strcmp ( obj_dir_real , cur_path_real . buf ) ) { result = cur ; cleanup } } cleanup strbuf_release ( & cur_path_real ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int core507d_read_caps ( struct nv50_disp * disp ) { struct nvif_push * push = disp -> core -> chan . push ; int ret ; ret = PUSH_WAIT ( push , 6 ) ; PUSH_MTHD ( push , NV507D , SET_NOTIFIER_CONTROL , NVDEF ( NV507D , SET_NOTIFIER_CONTROL , MODE , WRITE ) | NVVAL ( NV507D , SET_NOTIFIER_CONTROL , OFFSET , NV50_DISP_CORE_NTFY >> 2 ) | NVDEF ( NV507D , SET_NOTIFIER_CONTROL , NOTIFY , ENABLE ) ) ; PUSH_MTHD ( push , NV507D , GET_CAPABILITIES , 0x00000000 ) ; PUSH_MTHD ( push , NV507D , SET_NOTIFIER_CONTROL , NVDEF ( NV507D , SET_NOTIFIER_CONTROL , NOTIFY , DISABLE ) ) ; return PUSH_KICK ( push ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bcm_enet_open ( struct net_device * dev ) { struct bcm_enet_priv * priv ; struct sockaddr addr ; struct device * kdev ; struct phy_device * phydev ; int i , ret ; int size ; char phy_id [ MII_BUS_ID_SIZE + 3 ] ; void * p ; u32 val ; priv = netdev_priv ( dev ) ; kdev = & priv -> pdev -> dev ; if ( priv -> has_phy ) { snprintf ( phy_id , sizeof ( phy_id ) , PHY_ID_FMT , priv -> mii_bus -> id , priv -> phy_id ) ; phydev = phy_connect ( dev , phy_id , bcm_enet_adjust_phy_link , PHY_INTERFACE_MODE_MII ) ; if ( IS_ERR ( phydev ) ) { dev_err ( kdev , \"could not attach to PHY\\n\" ) ; return PTR_ERR ( phydev ) ; } phy_support_sym_pause ( phydev ) ; phy_set_max_speed ( phydev , SPEED_100 ) ; phy_set_sym_pause ( phydev , priv -> pause_rx , priv -> pause_rx , priv -> pause_auto ) ; phy_attached_info ( phydev ) ; priv -> old_link = 0 ; priv -> old_duplex = - 1 ; priv -> old_pause = - 1 ; } else { phydev = NULL ; } enet_writel ( priv , 0 , ENET_IRMASK_REG ) ; enet_dmac_writel ( priv , 0 , ENETDMAC_IRMASK , priv -> rx_chan ) ; enet_dmac_writel ( priv , 0 , ENETDMAC_IRMASK , priv -> tx_chan ) ; ret = request_irq ( dev -> irq , bcm_enet_isr_mac , 0 , dev -> name , dev ) ; if ( ret ) { out_phy_disconnect } ret = request_irq ( priv -> irq_rx , bcm_enet_isr_dma , 0 , dev -> name , dev ) ; if ( ret ) { out_freeirq } ret = request_irq ( priv -> irq_tx , bcm_enet_isr_dma , 0 , dev -> name , dev ) ; if ( ret ) { out_freeirq_rx } for ( i = 0 ; i < 4 ; i ++ ) { enet_writel ( priv , 0 , ENET_PML_REG ( i ) ) ; enet_writel ( priv , 0 , ENET_PMH_REG ( i ) ) ; } memcpy ( addr . sa_data , dev -> dev_addr , ETH_ALEN ) ; bcm_enet_set_mac_address ( dev , & addr ) ; size = priv -> rx_ring_size * sizeof ( bcm_enet_desc ) ; p = dma_alloc_coherent ( kdev , size , & priv -> rx_desc_dma , GFP_KERNEL ) ; if ( ! p ) { ret = - ENOMEM ; out_freeirq_tx } priv -> rx_desc_alloc_size = size ; priv -> rx_desc_cpu = p ; size = priv -> tx_ring_size * sizeof ( bcm_enet_desc ) ; p = dma_alloc_coherent ( kdev , size , & priv -> tx_desc_dma , GFP_KERNEL ) ; if ( ! p ) { ret = - ENOMEM ; out_free_rx_ring } priv -> tx_desc_alloc_size = size ; priv -> tx_desc_cpu = p ; priv -> tx_skb = kcalloc ( priv -> tx_ring_size , sizeof ( sk_buff * ) , GFP_KERNEL ) ; if ( ! priv -> tx_skb ) { ret = - ENOMEM ; out_free_tx_ring } priv -> tx_desc_count = priv -> tx_ring_size ; priv -> tx_dirty_desc = 0 ; priv -> tx_curr_desc = 0 ; spin_lock_init ( & priv -> tx_lock ) ; priv -> rx_buf = kcalloc ( priv -> rx_ring_size , sizeof ( void * ) , GFP_KERNEL ) ; if ( ! priv -> rx_buf ) { ret = - ENOMEM ; out_free_tx_skb } priv -> rx_desc_count = 0 ; priv -> rx_dirty_desc = 0 ; priv -> rx_curr_desc = 0 ; if ( priv -> dma_has_sram ) { enet_dma_writel ( priv , ENETDMA_BUFALLOC_FORCE_MASK | 0 , ENETDMA_BUFALLOC_REG ( priv -> rx_chan ) ) ; } else { enet_dmac_writel ( priv , ENETDMA_BUFALLOC_FORCE_MASK | 0 , ENETDMAC_BUFALLOC , priv -> rx_chan ) ; } if ( bcm_enet_refill_rx ( dev , false ) ) { dev_err ( kdev , \"cannot allocate rx buffer queue\\n\" ) ; ret = - ENOMEM ; out } if ( priv -> dma_has_sram ) { enet_dmas_writel ( priv , priv -> rx_desc_dma , ENETDMAS_RSTART_REG , priv -> rx_chan ) ; enet_dmas_writel ( priv , priv -> tx_desc_dma , ENETDMAS_RSTART_REG , priv -> tx_chan ) ; } else { enet_dmac_writel ( priv , priv -> rx_desc_dma , ENETDMAC_RSTART , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> tx_desc_dma , ENETDMAC_RSTART , priv -> tx_chan ) ; } if ( priv -> dma_has_sram ) { enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM2_REG , priv -> rx_chan ) ; enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM2_REG , priv -> tx_chan ) ; enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM3_REG , priv -> rx_chan ) ; enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM3_REG , priv -> tx_chan ) ; enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM4_REG , priv -> rx_chan ) ; enet_dmas_writel ( priv , 0 , ENETDMAS_SRAM4_REG , priv -> tx_chan ) ; } else { enet_dmac_writel ( priv , 0 , ENETDMAC_FC , priv -> rx_chan ) ; enet_dmac_writel ( priv , 0 , ENETDMAC_FC , priv -> tx_chan ) ; } enet_writel ( priv , priv -> hw_mtu , ENET_RXMAXLEN_REG ) ; enet_writel ( priv , priv -> hw_mtu , ENET_TXMAXLEN_REG ) ; enet_dmac_writel ( priv , priv -> dma_maxburst , ENETDMAC_MAXBURST , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> dma_maxburst , ENETDMAC_MAXBURST , priv -> tx_chan ) ; enet_writel ( priv , BCMENET_TX_FIFO_TRESH , ENET_TXWMARK_REG ) ; if ( priv -> dma_has_sram ) { val = priv -> rx_ring_size / 3 ; enet_dma_writel ( priv , val , ENETDMA_FLOWCL_REG ( priv -> rx_chan ) ) ; val = ( priv -> rx_ring_size * 2 ) / 3 ; enet_dma_writel ( priv , val , ENETDMA_FLOWCH_REG ( priv -> rx_chan ) ) ; } else { enet_dmac_writel ( priv , 5 , ENETDMAC_FC , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> rx_ring_size , ENETDMAC_LEN , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> tx_ring_size , ENETDMAC_LEN , priv -> tx_chan ) ; } wmb ( ) ; val = enet_readl ( priv , ENET_CTL_REG ) ; val |= ENET_CTL_ENABLE_MASK ; enet_writel ( priv , val , ENET_CTL_REG ) ; if ( priv -> dma_has_sram ) { enet_dma_writel ( priv , ENETDMA_CFG_EN_MASK , ENETDMA_CFG_REG ) ; } enet_dmac_writel ( priv , priv -> dma_chan_en_mask , ENETDMAC_CHANCFG , priv -> rx_chan ) ; enet_writel ( priv , ENET_IR_MIB , ENET_IR_REG ) ; enet_writel ( priv , ENET_IR_MIB , ENET_IRMASK_REG ) ; enet_dmac_writel ( priv , priv -> dma_chan_int_mask , ENETDMAC_IR , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> dma_chan_int_mask , ENETDMAC_IR , priv -> tx_chan ) ; napi_enable ( & priv -> napi ) ; enet_dmac_writel ( priv , priv -> dma_chan_int_mask , ENETDMAC_IRMASK , priv -> rx_chan ) ; enet_dmac_writel ( priv , priv -> dma_chan_int_mask , ENETDMAC_IRMASK , priv -> tx_chan ) ; if ( phydev ) { phy_start ( phydev ) ; } else { bcm_enet_adjust_link ( dev ) ; } netif_start_queue ( dev ) ; return 0 ; out bcm_enet_free_rx_buf_ring ( kdev , priv ) ; out_free_tx_skb kfree ( priv -> tx_skb ) ; out_free_tx_ring dma_free_coherent ( kdev , priv -> tx_desc_alloc_size , priv -> tx_desc_cpu , priv -> tx_desc_dma ) ; out_free_rx_ring dma_free_coherent ( kdev , priv -> rx_desc_alloc_size , priv -> rx_desc_cpu , priv -> rx_desc_dma ) ; out_freeirq_tx free_irq ( priv -> irq_tx , dev ) ; out_freeirq_rx free_irq ( priv -> irq_rx , dev ) ; out_freeirq free_irq ( dev -> irq , dev ) ; out_phy_disconnect if ( phydev ) { phy_disconnect ( phydev ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int tls_pre_init ( void ) { void * * mf ( size_t ) NULL ; void * * rf ( void * , size_t ) NULL ; void * ff ( void * ) NULL ; void * * mf ( size_t , const char * , int ) NULL ; void * * rf ( void * , size_t , const char * , int ) NULL ; void * ff ( void * , const char * , int ) NULL ; LM_INFO ( \"libssl linked mode: static\\n\" ) ; CRYPTO_get_mem_functions ( & mf , & rf , & ff ) ; LM_DBG ( \"initial memory functions - malloc: %p realloc: %p free: %p\\n\" , mf , rf , ff ) ; mf = NULL ; rf = NULL ; ff = NULL ; if ( ! CRYPTO_set_mem_ex_functions ( ser_malloc , ser_realloc , ser_free ) ) { if ( ! CRYPTO_set_mem_functions ( ser_malloc , ser_realloc , ser_free ) ) { LM_ERR ( \"Unable to set the memory allocation functions\\n\" ) ; CRYPTO_get_mem_functions ( & mf , & rf , & ff ) ; LM_ERR ( \"libssl current mem functions - m: %p r: %p f: %p\\n\" , mf , rf , ff ) ; LM_ERR ( \"module mem functions - m: %p r: %p f: %p\\n\" , ser_malloc , ser_realloc , ser_free ) ; LM_ERR ( \"Be sure tls module is loaded before any other module using\" \" libssl (can be loaded first to be safe)\\n\" ) ; return - 1 ; } LM_DBG ( \"updated memory functions - malloc: %p realloc: %p free: %p\\n\" , ser_malloc , ser_realloc , ser_free ) ; init_tls_compression ( ) ; return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ilbc_parse_sdp_line ( AVFormatContext * s , int st_index , PayloadContext * data , const char * line ) { const char * p ; AVStream * st ; if ( st_index < 0 ) { return 0 ; } st = s -> streams [ st_index ] ; if ( av_strstart ( line , \"fmtp:\" , & p ) ) { int ret = ff_parse_fmtp ( s , st , data , p , ilbc_parse_fmtp ) ; if ( ! st -> codecpar -> block_align ) { av_log ( s , AV_LOG_ERROR , \"No iLBC mode set\\n\" ) ; return AVERROR ( EINVAL ) ; } } return 0 ; } const RTPDynamicProtocolHandler ff_ilbc_dynamic_handler = { . enc_name = \"iLBC\" . codec_type = AVMEDIA_TYPE_AUDIO . codec_id = AV_CODEC_ID_ILBC . parse_sdp_a_line = ilbc_parse_sdp_line } ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void command ( const struct pinfo * pi , VARENT * ve ) { const struct kinfo_proc * kp = pi -> ki ; VAR * v ; int left , wantspace = 0 ; char * * p ; v = ve -> var ; if ( ve -> next != NULL || termwidth != UNLIMITED ) { if ( ve -> next == NULL ) { left = termwidth - ( totwidth - v -> width ) ; if ( left < 1 ) { left = v -> width ; } } else { left = v -> width ; } } else { left = INT_MAX ; } if ( needenv && kd != NULL ) { char * * envp = kvm_getenvv ( kd , kp , termwidth ) ; if ( ( p = envp ) != NULL ) { while ( * p ) { if ( wantspace ) { putchar ( ' ' ) ; left -- ; } left -= mbswprint ( * p , left , 0 ) ; p ++ ; wantspace = 1 ; } } } if ( needcomm ) { if ( pi -> prefix ) { left -= mbswprint ( pi -> prefix , left , 0 ) ; } if ( ! commandonly ) { char * * argv = NULL ; if ( kd != NULL ) { argv = kvm_getargv ( kd , kp , termwidth ) ; if ( ( p = argv ) != NULL ) { while ( * p ) { if ( wantspace ) { putchar ( ' ' ) ; left -- ; } left -= mbswprint ( * p , left , 0 ) ; if ( left == 0 ) { return ; } p ++ ; wantspace = 1 ; } } } if ( argv == NULL || argv [ 0 ] == NULL || kp -> p_name [ 0 ] != '\\0' || strcmp ( cmdpart ( argv [ 0 ] ) , kp -> p_comm ) ) { if ( wantspace ) { putchar ( ' ' ) ; if ( -- left == 0 ) { return ; } } putchar ( '(' ) ; left -- ; left -= print_comm_name ( kp , left , 0 ) ; if ( left == 0 ) { return ; } putchar ( ')' ) ; left -- ; } } else { if ( wantspace ) { putchar ( ' ' ) ; left -- ; } left -= print_comm_name ( kp , left , 0 ) ; } } if ( ve -> next != NULL ) { while ( left -- > 0 ) { putchar ( ' ' ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void CopyOneRowTo ( CopyToState cstate , TupleTableSlot * slot ) { bool need_delim = false ; FmgrInfo * out_functions = cstate -> out_functions ; MemoryContext oldcontext ; ListCell * cur ; char * string ; MemoryContextReset ( cstate -> rowcontext ) ; oldcontext = MemoryContextSwitchTo ( cstate -> rowcontext ) ; if ( cstate -> opts . binary ) { CopySendInt16 ( cstate , list_length ( cstate -> attnumlist ) ) ; } slot_getallattrs ( slot , NULL ) ; ( cur cstate -> attnumlist ; ) { int attnum = lfirst_int ( cur ) ; Datum value = slot -> tts_values [ attnum - 1 ] ; bool isnull = slot -> tts_isnull [ attnum - 1 ] ; if ( ! cstate -> opts . binary ) { if ( need_delim ) { CopySendChar ( cstate , cstate -> opts . delim [ 0 ] ) ; } need_delim = true ; } if ( isnull ) { if ( ! cstate -> opts . binary ) { CopySendString ( cstate , cstate -> opts . null_print_client ) ; } else { CopySendInt32 ( cstate , - 1 ) ; } } else { if ( ! cstate -> opts . binary ) { string = OutputFunctionCall ( & out_functions [ attnum - 1 ] , value ) ; if ( cstate -> opts . csv_mode ) { CopyAttributeOutCSV ( cstate , string , cstate -> opts . force_quote_flags [ attnum - 1 ] , list_length ( cstate -> attnumlist ) == 1 ) ; } else { CopyAttributeOutText ( cstate , string ) ; } } else { bytea * outputbytes ; outputbytes = SendFunctionCall ( & out_functions [ attnum - 1 ] , value ) ; CopySendInt32 ( cstate , VARSIZE ( outputbytes ) - VARHDRSZ ) ; CopySendData ( cstate , VARDATA ( outputbytes ) , VARSIZE ( outputbytes ) - VARHDRSZ ) ; } } } CopySendEndOfRow ( cstate ) ; MemoryContextSwitchTo ( oldcontext ) ; } { if ( ptr > start ) { CopySendData ( cstate , start , ptr - start ) ; } } 0 ; , { const char * ptr ; const char * start ; char c ; char delimc = cstate -> opts . delim [ 0 ] ; if ( cstate -> need_transcoding ) { ptr = pg_server_to_any ( string , strlen ( string ) , cstate -> file_encoding ) ; } else { ptr = string ; } if ( cstate -> encoding_embeds_ascii ) { start = ptr ; while ( ( c = * ptr ) != '\\0' ) { if ( ( unsigned char ) c < ( unsigned char ) 0x20 ) { switch ( c ) { case '\\b' : c = 'b' ; break ; case '\\f' : c = 'f' ; break ; case '\\n' : c = 'n' ; break ; case '\\r' : c = 'r' ; break ; case '\\t' : c = 't' ; break ; case '\\v' : c = 'v' ; break ; default : if ( c == delimc ) { break ; } ptr ++ ; continue ; } DUMPSOFAR ( ) ; CopySendChar ( cstate , '\\\\' ) ; CopySendChar ( cstate , c ) ; start = ++ ptr ; } if ( c == '\\\\' || c == delimc ) { DUMPSOFAR ( ) ; CopySendChar ( cstate , '\\\\' ) ; start = ptr ++ ; } if ( IS_HIGHBIT_SET ( c ) ) { ptr += pg_encoding_mblen ( cstate -> file_encoding , ptr ) ; } else { ptr ++ ; } } } else { start = ptr ; while ( ( c = * ptr ) != '\\0' ) { if ( ( unsigned char ) c < ( unsigned char ) 0x20 ) { switch ( c ) { case '\\b' : c = 'b' ; break ; case '\\f' : c = 'f' ; break ; case '\\n' : c = 'n' ; break ; case '\\r' : c = 'r' ; break ; case '\\t' : c = 't' ; break ; case '\\v' : c = 'v' ; break ; default : if ( c == delimc ) { break ; } ptr ++ ; continue ; } DUMPSOFAR ( ) ; CopySendChar ( cstate , '\\\\' ) ; CopySendChar ( cstate , c ) ; start = ++ ptr ; } if ( c == '\\\\' || c == delimc ) { DUMPSOFAR ( ) ; CopySendChar ( cstate , '\\\\' ) ; start = ptr ++ ; } else { ptr ++ ; } } } DUMPSOFAR ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sip_delete_value ( sip_header_t sip_header , sip_header_value_t sip_header_value ) { _sip_header_t * _sip_header ; sip_value_t * _sip_header_value ; int vlen ; char * c ; _sip_header = ( _sip_header_t * ) sip_header ; ( void ) pthread_mutex_lock ( & _sip_header -> sip_hdr_sipmsg -> sip_msg_mutex ) ; if ( _sip_header -> sip_hdr_sipmsg -> sip_msg_cannot_be_modified ) { ( void ) pthread_mutex_unlock ( & _sip_header -> sip_hdr_sipmsg -> sip_msg_mutex ) ; return ( EPERM ) ; } if ( _sip_header -> sip_header_state == SIP_HEADER_DELETED ) { ( void ) pthread_mutex_unlock ( & _sip_header -> sip_hdr_sipmsg -> sip_msg_mutex ) ; return ( EINVAL ) ; } _sip_header_value = ( sip_value_t * ) sip_header_value ; if ( _sip_header_value -> value_state == SIP_VALUE_DELETED ) { ( void ) pthread_mutex_unlock ( & _sip_header -> sip_hdr_sipmsg -> sip_msg_mutex ) ; return ( EINVAL ) ; } _sip_header -> sip_header_state = SIP_HEADER_DELETED_VAL ; _sip_header_value -> value_state = SIP_VALUE_DELETED ; vlen = _sip_header_value -> value_end - _sip_header_value -> value_start ; if ( _sip_header -> sip_hdr_parsed -> value == _sip_header_value ) { c = _sip_header_value -> value_start ; while ( * c -- != SIP_HCOLON ) { vlen ++ ; } } else { c = _sip_header_value -> value_start ; while ( * c -- != SIP_COMMA ) { vlen ++ ; } } if ( _sip_header_value -> next == NULL ) { sip_value_t * value = _sip_header -> sip_hdr_parsed -> value ; boolean_t crlf_present = B_FALSE ; char * s ; while ( value != NULL && value != _sip_header_value ) { crlf_present = B_FALSE ; if ( value -> value_state == SIP_VALUE_DELETED ) { value = value -> next ; continue ; } s = value -> value_end ; while ( s != value -> value_start ) { if ( * s == '\\r' && strncmp ( s , SIP_CRLF , strlen ( SIP_CRLF ) ) == 0 ) { crlf_present = B_TRUE ; break ; } s -- ; } value = value -> next ; } if ( ! crlf_present ) { c = _sip_header_value -> value_end ; while ( * c -- != '\\r' ) { vlen -- ; } assert ( vlen > 0 ) ; } } _sip_header -> sip_hdr_sipmsg -> sip_msg_len -= vlen ; if ( _sip_header -> sip_hdr_sipmsg -> sip_msg_buf != NULL ) { _sip_header -> sip_hdr_sipmsg -> sip_msg_modified = B_TRUE ; } ( void ) pthread_mutex_unlock ( & _sip_header -> sip_hdr_sipmsg -> sip_msg_mutex ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ahci_port_start ( struct ahci_uc_priv * uc_priv , u8 port ) { struct ahci_ioports * pp = & uc_priv -> port [ port ] ; struct sata_port_regs * port_mmio = pp -> port_mmio ; u32 port_status ; u32 mem ; int timeout = 10000000 ; debug ( \"Enter start port: %d\\n\" , port ) ; port_status = readl ( & port_mmio -> ssts ) ; debug ( \"Port %d status: %x\\n\" , port , port_status ) ; if ( ( port_status & 0xf ) != 0x03 ) { printf ( \"No Link on this port!\\n\" ) ; return - 1 ; } mem = ( u32 ) malloc ( AHCI_PORT_PRIV_DMA_SZ + 1024 ) ; if ( ! mem ) { printf ( \"No mem for table!\\n\" ) ; return - ENOMEM ; } mem = ( mem + 0x400 ) & ( ~ 0x3ff ) ; pp -> cmd_slot = ( ahci_cmd_hdr * ) mem ; debug ( \"cmd_slot = 0x%x\\n\" , ( unsigned int ) pp -> cmd_slot ) ; mem += ( AHCI_CMD_SLOT_SZ * DWC_AHSATA_MAX_CMD_SLOTS ) ; pp -> rx_fis = mem ; mem += AHCI_RX_FIS_SZ ; pp -> cmd_tbl = mem ; debug ( \"cmd_tbl_dma = 0x%lx\\n\" , pp -> cmd_tbl ) ; mem += AHCI_CMD_TBL_HDR ; writel_with_flush ( 0x00004444 , & port_mmio -> dmacr ) ; pp -> cmd_tbl_sg = ( ahci_sg * ) mem ; writel_with_flush ( ( u32 ) pp -> cmd_slot , & port_mmio -> clb ) ; writel_with_flush ( pp -> rx_fis , & port_mmio -> fb ) ; writel_with_flush ( ( SATA_PORT_CMD_FRE | readl ( & port_mmio -> cmd ) ) , & port_mmio -> cmd ) ; while ( ( readl ( & port_mmio -> tfd ) & ( SATA_PORT_TFD_STS_ERR | SATA_PORT_TFD_STS_DRQ | SATA_PORT_TFD_STS_BSY ) ) && -- timeout ) { } if ( timeout <= 0 ) { debug ( \"Device not ready for BSY, DRQ and\" \"ERR in TFD!\\n\" ) ; return - 1 ; } writel_with_flush ( PORT_CMD_ICC_ACTIVE | PORT_CMD_FIS_RX | PORT_CMD_POWER_ON | PORT_CMD_SPIN_UP | PORT_CMD_START , & port_mmio -> cmd ) ; debug ( \"Exit start port %d\\n\" , port ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _meta_flag_preparse ( token_t * tokens , const size_t start , struct _meta_flags * of , char * * errstr ) { unsigned int i ; size_t ret ; int tmp_int ; uint8_t seen [ 127 ] { 0 } ; ; for ( i = start ; tokens [ i ] . length != 0 ; i ++ ) { uint8_t o = ( uint8_t ) tokens [ i ] . value [ 0 ] ; if ( o >= 127 || seen [ o ] != 0 ) { * errstr = \"CLIENT_ERROR duplicate flag\" ; return - 1 ; } seen [ o ] = 1 ; switch ( o ) { case 'b' : ret = base64_decode ( ( unsigned char * ) tokens [ KEY_TOKEN ] . value , tokens [ KEY_TOKEN ] . length , ( unsigned char * ) tokens [ KEY_TOKEN ] . value , tokens [ KEY_TOKEN ] . length ) ; if ( ret == 0 ) { * errstr = \"CLIENT_ERROR error decoding key\" ; of -> has_error = 1 ; } tokens [ KEY_TOKEN ] . length = ret ; of -> key_binary = 1 ; break ; case 'N' : of -> locked = 1 ; of -> vivify = 1 ; if ( ! safe_strtol ( tokens [ i ] . value + 1 , & tmp_int ) ) { * errstr = \"CLIENT_ERROR bad token in command line format\" ; of -> has_error = 1 ; } else { of -> autoviv_exptime = realtime ( EXPTIME_TO_POSITIVE_TIME ( tmp_int ) ) ; } break ; case 'T' : of -> locked = 1 ; if ( ! safe_strtol ( tokens [ i ] . value + 1 , & tmp_int ) ) { * errstr = \"CLIENT_ERROR bad token in command line format\" ; of -> has_error = 1 ; } else { of -> exptime = realtime ( EXPTIME_TO_POSITIVE_TIME ( tmp_int ) ) ; of -> new_ttl = true ; } break ; case 'R' : of -> locked = 1 ; if ( ! safe_strtol ( tokens [ i ] . value + 1 , & tmp_int ) ) { * errstr = \"CLIENT_ERROR bad token in command line format\" ; of -> has_error = 1 ; } else { of -> recache_time = realtime ( EXPTIME_TO_POSITIVE_TIME ( tmp_int ) ) ; } break ; case 'l' : of -> la = 1 ; of -> locked = 1 ; break ; case 'O' : case 'P' : case 'L' : break ; case 'k' : case 's' : case 't' : case 'c' : case 'f' : break ; case 'v' : of -> value = 1 ; break ; case 'h' : of -> locked = 1 ; break ; case 'u' : of -> no_update = 1 ; break ; case 'q' : of -> no_reply = 1 ; break ; case 'F' : if ( ! safe_strtoul ( tokens [ i ] . value + 1 , & of -> client_flags ) ) { of -> has_error = true ; } break ; case 'C' : if ( ! safe_strtoull ( tokens [ i ] . value + 1 , & of -> req_cas_id ) ) { * errstr = \"CLIENT_ERROR bad token in command line format\" ; of -> has_error = true ; } else { of -> has_cas = true ; } break ; case 'M' : if ( tokens [ i ] . length != 2 ) { * errstr = \"CLIENT_ERROR incorrect length for M token\" ; of -> has_error = 1 ; } else { of -> mode = tokens [ i ] . value [ 1 ] ; } break ; case 'J' : if ( ! safe_strtoull ( tokens [ i ] . value + 1 , & of -> initial ) ) { * errstr = \"CLIENT_ERROR invalid numeric initial value\" ; of -> has_error = 1 ; } break ; case 'D' : if ( ! safe_strtoull ( tokens [ i ] . value + 1 , & of -> delta ) ) { * errstr = \"CLIENT_ERROR invalid numeric delta value\" ; of -> has_error = 1 ; } break ; case 'I' : of -> set_stale = 1 ; break ; default : * errstr = \"CLIENT_ERROR invalid flag\" ; return - 1 ; } } return of -> has_error ?- 1 : 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int next_line_is_if ( struct expression * expr ) { struct expression * next ; if ( ! __next_stmt || __next_stmt -> type != STMT_IF ) { return 0 ; } next = strip_expr ( __next_stmt -> if_conditional ) ; while ( next -> type == EXPR_PREOP && next -> op == '!' ) { next = strip_expr ( next -> unop ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void avpriv_mpegts_parse_close ( MpegTSContext * ts ) { mpegts_free ( ts ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void failed_real ( unsigned char * s1 , const char * s2 , unsigned char * s3 ) { failed_body ( s1 , s2 , s3 , 0 ) ; exitsh ( ERROR , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "AcpiUtReleaseMutex ( ) { ACPI_FUNCTION_NAME ( UtReleaseMutex ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_MUTEX , \"Thread %u releasing Mutex [%s]\\n\" , ( UINT32 ) AcpiOsGetThreadId ( ) , AcpiUtGetMutexName ( MutexId ) ) ) ; if ( AcpiGbl_MutexInfo [ MutexId ] . ThreadId == ACPI_MUTEX_NOT_ACQUIRED ) { ACPI_ERROR ( ( AE_INFO , \"Mutex [%s] (0x%X) is not acquired, cannot release\" , AcpiUtGetMutexName ( MutexId ) , MutexId ) ) ; return ( AE_NOT_ACQUIRED ) ; } { UINT32 i ; for ( i = MutexId ; i < ACPI_NUM_MUTEX ; i ++ ) { if ( AcpiGbl_MutexInfo [ i ] . ThreadId == AcpiOsGetThreadId ( ) ) { if ( i == MutexId ) { continue ; } ACPI_ERROR ( ( AE_INFO , \"Invalid release order: owns [%s], releasing [%s]\" , AcpiUtGetMutexName ( i ) , AcpiUtGetMutexName ( MutexId ) ) ) ; return ( AE_RELEASE_DEADLOCK ) ; } } } AcpiGbl_MutexInfo [ MutexId ] . ThreadId = ACPI_MUTEX_NOT_ACQUIRED ; AcpiOsReleaseMutex ( AcpiGbl_MutexInfo [ MutexId ] . Mutex ) ; return ( AE_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void slurm_pmi_finalize ( void ) { if ( pmi_fd >= 0 ) { close ( pmi_fd , NULL ) ; pmi_fd = - 1 ; } srun_port = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ath10k_wmi_tlv_put_host_mem_chunks ( struct ath10k * ar , void * host_mem_chunks ) { struct host_memory_chunk_tlv * chunk ; struct wmi_tlv * tlv ; int paddr ; int i ; __le16 tlv_len , tlv_tag ; tlv_tag = __cpu_to_le16 ( WMI_TLV_TAG_STRUCT_WLAN_HOST_MEMORY_CHUNK ) ; tlv_len = __cpu_to_le16 ( sizeof ( * chunk ) ) ; for ( i = 0 ; i < ar -> wmi . num_mem_chunks ; i ++ ) { tlv = host_mem_chunks ; tlv -> tag = tlv_tag ; tlv -> len = tlv_len ; chunk = ( void * ) tlv -> value ; chunk -> ptr = __cpu_to_le32 ( ar -> wmi . mem_chunks [ i ] . paddr ) ; chunk -> size = __cpu_to_le32 ( ar -> wmi . mem_chunks [ i ] . len ) ; chunk -> req_id = __cpu_to_le32 ( ar -> wmi . mem_chunks [ i ] . req_id ) ; if ( test_bit ( WMI_SERVICE_SUPPORT_EXTEND_ADDRESS , ar -> wmi . svc_map ) ) { paddr = ar -> wmi . mem_chunks [ i ] . paddr ; chunk -> ptr_high = __cpu_to_le32 ( upper_32_bits ( paddr ) ) ; } ath10k_dbg ( ar , ATH10K_DBG_WMI , \"wmi-tlv chunk %d len %d, addr 0x%llx, id 0x%x\\n\" , i , ar -> wmi . mem_chunks [ i ] . len , ( unsigned long long ) ar -> wmi . mem_chunks [ i ] . paddr , ar -> wmi . mem_chunks [ i ] . req_id ) ; host_mem_chunks += sizeof ( * tlv ) ; host_mem_chunks += sizeof ( * chunk ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "JsVar * jsjcStop ( ) { jsjcDebugPrintf ( \"; VARS: %j\\n\" , jit . vars ) ; jsvUnLock ( jit . vars ) ; jit . vars = 0 ; assert ( jit . stackDepth == 0 ) ; assert ( jit . blockCount == 0 ) ; FILE * f = fopen ( JIT_OUTPUT_FILE , \"wb\" ) ; JSV_GET_AS_CHAR_ARRAY ( icPtr , icLen , jit . initCode ) ; if ( icPtr ) { fwrite ( icPtr , 1 , icLen , f ) ; } JSV_GET_AS_CHAR_ARRAY ( cPtr , cLen , jit . code ) ; if ( cPtr ) { fwrite ( cPtr , 1 , cLen , f ) ; } fclose ( f ) ; size_t len = jsvGetStringLength ( jit . code ) + jsvGetStringLength ( jit . initCode ) ; JsVar * flat = jsvNewFlatStringOfLength ( ( unsigned int ) len ) ; if ( flat ) { JsvStringIterator src ; JsvStringIterator dst ; jsvStringIteratorNew ( & src , jit . initCode , 0 ) ; jsvStringIteratorNew ( & dst , flat , 0 ) ; while ( jsvStringIteratorHasChar ( & src ) ) { jsvStringIteratorSetCharAndNext ( & dst , jsvStringIteratorGetCharAndNext ( & src ) ) ; } jsvStringIteratorFree ( & src ) ; jsvStringIteratorNew ( & src , jit . code , 0 ) ; while ( jsvStringIteratorHasChar ( & src ) ) { jsvStringIteratorSetCharAndNext ( & dst , jsvStringIteratorGetCharAndNext ( & src ) ) ; } jsvStringIteratorFree ( & src ) ; jsvStringIteratorFree ( & dst ) ; } jsvStringIteratorFree ( & jit . codeIt ) ; jsvUnLock ( jit . code ) ; jit . code = 0 ; jsvUnLock ( jit . initCode , NULL ) ; jit . code = 0 ; return flat ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "usage ( ) { arg_printusage ( args , sizeof ( args ) / sizeof ( args [ 0 ] ) , \"\" ) ; exit ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sa1111_enable_device ( struct sa1111_dev * sadev ) { struct sa1111 * sachip = sa1111_chip_driver ( sadev ) ; unsigned long flags ; unsigned int val ; int ret ; if ( sachip -> pdata && sachip -> pdata -> enable ) { ret = sachip -> pdata -> enable ( sachip -> pdata -> data , sadev -> devid ) ; } if ( ret == 0 ) { spin_lock_irqsave ( & sachip -> lock , flags ) ; val = readl_relaxed ( sachip -> base + SA1111_SKPCR ) ; writel_relaxed ( val | sadev -> skpcr_mask , sachip -> base + SA1111_SKPCR ) ; spin_unlock_irqrestore ( & sachip -> lock , flags ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ssize_t nfs_file_read ( struct kiocb * iocb , struct iov_iter * to ) { struct inode * inode = file_inode ( iocb -> ki_filp ) ; ssize_t result ; if ( iocb -> ki_flags & IOCB_DIRECT ) { return nfs_file_direct_read ( iocb , to ) ; } dprintk ( \"NFS: read(%pD2, %zu@%lu)\\n\" , iocb -> ki_filp , iov_iter_count ( to ) , ( unsigned long ) iocb -> ki_pos ) ; nfs_start_io_read ( inode , NULL ) ; result = nfs_revalidate_mapping ( inode , iocb -> ki_filp -> f_mapping ) ; if ( ! result ) { result = generic_file_read_iter ( iocb , to ) ; if ( result > 0 ) { nfs_add_stats ( inode , NFSIOS_NORMALREADBYTES , result ) ; } } nfs_end_io_read ( inode ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _getch ( void ) int h_errno ; struct hostent * gethostbyname ( char * name ) { struct hostent * host1 ; h_errno = 0 ; host1 = ( hostent * ) emalloc ( sizeof ( hostent ) ) ; host1 -> h_name = name ; host1 -> h_addrtype = AF_INET ; host1 -> h_aliases = name ; host1 -> h_length = 4 ; host1 -> h_addr_list [ 0 ] = ( char * ) hostGetByName ( name ) ; return host1 ; } struct hostent * gethostbyaddr ( char * name , int size , int addr_type ) { struct hostent * host1 ; h_errno = 0 ; host1 = ( hostent * ) emalloc ( sizeof ( hostent ) ) ; host1 -> h_name = name ; host1 -> h_addrtype = AF_INET ; host1 -> h_aliases = name ; host1 -> h_length = 4 ; host1 -> h_addr_list = NULL ; return host1 ; } struct servent * getservbyname ( char * name , char * type ) { struct servent * serv1 ; serv1 = ( servent * ) emalloc ( sizeof ( servent ) ) ; serv1 -> s_name = \"ntp\" ; serv1 -> s_aliases = NULL ; serv1 -> s_port = 123 ; serv1 -> s_proto = \"udp\" ; return serv1 ; } void sleep ( int seconds ) { taskDelay ( seconds * TICK ) ; } void alarm ( int seconds ) { sleep ( seconds ) ; } int gettimeofday ( struct timeval * tvp ) { return ( get_process_stats ( tvp , PS_SELF , ( procstats * ) 0 , ( procstats * ) 0 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sf1_cap ( Ofl_desc * ofl , Xword val , Ifl_desc * ifl , Is_desc * cisp ) { Xword badval ; if ( ofl -> ofl_flags1 & FLG_OF1_OVSFCAP1 ) { DBG_CALL ( Dbg_cap_val_entry ( ofl -> ofl_lml , DBG_STATE_IGNORED , CA_SUNW_SF_1 , val , ld_targ . t_m . m_mach ) ) ; return ; } if ( ifl && ( ifl -> ifl_ehdr -> e_type == ET_REL ) ) { if ( val & SF1_SUNW_ADDR32 ) { ld_eprintf ( ofl , ERR_WARNING , MSG_INTL ( MSG_FIL_INADDR32SF1 ) , ifl -> ifl_name , EC_WORD ( cisp -> is_scnndx ) , cisp -> is_name ) ; val &= ~ SF1_SUNW_ADDR32 ; } } if ( ( badval = ( val & ~ SF1_SUNW_MASK ) ) != 0 ) { ld_eprintf ( ofl , ERR_WARNING , MSG_INTL ( MSG_FIL_BADSF1 ) , ifl -> ifl_name , EC_WORD ( cisp -> is_scnndx ) , cisp -> is_name , EC_XWORD ( badval ) ) ; val &= SF1_SUNW_MASK ; } if ( ( val & FP_FLAGS ) == SF1_SUNW_FPUSED ) { ld_eprintf ( ofl , ERR_WARNING , MSG_INTL ( MSG_FIL_BADSF1 ) , ifl -> ifl_name , EC_WORD ( cisp -> is_scnndx ) , cisp -> is_name , EC_XWORD ( val ) ) ; return ; } if ( ifl -> ifl_ehdr -> e_type != ET_REL ) { if ( ( val & SF1_SUNW_ADDR32 ) && ( ofl -> ofl_flags & FLG_OF_EXEC ) && ( ( ofl -> ofl_ocapset . oc_sf_1 . cm_val & SF1_SUNW_ADDR32 ) == 0 ) ) { ld_eprintf ( ofl , ERR_WARNING , MSG_INTL ( MSG_FIL_EXADDR32SF1 ) , ifl -> ifl_name , EC_WORD ( cisp -> is_scnndx ) , cisp -> is_name ) ; } return ; } if ( DBG_ENABLED ) { Dbg_cap_val_entry ( ofl -> ofl_lml , DBG_STATE_CURRENT , CA_SUNW_SF_1 , ofl -> ofl_ocapset . oc_sf_1 . cm_val , ld_targ . t_m . m_mach ) ; Dbg_cap_val_entry ( ofl -> ofl_lml , DBG_STATE_NEW , CA_SUNW_SF_1 , val , ld_targ . t_m . m_mach ) ; } if ( ( ofl -> ofl_ocapset . oc_sf_1 . cm_val & FP_FLAGS ) == FP_FLAGS ) { if ( ( val & FP_FLAGS ) != FP_FLAGS ) { ofl -> ofl_ocapset . oc_sf_1 . cm_val &= ~ SF1_SUNW_FPUSED ; } val &= ~ FP_FLAGS ; } if ( ( ofl -> ofl_ocapset . oc_sf_1 . cm_val & SF1_SUNW_FPKNWN ) == 0 ) { ofl -> ofl_ocapset . oc_sf_1 . cm_val &= ~ FP_FLAGS ; } else { val &= ~ FP_FLAGS ; } ofl -> ofl_ocapset . oc_sf_1 . cm_val |= val ; DBG_CALL ( Dbg_cap_val_entry ( ofl -> ofl_lml , DBG_STATE_RESOLVED , CA_SUNW_SF_1 , ofl -> ofl_ocapset . oc_sf_1 . cm_val , ld_targ . t_m . m_mach ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sof_nocodec_bes_setup ( struct device * dev , struct snd_soc_dai_driver * drv , struct snd_soc_dai_link * links , int link_num , struct snd_soc_card * card ) { struct snd_soc_dai_link_component * dlc ; int i ; if ( ! drv || ! links || ! card ) { return - EINVAL ; } for ( i = 0 ; i < link_num ; i ++ ) { dlc = devm_kcalloc ( dev , 3 , sizeof ( * dlc ) , GFP_KERNEL ) ; if ( ! dlc ) { return - ENOMEM ; } links [ i ] . name = devm_kasprintf ( dev , GFP_KERNEL , \"NoCodec-%d\" , i ) ; links [ i ] . stream_name = links [ i ] . name ; links [ i ] . cpus = & dlc [ 0 ] ; links [ i ] . codecs = & dlc [ 1 ] ; links [ i ] . platforms = & dlc [ 2 ] ; links [ i ] . num_cpus = 1 ; links [ i ] . num_codecs = 1 ; links [ i ] . num_platforms = 1 ; links [ i ] . id = i ; links [ i ] . no_pcm = 1 ; links [ i ] . cpus -> dai_name = drv [ i ] . name ; links [ i ] . platforms -> name = dev_name ( dev -> parent ) ; links [ i ] . codecs -> dai_name = \"snd-soc-dummy-dai\" ; links [ i ] . codecs -> name = \"snd-soc-dummy\" ; if ( drv [ i ] . playback . channels_min ) { links [ i ] . dpcm_playback = 1 ; } if ( drv [ i ] . capture . channels_min ) { links [ i ] . dpcm_capture = 1 ; } links [ i ] . be_hw_params_fixup = sof_pcm_dai_link_fixup ; } card -> dai_link = links ; card -> num_links = link_num ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ut32 consume_r ( RBuffer * b , ut64 bound , size_t * n_out , ConsumeFcn consume_fcn ) { r_return_val_if_fail ( b && n_out && consume_fcn , 0 ) ; ut32 tmp ; ut64 cur = r_buf_tell ( b ) ; ut8 * buf = R_NEWS ( ut8 , 16 ) ; if ( ! buf ) { return 0 ; } r_buf_read ( b , buf , 16 ) ; size_t n = consume_fcn ( buf , buf + bound + 1 , & tmp ) ; if ( ! n ) { free ( buf ) ; return 0 ; } r_buf_seek ( b , cur + n , R_BUF_SET ) ; * n_out = n ; free ( buf ) ; return tmp ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int board_mmc_getcd ( struct mmc * mmc ) { struct fsl_esdhc_cfg * cfg = ( fsl_esdhc_cfg * ) mmc -> priv ; int ret = 0 ; switch ( cfg -> esdhc_base ) { case USDHC1_BASE_ADDR : break ; case USDHC2_BASE_ADDR : ret = 1 ; break ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gdk_pixbuf_gif_anim_get_static_image ( ) { GdkPixbufGifAnim * gif_anim ; gif_anim = GDK_PIXBUF_GIF_ANIM ( animation , NULL ) ; if ( gif_anim -> frames == NULL ) { return NULL ; } else { return GDK_PIXBUF ( ( ( GdkPixbufFrame * ) gif_anim -> frames -> data ) -> pixbuf ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int create_node_instance_result ( const char * msg , size_t msg_len ) { node_instance_creation_result_t res = parse_create_node_instance_result ( msg , msg_len ) ; if ( ! res . machine_guid || ! res . node_id ) { error_report ( \"Error parsing CreateNodeInstanceResult\" ) ; freez ( res . machine_guid ) ; return 1 ; } debug ( D_ACLK , \"CreateNodeInstanceResult: guid:%s nodeid:%s\" , res . machine_guid , res . node_id ) ; uuid_t host_id , node_id ; if ( uuid_parse ( res . machine_guid , host_id ) ) { error ( \"Error parsing machine_guid provided by CreateNodeInstanceResult\" ) ; freez ( res . machine_guid ) ; freez ( res . node_id ) ; return 1 ; } if ( uuid_parse ( res . node_id , node_id ) ) { error ( \"Error parsing node_id provided by CreateNodeInstanceResult\" ) ; freez ( res . machine_guid ) ; freez ( res . node_id ) ; return 1 ; } update_node_id ( & host_id , & node_id ) ; aclk_query_t query = aclk_query_new ( NODE_STATE_UPDATE ) ; node_instance_connection_t node_state_update = { . hops = 1 . live = 0 . queryable = 1 . session_id = aclk_session_newarch . node_id = res . node_id . capabilities = NULL } ; RRDHOST * host = rrdhost_find_by_guid ( res . machine_guid ) ; if ( likely ( host ) ) { if ( host == localhost ) { node_state_update . live = 1 ; node_state_update . hops = 0 ; } else { node_state_update . live = ( ! rrdhost_flag_check ( host , RRDHOST_FLAG_ORPHAN ) ) ; node_state_update . hops = host -> system_info -> hops ; } node_state_update . capabilities = aclk_get_node_instance_capas ( host ) ; } rrdhost_aclk_state_lock ( localhost ) ; node_state_update . claim_id = localhost -> aclk_state . claimed_id ; query -> data . bin_payload . payload = generate_node_instance_connection ( & query -> data . bin_payload . size , & node_state_update ) ; rrdhost_aclk_state_unlock ( localhost ) ; freez ( ( void * ) node_state_update . capabilities ) ; query -> data . bin_payload . msg_name = \"UpdateNodeInstanceConnection\" ; query -> data . bin_payload . topic = ACLK_TOPICID_NODE_CONN ; aclk_queue_query ( query ) ; freez ( res . node_id ) ; freez ( res . machine_guid ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct ccmap_impl * ccmap_rehash ( struct ccmap * ccmap , uint32_t mask ) { struct ccmap_impl * old = ccmap_get_impl ( ccmap ) ; ccmap_impl * new = ccmap_impl_create ( mask ) ; ovs_assert ( old -> n_unique < new -> max_n ) ; while ( ! ccmap_try_rehash ( old , new ) ) { new -> basis = random_uint32 ( ) ; } new -> n = old -> n ; new -> n_unique = old -> n_unique ; ovsrcu_set ( & ccmap -> impl , new ) ; ovsrcu_postpone ( free_cacheline , old ) ; return new ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool __close ( RIODesc * fd ) { if ( ! fd || ! fd -> data ) { return false ; } RIOR2Web * riom = fd -> data ; R_FREE ( riom -> url , NULL ) ; R_FREE ( fd -> data ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int combo_init ( PX_Combo * cx , const uint8 * key , unsigned klen , const uint8 * iv , unsigned ivlen ) { int err ; unsigned ks , ivs ; PX_Cipher * c = cx -> cipher ; uint8 * ivbuf = NULL ; uint8 * keybuf ; ks = px_cipher_key_size ( c ) ; ivs = px_cipher_iv_size ( c ) ; if ( ivs > 0 ) { ivbuf = palloc0 ( ivs ) ; if ( ivlen > ivs ) { memcpy ( ivbuf , iv , ivs ) ; } if ( ivlen > 0 ) { memcpy ( ivbuf , iv , ivlen ) ; } } if ( klen > ks ) { klen = ks ; } keybuf = palloc0 ( ks ) ; memcpy ( keybuf , key , klen ) ; err = px_cipher_init ( c , keybuf , klen , ivbuf ) ; if ( ivbuf ) { pfree ( ivbuf ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "CURLMcode curl_multi_perform ( struct Curl_multi * multi , int * running_handles ) { struct Curl_easy * data ; CURLMcode returncode = CURLM_OK ; struct Curl_tree * t ; struct curltime now = Curl_now ( ) ; if ( multi -> in_callback ) { return CURLM_RECURSIVE_API_CALL ; } data = multi -> easyp ; while ( data ) { CURLMcode result ; SIGPIPE_VARIABLE ( pipe_st ) ; sigpipe_ignore ( data , & pipe_st ) ; result = multi_runsingle ( multi , & now , data ) ; sigpipe_restore ( & pipe_st ) ; if ( result ) { returncode = result ; } data = data -> next ; } { multi -> timetree = Curl_splaygetbest ( now , multi -> timetree , & t ) ; if ( t ) { ( void ) add_next_timeout ( now , multi , t -> payload ) ; } } t ; * running_handles = multi -> num_alive ; if ( CURLM_OK >= returncode ) { returncode = Curl_update_timer ( multi ) ; } return returncode ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void qeth_bridge_state_change_worker ( struct work_struct * work ) { struct qeth_bridge_state_data * data = container_of ( work , qeth_bridge_state_data , worker ) ; struct qeth_sbp_port_entry * entry = & data -> qports . entry [ 0 ] ; char env_locrem [ 32 ] ; char env_role [ 32 ] ; char env_state [ 32 ] ; char * env [ ] { env_locrem env_role env_state NULL } ; ; mutex_lock ( & data -> card -> conf_mutex ) ; data -> card -> options . sbp . role = entry -> role ; mutex_unlock ( & data -> card -> conf_mutex ) ; snprintf ( env_locrem , sizeof ( env_locrem ) , \"BRIDGEPORT=statechange\" ) ; snprintf ( env_role , sizeof ( env_role ) , \"ROLE=%s\" , ( entry -> role == QETH_SBP_ROLE_NONE ) ?\"none\" : ( entry -> role == QETH_SBP_ROLE_PRIMARY ) ?\"primary\" : ( entry -> role == QETH_SBP_ROLE_SECONDARY ) ?\"secondary\" : \"<INVALID>\" ) ; snprintf ( env_state , sizeof ( env_state ) , \"STATE=%s\" , ( entry -> state == QETH_SBP_STATE_INACTIVE ) ?\"inactive\" : ( entry -> state == QETH_SBP_STATE_STANDBY ) ?\"standby\" : ( entry -> state == QETH_SBP_STATE_ACTIVE ) ?\"active\" : \"<INVALID>\" ) ; kobject_uevent_env ( & data -> card -> gdev -> dev . kobj , KOBJ_CHANGE , env ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ECDSA_size ( const EC_KEY * r ) { BIGNUM * order = NULL ; const EC_GROUP * group ; ECDSA_SIG signature ; int ret = 0 ; if ( r == NULL ) { err } if ( ( group = EC_KEY_get0_group ( r ) ) == NULL ) { err } if ( ( order = BN_new ( ) ) == NULL ) { err } if ( ! EC_GROUP_get_order ( group , order , NULL ) ) { err } signature . r = order ; signature . s = order ; if ( ( ret = i2d_ECDSA_SIG ( & signature , NULL ) ) < 0 ) { ret = 0 ; } err return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int setup_partitions ( VP8Context * s , const uint8_t * buf , int buf_size ) { const uint8_t * sizes = buf ; int i ; int ret ; s -> num_coeff_partitions = 1 << vp89_rac_get_uint ( & s -> c , 2 ) ; buf += 3 * ( s -> num_coeff_partitions - 1 ) ; buf_size -= 3 * ( s -> num_coeff_partitions - 1 ) ; for ( i = 0 ; i < s -> num_coeff_partitions - 1 ; i ++ ) { int size = AV_RL24 ( sizes + 3 * i ) ; if ( buf_size - size < 0 ) { return - 1 ; } s -> coeff_partition_size [ i ] = size ; ret = ff_vpx_init_range_decoder ( & s -> coeff_partition [ i ] , buf , size ) ; if ( ret < 0 ) { return ret ; } buf += size ; buf_size -= size ; } s -> coeff_partition_size [ i ] = buf_size ; ff_vpx_init_range_decoder ( & s -> coeff_partition [ i ] , buf , buf_size ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void axg_spdifout_shutdown ( struct snd_pcm_substream * substream , struct snd_soc_dai * dai ) { struct axg_spdifout * priv = snd_soc_dai_get_drvdata ( dai ) ; clk_disable_unprepare ( priv -> pclk , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "qboolean CG_Asset_Parse ( int handle ) { pc_token_t token ; const char * tempStr ; if ( ! trap_PC_ReadToken ( handle , & token ) ) { return qfalse ; } if ( Q_stricmp ( token . string , \"{\" ) != 0 ) { return qfalse ; } while ( 1 ) { if ( ! trap_PC_ReadToken ( handle , & token ) ) { return qfalse ; } if ( Q_stricmp ( token . string , \"}\" ) == 0 ) { return qtrue ; } if ( Q_stricmp ( token . string , \"font\" ) == 0 ) { int pointSize ; if ( ! PC_String_Parse ( handle , & tempStr ) || ! PC_Int_Parse ( handle , & pointSize ) ) { return qfalse ; } cgDC . registerFont ( tempStr , pointSize , & cgDC . Assets . textFont ) ; continue ; } if ( Q_stricmp ( token . string , \"smallFont\" ) == 0 ) { int pointSize ; if ( ! PC_String_Parse ( handle , & tempStr ) || ! PC_Int_Parse ( handle , & pointSize ) ) { return qfalse ; } cgDC . registerFont ( tempStr , pointSize , & cgDC . Assets . smallFont ) ; continue ; } if ( Q_stricmp ( token . string , \"bigfont\" ) == 0 ) { int pointSize ; if ( ! PC_String_Parse ( handle , & tempStr ) || ! PC_Int_Parse ( handle , & pointSize ) ) { return qfalse ; } cgDC . registerFont ( tempStr , pointSize , & cgDC . Assets . bigFont ) ; continue ; } if ( Q_stricmp ( token . string , \"gradientbar\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & tempStr ) ) { return qfalse ; } cgDC . Assets . gradientBar = trap_R_RegisterShaderNoMip ( tempStr ) ; continue ; } if ( Q_stricmp ( token . string , \"menuEnterSound\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & tempStr ) ) { return qfalse ; } cgDC . Assets . menuEnterSound = trap_S_RegisterSound ( tempStr , NULL ) ; continue ; } if ( Q_stricmp ( token . string , \"menuExitSound\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & tempStr ) ) { return qfalse ; } cgDC . Assets . menuExitSound = trap_S_RegisterSound ( tempStr ) ; continue ; } if ( Q_stricmp ( token . string , \"itemFocusSound\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & tempStr ) ) { return qfalse ; } cgDC . Assets . itemFocusSound = trap_S_RegisterSound ( tempStr ) ; continue ; } if ( Q_stricmp ( token . string , \"menuBuzzSound\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & tempStr ) ) { return qfalse ; } cgDC . Assets . menuBuzzSound = trap_S_RegisterSound ( tempStr ) ; continue ; } if ( Q_stricmp ( token . string , \"cursor\" ) == 0 ) { if ( ! PC_String_Parse ( handle , & cgDC . Assets . cursorStr ) ) { return qfalse ; } cgDC . Assets . cursor = trap_R_RegisterShaderNoMip ( cgDC . Assets . cursorStr ) ; continue ; } if ( Q_stricmp ( token . string , \"fadeClamp\" ) == 0 ) { if ( ! PC_Float_Parse ( handle , & cgDC . Assets . fadeClamp ) ) { return qfalse ; } continue ; } if ( Q_stricmp ( token . string , \"fadeCycle\" ) == 0 ) { if ( ! PC_Int_Parse ( handle , & cgDC . Assets . fadeCycle ) ) { return qfalse ; } continue ; } if ( Q_stricmp ( token . string , \"fadeAmount\" ) == 0 ) { if ( ! PC_Float_Parse ( handle , & cgDC . Assets . fadeAmount ) ) { return qfalse ; } continue ; } if ( Q_stricmp ( token . string , \"shadowX\" ) == 0 ) { if ( ! PC_Float_Parse ( handle , & cgDC . Assets . shadowX ) ) { return qfalse ; } continue ; } if ( Q_stricmp ( token . string , \"shadowY\" ) == 0 ) { if ( ! PC_Float_Parse ( handle , & cgDC . Assets . shadowY ) ) { return qfalse ; } continue ; } if ( Q_stricmp ( token . string , \"shadowColor\" ) == 0 ) { if ( ! PC_Color_Parse ( handle , & cgDC . Assets . shadowColor ) ) { return qfalse ; } cgDC . Assets . shadowFadeClamp = cgDC . Assets . shadowColor [ 3 ] ; continue ; } } return qfalse ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int stm32mp_bsec_read_otp ( struct udevice * dev , u32 * val , u32 otp ) { struct stm32mp_bsec_plat * plat ; u32 tmp_data = 0 ; int ret ; if ( IS_ENABLED ( CONFIG_ARM_SMCCC ) && ! IS_ENABLED ( CONFIG_SPL_BUILD ) ) { return stm32_smc ( STM32_SMC_BSEC , STM32_SMC_READ_OTP , otp , 0 , val ) ; } plat = dev_get_plat ( dev ) ; ret = bsec_read_shadow ( dev , plat -> base , & tmp_data , otp ) ; ret = bsec_shadow_register ( dev , plat -> base , otp ) ; if ( ret ) { return ret ; } ret = bsec_read_shadow ( dev , plat -> base , val , otp ) ; if ( ret ) { return ret ; } ret = bsec_write_shadow ( dev , plat -> base , tmp_data , otp ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void setup_clock ( struct kvm_vm * vm , struct test_case * test_case ) { struct kvm_clock_data data ; memset ( & data , 0 , sizeof ( data ) ) ; data . clock = test_case -> kvmclock_base ; if ( test_case -> realtime_offset ) { struct timespec ts ; int r ; data . flags |= KVM_CLOCK_REALTIME ; { r = clock_gettime ( CLOCK_REALTIME , & ts ) ; } errno == EINTR ; TEST_ASSERT ( ! r , \"clock_gettime() failed: %d\\n\" , r ) ; data . realtime = ts . tv_sec * NSEC_PER_SEC ; data . realtime += ts . tv_nsec ; data . realtime += test_case -> realtime_offset ; } vm_ioctl ( vm , KVM_SET_CLOCK , & data ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int edt_ft5x06_ts_suspend ( struct device * dev ) { struct i2c_client * client = to_i2c_client ( dev ) ; struct edt_ft5x06_ts_data * tsdata = i2c_get_clientdata ( client ) ; struct gpio_desc * reset_gpio = tsdata -> reset_gpio ; int ret ; if ( device_may_wakeup ( dev ) ) { return 0 ; } if ( tsdata -> suspend_mode == EDT_PMODE_NOT_SUPPORTED ) { return 0 ; } ret = edt_ft5x06_register_write ( tsdata , PMOD_REGISTER_OPMODE , PMOD_REGISTER_HIBERNATE ) ; if ( ret ) { dev_warn ( dev , \"Failed to set hibernate mode\\n\" ) ; } disable_irq ( tsdata -> client -> irq ) ; gpiod_set_value_cansleep ( reset_gpio , 1 ) ; usleep_range ( 1000 , 2000 ) ; ret = regulator_disable ( tsdata -> vcc ) ; if ( ret ) { dev_warn ( dev , \"Failed to disable vcc\\n\" ) ; } ret = regulator_disable ( tsdata -> iovcc ) ; if ( ret ) { dev_warn ( dev , \"Failed to disable iovcc\\n\" ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long arg ) { struct pipe_buffer * bufs ; unsigned int size , nr_pages ; unsigned long user_bufs ; long ret = 0 ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; if ( ! nr_pages ) { return - EINVAL ; } if ( nr_pages > pipe -> buffers && size > pipe_max_size && ! capable ( CAP_SYS_RESOURCE ) ) { return - EPERM ; } user_bufs = account_pipe_buffers ( pipe -> user , pipe -> buffers , nr_pages ) ; if ( nr_pages > pipe -> buffers && ( too_many_pipe_buffers_hard ( user_bufs ) || too_many_pipe_buffers_soft ( user_bufs ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; out_revert_acct } if ( nr_pages < pipe -> nrbufs ) { ret = - EBUSY ; out_revert_acct } bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL_ACCOUNT | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) { ret = - ENOMEM ; out_revert_acct } if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) { tail = 0 ; } else { tail &= ( pipe -> buffers - 1 ) ; } head = pipe -> nrbufs - tail ; if ( head ) { memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( pipe_buffer ) ) ; } if ( tail ) { memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( pipe_buffer ) ) ; } } pipe -> curbuf = 0 ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; out_revert_acct ( void ) account_pipe_buffers ( pipe -> user , nr_pages , pipe -> buffers ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int psa_ecc_keygen ( int ecc_curve , unsigned key_size , psa_key_id_t * key_id ) { psa_key_attributes_t key_attr = { 0 } ; size_t ecc_curve_key_size ; psa_ecc_family_t family ; psa_status_t status ; int ret ; ret = psa_ecc_get_curve_info_from_curve_id ( ecc_curve , & family , & ecc_curve_key_size ) ; if ( ret != 0 ) { return ret ; } psa_set_key_type ( & key_attr , PSA_KEY_TYPE_ECC_KEY_PAIR ( family ) ) ; psa_set_key_bits ( & key_attr , ecc_curve_key_size * 8 ) ; psa_set_key_algorithm ( & key_attr , PSA_ALG_ECDH ) ; psa_set_key_usage_flags ( & key_attr , PSA_KEY_USAGE_DERIVE ) ; PSA_LOCK ( ) ; status = psa_generate_key ( & key_attr , key_id ) ; PSA_UNLOCK ( ) ; if ( status != PSA_SUCCESS ) { return WC_HW_E ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static netdev_tx_t hip04_mac_start_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hip04_priv * priv = netdev_priv ( ndev ) ; struct net_device_stats * stats = & ndev -> stats ; unsigned int tx_head = priv -> tx_head , count ; struct tx_desc * desc = & priv -> tx_desc [ tx_head ] ; dma_addr_t phys ; smp_rmb ( ) ; count = tx_count ( tx_head , READ_ONCE ( priv -> tx_tail ) ) ; if ( count == ( TX_DESC_NUM - 1 ) ) { netif_stop_queue ( ndev ) ; return NETDEV_TX_BUSY ; } phys = dma_map_single ( priv -> dev , skb -> data , skb -> len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( priv -> dev , phys ) ) { return NETDEV_TX_OK ; } priv -> tx_skb [ tx_head ] = skb ; priv -> tx_phys [ tx_head ] = phys ; desc -> send_size = ( __force u32 ) cpu_to_be32 ( skb -> len ) ; desc -> cfg = ( __force u32 ) cpu_to_be32 ( TX_CLEAR_WB | TX_FINISH_CACHE_INV | TX_RELEASE_TO_PPE | priv -> port << TX_POOL_SHIFT ) ; desc -> data_offset = ( __force u32 ) cpu_to_be32 ( phys & SOC_CACHE_LINE_MASK ) ; desc -> send_addr = ( __force u32 ) cpu_to_be32 ( phys & ~ SOC_CACHE_LINE_MASK ) ; desc -> cfg = ( __force u32 ) cpu_to_be32 ( TX_CLEAR_WB | TX_FINISH_CACHE_INV ) ; desc -> send_addr = ( __force u32 ) cpu_to_be32 ( phys ) ; phys = priv -> tx_desc_dma + tx_head * sizeof ( tx_desc ) ; desc -> wb_addr = ( __force u32 ) cpu_to_be32 ( phys + offsetof ( tx_desc , send_addr ) ) ; skb_tx_timestamp ( skb ) ; hip04_set_xmit_desc ( priv , phys ) ; count ++ ; netdev_sent_queue ( ndev , skb -> len ) ; priv -> tx_head = TX_NEXT ( tx_head ) ; stats -> tx_bytes += skb -> len ; stats -> tx_packets ++ ; smp_wmb ( ) ; if ( count >= priv -> tx_coalesce_frames ) { if ( napi_schedule_prep ( & priv -> napi ) ) { priv -> reg_inten &= ~ ( RCV_INT ) ; writel_relaxed ( DEF_INT_MASK & ~ RCV_INT , priv -> base + PPE_INTEN ) ; hrtimer_cancel ( & priv -> tx_coalesce_timer ) ; __napi_schedule ( & priv -> napi ) ; } } if ( ! hrtimer_is_queued ( & priv -> tx_coalesce_timer ) ) { hip04_start_tx_timer ( priv ) ; } return NETDEV_TX_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool cfs_num_is_contiguous ( struct list_head * nidlist ) { struct nidrange * nr ; struct addrrange * ar ; struct cfs_expr_list * el ; struct cfs_range_expr * re ; int last_hi = 0 ; __u32 last_end_nid = 0 ; int current_start_nid = 0 ; __u32 current_end_nid = 0 ; list_for_each_entry ( , , ) { list_for_each_entry ( , , ) { cfs_num_ar_min_max ( ar , & current_start_nid , & current_end_nid ) ; if ( last_end_nid && ( current_start_nid - last_end_nid != 1 ) ) { return false ; } last_end_nid = current_end_nid ; list_for_each_entry ( , , ) { list_for_each_entry ( , , ) { if ( re -> re_stride > 1 ) { return false ; } if ( last_hi && re -> re_hi - last_hi != 1 ) { return false ; } last_hi = re -> re_hi ; } } } } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int spwr_battery_prop_status ( struct spwr_battery_device * bat ) { u32 state = get_unaligned_le32 ( & bat -> bst . state ) ; u32 present_rate = get_unaligned_le32 ( & bat -> bst . present_rate ) ; lockdep_assert_held ( & bat -> lock ) ; if ( state & SAM_BATTERY_STATE_DISCHARGING ) { return POWER_SUPPLY_STATUS_DISCHARGING ; } if ( spwr_battery_is_full ( bat ) ) { return POWER_SUPPLY_STATUS_FULL ; } if ( present_rate == 0 ) { return POWER_SUPPLY_STATUS_NOT_CHARGING ; } return POWER_SUPPLY_STATUS_UNKNOWN ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gimp_image_invalidate_previews ( ) { GimpItemStack * layers ; GimpItemStack * channels ; g_return_if_fail ( GIMP_IS_IMAGE ( image ) ) ; layers = GIMP_ITEM_STACK ( gimp_image_get_layers ( image ) ) ; channels = GIMP_ITEM_STACK ( gimp_image_get_channels ( image ) ) ; gimp_item_stack_invalidate_previews ( layers , NULL ) ; gimp_item_stack_invalidate_previews ( channels ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void cleanup_callback_cred ( void ) { if ( callback_cred ) { put_rpccred ( callback_cred , NULL ) ; callback_cred = NULL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rproc_handle_carveout ( struct rproc * rproc , struct fw_rsc_carveout * rsc , int offset , int avail ) { struct rproc_mem_entry * carveout , * mapping ; struct device * dev = & rproc -> dev ; dma_addr_t dma ; void * va ; int ret ; if ( sizeof ( * rsc ) > avail ) { dev_err ( dev , \"carveout rsc is truncated\\n\" ) ; return - EINVAL ; } if ( rsc -> reserved ) { dev_err ( dev , \"carveout rsc has non zero reserved bytes\\n\" ) ; return - EINVAL ; } dev_dbg ( dev , \"carveout rsc: name: %s, da 0x%x, pa 0x%x, len 0x%x, flags 0x%x\\n\" , rsc -> name , rsc -> da , rsc -> pa , rsc -> len , rsc -> flags ) ; carveout = kzalloc ( sizeof ( * carveout ) , GFP_KERNEL ) ; if ( ! carveout ) { return - ENOMEM ; } va = dma_alloc_coherent ( dev -> parent , rsc -> len , & dma , GFP_KERNEL ) ; if ( ! va ) { dev_err ( dev -> parent , \"failed to allocate dma memory: len 0x%x\\n\" , rsc -> len ) ; ret = - ENOMEM ; free_carv } dev_dbg ( dev , \"carveout va %p, dma %pad, len 0x%x\\n\" , va , & dma , rsc -> len ) ; if ( rproc -> domain ) { mapping = kmalloc ( sizeof ( * mapping ) , GFP_KERNEL ) ; if ( ! mapping ) { ret = - ENOMEM ; dma_free } ret = iommu_map ( rproc -> domain , rsc -> da , dma , rsc -> len , rsc -> flags ) ; if ( ret ) { dev_err ( dev , \"iommu_map failed: %d\\n\" , ret ) ; free_mapping } mapping -> da = rsc -> da ; mapping -> len = rsc -> len ; list_add_tail ( & mapping -> node , & rproc -> mappings ) ; dev_dbg ( dev , \"carveout mapped 0x%x to %pad\\n\" , rsc -> da , & dma ) ; } rsc -> pa = dma ; carveout -> va = va ; carveout -> len = rsc -> len ; carveout -> dma = dma ; carveout -> da = rsc -> da ; list_add_tail ( & carveout -> node , & rproc -> carveouts ) ; return 0 ; free_mapping kfree ( mapping ) ; dma_free dma_free_coherent ( dev -> parent , rsc -> len , va , dma ) ; free_carv kfree ( carveout ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ipoib_mark_paths_invalid ( struct net_device * dev ) { struct ipoib_dev_priv * priv = ipoib_priv ( dev ) ; struct ipoib_path * path , * tp ; spin_lock_irq ( & priv -> lock ) ; list_for_each_entry_safe ( , , , ) { ipoib_dbg ( priv , \"mark path LID 0x%08x GID %pI6 invalid\\n\" , be32_to_cpu ( sa_path_get_dlid ( & path -> pathrec ) ) , path -> pathrec . dgid . raw ) ; } spin_unlock_irq ( & priv -> lock ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool kvm_mips_flush_gpa_pmd ( pmd_t * pmd , unsigned long start_gpa , unsigned long end_gpa ) { pte_t * pte ; unsigned long end = ~ 0ul ; int i_min = __pmd_offset ( start_gpa ) ; int i_max = __pmd_offset ( end_gpa ) ; bool safe_to_remove = ( i_min == 0 && i_max == PTRS_PER_PMD - 1 ) ; int i ; for ( i = i_min ; i <= i_max ; ++ i , start_gpa = 0 ) { pte = pte_offset ( pmd + i , 0 ) ; if ( i == i_max ) { end = end_gpa ; } if ( kvm_mips_flush_gpa_pte ( pte , start_gpa , end ) ) { pmd_clear ( pmd + i ) ; pte_free_kernel ( NULL , pte ) ; } else { safe_to_remove = false ; } } return safe_to_remove ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { int i , j ; GC_INIT ( ) ; init_staticroot ( ) ; if ( GC_get_find_leak ( ) ) { printf ( \"This test program is not designed for leak detection mode\\n\" ) ; } if ( NULL == staticroot ) { fprintf ( stderr , \"GC_malloc returned NULL\\n\" ) ; return 2 ; } GC_gcollect ( ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < ( int ) ( sizeof ( root ) / sizeof ( root [ 0 ] ) ) ; ++ i ) { * libsrl_getpelem2 ( i , j ) = libsrl_mktree ( 12 ) ; * libsrl_getpelem ( i , j ) = libsrl_mktree ( 12 ) ; ( ( j & 1 ) != 0 ?root_nz : root ) [ i ] = libsrl_mktree ( 12 ) ; GC_gcollect ( ) ; } for ( i = 0 ; i < ( int ) sizeof ( treenode ) ; ++ i ) { if ( staticroot [ i ] != 0x42 ) { fprintf ( stderr , \"Memory check failed\\n\" ) ; return 1 ; } } } printf ( \"SUCCEEDED\\n\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hvc_opal_hvsi_get_chars ( uint32_t vtermno , char * buf , int count ) { struct hvc_opal_priv * pv = hvc_opal_privs [ vtermno ] ; return hvsilib_get_chars ( & pv -> hvsi , buf , count ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool mrenclave_commit ( EVP_MD_CTX * ctx , uint8_t * mrenclave ) { int size ; if ( ! EVP_DigestFinal_ex ( ctx , ( unsigned char * ) mrenclave , & size ) ) { fprintf ( stderr , \"digest commit failed\\n\" ) ; return false ; } if ( size != 32 ) { fprintf ( stderr , \"invalid digest size = %u\\n\" , size ) ; return false ; } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( compat_put_timespec ) ; int compat_convert_timespec ( struct timespec __user * * kts , const void __user * cts ) { struct timespec ts ; struct timespec __user * uts ; if ( ! cts || COMPAT_USE_64BIT_TIME ) { * kts = ( timespec __user * ) cts ; return 0 ; } uts = compat_alloc_user_space ( sizeof ( ts ) ) ; if ( compat_get_timespec ( & ts , cts ) ) { return - EFAULT ; } if ( copy_to_user ( uts , & ts , sizeof ( ts ) ) ) { return - EFAULT ; } * kts = uts ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "X509_PKEY * X509_PKEY_new ( void ) { X509_PKEY * ret = NULL ; if ( ( ret = malloc ( sizeof ( X509_PKEY ) ) ) == NULL ) { ASN1error ( ERR_R_MALLOC_FAILURE ) ; err } ret -> version = 0 ; if ( ( ret -> enc_algor = X509_ALGOR_new ( ) ) == NULL ) { ASN1error ( ERR_R_MALLOC_FAILURE ) ; err } if ( ( ret -> enc_pkey = ASN1_OCTET_STRING_new ( ) ) == NULL ) { ASN1error ( ERR_R_MALLOC_FAILURE ) ; err } ret -> dec_pkey = NULL ; ret -> key_length = 0 ; ret -> key_data = NULL ; ret -> key_free = 0 ; ret -> cipher . cipher = NULL ; ret -> references = 1 ; return ( ret ) ; err if ( ret ) { X509_ALGOR_free ( ret -> enc_algor ) ; free ( ret ) ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ee1004_set_current_page ( struct device * dev , int page ) { int ret ; ret = i2c_smbus_write_byte ( ee1004_set_page [ page ] , 0x00 ) ; if ( ret == - ENXIO && ee1004_get_current_page ( ) == page ) { ret = 0 ; } if ( ret < 0 ) { dev_err ( dev , \"Failed to select page %d (%d)\\n\" , page , ret ) ; return ret ; } dev_dbg ( dev , \"Selected page %d\\n\" , page ) ; ee1004_current_page = page ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int parse_ul ( const char * val , unsigned long * num ) { char * endp = NULL ; cfs_time_t res ; res = strtoul ( val , & endp , 10 ) ; if ( endp && * endp ) { errno = EINVAL ; return - 1 ; } * num = res ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int huff_build ( VLC * vlc , uint8_t * len ) { HuffEntry he [ 256 ] ; uint32_t codes [ 256 ] ; uint8_t bits [ 256 ] ; uint8_t syms [ 256 ] ; uint32_t code ; int i ; for ( i = 0 ; i < 256 ; i ++ ) { he [ i ] . sym = 255 - i ; he [ i ] . len = len [ i ] ; } qsort ( he , 256 , sizeof ( HuffEntry ) , huff_cmp_len ) ; code = 1 ; for ( i = 255 ; i >= 0 ; i -- ) { codes [ i ] = code >> ( 32 - he [ i ] . len ) ; bits [ i ] = he [ i ] . len ; syms [ i ] = he [ i ] . sym ; code += 0x80000000u >> ( he [ i ] . len - 1 ) ; } return ff_init_vlc_sparse ( vlc , FFMIN ( he [ 255 ] . len , 12 ) , 256 , bits , sizeof ( * bits ) , sizeof ( * bits ) , codes , sizeof ( * codes ) , sizeof ( * codes ) , syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void iser_destroy_fastreg_desc ( struct iser_fr_desc * desc ) { struct iser_reg_resources * res = & desc -> rsc ; ib_dereg_mr ( res -> mr ) ; if ( res -> sig_mr ) { ib_dereg_mr ( res -> sig_mr ) ; res -> sig_mr = NULL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ltq_wdt_xrx_bootstatus_get ( struct device * dev ) { struct regmap * rcu_regmap ; u32 val ; int err ; rcu_regmap = syscon_regmap_lookup_by_phandle ( dev -> of_node , \"regmap\" ) ; if ( IS_ERR ( rcu_regmap ) ) { return PTR_ERR ( rcu_regmap ) ; } err = regmap_read ( rcu_regmap , LTQ_XRX_RCU_RST_STAT , & val ) ; if ( err ) { return err ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void zap_everything ( void ) { long after_zap ; long before_zap ; int i ; before_zap = inspect_me ( bounds_dir_ptr , NULL ) ; dprintf1 ( \"zapping everything start: %ld\\n\" , before_zap ) ; for ( i = 0 ; i < NR_MALLOCS ; i ++ ) { free_one_malloc ( i ) ; } after_zap = inspect_me ( bounds_dir_ptr ) ; dprintf1 ( \"zapping everything done: %ld\\n\" , after_zap ) ; if ( ( alignment >= MPX_BOUNDS_TABLE_COVERS ) && ( sz_alignment >= MPX_BOUNDS_TABLE_COVERS ) ) { if ( after_zap != 0 ) { test_failed ( ) ; } assert ( after_zap == 0 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int _dwarf_symbolic_relocs_to_disk ( Dwarf_P_Debug dbg , Dwarf_Signed * new_sec_count ) { int i = 0 ; Dwarf_Error error = 0 ; for ( i = 0 ; i < NUM_DEBUG_SECTIONS ; ++ i ) { int sec_index = 0 ; Dwarf_P_Per_Reloc_Sect p_reloc = dbg -> de_reloc_sect + i ; unsigned long ct = p_reloc -> pr_reloc_total_count ; int err = 0 ; sec_index = p_reloc -> pr_sect_num_of_reloc_sect ; if ( sec_index == 0 ) { int rel_section_index = 0 ; Dwarf_Unsigned name_idx = 0 ; if ( dbg -> de_callback_func ) { rel_section_index = dbg -> de_callback_func ( _dwarf_rel_section_names [ i ] , dbg -> de_relocation_record_size , SHT_REL , 0 , SHN_UNDEF , dbg -> de_elf_sects [ i ] , & name_idx , dbg -> de_user_data , & err ) ; } if ( rel_section_index == - 1 ) { { _dwarf_p_error ( dbg , & error , DW_DLE_ELF_SECT_ERR ) ; return ( DW_DLV_ERROR ) ; } } p_reloc -> pr_sect_num_of_reloc_sect = rel_section_index ; } if ( p_reloc -> pr_block_count < 2 ) { continue ; } { struct Dwarf_P_Relocation_Block_s * new_blk = 0 ; struct Dwarf_P_Relocation_Block_s * p_blk = 0 ; Dwarf_Small * data = 0 ; int res = 0 ; p_blk = p_reloc -> pr_first_block ; p_reloc -> pr_reloc_total_count = 0 ; p_reloc -> pr_first_block = 0 ; p_reloc -> pr_last_block = 0 ; p_reloc -> pr_block_count = 0 ; p_reloc -> pr_slots_per_block_to_alloc = ct ; res = _dwarf_pro_pre_alloc_specific_reloc_slots ( dbg , p_reloc , ct ) ; if ( res != DW_DLV_OK ) { return res ; } new_blk = p_reloc -> pr_first_block ; data = ( Dwarf_Small * ) new_blk -> rb_data ; { struct Dwarf_P_Relocation_Block_s * p_blk_last = 0 ; unsigned long len = p_blk -> rb_where_to_add_next - p_blk -> rb_data ; memcpy ( data , p_blk -> rb_data , len ) ; data += len ; p_blk_last = p_blk ; p_blk = p_blk -> rb_next ; _dwarf_p_dealloc ( dbg , ( Dwarf_Small * ) p_blk_last ) ; } p_blk ; new_blk -> rb_next_slot_to_use = ct ; new_blk -> rb_where_to_add_next = ( char * ) data ; p_reloc -> pr_reloc_total_count = ct ; } } * new_sec_count = 0 ; return DW_DLV_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int AddressTestCutIPv402 ( void ) { DetectAddress * a , * b , * c ; a = DetectAddressParseSingle ( \"1.2.3.0/255.255.255.0\" ) ; b = DetectAddressParseSingle ( \"1.2.2.0-1.2.3.4\" ) ; if ( DetectAddressCut ( NULL , a , b , & c ) == - 1 ) { error } if ( c == NULL ) { error } DetectAddressFree ( b ) ; DetectAddressFree ( c ) ; return 1 ; error DetectAddressFree ( a ) ; DetectAddressFree ( b ) ; DetectAddressFree ( c ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hash ( char * string ) { int hash_value ; while ( * string ) { hash_value += ( * string ++ & 0xDF ) ; } return hash_value % SCACHE_HASH_SIZE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int efinet_match ( struct netif * nif , void * machdep_hint ) { struct devdesc * dev = machdep_hint ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void omap_vout_cleanup_device ( struct omap_vout_device * vout ) { struct video_device * vfd ; struct omapvideo_info * ovid ; if ( ! vout ) { return ; } vfd = vout -> vfd ; ovid = & vout -> vid_info ; if ( vfd ) { if ( ! video_is_registered ( vfd ) ) { video_device_release ( vfd ) ; } else { video_unregister_device ( vfd ) ; } } v4l2_ctrl_handler_free ( & vout -> ctrl_handler ) ; if ( ovid -> rotation_type == VOUT_ROT_VRFB ) { omap_vout_release_vrfb ( vout ) ; if ( vout -> vrfb_static_allocation ) { omap_vout_free_vrfb_buffers ( vout ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static long native_hpte_remove ( unsigned long hpte_group ) { struct hash_pte * hptep ; int i ; int slot_offset ; unsigned long hpte_v ; DBG_LOW ( \"    remove(group=%lx)\\n\" , hpte_group ) ; slot_offset = mftb ( ) & 0x7 ; for ( i = 0 ; i < HPTES_PER_GROUP ; i ++ ) { hptep = htab_address + hpte_group + slot_offset ; hpte_v = be64_to_cpu ( hptep -> v ) ; if ( ( hpte_v & HPTE_V_VALID ) && ! ( hpte_v & HPTE_V_BOLTED ) ) { native_lock_hpte ( hptep ) ; hpte_v = be64_to_cpu ( hptep -> v ) ; if ( ( hpte_v & HPTE_V_VALID ) && ! ( hpte_v & HPTE_V_BOLTED ) ) { break ; } native_unlock_hpte ( hptep ) ; } slot_offset ++ ; slot_offset &= 0x7 ; } if ( i == HPTES_PER_GROUP ) { return - 1 ; } release_hpte_lock ( ) ; return i ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * nextdot ( const char * str ) { register char * cp ; register int c ; if ( * str == '.' ) { str ++ ; } for ( cp = ( char * ) str ; c = * cp ; cp ++ ) { if ( c == '[' ) { cp = nv_endsubscript ( ( Namval_t * ) 0 , ( char * ) cp , 0 ) ; return ( * cp == '.' ?cp : 0 ) ; } } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static h2o_iovec_t memory_status_json ( void * priv , h2o_globalconf_t * gconf , h2o_req_t * req ) { struct st_memory_status_ctx_t * csc = priv ; h2o_iovec_t ret ; \" \\\"memory.\" H2O_TO_STR ( prefix ) \".chunks\\\": %\" PRIu64 \",\\n \\\"memory.\" H2O_TO_STR ( prefix ) \".low_watermark\\\": %\" PRIu64 \",\\n\" ret . base = h2o_mem_alloc_pool ( & req -> pool , char , BUFSIZE ) ; ret . len = snprintf ( ret . base , BUFSIZE , \",\\n\" FMT ( ) FMT ( ) FMT ( socket . zerocopy ) \" \\\"memory.socket.zerocopy.inflight\\\": %zu\\n\" , ARGS ( mem_pool ) , ARGS ( socket_ssl ) , ARGS ( socket_zerocopy ) , csc -> socket_zerocopy_inflight * h2o_socket_zerocopy_buffer_allocator . conf -> memsize ) ; pthread_mutex_destroy ( & csc -> mutex ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * pr_type ( int t ) { static char * ttab [ ] { \"Echo Reply\" \"ICMP 1\" \"ICMP 2\" \"Dest Unreachable\" \"Source Quench\" \"Redirect\" \"ICMP 6\" \"ICMP 7\" \"Echo\" \"Router Advertise\" \"Router Solicitation\" \"Time Exceeded\" \"Parameter Problem\" \"Timestamp\" \"Timestamp Reply\" \"Info Request\" \"Info Reply\" \"Netmask Request\" \"Netmask Reply\" } ; ; return ( ttab [ t ] ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mmc_cmdq_switch ( struct mmc_card * card , bool enable ) { u8 val = enable ?EXT_CSD_CMDQ_MODE_ENABLED : 0 ; int err ; err = mmc_switch ( card , EXT_CSD_CMD_SET_NORMAL , EXT_CSD_CMDQ_MODE_EN , val , card -> ext_csd . generic_cmd6_time ) ; if ( ! err ) { card -> ext_csd . cmdq_en = enable ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pegasus_set_wol ( struct net_device * dev , struct ethtool_wolinfo * wol ) { pegasus_t * pegasus = netdev_priv ( dev ) ; u8 reg78 = 0x04 ; int ret ; if ( wol -> wolopts & WAKE_MAGIC ) { reg78 |= 0x80 ; } if ( wol -> wolopts & WAKE_PHY ) { reg78 |= 0x40 ; } if ( wol -> wolopts ) { pegasus -> eth_regs [ 0 ] |= 0x10 ; } else { pegasus -> eth_regs [ 0 ] &= ~ 0x10 ; } pegasus -> wolopts = wol -> wolopts ; ret = set_register ( pegasus , WakeupControl , reg78 ) ; if ( ! ret ) { ret = device_set_wakeup_enable ( & pegasus -> usb -> dev , wol -> wolopts ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ath10k_wow_op_resume ( struct ieee80211_hw * hw ) { struct ath10k * ar = hw -> priv ; int ret ; mutex_lock ( & ar -> conf_mutex ) ; if ( WARN_ON ( ! test_bit ( ATH10K_FW_FEATURE_WOWLAN_SUPPORT , ar -> running_fw -> fw_file . fw_features ) ) ) { exit } ret = ath10k_hif_resume ( ar ) ; if ( ret ) { ath10k_warn ( ar , \"failed to resume hif: %d\\n\" , ret ) ; exit } ret = ath10k_wow_wakeup ( ar ) ; if ( ret ) { ath10k_warn ( ar , \"failed to wakeup from wow: %d\\n\" , ret ) ; } exit if ( ret ) { switch ( ar -> state ) { case ATH10K_STATE_ON : ar -> state = ATH10K_STATE_RESTARTING ; ret = 1 ; break ; case ATH10K_STATE_OFF : case ATH10K_STATE_RESTARTING : case ATH10K_STATE_RESTARTED : case ATH10K_STATE_UTF : case ATH10K_STATE_WEDGED : ath10k_warn ( ar , \"encountered unexpected device state %d on resume, cannot recover\\n\" , ar -> state ) ; ret = - EIO ; break ; } } mutex_unlock ( & ar -> conf_mutex ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * query_wmi ( QueryWmiType type ) { GString * result = NULL ; HRESULT hr ; IWbemLocator * locator = NULL ; BSTR namespaceName = NULL ; BSTR queryLanguageName = NULL ; BSTR query = NULL ; IWbemServices * ; NULL IUnknown * namespaceUnknown = NULL ; IEnumWbemClassObject * enumerator = NULL ; int i ; gboolean atleast_one_appended = FALSE ; hr = CoCreateInstance ( & CLSID_WbemLocator , 0 , CLSCTX_INPROC_SERVER , & IID_IWbemLocator , ( LPVOID * ) & locator ) ; if ( FAILED ( hr ) ) { exit } namespaceName = SysAllocString ( L\"root\\\\CIMV2\" ) ; hr = locator -> lpVtbl -> ConnectServer ( , , , , , 0 , , , ) ; if ( FAILED ( hr ) ) { release_locator } hr = ; lpVtbl -> QueryInterface , IID_IUnknown , void * * } if ( FAILED ( hr ) ) { release_namespace } hr = CoSetProxyBlanket ( namespaceUnknown , RPC_C_AUTHN_WINNT , RPC_C_AUTHZ_NONE , NULL , RPC_C_AUTHN_LEVEL_CALL , RPC_C_IMP_LEVEL_IMPERSONATE , NULL , EOAC_NONE ) ; if ( FAILED ( hr ) ) { release_namespaceUnknown } queryLanguageName = SysAllocString ( L\"WQL\" ) ; switch ( type ) { case QUERY_WMI_OS : query = SysAllocString ( L\"SELECT Caption FROM Win32_OperatingSystem\" ) ; break ; case QUERY_WMI_CPU : query = SysAllocString ( L\"SELECT Name, MaxClockSpeed FROM Win32_Processor\" ) ; break ; case QUERY_WMI_VGA : query = SysAllocString ( L\"SELECT Name FROM Win32_VideoController\" ) ; break ; case QUERY_WMI_HDD : query = SysAllocString ( L\"SELECT Name, Capacity, FreeSpace FROM Win32_Volume\" ) ; break ; default : release_queryLanguageName } hr = ; lpVtbl -> ExecQuery , queryLanguageName , query , WBEM_FLAG_FORWARD_ONLY , NULL , enumerator if ( FAILED ( hr ) ) { release_query } result = g_string_new ( \"\" ) ; for ( i = 0 ; ; i ++ ) { ULONG numReturned = 0 ; IWbemClassObject * object ; char * line ; hr = enumerator -> lpVtbl -> Next ( enumerator , WBEM_INFINITE , 1 , & object , & numReturned ) ; if ( FAILED ( hr ) || numReturned == 0 ) { break ; } switch ( type ) { case QUERY_WMI_OS : line = read_os_name ( object ) ; break ; case QUERY_WMI_CPU : line = read_cpu_info ( object ) ; break ; case QUERY_WMI_VGA : line = read_vga_name ( object ) ; break ; case QUERY_WMI_HDD : line = read_hdd_info ( object ) ; break ; default : break ; } object -> lpVtbl -> Release ( object ) ; if ( line != NULL ) { if ( atleast_one_appended ) { g_string_append ( result , \", \" ) ; } g_string_append ( result , line ) ; atleast_one_appended = TRUE ; } } enumerator -> lpVtbl -> Release ( enumerator ) ; release_query SysFreeString ( query ) ; release_queryLanguageName SysFreeString ( queryLanguageName ) ; release_namespaceUnknown namespaceUnknown -> lpVtbl -> Release ( namespaceUnknown ) ; release_namespace lpVtbl -> Release release_locator locator -> lpVtbl -> Release ( locator ) ; SysFreeString ( namespaceName ) ; exit if ( result == NULL ) { return NULL ; } return g_string_free ( result , FALSE ) ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx ( int node , int qlm ) { cvmx_gserx_cfg_t gserx_cfg ; int qlm_mode [ 2 ] [ 9 ] { { - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 } { - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 } } ; ; if ( qlm_mode [ node ] [ qlm ] != - 1 ) { return qlm_mode [ node ] [ qlm ] ; } gserx_cfg . u64 = csr_rd_node ( node , CVMX_GSERX_CFG ( qlm ) ) ; if ( gserx_cfg . s . pcie ) { switch ( qlm ) { case 0 : case 1 : { cvmx_pemx_cfg_t pemx_cfg ; pemx_cfg . u64 = csr_rd_node ( node , CVMX_PEMX_CFG ( 0 ) ) ; if ( pemx_cfg . cn78xx . lanes8 ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE_1X8 ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE ; } break ; } case 2 : { cvmx_pemx_cfg_t pemx_cfg ; pemx_cfg . u64 = csr_rd_node ( node , CVMX_PEMX_CFG ( 2 ) ) ; if ( pemx_cfg . cn78xx . lanes8 ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE_1X8 ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE ; } break ; } case 3 : { cvmx_pemx_cfg_t pemx_cfg ; pemx_cfg . u64 = csr_rd_node ( node , CVMX_PEMX_CFG ( 2 ) ) ; if ( pemx_cfg . cn78xx . lanes8 ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE_1X8 ; } pemx_cfg . u64 = csr_rd_node ( node , CVMX_PEMX_CFG ( 3 ) ) ; if ( pemx_cfg . cn78xx . lanes8 ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE_1X8 ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE ; } break ; } case 4 : { cvmx_pemx_cfg_t pemx_cfg ; pemx_cfg . u64 = csr_rd_node ( node , CVMX_PEMX_CFG ( 3 ) ) ; if ( pemx_cfg . cn78xx . lanes8 ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE_1X8 ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_PCIE ; } break ; } default : qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_DISABLED ; break ; } } if ( gserx_cfg . s . ila ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_ILK ; } if ( gserx_cfg . s . bgx ) { cvmx_bgxx_cmrx_config_t cmr_config ; cvmx_bgxx_spux_br_pmd_control_t pmd_control ; int bgx = ( qlm < 2 ) ?qlm : qlm - 2 ; cmr_config . u64 = csr_rd_node ( node , CVMX_BGXX_CMRX_CONFIG ( 0 , bgx ) ) ; pmd_control . u64 = csr_rd_node ( node , CVMX_BGXX_SPUX_BR_PMD_CONTROL ( 0 , bgx ) ) ; switch ( cmr_config . s . lmac_type ) { case 0 : qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_SGMII ; break ; case 1 : qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_XAUI ; break ; case 2 : qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_RXAUI ; break ; case 3 : if ( pmd_control . s . train_en ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_10G_KR ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_XFI ; } break ; case 4 : if ( pmd_control . s . train_en ) { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_40G_KR4 ; } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_XLAUI ; } break ; default : qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_DISABLED ; break ; } } else { qlm_mode [ node ] [ qlm ] = CVMX_QLM_MODE_DISABLED ; } return qlm_mode [ node ] [ qlm ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void adbhid_input_keycode ( int id , int scancode , int repeat ) { struct adbhid * ahid = adbhid [ id ] ; int keycode , up_flag , key ; keycode = scancode & 0x7f ; up_flag = scancode & 0x80 ; if ( restore_capslock_events ) { if ( keycode == ADB_KEY_CAPSLOCK && ! up_flag ) { if ( ahid -> flags & FLAG_CAPSLOCK_IGNORE_NEXT ) { ahid -> flags &= ~ FLAG_CAPSLOCK_IGNORE_NEXT ; return ; } else { ahid -> flags |= FLAG_CAPSLOCK_TRANSLATE | FLAG_CAPSLOCK_DOWN ; } } if ( scancode == 0xff && ! ( ahid -> flags & FLAG_POWER_KEY_PRESSED ) ) { if ( ahid -> flags & FLAG_CAPSLOCK_TRANSLATE ) { keycode = ADB_KEY_CAPSLOCK ; if ( ahid -> flags & FLAG_CAPSLOCK_DOWN ) { up_flag = 1 ; ahid -> flags &= ~ FLAG_CAPSLOCK_DOWN ; } else { up_flag = 0 ; ahid -> flags &= ~ FLAG_CAPSLOCK_TRANSLATE ; } } else { pr_info ( \"Spurious caps lock event (scancode 0xff).\\n\" ) ; } } } switch ( keycode ) { case ADB_KEY_CAPSLOCK : if ( ! restore_capslock_events ) { input_report_key ( ahid -> input , KEY_CAPSLOCK , 1 ) ; input_sync ( ahid -> input , NULL ) ; input_report_key ( ahid -> input , KEY_CAPSLOCK , 0 ) ; input_sync ( ahid -> input ) ; return ; } break ; case ADB_KEY_POWER_OLD : switch ( pmac_call_feature ( PMAC_FTR_GET_MB_INFO , NULL , PMAC_MB_INFO_MODEL , 0 ) ) { case PMAC_TYPE_COMET : case PMAC_TYPE_HOOPER : case PMAC_TYPE_KANGA : keycode = ADB_KEY_POWER ; } break ; case ADB_KEY_POWER : if ( up_flag ) { ahid -> flags &= ~ FLAG_POWER_KEY_PRESSED ; } else { ahid -> flags |= FLAG_POWER_KEY_PRESSED ; } if ( ahid -> flags & FLAG_FN_KEY_PRESSED ) { keycode = ADB_KEY_CMD ; if ( up_flag ) { ahid -> flags &= ~ FLAG_POWER_FROM_FN ; } else { ahid -> flags |= FLAG_POWER_FROM_FN ; } } if ( ahid -> flags & FLAG_POWER_FROM_FN ) { keycode = ADB_KEY_CMD ; ahid -> flags &= ~ FLAG_POWER_FROM_FN ; } break ; case ADB_KEY_FN : if ( up_flag ) { ahid -> flags &= ~ FLAG_FN_KEY_PRESSED ; if ( ahid -> flags & FLAG_EMU_FWDEL_DOWN ) { ahid -> flags &= ~ FLAG_EMU_FWDEL_DOWN ; keycode = ADB_KEY_FWDEL ; break ; } } else { ahid -> flags |= FLAG_FN_KEY_PRESSED ; } break ; case ADB_KEY_DEL : if ( ahid -> flags & FLAG_FN_KEY_PRESSED ) { keycode = ADB_KEY_FWDEL ; if ( up_flag ) { ahid -> flags &= ~ FLAG_EMU_FWDEL_DOWN ; } else { ahid -> flags |= FLAG_EMU_FWDEL_DOWN ; } } break ; } key = adbhid [ id ] -> keycode [ keycode ] ; if ( key ) { input_report_key ( adbhid [ id ] -> input , key , ! up_flag ) ; input_sync ( adbhid [ id ] -> input ) ; } else { pr_info ( \"Unhandled ADB key (scancode %#02x) %s.\\n\" , keycode , up_flag ?\"released\" : \"pressed\" ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int wdt87xx_validate_fw_chunk ( const void * data , int id ) { if ( id == CHUNK_ID_FRWR ) { u32 fw_id ; fw_id = get_unaligned_le32 ( data + FW_CHUNK_PAYLOAD_OFFSET ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void set_terminated ( struct expression * expr , struct smatch_state * state ) { struct symbol * sym ; char * name ; name = expr_to_var_sym ( expr , & sym ) ; set_terminated_var_sym ( name , sym , state ) ; free_string ( name ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "long blkdev_ioctl ( struct file * file , unsigned cmd , unsigned long arg ) { struct block_device * bdev = I_BDEV ( file -> f_mapping -> host ) ; void __user * argp = ( void __user * ) arg ; fmode_t mode = file -> f_mode ; int ret ; if ( file -> f_flags & O_NDELAY ) { mode |= FMODE_NDELAY ; } else { mode &= ~ FMODE_NDELAY ; } switch ( cmd ) { case HDIO_GETGEO : return blkdev_getgeo ( bdev , argp ) ; case BLKPG : return blkpg_ioctl ( bdev , argp ) ; case BLKRAGET : case BLKFRAGET : if ( ! argp ) { return - EINVAL ; } return put_long ( argp , ( bdev -> bd_disk -> bdi -> ra_pages * PAGE_SIZE ) / 512 ) ; case BLKGETSIZE : return put_ulong ( argp , bdev_nr_sectors ( bdev ) ) ; case BLKBSZGET : return put_int ( argp , block_size ( bdev ) ) ; case BLKBSZSET : return blkdev_bszset ( bdev , mode , argp ) ; case BLKGETSIZE64 : return put_u64 ( argp , bdev_nr_bytes ( bdev ) ) ; case BLKTRACESETUP : return blk_trace_ioctl ( bdev , cmd , argp ) ; default : break ; } ret = blkdev_common_ioctl ( file , mode , cmd , arg , argp ) ; if ( ret != - ENOIOCTLCMD ) { return ret ; } if ( ! bdev -> bd_disk -> fops -> ioctl ) { return - ENOTTY ; } return bdev -> bd_disk -> fops -> ioctl ( bdev , mode , cmd , arg ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void otx2_cptlf_unregister_interrupts ( struct otx2_cptlfs_info * lfs ) { int i , offs , vector ; for ( i = 0 ; i < lfs -> lfs_num ; i ++ ) { for ( offs = 0 ; offs < OTX2_CPT_LF_MSIX_VECTORS ; offs ++ ) { vector = pci_irq_vector ( lfs -> pdev , lfs -> lf [ i ] . msix_offset + offs ) ; free_irq ( vector , & lfs -> lf [ i ] ) ; lfs -> lf [ i ] . is_irq_reg [ offs ] = false ; } } cptlf_disable_intrs ( lfs ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void G_ExplodeMissile ( gentity_t * ent ) { vec3_t dir ; vec3_t origin ; qboolean small = qfalse ; qboolean zombiespit = qfalse ; BG_EvaluateTrajectory ( & ent -> s . pos , level . time , origin ) ; SnapVector ( origin , NULL ) ; G_SetOrigin ( ent , origin ) ; dir [ 0 ] = dir [ 1 ] = 0 ; dir [ 2 ] = 1 ; ent -> s . eType = ET_GENERAL ; if ( ! Q_stricmp ( ent -> classname , \"props_explosion\" ) ) { G_AddEvent ( ent , EV_MISSILE_MISS_SMALL , DirToByte ( dir ) ) ; small = qtrue ; } if ( ! Q_stricmp ( ent -> classname , \"air strike\" ) ) { G_AddEvent ( ent , EV_MISSILE_MISS_LARGE , DirToByte ( dir ) ) ; small = qfalse ; } if ( ! Q_stricmp ( ent -> classname , \"props_explosion_large\" ) ) { G_AddEvent ( ent , EV_MISSILE_MISS_LARGE , DirToByte ( dir ) ) ; small = qfalse ; } if ( ! Q_stricmp ( ent -> classname , \"zombiespit\" ) ) { G_AddEvent ( ent , EV_SPIT_MISS , DirToByte ( dir ) ) ; zombiespit = qtrue ; } if ( ! Q_stricmp ( ent -> classname , \"flamebarrel\" ) ) { ent -> freeAfterEvent = qtrue ; trap_LinkEntity ( ent ) ; return ; } else { G_AddEvent ( ent , EV_MISSILE_MISS , DirToByte ( dir ) ) ; } ent -> freeAfterEvent = qtrue ; if ( ent -> splashDamage ) { if ( G_RadiusDamage ( ent -> r . currentOrigin , ent -> parent , ent -> splashDamage , ent -> splashRadius , ent , ent -> splashMethodOfDeath ) ) { if ( g_entities [ ent -> r . ownerNum ] . client ) { g_entities [ ent -> r . ownerNum ] . client -> ps . persistant [ PERS_ACCURACY_HITS ] ++ ; } } } trap_LinkEntity ( ent ) ; if ( ! zombiespit ) { gentity_t * Msmoke ; Msmoke = G_Spawn ( ) ; VectorCopy ( ent -> r . currentOrigin , Msmoke -> s . origin ) ; if ( small ) { Msmoke -> s . density = 1 ; } Msmoke -> think = M_think ; Msmoke -> nextthink = level . time + FRAMETIME ; if ( ent -> parent && ! Q_stricmp ( ent -> parent -> classname , \"props_flamebarrel\" ) ) { Msmoke -> health = 10 ; } else { Msmoke -> health = 5 ; } Concussive_fx ( Msmoke -> s . origin ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void blkid_probe_free_value ( struct blkid_prval * v ) { if ( ! v ) { return ; } list_del ( & v -> prvals ) ; free ( v -> data ) ; DBG ( LOWPROBE , ul_debug ( \" free value %s\" , v -> name ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cmd_banner_motd_file ( const char * file ) { int success = CMD_SUCCESS ; char p [ PATH_MAX ] ; char * rpath ; char * in ; rpath = realpath ( file , p ) ; in = strstr ( rpath , SYSCONFDIR ) ; if ( in == rpath ) { XFREE ( MTYPE_HOST , host . motdfile ) ; host . motdfile = XSTRDUP ( MTYPE_HOST , file ) ; } else { success = CMD_WARNING_CONFIG_FAILED ; } return success ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tcmu_genl_set_features ( struct sk_buff * skb , struct genl_info * info ) { if ( info -> attrs [ TCMU_ATTR_SUPP_KERN_CMD_REPLY ] ) { tcmu_kern_cmd_reply_supported = nla_get_u8 ( info -> attrs [ TCMU_ATTR_SUPP_KERN_CMD_REPLY ] , NULL ) ; printk ( KERN_INFO \"tcmu daemon: command reply support %u.\\n\" , tcmu_kern_cmd_reply_supported ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fd_close ( int fd , void * d ) { struct fd_chan * data = d ; int err ; CATCH_EINTR ( err = tcsetattr ( fd , TCSAFLUSH , & data -> tt ) ) ; if ( err ) { printk ( UM_KERN_ERR \"Failed to restore terminal state - \" \"errno = %d\\n\" , - err ) ; } data -> raw = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ieee80211_set_smps ( struct ieee80211_sub_if_data * sdata , enum ieee80211_smps_mode smps_mode ) { struct ieee80211_local * local = sdata -> local ; int err ; if ( ! ( local -> hw . wiphy -> features & NL80211_FEATURE_DYNAMIC_SMPS ) && ( smps_mode == IEEE80211_SMPS_DYNAMIC || smps_mode == IEEE80211_SMPS_AUTOMATIC ) ) { return - EINVAL ; } if ( sdata -> vif . type != NL80211_IFTYPE_STATION ) { return - EOPNOTSUPP ; } sdata_lock ( sdata ) ; err = __ieee80211_request_smps_mgd ( sdata , & sdata -> deflink , smps_mode ) ; sdata_unlock ( sdata ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void free_symbol_table ( void ) { symbol_table = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void checkformerr ( sldns_buffer * pkt ) { int status = 0 ; char * s = sldns_wire2str_pkt ( sldns_buffer_begin ( pkt ) , sldns_buffer_limit ( pkt ) ) ; if ( ! s ) { fatal_exit ( \"out of memory\" ) ; } if ( strstr ( s , \"Error\" ) ) { status = 1 ; } if ( strstr ( s , \"error\" ) ) { status = 1 ; } if ( status == 0 ) { printf ( \"Formerr, but ldns gives packet:\\n\" ) ; printf ( \"%s\\n\" , s ) ; exit ( 1 ) ; } free ( s ) ; unit_assert ( status != 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "u32 mt76_mac_process_rx ( struct mt7601u_dev * dev , struct sk_buff * skb , u8 * data , void * rxi ) { struct ieee80211_rx_status * status = IEEE80211_SKB_RXCB ( skb ) ; struct mt7601u_rxwi * rxwi = rxi ; u32 len , ctl = le32_to_cpu ( rxwi -> ctl ) ; u16 rate = le16_to_cpu ( rxwi -> rate ) ; int rssi ; len = FIELD_GET ( MT_RXWI_CTL_MPDU_LEN , ctl ) ; if ( rxwi -> rxinfo & cpu_to_le32 ( MT_RXINFO_DECRYPT ) ) { status -> flag |= RX_FLAG_DECRYPTED ; status -> flag |= RX_FLAG_MMIC_STRIPPED ; status -> flag |= RX_FLAG_MIC_STRIPPED ; status -> flag |= RX_FLAG_ICV_STRIPPED ; status -> flag |= RX_FLAG_IV_STRIPPED ; } if ( rxwi -> rxinfo & cpu_to_le32 ( MT_RXINFO_PN_LEN ) ) { status -> flag &= ~ RX_FLAG_IV_STRIPPED ; } status -> chains = BIT ( 0 ) ; rssi = mt7601u_phy_get_rssi ( dev , rxwi , rate ) ; status -> chain_signal [ 0 ] = status -> signal = rssi ; status -> freq = dev -> chandef . chan -> center_freq ; status -> band = dev -> chandef . chan -> band ; mt76_mac_process_rate ( status , rate ) ; spin_lock_bh ( & dev -> con_mon_lock ) ; if ( mt7601u_rx_is_our_beacon ( dev , data ) ) { mt7601u_rx_monitor_beacon ( dev , rxwi , rate , rssi ) ; } if ( rxwi -> rxinfo & cpu_to_le32 ( MT_RXINFO_U2M ) ) { ewma_rssi_add ( & dev -> avg_rssi , - rssi ) ; } spin_unlock_bh ( & dev -> con_mon_lock ) ; return len ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ezport_firmware_flash_data ( struct spi_device * spi , const u8 * data , size_t size ) { int ret ; size_t address = 0 ; size_t transfer_size ; dev_dbg ( & spi -> dev , \"EzPort flash data with %zu bytes...\\n\" , size ) ; ret = ezport_get_status_register ( spi ) ; if ( ret & EZPORT_STATUS_FS ) { ret = ezport_bulk_erase ( spi ) ; if ( ret < 0 ) { return ret ; } if ( ret & EZPORT_STATUS_FS ) { return - EINVAL ; } } while ( size - address > 0 ) { if ( ! ( address & EZPORT_SECTOR_MASK ) ) { ret = ezport_section_erase ( spi , address ) ; if ( ret < 0 ) { return ret ; } if ( ret & EZPORT_STATUS_WIP || ret & EZPORT_STATUS_WEF ) { return - EIO ; } } transfer_size = min ( ( size_t ) EZPORT_TRANSFER_SIZE , size - address ) ; ret = ezport_flash_transfer ( spi , address , data + address , transfer_size ) ; if ( ret < 0 ) { return ret ; } if ( ret & EZPORT_STATUS_WIP ) { return - ETIMEDOUT ; } if ( ret & EZPORT_STATUS_WEF ) { return - EIO ; } address += transfer_size ; } dev_dbg ( & spi -> dev , \"EzPort verify flashed data...\\n\" ) ; ret = ezport_firmware_compare_data ( spi , data , size ) ; if ( ret == - EACCES ) { ret = 0 ; } if ( ret < 0 ) { dev_err ( & spi -> dev , \"Failed to verify flashed data: %d\\n\" , ret ) ; } ret = ezport_soft_reset ( spi ) ; if ( ret < 0 ) { dev_warn ( & spi -> dev , \"EzPort reset failed!\\n\" ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct clk * _register_divider ( struct device * dev , const char * name , const char * parent_name , unsigned long flags , void __iomem * reg , u8 shift , u8 width , u8 clk_divider_flags , const struct clk_div_table * table ) { struct clk_divider * div ; struct clk * clk ; int ret ; if ( clk_divider_flags & CLK_DIVIDER_HIWORD_MASK ) { if ( width + shift > 16 ) { dev_warn ( dev , \"divider value exceeds LOWORD field\\n\" ) ; return ERR_PTR ( - EINVAL ) ; } } div = kzalloc ( sizeof ( * div ) , GFP_KERNEL ) ; if ( ! div ) { return ERR_PTR ( - ENOMEM ) ; } div -> reg = reg ; div -> shift = shift ; div -> width = width ; div -> flags = clk_divider_flags ; div -> table = table ; div -> io_divider_val = * ( u32 * ) reg ; clk = & div -> clk ; clk -> flags = flags ; ret = clk_register ( clk , UBOOT_DM_CLK_CCF_DIVIDER , name , parent_name ) ; if ( ret ) { return ERR_PTR ( ret ) ; } return clk ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void remove_trailing_rmap_items ( struct ksm_rmap_item * * rmap_list ) { while ( * rmap_list ) { struct ksm_rmap_item * rmap_item = * rmap_list ; * rmap_list = rmap_item -> rmap_list ; remove_rmap_item_from_tree ( rmap_item , NULL ) ; free_rmap_item ( rmap_item ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int set_param ( char * name , char * value ) { struct param_ptr * p ; double ppc ; p = search_param ( name ) ; if ( p == NULL ) { return 0 ; } switch ( p -> type ) { case P_INT : if ( atoi ( value ) >= 0 ) { * ( int * ) p -> varptr = ( p -> inputtype == PI_ONOFF ) ?str_to_bool ( value , * ( int * ) p -> varptr ) : atoi ( value ) ; } break ; case P_NZINT : if ( atoi ( value ) > 0 ) { * ( int * ) p -> varptr = atoi ( value ) ; } break ; case P_SHORT : * ( short * ) p -> varptr = ( p -> inputtype == PI_ONOFF ) ?str_to_bool ( value , * ( short * ) p -> varptr ) : atoi ( value ) ; break ; case P_CHARINT : * ( char * ) p -> varptr = ( p -> inputtype == PI_ONOFF ) ?str_to_bool ( value , * ( char * ) p -> varptr ) : atoi ( value ) ; break ; case P_CHAR : * ( char * ) p -> varptr = value [ 0 ] ; break ; case P_STRING : * ( char * * ) p -> varptr = value ; break ; case P_SSLPATH : if ( value != NULL && value [ 0 ] != '\\0' ) { * ( char * * ) p -> varptr = rcFile ( value ) ; } else { * ( char * * ) p -> varptr = NULL ; } ssl_path_modified = 1 ; break ; case P_COLOR : * ( int * ) p -> varptr = str_to_color ( value ) ; break ; case P_CODE : * ( wc_ces * ) p -> varptr = wc_guess_charset_short ( value , * ( wc_ces * ) p -> varptr ) ; break ; case P_PIXELS : ppc = atof ( value ) ; if ( ppc >= MINIMUM_PIXEL_PER_CHAR && ppc <= MAXIMUM_PIXEL_PER_CHAR * 2 ) { * ( double * ) p -> varptr = ppc ; } break ; case P_SCALE : ppc = atof ( value ) ; if ( ppc >= 10 && ppc <= 1000 ) { * ( double * ) p -> varptr = ppc ; } break ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sticon_putc ( struct vc_data * conp , int c , int ypos , int xpos ) { int redraw_cursor = 0 ; if ( conp -> vc_mode != KD_TEXT ) { return ; } if ( ( p -> cursor_x == xpos ) && ( p -> cursor_y == ypos ) ) { cursor_undrawn ( ) ; redraw_cursor = 1 ; } sti_putc ( sticon_sti , c , ypos , xpos ) ; if ( redraw_cursor ) { vbl_cursor_cnt = CURSOR_DRAW_DELAY ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct bnxt_qplib_rcfw_sbuf * bnxt_qplib_rcfw_alloc_sbuf ( struct bnxt_qplib_rcfw * rcfw , u32 size ) { struct bnxt_qplib_rcfw_sbuf * sbuf ; sbuf = kzalloc ( sizeof ( * sbuf ) , GFP_KERNEL ) ; if ( ! sbuf ) { return in ; } sbuf -> size = size ; sbuf -> sb = dma_alloc_coherent ( & rcfw -> pdev -> dev , sbuf -> size , & sbuf -> dma_addr , GFP_KERNEL ) ; if ( ! sbuf -> sb ) { bail } return sbuf ; bail kfree ( sbuf ) ; return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int testVirPCIDeviceGetVPD ( const void * opaque ) { const struct testPCIDevData * data = opaque ; g_autoptr ( ) dev = NULL ; virPCIDeviceAddress devAddr = { . domain = data -> domain . bus = data -> bus . slot = data -> slot . function = data -> function } ; g_autoptr ( ) res = NULL ; dev = virPCIDeviceNew ( & devAddr ) ; res = virPCIDeviceGetVPD ( dev ) ; if ( res -> ro == NULL ) { return - 1 ; } if ( STRNEQ ( res -> name , \"testname\" ) ) { VIR_TEST_DEBUG ( \"Unexpected name present in VPD: %s\" , res -> name ) ; return - 1 ; } if ( STRNEQ ( res -> ro -> part_number , \"42\" ) ) { VIR_TEST_DEBUG ( \"Unexpected part number value present in VPD: %s\" , res -> ro -> part_number ) ; return - 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void filewclose ( File * f ) { if ( ! f ) { return ; } if ( ! f -> iswopen ) { return ; } if ( f -> free ) { if ( ftruncate ( f -> fd , f -> w -> filesize - f -> free ) != 0 ) { twarn ( \"ftruncate\" ) ; } } if ( close ( f -> fd ) == - 1 ) { twarn ( \"close\" ) ; } f -> iswopen = 0 ; filedecref ( f ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xnf_kstat_aux_update ( kstat_t * ksp , int flag ) { xnf_t * xnfp ; kstat_named_t * knp ; xnfp = ksp -> ks_private ; knp = ksp -> ks_data ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_tx_cksum_deferred ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_rx_cksum_no_need ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_interrupts ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_unclaimed_interrupts ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_tx_pullup ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_tx_lookaside ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_tx_drop ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_tx_eth_hdr_split ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_buf_allocated ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_buf_outstanding ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_gref_outstanding ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_gref_failure ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_gref_peak ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_rx_allocb_fail ; ( knp ++ ) -> value . ui64 = xnfp -> xnf_stat_rx_desballoc_fail ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nmk_i2c_suspend_late ( struct device * dev ) { int ret ; ret = pm_runtime_force_suspend ( dev ) ; pinctrl_pm_select_sleep_state ( dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static Boolean stack_resize ( generic_stack_t * stack , size_t n_default , size_t elt_size ) { size_t new_n_alloc ; void * newaddr ; new_n_alloc = ( stack -> stk_n_alloc == 0 ) ?n_default : ( stack -> stk_n_alloc * 2 ) ; newaddr = libld_realloc ( stack -> stk_s , new_n_alloc * elt_size ) ; stack -> stk_s = newaddr ; stack -> stk_n_alloc = new_n_alloc ; return ( TRUE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct mlxfw_mfa2_file * mlxfw_mfa2_file_init ( const struct firmware * fw ) { const struct mlxfw_mfa2_tlv_package_descriptor * pd ; const struct mlxfw_mfa2_tlv_multi * multi ; const struct mlxfw_mfa2_tlv * multi_child ; const struct mlxfw_mfa2_tlv * first_tlv ; struct mlxfw_mfa2_file * mfa2_file ; const void * first_tlv_ptr ; const void * cb_top_ptr ; mfa2_file = kmalloc ( sizeof ( * mfa2_file ) , GFP_KERNEL ) ; if ( ! mfa2_file ) { return ERR_PTR ( - ENOMEM ) ; } mfa2_file -> fw = fw ; first_tlv_ptr = fw -> data + NLA_ALIGN ( mlxfw_mfa2_fingerprint_len ) ; first_tlv = mlxfw_mfa2_tlv_get ( mfa2_file , first_tlv_ptr ) ; if ( ! first_tlv ) { pr_err ( \"Could not parse package descriptor TLV\\n\" ) ; err_out } multi = mlxfw_mfa2_tlv_multi_get ( mfa2_file , first_tlv ) ; if ( ! multi ) { pr_err ( \"First TLV is not of valid multi type\\n\" ) ; err_out } multi_child = mlxfw_mfa2_tlv_multi_child ( mfa2_file , multi ) ; if ( ! multi_child ) { err_out } pd = mlxfw_mfa2_tlv_package_descriptor_get ( mfa2_file , multi_child ) ; if ( ! pd ) { pr_err ( \"Could not parse package descriptor TLV\\n\" ) ; err_out } mfa2_file -> first_dev = mlxfw_mfa2_tlv_next ( mfa2_file , first_tlv ) ; if ( ! mfa2_file -> first_dev ) { pr_err ( \"First device TLV is not valid\\n\" ) ; err_out } mfa2_file -> dev_count = be16_to_cpu ( pd -> num_devices ) ; mfa2_file -> first_component = mlxfw_mfa2_tlv_advance ( mfa2_file , mfa2_file -> first_dev , mfa2_file -> dev_count ) ; mfa2_file -> component_count = be16_to_cpu ( pd -> num_components ) ; mfa2_file -> cb = fw -> data + NLA_ALIGN ( be32_to_cpu ( pd -> cb_offset ) ) ; if ( ! mlxfw_mfa2_valid_ptr ( mfa2_file , mfa2_file -> cb ) ) { pr_err ( \"Component block is out side the file\\n\" ) ; err_out } mfa2_file -> cb_archive_size = be32_to_cpu ( pd -> cb_archive_size ) ; cb_top_ptr = mfa2_file -> cb + mfa2_file -> cb_archive_size - 1 ; if ( ! mlxfw_mfa2_valid_ptr ( mfa2_file , cb_top_ptr ) ) { pr_err ( \"Component block size is too big\\n\" ) ; err_out } if ( ! mlxfw_mfa2_file_validate ( mfa2_file ) ) { err_out } return mfa2_file ; err_out kfree ( mfa2_file ) ; return ERR_PTR ( - EINVAL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int prestera_flower_parse_goto_action ( struct prestera_flow_block * block , struct prestera_acl_rule * rule , u32 chain_index , const struct flow_action_entry * act ) { struct prestera_acl_ruleset * ruleset ; if ( rule -> re_arg . jump . valid ) { return - EEXIST ; } ruleset = prestera_acl_ruleset_get ( block -> sw -> acl , block , act -> chain_index ) ; if ( IS_ERR ( ruleset ) ) { return PTR_ERR ( ruleset ) ; } rule -> re_arg . jump . valid = 1 ; rule -> re_arg . jump . i . index = prestera_acl_ruleset_index_get ( ruleset ) ; rule -> jump_ruleset = ruleset ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ssl_kex_peer_public_dhe ( DH * dh , CBS * cbs , int * decode_error , int * invalid_key ) { BIGNUM * pub_key = NULL ; int check_flags ; CBS dh_y ; int ret ; * decode_error = 0 ; * invalid_key = 0 ; if ( ! CBS_get_u16_length_prefixed ( cbs , & dh_y ) ) { * decode_error = 1 ; err } if ( ( pub_key = BN_bin2bn ( CBS_data ( & dh_y ) , CBS_len ( & dh_y ) , NULL ) ) == NULL ) { err } if ( ! DH_set0_key ( dh , pub_key , NULL ) ) { err } pub_key = NULL ; if ( ! DH_check_pub_key ( dh , DH_get0_pub_key ( dh ) , & check_flags ) ) { err } if ( check_flags != 0 ) { * invalid_key = 1 ; } ret = 1 ; err BN_free ( pub_key ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char jsvStringIteratorGetCharAndNext ( JsvStringIterator * it ) { char ch = jsvStringIteratorGetChar ( it ) ; jsvStringIteratorNextInline ( it , NULL ) ; return ch ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int imx8mq_phy_power_off ( struct phy * phy ) { struct imx8mq_usb_phy * imx_phy = phy_get_drvdata ( phy ) ; clk_disable_unprepare ( imx_phy -> clk ) ; regulator_disable ( imx_phy -> vbus , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void bfin_rx_hwtstamp ( struct net_device * netdev , struct sk_buff * skb ) { struct bfin_mac_local * lp = netdev_priv ( netdev ) ; u32 valid ; u64 regval , ns ; struct skb_shared_hwtstamps * shhwtstamps ; valid = bfin_read_EMAC_PTP_ISTAT ( ) & RXEL ; if ( ! valid ) { return ; } shhwtstamps = skb_hwtstamps ( skb ) ; regval = bfin_read_EMAC_PTP_RXSNAPLO ( ) ; regval |= ( u64 ) bfin_read_EMAC_PTP_RXSNAPHI ( ) << 32 ; ns = regval << lp -> shift ; memset ( shhwtstamps , 0 , sizeof ( * shhwtstamps ) ) ; shhwtstamps -> hwtstamp = ns_to_ktime ( ns ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void machfb_copyrect ( struct machfb_softc * sc , int sx , int sy , int dx , int dy , int w , int h ) { uint32_t dest_ctl = 0 ; machfb_wait_fifo ( sc , 10 ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DP_WRITE_MASK , 0xff ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DP_SRC , M64_FRGD_SRC_BLIT ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DP_MIX , M64_MIX_SRC << 16 ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_CLR_CMP_CNTL , 0 ) ; if ( dy < sy ) { dest_ctl = M64_DST_Y_TOP_TO_BOTTOM ; } else { sy += h - 1 ; dy += h - 1 ; dest_ctl = M64_DST_Y_BOTTOM_TO_TOP ; } if ( dx < sx ) { dest_ctl |= M64_DST_X_LEFT_TO_RIGHT ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_SRC_CNTL , M64_SRC_LINE_X_LEFT_TO_RIGHT ) ; } else { dest_ctl |= M64_DST_X_RIGHT_TO_LEFT ; sx += w - 1 ; dx += w - 1 ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_SRC_CNTL , M64_SRC_LINE_X_RIGHT_TO_LEFT ) ; } bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DST_CNTL , dest_ctl ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_SRC_Y_X , M64_COORDS ( sx , sy ) ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_SRC_WIDTH1 , w ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DST_Y_X , M64_COORDS ( dx , dy ) ) ; bus_space_write_4 ( sc -> sc_regt , sc -> sc_regh , M64_DST_HEIGHT_WIDTH , M64_COORDS ( w , h ) ) ; machfb_wait ( sc , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int count_dir_entries ( const char * dirname ) { DIR * dir = opendir ( dirname ) ; int len = 0 ; struct dirent * d ; if ( ! dir ) { return 0 ; } while ( ( d = readdir ( dir ) ) ) { if ( ! strcmp ( d -> d_name , \"..\" ) || ! strcmp ( d -> d_name , \".\" ) ) { continue ; } len ++ ; } closedir ( dir , NULL ) ; return len ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct drm_display_mode * amdgpu_connector_lcd_native_mode ( struct drm_encoder * encoder ) { struct drm_device * dev = encoder -> dev ; struct amdgpu_encoder * amdgpu_encoder = to_amdgpu_encoder ( encoder ) ; struct drm_display_mode * mode = NULL ; struct drm_display_mode * native_mode = & amdgpu_encoder -> native_mode ; if ( native_mode -> hdisplay != 0 && native_mode -> vdisplay != 0 && native_mode -> clock != 0 ) { mode = drm_mode_duplicate ( dev , native_mode ) ; if ( ! mode ) { return in ; } mode -> type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER ; drm_mode_set_name ( mode ) ; DRM_DEBUG_KMS ( \"Adding native panel mode %s\\n\" , mode -> name ) ; } if ( native_mode -> hdisplay != 0 && native_mode -> vdisplay != 0 ) { mode = drm_cvt_mode ( dev , native_mode -> hdisplay , native_mode -> vdisplay , 60 , true , false , false ) ; if ( ! mode ) { return NULL ; } mode -> type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER ; DRM_DEBUG_KMS ( \"Adding cvt approximation of native panel mode %s\\n\" , mode -> name ) ; } return mode ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void armada510_crtc_disable ( struct armada_crtc * dcrtc ) { if ( dcrtc -> clk ) { clk_disable_unprepare ( dcrtc -> clk , NULL ) ; dcrtc -> clk = NULL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void rereadpt ( int fd , const char * devname ) { struct stat st ; int try = 0 ; if ( fstat ( fd , & st ) || ! S_ISBLK ( st . st_mode ) ) { return ; } { xusleep ( 250000 ) ; ioctl ( fd , BLKRRPART ) ; if ( errno != EBUSY ) { break ; } } try ++ < 4 ; printf ( _ ( \"%s: calling ioctl to re-read partition table: %m\\n\" ) , devname ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dz_startup ( struct uart_port * uport ) { struct dz_port * dport = to_dport ( uport ) ; struct dz_mux * mux = dport -> mux ; unsigned long flags ; int irq_guard ; int ret ; u16 tmp ; irq_guard = atomic_add_return ( 1 , & mux -> irq_guard ) ; ret = request_irq ( dport -> port . irq , dz_interrupt , IRQF_SHARED , \"dz\" , mux ) ; if ( ret ) { atomic_add ( - 1 , & mux -> irq_guard ) ; printk ( KERN_ERR \"dz: Cannot get IRQ %d!\\n\" , dport -> port . irq ) ; return ret ; } spin_lock_irqsave ( & dport -> port . lock , flags ) ; tmp = dz_in ( dport , DZ_CSR ) ; tmp |= DZ_RIE | DZ_TIE ; dz_out ( dport , DZ_CSR , tmp ) ; spin_unlock_irqrestore ( & dport -> port . lock , flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ohci_handle_root_hub_pipe_open ( usba_pipe_handle_data_t * ph , usb_flags_t usb_flags ) { ohci_state_t * ohcip = ohci_obtain_state ( ph -> p_usba_device -> usb_root_hub_dip ) ; usb_ep_descr_t * eptd = & ph -> p_ep ; USB_DPRINTF_L4 ( PRINT_MASK_ROOT_HUB , ohcip -> ohci_log_hdl , \"ohci_handle_root_hub_pipe_open: Root hub pipe open\" ) ; ASSERT ( mutex_owned ( & ohcip -> ohci_int_mutex ) ) ; switch ( eptd -> bmAttributes & USB_EP_ATTR_MASK ) { case USB_EP_ATTR_CONTROL : ohcip -> ohci_root_hub . rh_ctrl_pipe_handle = ph ; ohcip -> ohci_root_hub . rh_ctrl_pipe_state = OHCI_PIPE_STATE_IDLE ; USB_DPRINTF_L4 ( PRINT_MASK_ROOT_HUB , ohcip -> ohci_log_hdl , \"ohci_handle_root_hub_pipe_open: Root hub control \" \"pipe open succeeded\" ) ; break ; case USB_EP_ATTR_INTR : ohcip -> ohci_root_hub . rh_intr_pipe_handle = ph ; ohcip -> ohci_root_hub . rh_intr_pipe_state = OHCI_PIPE_STATE_IDLE ; ohcip -> ohci_root_hub . rh_client_intr_reqp = NULL ; ohcip -> ohci_root_hub . rh_curr_intr_reqp = NULL ; USB_DPRINTF_L4 ( PRINT_MASK_ROOT_HUB , ohcip -> ohci_log_hdl , \"ohci_handle_root_hub_pipe_open: Root hub interrupt \" \"pipe open succeeded\" ) ; break ; default : USB_DPRINTF_L2 ( PRINT_MASK_ROOT_HUB , ohcip -> ohci_log_hdl , \"ohci_handle_root_hub_pipe_open: Root hub pipe open\" \"failed\" ) ; return ( USB_FAILURE ) ; } ohcip -> ohci_open_pipe_count ++ ; return ( USB_SUCCESS ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int intel_lpss_assign_devs ( struct intel_lpss * lpss ) { const struct mfd_cell * cell ; unsigned int type ; type = lpss -> caps & LPSS_PRIV_CAPS_TYPE_MASK ; type >>= LPSS_PRIV_CAPS_TYPE_SHIFT ; switch ( type ) { case LPSS_DEV_I2C : cell = & intel_lpss_i2c_cell ; break ; case LPSS_DEV_UART : cell = & intel_lpss_uart_cell ; break ; case LPSS_DEV_SPI : cell = & intel_lpss_spi_cell ; break ; default : return - ENODEV ; } lpss -> cell = devm_kmemdup ( lpss -> dev , cell , sizeof ( * cell ) , GFP_KERNEL ) ; lpss -> type = type ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tmp51x_probe ( struct i2c_client * client ) { struct device * dev = & client -> dev ; struct tmp51x_data * data ; struct device * hwmon_dev ; int ret ; data = devm_kzalloc ( dev , sizeof ( * data ) , GFP_KERNEL ) ; if ( client -> dev . of_node ) { data -> id = ( tmp51x_ids ) device_get_match_data ( & client -> dev ) ; } else { data -> id = i2c_match_id ( tmp51x_id , client ) -> driver_data ; } ret = tmp51x_configure ( dev , data ) ; if ( ret < 0 ) { dev_err ( dev , \"error configuring the device: %d\\n\" , ret ) ; return ret ; } data -> regmap = devm_regmap_init_i2c ( client , & tmp51x_regmap_config ) ; if ( IS_ERR ( data -> regmap ) ) { dev_err ( dev , \"failed to allocate register map\\n\" ) ; return PTR_ERR ( data -> regmap ) ; } ret = tmp51x_init ( data ) ; if ( ret < 0 ) { dev_err ( dev , \"error configuring the device: %d\\n\" , ret ) ; return - ENODEV ; } hwmon_dev = devm_hwmon_device_register_with_info ( dev , client -> name , data , & tmp51x_chip_info , NULL ) ; if ( IS_ERR ( hwmon_dev ) ) { return PTR_ERR ( hwmon_dev ) ; } dev_dbg ( dev , \"power monitor %s\\n\" , client -> name ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int fls_impl ( uint64_t bits ) { int i = 1 ; int bits32 ; if ( bits == 0 ) { return ( 0 ) ; } if ( ( bits32 = ( uint32_t ) ( bits >> 32 ) ) != 0 ) { i += 32 ; } else { bits32 = ( uint32_t ) bits ; } if ( ( bits32 & 0xffff0000 ) != 0 ) { bits32 >>= 16 ; i += 16 ; } if ( ( bits32 & 0xff00 ) != 0 ) { bits32 >>= 8 ; i += 8 ; } if ( ( bits32 & 0xf0 ) != 0 ) { bits32 >>= 4 ; i += 4 ; } if ( ( bits32 & 0xc ) != 0 ) { bits32 >>= 2 ; i += 2 ; } if ( ( bits32 & 0x2 ) != 0 ) { i += 1 ; } return ( i ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "rpmKeyring rpmKeyringNew ( void ) { rpmKeyring keyring = xcalloc ( 1 , sizeof ( * keyring ) ) ; keyring -> keys = NULL ; keyring -> numkeys = 0 ; pthread_rwlock_init ( & keyring -> lock , NULL ) ; return keyring ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "obj_coff_val ( ) { if ( def_symbol_in_progress == NULL ) { as_warn ( _ ( \".val pseudo-op used outside of .def/.endef ignored.\" ) ) ; demand_empty_rest_of_line ( ) ; return ; } if ( is_name_beginner ( * input_line_pointer ) ) { char * symbol_name = input_line_pointer ; char name_end = get_symbol_end ( ) ; symbol_name = tc_canonicalize_symbol_name ( symbol_name ) ; if ( streq ( symbol_name , \".\" ) ) { symbol_set_frag ( def_symbol_in_progress , frag_now ) ; S_SET_VALUE ( def_symbol_in_progress , ( valueT ) frag_now_fix ( ) ) ; } if ( ! streq ( S_GET_NAME ( def_symbol_in_progress ) , symbol_name ) ) { expressionS exp ; exp . X_op = O_symbol ; exp . X_add_symbol = symbol_find_or_make ( symbol_name ) ; exp . X_add_number = 0 ; symbol_set_value_expression ( def_symbol_in_progress , & exp ) ; SF_SET_GET_SEGMENT ( def_symbol_in_progress ) ; } * input_line_pointer = name_end ; } else { S_SET_VALUE ( def_symbol_in_progress , get_absolute_expression ( ) ) ; } demand_empty_rest_of_line ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int is_pure_ops_struct ( const_tree node ) { const_tree field ; gcc_assert ( TREE_CODE ( node ) == RECORD_TYPE || TREE_CODE ( node ) == UNION_TYPE ) ; for ( field = TYPE_FIELDS ( node ) ; field ; field = TREE_CHAIN ( field ) ) { const_tree fieldtype = get_field_type ( field ) ; enum tree_code code = TREE_CODE ( fieldtype ) ; if ( node == fieldtype ) { continue ; } if ( code == RECORD_TYPE || code == UNION_TYPE ) { continue ; } if ( ! is_fptr ( fieldtype ) ) { return 0 ; } } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dissect_ber_GeneralString ( asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , char * name_string , guint name_len ) { tvbuff_t * out_tvb ; gint tvb_len ; offset = dissect_ber_restricted_string ( FALSE , BER_UNI_TAG_GeneralString , actx , tree , tvb , offset , hf_id , ( name_string ) ?& out_tvb : NULL ) ; if ( name_string ) { if ( out_tvb ) { tvb_len = tvb_reported_length ( out_tvb ) ; if ( ( guint ) tvb_len >= name_len ) { tvb_memcpy ( out_tvb , ( guint8 * ) name_string , 0 , name_len - 1 ) ; name_string [ name_len - 1 ] = '\\0' ; } else { tvb_memcpy ( out_tvb , ( guint8 * ) name_string , 0 , tvb_len ) ; name_string [ tvb_len ] = '\\0' ; } } } return offset ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void free_hugepd_range ( struct mmu_gather * tlb , hugepd_t * hpdp , int pdshift , unsigned long start , unsigned long end , unsigned long floor , unsigned long ceiling ) { pte_t * hugepte = hugepd_page ( * hpdp ) ; int i ; unsigned long pdmask = ~ ( ( 1UL << pdshift ) - 1 ) ; unsigned int num_hugepd = 1 ; unsigned int shift = hugepd_shift ( * hpdp ) ; if ( shift > pdshift ) { num_hugepd = 1 << ( shift - pdshift ) ; } start &= pdmask ; if ( start < floor ) { return ; } if ( ceiling ) { ceiling &= pdmask ; if ( ! ceiling ) { return ; } } for ( i = 0 ; i < num_hugepd ; i ++ , hpdp ++ ) { * hpdp = __hugepd ( 0 ) ; } if ( shift >= pdshift ) { hugepd_free ( tlb , hugepte ) ; } else { pgtable_free_tlb ( tlb , hugepte , pdshift - shift ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int meson_clk_pll_set_rate ( struct clk_hw * hw , unsigned long rate , unsigned long parent_rate ) { struct clk_regmap * clk = to_clk_regmap ( hw ) ; struct meson_clk_pll_data * pll = meson_clk_pll_data ( clk ) ; unsigned int enabled , m , n , frac = 0 ; unsigned long old_rate ; int ret ; old_rate = clk_hw_get_rate ( hw ) ; ret = meson_clk_get_pll_settings ( rate , parent_rate , & m , & n , pll ) ; if ( ret ) { return ret ; } enabled = meson_parm_read ( clk -> map , & pll -> en ) ; if ( enabled ) { meson_clk_pll_disable ( hw ) ; } meson_parm_write ( clk -> map , & pll -> n , n ) ; meson_parm_write ( clk -> map , & pll -> m , m ) ; if ( MESON_PARM_APPLICABLE ( & pll -> frac ) ) { frac = __pll_params_with_frac ( rate , parent_rate , m , n , pll ) ; meson_parm_write ( clk -> map , & pll -> frac , frac ) ; } if ( ! enabled ) { return 0 ; } ret = meson_clk_pll_enable ( hw ) ; if ( ret ) { pr_warn ( \"%s: pll did not lock, trying to restore old rate %lu\\n\" , __func__ , old_rate ) ; meson_clk_pll_set_rate ( hw , old_rate , parent_rate ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int radiustab_init ( void ) { quotatab_register_backend ( \"radius\" , radiustab_open , QUOTATAB_LIMIT_SRC ) ; pr_event_register ( & quotatab_radius_module , \"core.module-unload\" , radiustab_mod_unload_ev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void balloon_up ( struct work_struct * dummy ) { unsigned int num_pages = dm_device . balloon_wrk . num_pages ; unsigned int num_ballooned = 0 ; struct dm_balloon_response * bl_resp ; int alloc_unit ; int ret ; bool done = false ; int i ; long avail_pages ; unsigned long floor ; alloc_unit = PAGES_IN_2M ; avail_pages = si_mem_available ( ) ; floor = compute_balloon_floor ( ) ; if ( avail_pages < num_pages || avail_pages - num_pages < floor ) { pr_info ( \"Balloon request will be partially fulfilled. %s\\n\" , avail_pages < num_pages ?\"Not enough memory.\" : \"Balloon floor reached.\" ) ; num_pages = avail_pages > floor ?( avail_pages - floor ) : 0 ; } while ( ! done ) { memset ( balloon_up_send_buffer , 0 , HV_HYP_PAGE_SIZE ) ; bl_resp = ( dm_balloon_response * ) balloon_up_send_buffer ; bl_resp -> hdr . type = DM_BALLOON_RESPONSE ; bl_resp -> hdr . size = sizeof ( dm_balloon_response ) ; num_pages -= num_ballooned ; num_ballooned = alloc_balloon_pages ( & dm_device , num_pages , bl_resp , alloc_unit ) ; if ( alloc_unit != 1 && num_ballooned == 0 ) { alloc_unit = 1 ; continue ; } if ( num_ballooned == 0 || num_ballooned == num_pages ) { pr_debug ( \"Ballooned %u out of %u requested pages.\\n\" , num_pages , dm_device . balloon_wrk . num_pages ) ; bl_resp -> more_pages = 0 ; done = true ; dm_device . state = DM_INITIALIZED ; } { bl_resp -> hdr . trans_id = atomic_inc_return ( & trans_id ) ; ret = vmbus_sendpacket ( dm_device . dev -> channel , bl_resp , bl_resp -> hdr . size , ( unsigned long ) NULL , VM_PKT_DATA_INBAND , 0 ) ; if ( ret == - EAGAIN ) { msleep ( 20 ) ; } post_status ( & dm_device ) ; } ret == - EAGAIN ; if ( ret ) { pr_err ( \"Balloon response failed\\n\" ) ; for ( i = 0 ; i < bl_resp -> range_count ; i ++ ) { free_balloon_pages ( & dm_device , & bl_resp -> range_array [ i ] ) ; } done = true ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void netsec_uninit_pkt_dring ( struct netsec_priv * priv , int id ) { struct netsec_desc_ring * dring = & priv -> desc_ring [ id ] ; struct netsec_desc * desc ; u16 idx ; if ( ! dring -> vaddr || ! dring -> desc ) { return ; } for ( idx = 0 ; idx < DESC_NUM ; idx ++ ) { desc = & dring -> desc [ idx ] ; if ( ! desc -> addr ) { continue ; } if ( id == NETSEC_RING_RX ) { struct page * page = virt_to_page ( desc -> addr ) ; page_pool_put_full_page ( dring -> page_pool , page , false ) ; } if ( id == NETSEC_RING_TX ) { dma_unmap_single ( priv -> dev , desc -> dma_addr , desc -> len , DMA_TO_DEVICE ) ; dev_kfree_skb ( desc -> skb ) ; } } if ( id == NETSEC_RING_RX ) { if ( xdp_rxq_info_is_reg ( & dring -> xdp_rxq ) ) { xdp_rxq_info_unreg ( & dring -> xdp_rxq ) ; } page_pool_destroy ( dring -> page_pool ) ; } memset ( dring -> vaddr , 0 , DESC_SZ * DESC_NUM ) ; dring -> head = 0 ; dring -> tail = 0 ; if ( id == NETSEC_RING_TX ) { netdev_reset_queue ( priv -> ndev ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pcf8583_rtc_set_time ( struct device * dev , struct rtc_time * tm ) { struct i2c_client * client = to_i2c_client ( dev ) ; unsigned char year [ 2 ] , chk ; struct rtc_mem cmos_year = { . loc = CMOS_YEAR . nr = sizeof ( year ) . data = year } ; struct rtc_mem cmos_check = { . loc = CMOS_CHECKSUM . nr = 1 . data = & chk } ; int proper_year = tm -> tm_year + 1900 ; int ret ; ret = pcf8583_set_datetime ( client , tm , 1 ) ; if ( ret ) { return ret ; } ret = pcf8583_read_mem ( client , & cmos_check ) ; if ( ret ) { return ret ; } ret = pcf8583_read_mem ( client , & cmos_year ) ; if ( ret ) { return ret ; } chk -= year [ 1 ] + year [ 0 ] ; year [ 1 ] = proper_year / 100 ; year [ 0 ] = proper_year % 100 ; chk += year [ 1 ] + year [ 0 ] ; ret = pcf8583_write_mem ( client , & cmos_year ) ; if ( ret ) { return ret ; } ret = pcf8583_write_mem ( client , & cmos_check ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void freedolh ( void ) { unsigned char * * argp ; struct dolnod * argblk ; if ( argblk = dolh ) { if ( ( -- argblk -> doluse ) == 0 ) { for ( argp = argblk -> dolarg ; * argp != ( unsigned char * ) ENDARGS ; argp ++ ) { free ( * argp ) ; } free ( argblk ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static tool_rc tpm2_tool_onrun ( ESYS_CONTEXT * ectx , tpm2_option_flags flags ) { UNUSED ( flags ) ; tool_rc rc = check_options ( ) ; rc = process_inputs ( ectx ) ; if ( rc != tool_rc_success ) { return rc ; } rc = pcrread ( ectx ) ; if ( rc != tool_rc_success ) { return rc ; } return process_outputs ( ectx ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int stm32_exti_probe ( struct platform_device * pdev ) { int ret , i ; struct device * dev = & pdev -> dev ; struct device_node * np = dev -> of_node ; struct irq_domain * parent_domain , * domain ; struct stm32_exti_host_data * host_data ; const struct stm32_exti_drv_data * drv_data ; host_data = devm_kzalloc ( dev , sizeof ( * host_data ) , GFP_KERNEL ) ; if ( ! host_data ) { return - ENOMEM ; } ret = of_hwspin_lock_get_id ( np , 0 ) ; if ( ret == - EPROBE_DEFER ) { return ret ; } if ( ret >= 0 ) { host_data -> hwlock = devm_hwspin_lock_request_specific ( dev , ret ) ; if ( ! host_data -> hwlock ) { dev_err ( dev , \"Failed to request hwspinlock\\n\" ) ; return - EINVAL ; } } if ( ret != - ENOENT ) { dev_err ( dev , \"Failed to get hwspinlock\\n\" ) ; return ret ; } drv_data = of_device_get_match_data ( dev ) ; if ( ! drv_data ) { dev_err ( dev , \"no of match data\\n\" ) ; return - ENODEV ; } host_data -> drv_data = drv_data ; host_data -> chips_data = devm_kcalloc ( dev , drv_data -> bank_nr , sizeof ( * host_data -> chips_data ) , GFP_KERNEL ) ; host_data -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( host_data -> base ) ) { return PTR_ERR ( host_data -> base ) ; } for ( i = 0 ; i < drv_data -> bank_nr ; i ++ ) { stm32_exti_chip_init ( host_data , i , np ) ; } parent_domain = irq_find_host ( of_irq_find_parent ( np ) ) ; if ( ! parent_domain ) { dev_err ( dev , \"GIC interrupt-parent not found\\n\" ) ; return - EINVAL ; } domain = irq_domain_add_hierarchy ( parent_domain , 0 , drv_data -> bank_nr * IRQS_PER_BANK , np , & stm32_exti_h_domain_ops , host_data ) ; if ( ! domain ) { dev_err ( dev , \"Could not register exti domain\\n\" ) ; return - ENOMEM ; } ret = devm_add_action_or_reset ( dev , stm32_exti_remove_irq , domain ) ; if ( ret ) { return ret ; } stm32_exti_h_syscore_init ( host_data ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static mime_type_t * add_printer_filters ( const char * command , mime_t * mime , const char * printer , const char * ppdfile , mime_type_t * * prefilter_type ) { ppd_file_t * ppd ; _ppd_cache_t * pc ; const char * value ; mime_type_t * printer_type ; if ( ( ppd = _ppdOpenFile ( ppdfile , _PPD_LOCALIZATION_NONE ) ) == NULL ) { ppd_status_t status ; int linenum ; status = ppdLastError ( & linenum ) ; _cupsLangPrintf ( stderr , _ ( \"%s: Unable to open PPD file: %s on line %d.\" ) , command , ppdErrorString ( status ) , linenum ) ; return ( NULL ) ; } pc = _ppdCacheCreateWithPPD ( ppd ) ; printer_type = mimeAddType ( mime , \"printer\" , printer ) ; * prefilter_type = NULL ; if ( pc -> filters ) { for ( value = ( const char * ) cupsArrayFirst ( pc -> filters ) ; value ; value = ( const char * ) cupsArrayNext ( pc -> filters ) ) { add_printer_filter ( command , mime , printer_type , value ) ; } } else { add_printer_filter ( command , mime , printer_type , \"application/vnd.cups-raw 0 -\" ) ; add_printer_filter ( command , mime , printer_type , \"application/vnd.cups-postscript 0 -\" ) ; } if ( pc -> prefilters ) { * prefilter_type = mimeAddType ( mime , \"prefilter\" , printer ) ; for ( value = ( const char * ) cupsArrayFirst ( pc -> prefilters ) ; value ; value = ( const char * ) cupsArrayNext ( pc -> prefilters ) ) { add_printer_filter ( command , mime , * prefilter_type , value ) ; } } return ( printer_type ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int stac_suspend ( struct hda_codec * codec ) { stac_shutup ( codec , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct its_device * its_find_device ( struct its_node * its , u32 dev_id ) { struct its_device * its_dev = NULL , * tmp ; cfs_time_t flags ; raw_spin_lock_irqsave ( & its -> lock , flags ) ; list_for_each_entry ( , , ) { if ( tmp -> device_id == dev_id ) { its_dev = tmp ; break ; } } raw_spin_unlock_irqrestore ( & its -> lock , flags ) ; return its_dev ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int at91_pinctrl_probe ( struct platform_device * pdev ) { struct at91_pinctrl * info ; struct pinctrl_pin_desc * pdesc ; int ret , i , j , k ; info = devm_kzalloc ( & pdev -> dev , sizeof ( * info ) , GFP_KERNEL ) ; ret = at91_pinctrl_probe_dt ( pdev , info ) ; if ( ret ) { return ret ; } at91_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; at91_pinctrl_desc . npins = gpio_banks * MAX_NB_GPIO_PER_BANK ; at91_pinctrl_desc . pins = pdesc = devm_kcalloc ( & pdev -> dev , at91_pinctrl_desc . npins , sizeof ( * pdesc ) , GFP_KERNEL ) ; if ( ! at91_pinctrl_desc . pins ) { return - ENOMEM ; } for ( i = 0 , k = 0 ; i < gpio_banks ; i ++ ) { for ( j = 0 ; j < MAX_NB_GPIO_PER_BANK ; j ++ , k ++ ) { pdesc -> number = k ; pdesc -> name = kasprintf ( GFP_KERNEL , \"pio%c%d\" , i + 'A' , j ) ; pdesc ++ ; } } platform_set_drvdata ( pdev , info ) ; info -> pctl = devm_pinctrl_register ( & pdev -> dev , & at91_pinctrl_desc , info ) ; if ( IS_ERR ( info -> pctl ) ) { dev_err ( & pdev -> dev , \"could not register AT91 pinctrl driver\\n\" ) ; return PTR_ERR ( info -> pctl ) ; } for ( i = 0 ; i < gpio_banks ; i ++ ) { if ( gpio_chips [ i ] ) { pinctrl_add_gpio_range ( info -> pctl , & gpio_chips [ i ] -> range ) ; } } dev_info ( & pdev -> dev , \"initialized AT91 pinctrl driver\\n\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void print_cipso ( const uchar_t * opt ) { int optlen , taglen , tagnum ; uint32_t doi ; char line [ CIPSO_GENERIC_ARRAY_LEN ] ; char * oldnest ; optlen = opt [ 1 ] ; if ( optlen ( TSOL_CIPSO_MIN_LENGTH || optlen ) TSOL_CIPSO_MAX_LENGTH ) { return ; } oldnest = prot_nest_prefix ; prot_nest_prefix = prot_prefix ; show_header ( \"CIPSO:  \" , \"Common IP Security Option\" , 0 ) ; show_space ( ) ; ( void ) snprintf ( get_line ( 0 , 0 ) , get_line_remain ( ) , \"Type = CIPSO (%d), Length = %d\" , opt [ 0 ] , opt [ 1 ] ) ; ( void ) memcpy ( & doi , opt + 2 , sizeof ( doi ) ) ; ( void ) snprintf ( get_line ( 0 , 0 ) , get_line_remain ( ) , \"Domain of Interpretation = %u\" , ( unsigned ) ntohl ( doi ) ) ; if ( opt [ 1 ] == TSOL_CIPSO_MIN_LENGTH ) { show_space ( ) ; prot_prefix = prot_nest_prefix ; prot_nest_prefix = oldnest ; return ; } optlen -= TSOL_CIPSO_MIN_LENGTH ; opt += TSOL_CIPSO_MIN_LENGTH ; tagnum = 1 ; while ( optlen >= TSOL_TT1_MIN_LENGTH ) { ( void ) snprintf ( line , sizeof ( line ) , \"Tag# %d\" , tagnum ) ; show_header ( \"CIPSO:  \" , line , 0 ) ; switch ( opt [ 0 ] ) { case 1 : taglen = interpret_cipso_tagtype1 ( opt ) ; break ; case 3 : taglen = interpret_cipso_tagtype3 ( opt ) ; break ; default : ( void ) snprintf ( get_line ( 0 , 0 ) , get_line_remain ( ) , \"Unknown Tag Type %d\" , opt [ 0 ] ) ; show_space ( ) ; prot_prefix = prot_nest_prefix ; prot_nest_prefix = oldnest ; return ; } optlen -= taglen ; opt += taglen ; tagnum ++ ; } show_space ( ) ; prot_prefix = prot_nest_prefix ; prot_nest_prefix = oldnest ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sync_collector ( ebpf_module_t * em ) { heartbeat_t hb ; heartbeat_init ( & hb ) ; int update_every = em -> update_every ; int counter = update_every - 1 ; while ( ! ebpf_exit_plugin ) { ( void ) heartbeat_next ( & hb , USEC_PER_SEC ) ; counter = 0 ; ebpf_sync_read_global_table ( ) ; pthread_mutex_lock ( & lock ) ; sync_send_data ( ) ; pthread_mutex_unlock ( & lock ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int msm_hdmi_phy_resource_init ( struct hdmi_phy * phy ) { struct hdmi_phy_cfg * cfg = phy -> cfg ; struct device * dev = & phy -> pdev -> dev ; int i , ret ; phy -> regs = devm_kcalloc ( dev , cfg -> num_regs , sizeof ( phy -> regs [ 0 ] ) , GFP_KERNEL ) ; phy -> clks = devm_kcalloc ( dev , cfg -> num_clks , sizeof ( phy -> clks [ 0 ] ) , GFP_KERNEL ) ; if ( ! phy -> clks ) { return - ENOMEM ; } for ( i = 0 ; i < cfg -> num_regs ; i ++ ) { phy -> regs [ i ] . supply = cfg -> reg_names [ i ] ; } ret = devm_regulator_bulk_get ( dev , cfg -> num_regs , phy -> regs ) ; if ( ret ) { if ( ret != - EPROBE_DEFER ) { DRM_DEV_ERROR ( dev , \"failed to get phy regulators: %d\\n\" , ret ) ; } return ret ; } for ( i = 0 ; i < cfg -> num_clks ; i ++ ) { struct clk * clk ; clk = msm_clk_get ( phy -> pdev , cfg -> clk_names [ i ] ) ; if ( IS_ERR ( clk ) ) { ret = PTR_ERR ( clk ) ; DRM_DEV_ERROR ( dev , \"failed to get phy clock: %s (%d)\\n\" , cfg -> clk_names [ i ] , ret ) ; return ret ; } phy -> clks [ i ] = clk ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int SSHParserTest12 ( void ) { int result = 0 ; Flow f ; uint8_t sshbuf1 [ ] \"SSH-2.0-MySSHClient-0.5.1\\r\\n\" ; ; uint32_t sshlen1 = sizeof ( sshbuf1 ) - 1 ; uint8_t sshbuf2 [ ] { 0x00 0x00 0x00 0x03 0x01 17 0x00 } ; ; uint32_t sshlen2 = sizeof ( sshbuf2 ) ; uint8_t sshbuf3 [ ] { 0x00 0x00 0x00 0x03 0x01 21 0x00 } ; ; uint32_t sshlen3 = sizeof ( sshbuf3 ) ; TcpSession ssn ; AppLayerParserThreadCtx * alp_tctx = AppLayerParserThreadCtxAlloc ( ) ; memset ( & f , 0 , sizeof ( f ) ) ; FLOW_INITIALIZE ( & f ) ; f . protoctx = ( void * ) & ssn ; f . alproto = ALPROTO_SSH ; StreamTcpInitConfig ( true ) ; int r = AppLayerParserParse ( NULL , alp_tctx , & f , ALPROTO_SSH , STREAM_TOSERVER , sshbuf1 , sshlen1 ) ; if ( r != 0 ) { printf ( \"toserver chunk 1 returned %\" PRId32 \", expected 0: \" , r ) ; end } r = AppLayerParserParse ( NULL , alp_tctx , & f , ALPROTO_SSH , STREAM_TOSERVER , sshbuf2 , sshlen2 ) ; if ( r != 0 ) { printf ( \"toserver chunk 2 returned %\" PRId32 \", expected 0: \" , r ) ; end } r = AppLayerParserParse ( NULL , alp_tctx , & f , ALPROTO_SSH , STREAM_TOSERVER , sshbuf3 , sshlen3 ) ; if ( r != 0 ) { printf ( \"toserver chunk 3 returned %\" PRId32 \", expected 0: \" , r ) ; end } void * ssh_state = f . alstate ; if ( ssh_state == NULL ) { printf ( \"no ssh state: \" ) ; end } void * tx = rs_ssh_state_get_tx ( ssh_state , 0 ) ; if ( rs_ssh_tx_get_flags ( tx , STREAM_TOSERVER ) != SshStateFinished ) { printf ( \"Didn't detect the msg code of new keys (ciphered data starts): \" ) ; end } if ( SSHParserTestUtilCheck ( \"2.0\" , \"MySSHClient-0.5.1\" , tx , STREAM_TOSERVER ) ) { end } result = 1 ; end if ( alp_tctx != NULL ) { AppLayerParserThreadCtxFree ( alp_tctx ) ; } StreamTcpFreeConfig ( true ) ; FLOW_DESTROY ( & f ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static uint32_t do_phy_read ( lan9118_state * s , int reg ) { uint32_t val ; switch ( reg ) { case 0 : return s -> phy_control ; case 1 : return s -> phy_status ; case 2 : return 0x0007 ; case 3 : return 0xc0d1 ; case 4 : return s -> phy_advertise ; case 5 : return 0x0f71 ; case 6 : return 1 ; case 29 : val = s -> phy_int ; phy_update_irq ( s ) ; return val ; case 30 : return s -> phy_int_mask ; default : BADF ( \"PHY read reg %d\\n\" , reg ) ; return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int parse_struct_or_union_specifier ( int sym , zend_ffi_dcl * dcl ) { if ( sym == YY_STRUCT ) { sym = get_sym ( ) ; dcl -> flags |= ZEND_FFI_DCL_STRUCT ; } if ( sym == YY_UNION ) { sym = get_sym ( ) ; dcl -> flags |= ZEND_FFI_DCL_UNION ; } else { yy_error_sym ( \"unexpected\" , sym ) ; } if ( YY_IN_SET ( sym , ( YY___ATTRIBUTE , YY___ATTRIBUTE__ , YY___DECLSPEC , YY___CDECL , YY___STDCALL , YY___FASTCALL , YY___THISCALL , YY___VECTORCALL ) , \"\\000\\000\\000\\000\\000\\000\\360\\017\\000\\000\\000\\000\\000\" ) ) { sym = parse_attributes ( sym , dcl ) ; } if ( sym == YY_ID ) { const char * name ; int name_len ; sym = parse_ID ( sym , & name , & name_len ) ; zend_ffi_declare_tag ( name , name_len , dcl , 1 ) ; if ( sym == YY__LBRACE ) { sym = parse_struct_contents ( sym , dcl ) ; zend_ffi_declare_tag ( name , name_len , dcl , 0 ) ; } } if ( sym == YY__LBRACE ) { zend_ffi_make_struct_type ( dcl ) ; sym = parse_struct_contents ( sym , dcl ) ; } else { yy_error_sym ( \"unexpected\" , sym ) ; } return sym ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void echo_eventcb ( struct bufferevent * bev , short what , void * ctx ) { if ( what & ( BEV_EVENT_EOF | BEV_EVENT_ERROR ) ) { -- n_echo_conns_open ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mwifiex_process_sta_rx_packet ( struct mwifiex_private * priv , struct sk_buff * skb ) { struct mwifiex_adapter * adapter = priv -> adapter ; int ret = 0 ; struct rxpd * local_rx_pd ; struct rx_packet_hdr * rx_pkt_hdr ; u8 ta [ ETH_ALEN ] ; u16 rx_pkt_type , rx_pkt_offset , rx_pkt_length , seq_num ; struct mwifiex_sta_node * sta_ptr ; local_rx_pd = ( rxpd * ) ( skb -> data ) ; rx_pkt_type = le16_to_cpu ( local_rx_pd -> rx_pkt_type ) ; rx_pkt_offset = le16_to_cpu ( local_rx_pd -> rx_pkt_offset ) ; rx_pkt_length = le16_to_cpu ( local_rx_pd -> rx_pkt_length ) ; seq_num = le16_to_cpu ( local_rx_pd -> seq_num ) ; rx_pkt_hdr = ( void * ) local_rx_pd + rx_pkt_offset ; if ( ( rx_pkt_offset + rx_pkt_length ) > ( u16 ) skb -> len ) { mwifiex_dbg ( adapter , ERROR , \"wrong rx packet: len=%d, rx_pkt_offset=%d, rx_pkt_length=%d\\n\" , skb -> len , rx_pkt_offset , rx_pkt_length ) ; priv -> stats . rx_dropped ++ ; return ret ; } if ( rx_pkt_type == PKT_TYPE_MGMT ) { ret = mwifiex_process_mgmt_packet ( priv , skb ) ; if ( ret ) { mwifiex_dbg ( adapter , DATA , \"Rx of mgmt packet failed\" ) ; } dev_kfree_skb_any ( skb ) ; return ret ; } if ( ( ! IS_11N_ENABLED ( priv ) && ! ( ISSUPP_TDLS_ENABLED ( priv -> adapter -> fw_cap_info ) && ! ( local_rx_pd -> flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET ) ) ) || ! ether_addr_equal_unaligned ( priv -> curr_addr , rx_pkt_hdr -> eth803_hdr . h_dest ) ) { mwifiex_process_rx_packet ( priv , skb ) ; return ret ; } if ( mwifiex_queuing_ra_based ( priv ) || ( ISSUPP_TDLS_ENABLED ( priv -> adapter -> fw_cap_info ) && local_rx_pd -> flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET ) ) { memcpy ( ta , rx_pkt_hdr -> eth803_hdr . h_source , ETH_ALEN ) ; if ( local_rx_pd -> flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET && local_rx_pd -> priority < MAX_NUM_TID ) { sta_ptr = mwifiex_get_sta_entry ( priv , ta ) ; if ( sta_ptr ) { sta_ptr -> rx_seq [ local_rx_pd -> priority ] = le16_to_cpu ( local_rx_pd -> seq_num ) ; } mwifiex_auto_tdls_update_peer_signal ( priv , ta , local_rx_pd -> snr , local_rx_pd -> nf ) ; } } else { if ( rx_pkt_type != PKT_TYPE_BAR ) { priv -> rx_seq [ local_rx_pd -> priority ] = seq_num ; } memcpy ( ta , priv -> curr_bss_params . bss_descriptor . mac_address , ETH_ALEN ) ; } ret = mwifiex_11n_rx_reorder_pkt ( priv , seq_num , local_rx_pd -> priority , ta , ( u8 ) rx_pkt_type , skb ) ; if ( ret || ( rx_pkt_type == PKT_TYPE_BAR ) ) { dev_kfree_skb_any ( skb ) ; } if ( ret ) { priv -> stats . rx_dropped ++ ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cond_evaluate_expr ( struct policydb * p , struct cond_expr * expr ) { u32 i ; int s [ COND_EXPR_MAXDEPTH ] ; int sp = - 1 ; for ( i = 0 ; i < expr -> len ; i ++ ) { struct cond_expr_node * node = & expr -> nodes [ i ] ; switch ( node -> expr_type ) { case COND_BOOL : if ( sp == ( COND_EXPR_MAXDEPTH - 1 ) ) { return - 1 ; } sp ++ ; s [ sp ] = p -> bool_val_to_struct [ node -> bool - 1 ] -> state ; break ; case COND_NOT : if ( sp < 0 ) { return - 1 ; } s [ sp ] = ! s [ sp ] ; break ; case COND_OR : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] |= s [ sp + 1 ] ; break ; case COND_AND : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] &= s [ sp + 1 ] ; break ; case COND_XOR : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] ^= s [ sp + 1 ] ; break ; case COND_EQ : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] = ( s [ sp ] == s [ sp + 1 ] ) ; break ; case COND_NEQ : if ( sp < 1 ) { return - 1 ; } sp -- ; s [ sp ] = ( s [ sp ] != s [ sp + 1 ] ) ; break ; default : return - 1 ; } } return s [ 0 ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int lp8788_charger_probe ( struct platform_device * pdev ) { struct lp8788 * lp = dev_get_drvdata ( pdev -> dev . parent ) ; struct lp8788_charger * pchg ; struct device * dev = & pdev -> dev ; int ret ; pchg = devm_kzalloc ( dev , sizeof ( lp8788_charger ) , GFP_KERNEL ) ; if ( ! pchg ) { return - ENOMEM ; } pchg -> lp = lp ; pchg -> pdata = lp -> pdata ?lp -> pdata -> chg_pdata : NULL ; platform_set_drvdata ( pdev , pchg ) ; ret = lp8788_update_charger_params ( pdev , pchg ) ; if ( ret ) { return ret ; } lp8788_setup_adc_channel ( & pdev -> dev , pchg ) ; ret = lp8788_psy_register ( pdev , pchg ) ; if ( ret ) { return ret ; } ret = sysfs_create_group ( & pdev -> dev . kobj , & lp8788_attr_group ) ; if ( ret ) { lp8788_psy_unregister ( pchg , NULL ) ; return ret ; } ret = lp8788_irq_register ( pdev , pchg ) ; if ( ret ) { dev_warn ( dev , \"failed to register charger irq: %d\\n\" , ret ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int request_log ( uintptr_t addr , uint_t flags , int argc , const mdb_arg_t * argv ) { request_log_entry_t cur ; hrtime_t dur ; hrtime_t dursec ; hrtime_t durnsec ; char durstr [ 20 ] ; char stampstr [ 20 ] ; char requstr [ 30 ] ; char respstr [ 30 ] ; char typestr [ 30 ] ; uintptr_t node = 0 ; int client = 0 ; uint64_t clientid = 0 ; int idx ; int opt_v = FALSE ; if ( ! ( flags & DCMD_ADDRSPEC ) ) { if ( mdb_walk_dcmd ( \"configd_log\" , \"configd_log\" , argc , argv ) == - 1 ) { mdb_warn ( \"can't walk 'configd_log'\" ) ; return ( DCMD_ERR ) ; } return ( DCMD_OK ) ; } if ( mdb_getopts ( argc , argv , 'c' , MDB_OPT_UINTPTR , & client , 'i' , MDB_OPT_UINT64 , & clientid , 'n' , MDB_OPT_UINTPTR , & node , 'v' , MDB_OPT_SETBITS , TRUE , & opt_v , NULL ) != argc ) { return ( DCMD_USAGE ) ; } if ( DCMD_HDRSPEC ( flags ) ) { mdb_printf ( \"%<u>%-?s %-4s %-14s %9s %-22s %-17s\\n%</u>\" , \"ADDR\" , \"THRD\" , \"START\" , \"DURATION\" , \"REQUEST\" , \"RESPONSE\" ) ; } if ( mdb_vread ( & cur , sizeof ( cur ) , addr ) == - 1 ) { mdb_warn ( \"couldn't read log entry at %p\" , addr ) ; return ( DCMD_ERR ) ; } if ( clientid != 0 && clientid != cur . rl_clientid ) { return ( DCMD_OK ) ; } if ( client != 0 && client != ( uintptr_t ) cur . rl_client ) { return ( DCMD_OK ) ; } if ( node != 0 ) { for ( idx = 0 ; idx < MIN ( MAX_PTRS , cur . rl_num_ptrs ) ; idx ++ ) { if ( ( uintptr_t ) cur . rl_ptrs [ idx ] . rlp_data == node ) { node = 0 ; break ; } } if ( node != 0 ) { return ( DCMD_OK ) ; } } enum_lookup ( requstr , sizeof ( requstr ) , request_enum , cur . rl_request , \"REP_PROTOCOL_\" , \"\" ) ; if ( cur . rl_end != 0 ) { enum_lookup ( respstr , sizeof ( respstr ) , response_enum , cur . rl_response , \"REP_PROTOCOL_\" , \"FAIL_\" ) ; dur = cur . rl_end - cur . rl_start ; dursec = dur / NANOSEC ; durnsec = dur % NANOSEC ; if ( dursec <= 9 ) { mdb_snprintf ( durstr , sizeof ( durstr ) , \"%lld.%06lld\" , dursec , durnsec / ( NANOSEC / MICROSEC ) ) ; } if ( dursec <= 9999 ) { mdb_snprintf ( durstr , sizeof ( durstr ) , \"%lld.%03lld\" , dursec , NSEC2MSEC ( durnsec ) ) ; } else { mdb_snprintf ( durstr , sizeof ( durstr ) , \"%lld\" , dursec ) ; } } else { ( void ) strcpy ( durstr , \"-\" ) ; ( void ) strcpy ( respstr , \"-\" ) ; } if ( max_time_seen != 0 && max_time_seen >= cur . rl_start ) { dur = max_time_seen - cur . rl_start ; dursec = dur / NANOSEC ; durnsec = dur % NANOSEC ; if ( dursec <= 99ULL ) { mdb_snprintf ( stampstr , sizeof ( stampstr ) , \"-%lld.%09lld\" , dursec , durnsec ) ; } if ( dursec <= 99999ULL ) { mdb_snprintf ( stampstr , sizeof ( stampstr ) , \"-%lld.%06lld\" , dursec , durnsec / ( NANOSEC / MICROSEC ) ) ; } if ( dursec <= 99999999ULL ) { mdb_snprintf ( stampstr , sizeof ( stampstr ) , \"-%lld.%03lld\" , dursec , NSEC2MSEC ( durnsec ) ) ; } else { mdb_snprintf ( stampstr , sizeof ( stampstr ) , \"-%lld\" , dursec ) ; } } else { ( void ) strcpy ( stampstr , \"-\" ) ; } mdb_printf ( \"%0?x %4d T%13s %9s %-22s %-17s\\n\" , addr , cur . rl_tid , stampstr , durstr , requstr , respstr ) ; if ( opt_v ) { mdb_printf ( \"\\tclient: %?p (%d)\\tptrs: %d\\tstamp: %llx\\n\" , cur . rl_client , cur . rl_clientid , cur . rl_num_ptrs , cur . rl_start ) ; for ( idx = 0 ; idx < MIN ( MAX_PTRS , cur . rl_num_ptrs ) ; idx ++ ) { enum_lookup ( typestr , sizeof ( typestr ) , ptr_type_enum , cur . rl_ptrs [ idx ] . rlp_type , \"RC_PTR_TYPE_\" , \"\" ) ; mdb_printf ( \"\\t\\t%-7s %5d %?p %?p\\n\" , typestr , cur . rl_ptrs [ idx ] . rlp_id , cur . rl_ptrs [ idx ] . rlp_ptr , cur . rl_ptrs [ idx ] . rlp_data ) ; } mdb_printf ( \"\\n\" ) ; } return ( DCMD_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ft_pci_setup ( void * blob , struct bd_info * bd ) { int nodeoffset ; int tmp [ 2 ] ; const char * path ; if ( pci_num_buses < 1 ) { return ; } nodeoffset = fdt_path_offset ( blob , \"/aliases\" ) ; if ( nodeoffset >= 0 ) { path = fdt_getprop ( blob , nodeoffset , \"pci0\" , NULL ) ; if ( path ) { tmp [ 0 ] = cpu_to_be32 ( pci_hose [ 0 ] . first_busno ) ; tmp [ 1 ] = cpu_to_be32 ( pci_hose [ 0 ] . last_busno ) ; do_fixup_by_path ( blob , path , \"bus-range\" , & tmp , sizeof ( tmp ) , 1 ) ; tmp [ 0 ] = cpu_to_be32 ( gd -> pci_clk , NULL ) ; do_fixup_by_path ( blob , path , \"clock-frequency\" , & tmp , sizeof ( tmp [ 0 ] ) , 1 ) ; } if ( pci_num_buses < 2 ) { return ; } path = fdt_getprop ( blob , nodeoffset , \"pci1\" , NULL ) ; if ( path ) { tmp [ 0 ] = cpu_to_be32 ( pci_hose [ 1 ] . first_busno ) ; tmp [ 1 ] = cpu_to_be32 ( pci_hose [ 1 ] . last_busno ) ; do_fixup_by_path ( blob , path , \"bus-range\" , & tmp , sizeof ( tmp ) , 1 ) ; tmp [ 0 ] = cpu_to_be32 ( gd -> pci_clk ) ; do_fixup_by_path ( blob , path , \"clock-frequency\" , & tmp , sizeof ( tmp [ 0 ] ) , 1 ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ath12k_wmi_start_scan_init ( struct ath12k * ar , struct ath12k_wmi_scan_req_arg * arg ) { arg -> scan_req_id = 1 ; arg -> scan_priority = WMI_SCAN_PRIORITY_LOW ; arg -> dwell_time_active = 50 ; arg -> dwell_time_active_2g = 0 ; arg -> dwell_time_passive = 150 ; arg -> dwell_time_active_6g = 40 ; arg -> dwell_time_passive_6g = 30 ; arg -> min_rest_time = 50 ; arg -> max_rest_time = 500 ; arg -> repeat_probe_time = 0 ; arg -> probe_spacing_time = 0 ; arg -> idle_time = 0 ; arg -> max_scan_time = 20000 ; arg -> probe_delay = 5 ; arg -> notify_scan_events = WMI_SCAN_EVENT_STARTED | WMI_SCAN_EVENT_COMPLETED | WMI_SCAN_EVENT_BSS_CHANNEL | WMI_SCAN_EVENT_FOREIGN_CHAN | WMI_SCAN_EVENT_DEQUEUED ; arg -> scan_flags |= WMI_SCAN_CHAN_STAT_EVENT ; eth_broadcast_addr ( arg -> bssid_list [ 0 ] . addr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mod_register ( char * path , int * dlflags , void * p1 , void * p2 ) { sr_kemi_modules_add ( sr_kemi_diversion_exports , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MODRET sql_sqlite_open ( cmd_rec * cmd ) { conn_entry_t * entry = NULL ; db_conn_t * conn = NULL ; const char * stmt = NULL ; int res , xerrno = 0 ; int nretries = 0 ; sql_log ( DEBUG_FUNC , \"%s\" , \"entering \\tsqlite cmd_open\" ) ; if ( cmd -> argc < 1 ) { sql_log ( DEBUG_FUNC , \"%s\" , \"exiting \\tsqlite cmd_open\" ) ; return PR_ERROR_MSG ( cmd , MOD_SQL_SQLITE_VERSION , \"badly formed request\" ) ; } entry = sql_sqlite_get_conn ( cmd -> argv [ 0 ] ) ; if ( entry == NULL ) { sql_log ( DEBUG_FUNC , \"%s\" , \"exiting \\tsqlite cmd_open\" ) ; return PR_ERROR_MSG ( cmd , MOD_SQL_SQLITE_VERSION , pstrcat ( cmd -> tmp_pool , \"unknown named connection: \" , cmd -> argv [ 0 ] , NULL ) ) ; } conn = ( db_conn_t * ) entry -> data ; if ( entry -> nconn > 0 ) { entry -> nconn ++ ; if ( entry -> timer ) { pr_timer_reset ( entry -> timer , & sql_sqlite_module ) ; } sql_log ( DEBUG_INFO , \"'%s' connection count is now %u\" , entry -> name , entry -> nconn ) ; sql_log ( DEBUG_FUNC , \"%s\" , \"exiting \\tsqlite cmd_open\" ) ; return PR_HANDLED ( cmd ) ; } PRIVS_ROOT res = sqlite3_open_v2 ( conn -> dsn , & ( conn -> dbh ) , SQLITE_OPEN_READWRITE , NULL ) ; xerrno = errno ; PRIVS_RELINQUISH if ( res != SQLITE_OK ) { char * errstr ; errstr = pstrcat ( cmd -> pool , sqlite3_errmsg ( conn -> dbh ) , \" (\" , strerror ( xerrno ) , \")\" , NULL ) ; sql_log ( DEBUG_FUNC , \"error opening SQLite database '%s': %s\" , conn -> dsn , errstr ) ; sql_log ( DEBUG_FUNC , \"%s\" , \"exiting \\tsqlite cmd_open\" ) ; return PR_ERROR_MSG ( cmd , MOD_SQL_SQLITE_VERSION , errstr ) ; } if ( pr_trace_get_level ( trace_channel ) >= SQLITE_TRACE_LEVEL ) { sqlite3_trace ( conn -> dbh , db_trace , NULL ) ; } stmt = \"PRAGMA journal_mode = MEMORY;\" ; res = sqlite3_exec ( conn -> dbh , stmt , NULL , NULL , NULL ) ; while ( res != SQLITE_OK ) { if ( res == SQLITE_BUSY ) { struct timeval tv ; nretries ++ ; sql_log ( DEBUG_FUNC , \"attempt #%u, database busy, trying '%s' again\" , nretries , stmt ) ; tv . tv_sec = 0 ; tv . tv_usec = 500000L ; if ( select ( 0 , NULL , NULL , NULL , & tv ) < 0 ) { if ( errno == EINTR ) { pr_signals_handle ( ) ; } } res = sqlite3_exec ( conn -> dbh , stmt , NULL , NULL , NULL ) ; } } if ( res != SQLITE_OK ) { sql_log ( DEBUG_FUNC , \"error setting MEMORY journal mode: %s\" , sqlite3_errmsg ( conn -> dbh ) ) ; } sql_log ( DEBUG_INFO , MOD_SQL_SQLITE_VERSION \": SQLite version: %s\" , sqlite3_libversion ( ) ) ; entry -> nconn ++ ; if ( pr_sql_conn_policy == SQL_CONN_POLICY_PERSESSION ) { if ( entry -> nconn == 1 ) { entry -> nconn ++ ; } } if ( entry -> ttl > 0 ) { entry -> timer = pr_timer_add ( entry -> ttl , - 1 , & sql_sqlite_module , sql_sqlite_timer_cb , \"sqlite connection ttl\" ) ; sql_log ( DEBUG_INFO , \"'%s' connection: %d second timer started\" , entry -> name , entry -> ttl ) ; entry -> nconn ++ ; } sql_log ( DEBUG_INFO , \"'%s' connection opened\" , entry -> name ) ; sql_log ( DEBUG_INFO , \"'%s' connection count is now %u\" , entry -> name , entry -> nconn ) ; pr_event_generate ( \"mod_sql.db.connection-opened\" , & sql_sqlite_module ) ; sql_log ( DEBUG_FUNC , \"%s\" , \"exiting \\tsqlite cmd_open\" ) ; return PR_HANDLED ( cmd ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int fru_get_num_packets ( segment_hdl_t segment , door_cred_t * cred ) { packet_info_t numpackets ; int fd ; if ( ( fd = fru_open_dev ( ) ) == - 1 ) { return ( - 1 ) ; } numpackets . hdl = segment ; numpackets . cnt = 0 ; return ( numpackets . cnt ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _cmp_sci_clk ( const void * a , const void * b ) { const struct sci_clk * ca = a ; const struct sci_clk * cb = * ( sci_clk * * ) b ; if ( ca -> dev_id == cb -> dev_id && ca -> clk_id == cb -> clk_id ) { return 0 ; } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int show_interface_msg ( struct imsg * imsg ) { struct ctl_iface * iface ; char * netid ; switch ( imsg -> hdr . type ) { case IMSG_CTL_SHOW_IFACE : iface = imsg -> data ; if ( asprintf ( & netid , \"%s/%d\" , inet_ntoa ( iface -> addr ) , mask2prefixlen ( iface -> mask . s_addr ) ) == - 1 ) { err ( 1 , NULL ) ; } printf ( \"%-11s %-18s %-10s %-10s %-8s\\n\" , iface -> name , netid , if_state_name ( iface -> state ) , get_linkstate ( iface -> if_type , iface -> linkstate ) , iface -> uptime == 0 ?\"00:00:00\" : fmt_timeframe_core ( iface -> uptime ) ) ; break ; case IMSG_CTL_END : printf ( \"\\n\" ) ; return ( 1 ) ; default : break ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dirserv_should_launch_reachability_test ( const routerinfo_t * ri , const routerinfo_t * ri_old ) { if ( ! authdir_mode_handles_descs ( get_options ( ) , ri -> purpose ) ) { return 0 ; } if ( ! ri_old ) { log_info ( LD_DIR , \"descriptor for new router %s\" , router_describe ( ri ) ) ; return 1 ; } if ( ri_old -> is_hibernating && ! ri -> is_hibernating ) { log_info ( LD_DIR , \"out of hibernation: router %s\" , router_describe ( ri ) ) ; return 1 ; } if ( ! routers_have_same_or_addrs ( ri , ri_old ) ) { log_info ( LD_DIR , \"address or port changed: router %s\" , router_describe ( ri ) ) ; return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void rv770_fini ( struct radeon_device * rdev ) { radeon_pm_fini ( rdev ) ; r700_cp_fini ( rdev ) ; r600_dma_fini ( rdev ) ; r600_irq_fini ( rdev ) ; radeon_wb_fini ( rdev ) ; radeon_ib_pool_fini ( rdev ) ; radeon_irq_kms_fini ( rdev ) ; uvd_v1_0_fini ( rdev ) ; radeon_uvd_fini ( rdev ) ; rv770_pcie_gart_fini ( rdev ) ; r600_vram_scratch_fini ( rdev ) ; radeon_gem_fini ( rdev ) ; radeon_fence_driver_fini ( rdev ) ; radeon_agp_fini ( rdev ) ; radeon_bo_fini ( rdev ) ; radeon_atombios_fini ( rdev ) ; rdev -> bios = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void dpu_encoder_phys_wb_setup ( struct dpu_encoder_phys * phys_enc ) { struct dpu_hw_wb * hw_wb = phys_enc -> hw_wb ; struct drm_display_mode mode = phys_enc -> cached_mode ; struct drm_framebuffer * fb ; DPU_DEBUG ( \"[mode_set:%d, \\\"%s\\\",%d,%d]\\n\" , hw_wb -> idx - WB_0 , mode . name , mode . hdisplay , mode . vdisplay ) ; dpu_encoder_phys_wb_set_ot_limit ( phys_enc ) ; dpu_encoder_phys_wb_set_qos_remap ( phys_enc ) ; dpu_encoder_phys_wb_set_qos ( phys_enc ) ; dpu_encoder_phys_wb_setup_fb ( phys_enc , fb ) ; dpu_encoder_phys_wb_setup_cdp ( phys_enc ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int addr4_resolve ( struct sockaddr * src_sock , const struct sockaddr * dst_sock , struct rdma_dev_addr * addr , struct rtable * * prt ) { struct sockaddr_in * src_in = ( sockaddr_in * ) src_sock ; const struct sockaddr_in * dst_in = ( const sockaddr_in * ) dst_sock ; __be32 src_ip = src_in -> sin_addr . s_addr ; __be32 dst_ip = dst_in -> sin_addr . s_addr ; struct rtable * rt ; struct flowi4 fl4 ; int ret ; fl4 . daddr = dst_ip ; fl4 . saddr = src_ip ; fl4 . flowi4_oif = addr -> bound_dev_if ; rt = ip_route_output_key ( addr -> net , & fl4 ) ; ret = PTR_ERR_OR_ZERO ( rt ) ; if ( ret ) { return ret ; } src_in -> sin_addr . s_addr = fl4 . saddr ; addr -> hoplimit = ip4_dst_hoplimit ( & rt -> dst ) ; * prt = rt ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s5m8767_enable_ext_control ( struct s5m8767_info * s5m8767 , struct regulator_dev * rdev ) { int id = rdev_get_id ( rdev ) ; int ret , reg , enable_ctrl ; if ( id != S5M8767_BUCK9 ) { return - EINVAL ; } ret = s5m8767_get_register ( s5m8767 , id , & reg , & enable_ctrl ) ; return regmap_update_bits ( s5m8767 -> iodev -> regmap_pmic , reg , S5M8767_ENCTRL_MASK , S5M8767_ENCTRL_USE_GPIO << S5M8767_ENCTRL_SHIFT ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * argv [ ] ) { int t , i ; int maxdev ; int flags = 0 ; int status = 0 ; int errors = 0 ; int numdev ; extern int optind ; testcfg_t * tcfg ; ( void ) setlocale ( LC_ALL , \"\" ) ; ( void ) textdomain ( TEXT_DOMAIN ) ; tcfg = & test_stereo ; while ( ( i = getopt ( argc , argv , \"l2457r:\" ) ) != EOF ) { switch ( i ) { case 'l' : flags |= TF_LOOP ; break ; case '2' : tcfg = & test_stereo ; break ; case '4' : tcfg = & test_quad ; break ; case '5' : tcfg = & test_51 ; break ; case '7' : tcfg = & test_71 ; break ; case 'r' : tcfg -> rate = atoi ( optarg ) ; break ; default : ( void ) printf ( _ ( \"Usage: %s [options...] [device]\\n\" \"\t-2\tStereo test\\n\" \"\t-4\tQuadraphonic 4.0 test\\n\" \"\t-5\tSurround 5.1 test\\n\" \"\t-7\tSurround 7.1 test\\n\" \"\t-r\tSample Rate (48000|96000|192000)\\n\" \"\t-l\tLoop test\\n\" ) , argv [ 0 ] ) ; exit ( - 1 ) ; } } if ( ( mixerfd = open ( \"/dev/mixer\" , O_RDWR , 0 ) ) == - 1 ) { int err = errno ; perror ( \"/dev/mixer\" ) ; errno = err ; describe_error ( errno ) ; exit ( - 1 ) ; } prepare ( tcfg ) ; maxdev = find_num_devices ( ) ; if ( maxdev < 1 ) { ( void ) printf ( _ ( \"\\n*** No audio hardware available ***\\n\" ) ) ; exit ( - 1 ) ; } numdev = ( argc - optind ) ; { char * dn ; oss_audioinfo ainfo ; int rv ; if ( numdev > 0 ) { for ( t = 0 ; t < numdev ; t ++ ) { dn = argv [ optind + t ] ; rv = test_device ( dn , flags , tcfg ) ; if ( rv < 0 ) { errors ++ ; } if ( rv ) { status ++ ; } } } else { for ( t = 0 ; t < maxdev ; t ++ ) { ainfo . dev = t ; if ( ioctl ( mixerfd , SNDCTL_AUDIOINFO , & ainfo ) == - 1 ) { perror ( \"SNDCTL_AUDIOINFO\" ) ; status ++ ; continue ; } dn = ainfo . devnode ; rv = test_device ( dn , flags , tcfg ) ; if ( rv < 0 ) { errors ++ ; } if ( rv ) { status ++ ; } } } if ( errors == 0 ) { ( void ) printf ( _ ( \"\\n*** All tests completed OK ***\\n\" ) ) ; } else { ( void ) printf ( _ ( \"\\n*** Errors were detected ***\\n\" ) ) ; } } status && ( flags & TF_LOOP ) ; ( void ) close ( mixerfd ) ; return ( status ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int snd_pcm_add_chmap_ctls ( struct snd_pcm * pcm , int stream , const struct snd_pcm_chmap_elem * chmap , int max_channels , unsigned long private_value , struct snd_pcm_chmap * * info_ret ) { struct snd_pcm_chmap * info ; struct snd_kcontrol_new knew = { . iface = SNDRV_CTL_ELEM_IFACE_PCM . access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK . info = pcm_chmap_ctl_info . get = pcm_chmap_ctl_get . tlv . c = pcm_chmap_ctl_tlv } ; int err ; if ( WARN_ON ( pcm -> streams [ stream ] . chmap_kctl ) ) { return - EBUSY ; } info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; info -> pcm = pcm ; info -> stream = stream ; info -> chmap = chmap ; info -> max_channels = max_channels ; if ( stream == SNDRV_PCM_STREAM_PLAYBACK ) { knew . name = \"Playback Channel Map\" ; } else { knew . name = \"Capture Channel Map\" ; } knew . device = pcm -> device ; knew . count = pcm -> streams [ stream ] . substream_count ; knew . private_value = private_value ; info -> kctl = snd_ctl_new1 ( & knew , info ) ; if ( ! info -> kctl ) { kfree ( info ) ; return - ENOMEM ; } info -> kctl -> private_free = pcm_chmap_ctl_private_free ; err = snd_ctl_add ( pcm -> card , info -> kctl ) ; if ( err < 0 ) { return err ; } pcm -> streams [ stream ] . chmap_kctl = info -> kctl ; if ( info_ret ) { * info_ret = info ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int tegra_asoc_machine_probe ( struct platform_device * pdev ) { struct device_node * np_codec , * np_i2s , * np_ac97 ; const struct tegra_asoc_data * asoc ; struct device * dev = & pdev -> dev ; struct tegra_machine * machine ; struct snd_soc_card * card ; struct gpio_desc * gpiod ; int err ; machine = devm_kzalloc ( dev , sizeof ( * machine ) , GFP_KERNEL ) ; asoc = of_device_get_match_data ( dev ) ; card = asoc -> card ; card -> dev = dev ; machine -> asoc = asoc ; machine -> mic_jack = & tegra_machine_mic_jack ; machine -> hp_jack_gpio = & tegra_machine_hp_jack_gpio ; snd_soc_card_set_drvdata ( card , machine ) ; gpiod = devm_gpiod_get_optional ( dev , \"nvidia,hp-mute\" , GPIOD_OUT_HIGH ) ; machine -> gpiod_hp_mute = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } gpiod = devm_gpiod_get_optional ( dev , \"nvidia,hp-det\" , GPIOD_IN ) ; machine -> gpiod_hp_det = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } gpiod = devm_gpiod_get_optional ( dev , \"nvidia,mic-det\" , GPIOD_IN ) ; machine -> gpiod_mic_det = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } gpiod = devm_gpiod_get_optional ( dev , \"nvidia,spkr-en\" , GPIOD_OUT_LOW ) ; machine -> gpiod_spkr_en = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } gpiod = devm_gpiod_get_optional ( dev , \"nvidia,int-mic-en\" , GPIOD_OUT_LOW ) ; machine -> gpiod_int_mic_en = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } gpiod = devm_gpiod_get_optional ( dev , \"nvidia,ext-mic-en\" , GPIOD_OUT_LOW ) ; machine -> gpiod_ext_mic_en = gpiod ; if ( IS_ERR ( gpiod ) ) { return PTR_ERR ( gpiod ) ; } err = snd_soc_of_parse_card_name ( card , \"nvidia,model\" ) ; if ( err ) { return err ; } if ( ! card -> dapm_routes ) { err = snd_soc_of_parse_audio_routing ( card , \"nvidia,audio-routing\" ) ; if ( err ) { return err ; } } if ( asoc -> set_ac97 ) { err = tegra_machine_register_codec ( dev , asoc -> codec_dev_name ) ; if ( err ) { return err ; } np_ac97 = tegra_machine_parse_phandle ( dev , \"nvidia,ac97-controller\" ) ; if ( IS_ERR ( np_ac97 ) ) { return PTR_ERR ( np_ac97 ) ; } card -> dai_link -> cpus -> of_node = np_ac97 ; card -> dai_link -> platforms -> of_node = np_ac97 ; } else { np_codec = tegra_machine_parse_phandle ( dev , \"nvidia,audio-codec\" ) ; if ( IS_ERR ( np_codec ) ) { return PTR_ERR ( np_codec ) ; } np_i2s = tegra_machine_parse_phandle ( dev , \"nvidia,i2s-controller\" ) ; if ( IS_ERR ( np_i2s ) ) { return PTR_ERR ( np_i2s ) ; } card -> dai_link -> cpus -> of_node = np_i2s ; card -> dai_link -> codecs -> of_node = np_codec ; card -> dai_link -> platforms -> of_node = np_i2s ; } if ( asoc -> add_common_controls ) { card -> controls = tegra_machine_controls ; card -> num_controls = ARRAY_SIZE ( tegra_machine_controls ) ; } if ( asoc -> add_common_dapm_widgets ) { card -> dapm_widgets = tegra_machine_dapm_widgets ; card -> num_dapm_widgets = ARRAY_SIZE ( tegra_machine_dapm_widgets ) ; } if ( asoc -> add_common_snd_ops ) { card -> dai_link -> ops = & tegra_machine_snd_ops ; } if ( ! card -> owner ) { card -> owner = THIS_MODULE ; } if ( ! card -> driver_name ) { card -> driver_name = \"tegra\" ; } machine -> clk_pll_a = devm_clk_get ( dev , \"pll_a\" ) ; if ( IS_ERR ( machine -> clk_pll_a ) ) { dev_err ( dev , \"Can't retrieve clk pll_a\\n\" ) ; return PTR_ERR ( machine -> clk_pll_a ) ; } machine -> clk_pll_a_out0 = devm_clk_get ( dev , \"pll_a_out0\" ) ; if ( IS_ERR ( machine -> clk_pll_a_out0 ) ) { dev_err ( dev , \"Can't retrieve clk pll_a_out0\\n\" ) ; return PTR_ERR ( machine -> clk_pll_a_out0 ) ; } machine -> clk_cdev1 = devm_clk_get ( dev , \"mclk\" ) ; if ( IS_ERR ( machine -> clk_cdev1 ) ) { dev_err ( dev , \"Can't retrieve clk cdev1\\n\" ) ; return PTR_ERR ( machine -> clk_cdev1 ) ; } if ( ! of_find_property ( dev -> of_node , \"assigned-clock-parents\" , NULL ) && ! of_machine_is_compatible ( \"nvidia,tegra20\" ) ) { struct clk * clk_out_1 , * clk_extern1 ; dev_warn ( dev , \"Configuring clocks for a legacy device-tree\\n\" ) ; dev_warn ( dev , \"Please update DT to use assigned-clock-parents\\n\" ) ; clk_extern1 = devm_clk_get ( dev , \"extern1\" ) ; if ( IS_ERR ( clk_extern1 ) ) { dev_err ( dev , \"Can't retrieve clk extern1\\n\" ) ; return PTR_ERR ( clk_extern1 ) ; } err = clk_set_parent ( clk_extern1 , machine -> clk_pll_a_out0 ) ; if ( err < 0 ) { dev_err ( dev , \"Set parent failed for clk extern1\\n\" ) ; return err ; } clk_out_1 = devm_clk_get ( dev , \"pmc_clk_out_1\" ) ; if ( IS_ERR ( clk_out_1 ) ) { dev_err ( dev , \"Can't retrieve pmc_clk_out_1\\n\" ) ; return PTR_ERR ( clk_out_1 ) ; } err = clk_set_parent ( clk_out_1 , clk_extern1 ) ; if ( err < 0 ) { dev_err ( dev , \"Set parent failed for pmc_clk_out_1\\n\" ) ; return err ; } machine -> clk_cdev1 = clk_out_1 ; } if ( asoc -> set_ac97 ) { err = clk_set_rate ( machine -> clk_pll_a , 73728000 ) ; if ( err ) { dev_err ( dev , \"Can't set pll_a rate: %d\\n\" , err ) ; return err ; } err = clk_set_rate ( machine -> clk_pll_a_out0 , 24576000 ) ; if ( err ) { dev_err ( dev , \"Can't set pll_a_out0 rate: %d\\n\" , err ) ; return err ; } machine -> set_baseclock = 73728000 ; machine -> set_mclk = 24576000 ; } err = clk_prepare_enable ( machine -> clk_cdev1 ) ; if ( err ) { dev_err ( dev , \"Can't enable cdev1: %d\\n\" , err ) ; return err ; } err = devm_snd_soc_register_card ( dev , card ) ; if ( err ) { return err ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static enum zfcp_erp_act_result zfcp_erp_port_forced_strategy_close ( struct zfcp_erp_action * act ) { int retval ; retval = zfcp_fsf_close_physical_port ( act , NULL ) ; if ( retval == - ENOMEM ) { return ZFCP_ERP_NOMEM ; } act -> step = ZFCP_ERP_STEP_PHYS_PORT_CLOSING ; if ( retval ) { return ZFCP_ERP_FAILED ; } return ZFCP_ERP_CONTINUES ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void it821x_passthru_bmdma_stop ( struct ata_queued_cmd * qc ) { struct ata_port * ap = qc -> ap ; struct ata_device * adev = qc -> dev ; struct it821x_dev * itdev = ap -> private_data ; int unit = adev -> devno ; ata_bmdma_stop ( qc , NULL ) ; if ( itdev -> mwdma [ unit ] != MWDMA_OFF ) { it821x_program ( ap , adev , itdev -> pio [ unit ] ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tpmfront_resume ( struct xenbus_device * dev ) { tpmfront_remove ( dev , NULL ) ; return tpmfront_probe ( dev , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int aiff_read_header ( AVFormatContext * s ) { int ret ; int64_t filesize , size ; int64_t offset = 0 , position ; uint32_t tag ; unsigned version = AIFF_C_VERSION1 ; AVIOContext * pb = s -> pb ; AVStream * st ; AIFFInputContext * aiff = s -> priv_data ; ID3v2ExtraMeta * id3v2_extra_meta ; filesize = get_tag ( pb , & tag ) ; if ( filesize < 4 || tag != MKTAG ( 'F' , 'O' , 'R' , 'M' ) ) { return AVERROR_INVALIDDATA ; } tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( 'A' , 'I' , 'F' , 'F' ) ) { version = AIFF ; } if ( tag != MKTAG ( 'A' , 'I' , 'F' , 'C' ) ) { return AVERROR_INVALIDDATA ; } filesize -= 4 ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { return AVERROR ( ENOMEM ) ; } while ( filesize > 0 ) { size = get_tag ( pb , & tag ) ; if ( size == AVERROR_EOF && offset > 0 && st -> codecpar -> block_align ) { av_log ( s , AV_LOG_WARNING , \"header parser hit EOF\\n\" ) ; got_sound } if ( size < 0 ) { return size ; } filesize -= size + 8 ; switch ( tag ) { case MKTAG ( 'C' , 'O' , 'M' , 'M' ) : st -> nb_frames = get_aiff_header ( s , size , version ) ; if ( st -> nb_frames < 0 ) { return st -> nb_frames ; } if ( offset > 0 ) { got_sound } break ; case MKTAG ( 'I' , 'D' , '3' , ' ' ) : position = avio_tell ( pb ) ; ff_id3v2_read ( s , ID3v2_DEFAULT_MAGIC , & id3v2_extra_meta , size ) ; if ( id3v2_extra_meta ) { if ( ( ret = ff_id3v2_parse_apic ( s , id3v2_extra_meta ) ) < 0 || ( ret = ff_id3v2_parse_chapters ( s , id3v2_extra_meta ) ) < 0 ) { ff_id3v2_free_extra_meta ( & id3v2_extra_meta ) ; return ret ; } } ff_id3v2_free_extra_meta ( & id3v2_extra_meta ) ; if ( position + size > avio_tell ( pb ) ) { avio_skip ( pb , position + size - avio_tell ( pb ) ) ; } break ; case MKTAG ( 'F' , 'V' , 'E' , 'R' ) : version = avio_rb32 ( pb ) ; break ; case MKTAG ( 'N' , 'A' , 'M' , 'E' ) : get_meta ( s , \"title\" , size ) ; break ; case MKTAG ( 'A' , 'U' , 'T' , 'H' ) : get_meta ( s , \"author\" , size ) ; break ; case MKTAG ( '(' , 'c' , ')' , ' ' ) : get_meta ( s , \"copyright\" , size ) ; break ; case MKTAG ( 'A' , 'N' , 'N' , 'O' ) : get_meta ( s , \"comment\" , size ) ; break ; case MKTAG ( 'S' , 'S' , 'N' , 'D' ) : if ( size < 8 ) { return AVERROR_INVALIDDATA ; } aiff -> data_end = avio_tell ( pb ) + size ; offset = avio_rb32 ( pb ) ; avio_rb32 ( pb ) ; offset += avio_tell ( pb ) ; if ( st -> codecpar -> block_align && ! ( pb -> seekable & AVIO_SEEKABLE_NORMAL ) ) { got_sound } if ( ! ( pb -> seekable & AVIO_SEEKABLE_NORMAL ) ) { av_log ( s , AV_LOG_ERROR , \"file is not seekable\\n\" ) ; return - 1 ; } avio_skip ( pb , size - 8 ) ; break ; case MKTAG ( 'w' , 'a' , 'v' , 'e' ) : if ( ( uint64_t ) size > ( 1 << 30 ) ) { return AVERROR_INVALIDDATA ; } if ( ( ret = ff_get_extradata ( s , st -> codecpar , pb , size ) ) < 0 ) { return ret ; } if ( ( st -> codecpar -> codec_id == AV_CODEC_ID_QDMC || st -> codecpar -> codec_id == AV_CODEC_ID_QDM2 ) && size >= 12 * 4 && ! st -> codecpar -> block_align ) { st -> codecpar -> block_align = AV_RB32 ( st -> codecpar -> extradata + 11 * 4 ) ; aiff -> block_duration = AV_RB32 ( st -> codecpar -> extradata + 9 * 4 ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_QCELP ) { char rate = 0 ; if ( size >= 25 ) { rate = st -> codecpar -> extradata [ 24 ] ; } switch ( rate ) { case 'H' : st -> codecpar -> block_align = 17 ; break ; case 'F' : default : st -> codecpar -> block_align = 35 ; } aiff -> block_duration = 160 ; st -> codecpar -> bit_rate = st -> codecpar -> sample_rate * ( st -> codecpar -> block_align << 3 ) / aiff -> block_duration ; } break ; case MKTAG ( 'C' , 'H' , 'A' , 'N' ) : if ( ( ret = ff_mov_read_chan ( s , pb , st , size ) ) < 0 ) { return ret ; } break ; case MKTAG ( 'A' , 'P' , 'C' , 'M' ) : st -> codecpar -> codec_id = AV_CODEC_ID_ADPCM_XA ; aiff -> data_end = avio_tell ( pb ) + size ; offset = avio_tell ( pb ) + 8 ; avio_rb32 ( pb ) ; st -> codecpar -> block_align = avio_rb32 ( pb ) ; got_sound break ; case 0 : if ( offset > 0 && st -> codecpar -> block_align ) { got_sound } default : avio_skip ( pb , size ) ; } if ( size & 1 ) { filesize -- ; avio_skip ( pb , 1 ) ; } } ret = ff_replaygain_export ( st , s -> metadata ) ; if ( ret < 0 ) { return ret ; } got_sound if ( ! st -> codecpar -> block_align && st -> codecpar -> codec_id == AV_CODEC_ID_QCELP ) { av_log ( s , AV_LOG_WARNING , \"qcelp without wave chunk, assuming full rate\\n\" ) ; st -> codecpar -> block_align = 35 ; } if ( st -> codecpar -> block_align <= 0 ) { av_log ( s , AV_LOG_ERROR , \"could not find COMM tag or invalid block_align value\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( aiff -> block_duration < 0 ) { return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( st , 64 , 1 , st -> codecpar -> sample_rate ) ; st -> start_time = 0 ; st -> duration = st -> nb_frames * aiff -> block_duration ; avio_seek ( pb , offset , SEEK_SET ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int do_umount ( struct mount * mnt , int flags ) { struct super_block * sb = mnt -> mnt . mnt_sb ; int retval ; retval = security_sb_umount ( & mnt -> mnt , flags ) ; if ( retval ) { return retval ; } if ( flags & MNT_EXPIRE ) { if ( & mnt -> mnt == current -> fs -> root . mnt || flags & ( MNT_FORCE | MNT_DETACH ) ) { return - EINVAL ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) != 2 ) { unlock_mount_hash ( ) ; return - EBUSY ; } unlock_mount_hash ( ) ; if ( ! xchg ( & mnt -> mnt_expiry_mark , 1 ) ) { return - EAGAIN ; } } if ( flags & MNT_FORCE && sb -> s_op -> umount_begin ) { sb -> s_op -> umount_begin ( sb ) ; } if ( & mnt -> mnt == current -> fs -> root . mnt && ! ( flags & MNT_DETACH ) ) { down_write ( & sb -> s_umount ) ; if ( ! ( sb -> s_flags & MS_RDONLY ) ) { retval = do_remount_sb ( sb , MS_RDONLY , NULL , 0 ) ; } up_write ( & sb -> s_umount ) ; return retval ; } namespace_lock ( ) ; lock_mount_hash ( ) ; event ++ ; if ( flags & MNT_DETACH ) { if ( ! list_empty ( & mnt -> mnt_list ) ) { umount_tree ( mnt , UMOUNT_PROPAGATE ) ; } retval = 0 ; } else { shrink_submounts ( mnt ) ; retval = - EBUSY ; if ( ! propagate_mount_busy ( mnt , 2 ) ) { if ( ! list_empty ( & mnt -> mnt_list ) ) { umount_tree ( mnt , UMOUNT_PROPAGATE | UMOUNT_SYNC ) ; } retval = 0 ; } } unlock_mount_hash ( ) ; namespace_unlock ( ) ; return retval ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "IPPair * IPPairDequeue ( IPPairQueue * q ) { HQLOCK_LOCK ( q ) ; IPPair * h = q -> bot ; if ( h == NULL ) { HQLOCK_UNLOCK ( q ) ; return NULL ; } if ( q -> bot -> lprev != NULL ) { q -> bot = q -> bot -> lprev ; q -> bot -> lnext = NULL ; } else { q -> top = NULL ; } BUG_ON ( q -> len == 0 ) ; if ( q -> len > 0 ) { q -> len -- ; } h -> lnext = NULL ; h -> lprev = NULL ; HQLOCK_UNLOCK ( q ) ; return h ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool vread_at_be32 ( RBin * b , ut32 vaddr , ut32 * out ) { ut8 buf [ 4 ] { 0 } ; ; * out = r_read_be32 ( & buf ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "l_ok recogShowContent ( FILE * fp , L_RECOG * recog , l_int32 index , l_int32 display ) { char buf [ 128 ] ; l_int32 i , val , count ; PIX * pix ; NUMA * na ; if ( ! fp ) { return ERROR_INT ( \"stream not defined\" , __func__ , 1 ) ; } if ( ! recog ) { return ERROR_INT ( \"recog not defined\" , __func__ , 1 ) ; } fprintf ( fp , \"Debug print of recog contents\\n\" ) ; fprintf ( fp , \"  Setsize: %d\\n\" , recog -> setsize ) ; fprintf ( fp , \"  Binarization threshold: %d\\n\" , recog -> threshold ) ; fprintf ( fp , \"  Maximum matching y-jiggle: %d\\n\" , recog -> maxyshift ) ; if ( recog -> linew <= 0 ) { fprintf ( fp , \"  Using image templates for matching\\n\" ) ; } else { fprintf ( fp , \"  Using templates with fixed line width for matching\\n\" ) ; } if ( recog -> scalew == 0 ) { fprintf ( fp , \"  No width scaling of templates\\n\" ) ; } else { fprintf ( fp , \"  Template width scaled to %d\\n\" , recog -> scalew ) ; } if ( recog -> scaleh == 0 ) { fprintf ( fp , \"  No height scaling of templates\\n\" ) ; } else { fprintf ( fp , \"  Template height scaled to %d\\n\" , recog -> scaleh ) ; } fprintf ( fp , \"  Number of samples in each class:\\n\" ) ; pixaaGetCount ( recog -> pixaa_u , & na ) ; for ( i = 0 ; i < recog -> setsize ; i ++ ) { l_dnaGetIValue ( recog -> dna_tochar , i , & val ) ; numaGetIValue ( na , i , & count ) ; if ( val < 128 ) { fprintf ( fp , \"    class %d, char %c:   %d\\n\" , i , val , count ) ; } else { fprintf ( fp , \"    class %d, val %d:   %d\\n\" , i , val , count ) ; } } numaDestroy ( & na ) ; if ( display ) { lept_mkdir ( \"lept/recog\" ) ; pix = pixaaDisplayByPixa ( recog -> pixaa_u , 50 , 1.0 , 20 , 20 , 0 ) ; sprintf ( buf , \"/tmp/lept/recog/templates_u.%d.png\" , index ) ; pixWriteDebug ( buf , pix , IFF_PNG ) ; pixDisplay ( pix , 0 , 200 * index ) ; pixDestroy ( & pix ) ; if ( recog -> train_done ) { pix = pixaaDisplayByPixa ( recog -> pixaa , 50 , 1.0 , 20 , 20 , 0 ) ; snprintf ( buf , sizeof ( buf ) , \"/tmp/lept/recog/templates.%d.png\" , index ) ; pixWriteDebug ( buf , pix , IFF_PNG ) ; pixDisplay ( pix , 800 , 200 * index ) ; pixDestroy ( & pix ) ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pmu_apic_update ( uint32_t val ) { int ret ; struct xen_pmu_data * xenpmu_data = get_xenpmu_data ( ) ; if ( ! xenpmu_data ) { pr_warn_once ( \"%s: pmudata not initialized\\n\" , __func__ ) ; return - EINVAL ; } xenpmu_data -> pmu . l . lapic_lvtpc = val ; ret = HYPERVISOR_xenpmu_op ( XENPMU_lvtpc_set , NULL ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pci_free_intr_fixed ( dev_info_t * pdip , dev_info_t * rdip , ddi_intr_handle_impl_t * hdlp ) { struct intrspec * ispec ; ddi_intr_handle_impl_t info_hdl ; int ret ; apic_get_type_t type_info ; bzero ( & info_hdl , sizeof ( ddi_intr_handle_impl_t ) ) ; info_hdl . ih_private = & type_info ; if ( * psm_intr_ops ( NULL , & info_hdl , PSM_INTR_OP_APIC_TYPE , NULL ) == PSM_SUCCESS && strcmp ( type_info . avgi_type , APIC_APIX_NAME ) == 0 ) { ispec = ( intrspec * ) pci_intx_get_ispec ( pdip , rdip , ( int ) hdlp -> ih_inum ) ; if ( ispec == NULL ) { return ( DDI_FAILURE ) ; } ( ( ihdl_plat_t * ) hdlp -> ih_private ) -> ip_ispecp = ispec ; ret = * psm_intr_ops ( rdip , hdlp , PSM_INTR_OP_FREE_VECTORS , NULL ) ; } else { ret = DDI_SUCCESS ; } return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * format_add_linestart ( const char * text , const char * linestart ) { GString * str ; char * ret ; if ( strchr ( text , '\\n' ) == NULL ) { return g_strconcat ( linestart , text , NULL ) ; } str = g_string_new ( linestart ) ; while ( * text != '\\0' ) { g_string_append_c ( str , * text ) ; if ( * text == '\\n' ) { g_string_append ( str , linestart ) ; } text ++ ; } ret = str -> str ; g_string_free ( str , FALSE ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int virSecurityDACSetHostdevLabel ( virSecurityManager * mgr , virDomainDef * def , virDomainHostdevDef * dev , const char * vroot ) { virSecurityDACData * priv = virSecurityManagerGetPrivateData ( mgr ) ; virSecurityDACCallbackData cbdata ; virDomainHostdevSubsysUSB * usbsrc = & dev -> source . subsys . u . usb ; virDomainHostdevSubsysPCI * pcisrc = & dev -> source . subsys . u . pci ; virDomainHostdevSubsysSCSI * scsisrc = & dev -> source . subsys . u . scsi ; virDomainHostdevSubsysSCSIVHost * hostsrc = & dev -> source . subsys . u . scsi_host ; virDomainHostdevSubsysMediatedDev * mdevsrc = & dev -> source . subsys . u . mdev ; int ret = - 1 ; if ( ! priv -> dynamicOwnership ) { return 0 ; } if ( dev -> mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ) { return 0 ; } if ( dev -> source . subsys . type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI && scsisrc -> protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI ) { return 0 ; } cbdata . manager = mgr ; cbdata . secdef = virDomainDefGetSecurityLabelDef ( def , SECURITY_DAC_NAME ) ; if ( cbdata . secdef && ! cbdata . secdef -> relabel ) { return 0 ; } switch ( ( virDomainHostdevSubsysType ) dev -> source . subsys . type ) { case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB : { g_autoptr ( ) usb = NULL ; if ( dev -> missing ) { return 0 ; } if ( ! ( usb = virUSBDeviceNew ( usbsrc -> bus , usbsrc -> device , vroot ) ) ) { return - 1 ; } ret = virUSBDeviceFileIterate ( usb , virSecurityDACSetUSBLabel , & cbdata ) ; break ; } case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI : { g_autoptr ( ) pci = NULL ; if ( ! virPCIDeviceExists ( & pcisrc -> addr ) ) { break ; } pci = virPCIDeviceNew ( & pcisrc -> addr ) ; if ( ! pci ) { return - 1 ; } if ( pcisrc -> backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ) { g_autofree char * vfioGroupDev = virPCIDeviceGetIOMMUGroupDev ( pci ) ; ret = virSecurityDACSetHostdevLabelHelper ( vfioGroupDev , false , & cbdata ) ; } else { ret = virPCIDeviceFileIterate ( pci , virSecurityDACSetPCILabel , & cbdata ) ; } break ; } case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI : { virDomainHostdevSubsysSCSIHost * scsihostsrc = & scsisrc -> u . host ; g_autoptr ( ) scsi = virSCSIDeviceNew ( NULL , scsihostsrc -> adapter , scsihostsrc -> bus , scsihostsrc -> target , scsihostsrc -> unit , dev -> readonly , dev -> shareable ) ; if ( ! scsi ) { return - 1 ; } ret = virSCSIDeviceFileIterate ( scsi , virSecurityDACSetSCSILabel , & cbdata ) ; break ; } case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST : { g_autoptr ( ) host = virSCSIVHostDeviceNew ( hostsrc -> wwpn ) ; if ( ! host ) { return - 1 ; } ret = virSCSIVHostDeviceFileIterate ( host , virSecurityDACSetHostLabel , & cbdata ) ; break ; } case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV : { g_autofree char * vfiodev = NULL ; if ( ! ( vfiodev = virMediatedDeviceGetIOMMUGroupDev ( mdevsrc -> uuidstr ) ) ) { return - 1 ; } ret = virSecurityDACSetHostdevLabelHelper ( vfiodev , true , & cbdata ) ; break ; } case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST : ret = 0 ; break ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ax25_register_dev_sysctl ( ax25_dev * ax25_dev ) { char path [ sizeof ( \"net/ax25/\" ) + IFNAMSIZ ] ; int k ; struct ctl_table * table ; table = kmemdup ( ax25_param_table , sizeof ( ax25_param_table ) , GFP_KERNEL ) ; for ( k = 0 ; k < AX25_MAX_VALUES ; k ++ ) { table [ k ] . data = & ax25_dev -> values [ k ] ; } snprintf ( path , sizeof ( path ) , \"net/ax25/%s\" , ax25_dev -> dev -> name ) ; ax25_dev -> sysheader = register_net_sysctl ( & init_net , path , table ) ; if ( ! ax25_dev -> sysheader ) { kfree ( table ) ; return - ENOMEM ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int dwc2_phy_setup ( struct udevice * dev , struct phy_bulk * phys ) { int ret ; ret = generic_phy_get_bulk ( dev , phys ) ; ret = generic_phy_init_bulk ( phys ) ; if ( ret ) { return ret ; } ret = generic_phy_power_on_bulk ( phys ) ; if ( ret ) { generic_phy_exit_bulk ( phys ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int intro ( void ) { _cleanup_ ( ) sd_hwdb * hwdb ; int r ; r = sd_hwdb_new ( & hwdb ) ; if ( r == - ENOENT || ERRNO_IS_PRIVILEGE ( r ) ) { return log_tests_skipped_errno ( r , \"cannot open hwdb\" ) ; } return EXIT_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "START_TEST ( ) { register unsigned int i = 0 ; const char * paths [ 4 ] { \"/dev/null\" \"none\" \"off\" NULL } ; ; const char * path ; for ( path = paths [ i ] ; path != NULL ; path = paths [ i ++ ] ) { int res ; const char * field , * ok ; pid_t scoreboard_pid ; time_t scoreboard_uptime ; pr_scoreboard_entry_t * score ; res = pr_set_scoreboard ( path , NULL ) ; ck_assert_msg ( res == 0 , \"Failed set to scoreboard to '%s': %s\" , path , strerror ( errno ) ) ; ok = PR_RUN_DIR \"/proftpd.scoreboard\" ; path = pr_get_scoreboard ( ) ; ck_assert_msg ( path != NULL , \"Failed to get scoreboard path: %s\" , strerror ( errno ) ) ; ck_assert_msg ( strcmp ( path , ok ) == 0 , \"Expected path '%s', got '%s'\" , ok , path ) ; res = pr_open_scoreboard ( O_RDONLY ) ; ck_assert_msg ( res == 0 , \"Failed to open '%s' scoreboard: %s\" , path , strerror ( errno ) ) ; res = pr_scoreboard_scrub ( ) ; ck_assert_msg ( res == 0 , \"Failed to scrub '%s' scoreboard: %s\" , path , strerror ( errno ) ) ; scoreboard_pid = pr_scoreboard_get_daemon_pid ( ) ; ck_assert_msg ( scoreboard_pid == 0 , \"Expected to get scoreboard PID 0, got %lu\" , ( unsigned long ) scoreboard_pid ) ; scoreboard_uptime = pr_scoreboard_get_daemon_uptime ( ) ; ck_assert_msg ( scoreboard_uptime == 0 , \"Expected to get scoreboard uptime 0, got %lu\" , ( unsigned long ) scoreboard_uptime ) ; res = pr_scoreboard_entry_add ( ) ; ck_assert_msg ( res == 0 , \"Failed to add entry to '%s' scoreboard: %s\" , path , strerror ( errno ) ) ; score = pr_scoreboard_entry_read ( ) ; ck_assert_msg ( score == NULL , \"Expected null entry\" ) ; field = pr_scoreboard_entry_get ( PR_SCORE_CMD_ARG ) ; ck_assert_msg ( field == NULL , \"Expected null CMD_ARG field\" ) ; res = pr_scoreboard_entry_update ( getpid ( ) , PR_SCORE_CWD , \"foo\" , NULL ) ; ck_assert_msg ( res == 0 , \"Failed to update CWD field: %s\" , strerror ( errno ) ) ; res = pr_scoreboard_entry_del ( FALSE ) ; ck_assert_msg ( res == 0 , \"Failed to delete entry from '%s' scoreboard: %s\" , path , strerror ( errno ) ) ; res = pr_close_scoreboard ( FALSE ) ; ck_assert_msg ( res == 0 , \"Failed to close '%s' scoreboard: %s\" , path , strerror ( errno ) ) ; pr_set_scoreboard ( NULL ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct section * elf_create_reloc_section ( struct elf * elf , struct section * base , int reltype ) int elf_add_reloc ( struct elf * elf , struct section * sec , unsigned long offset , unsigned int type , struct symbol * sym , s64 addend ) { struct reloc * reloc ; if ( ! sec -> reloc && ! elf_create_reloc_section ( elf , sec , SHT_RELA ) ) { return - 1 ; } reloc = malloc ( sizeof ( * reloc ) ) ; if ( ! reloc ) { perror ( \"malloc\" ) ; return - 1 ; } reloc -> sec = sec -> reloc ; reloc -> offset = offset ; reloc -> type = type ; reloc -> sym = sym ; reloc -> addend = addend ; list_add_tail ( & reloc -> sym_reloc_entry , & sym -> reloc_list ) ; list_add_tail ( & reloc -> list , & sec -> reloc -> reloc_list ) ; elf_hash_add ( reloc , & reloc -> hash , reloc_hash ( reloc ) ) ; sec -> reloc -> sh . sh_size += sec -> reloc -> sh . sh_entsize ; sec -> reloc -> changed = true ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int connclose ( queue_t * q , int cflag , cred_t * crp ) { vnode_t * streamvp ; fifonode_t * streamfnp ; qprocsoff ( q ) ; streamvp = strq2vp ( q ) ; ASSERT ( streamvp != NULL ) ; ASSERT ( streamvp -> v_type == VFIFO ) ; streamfnp = VTOF ( streamvp ) ; streamfnp -> fn_flag &= ~ FIFOCONNLD ; VN_RELE ( streamvp , NULL ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "af_check ( ) { if ( family == AF_INET6 ) { return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rv3032_exit_eerd ( struct rv3032_data * rv3032 , u32 eerd ) { return regmap_update_bits ( rv3032 -> regmap , RV3032_CTRL1 , RV3032_CTRL1_EERD , 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct NeoMutt * neomutt_new ( struct ConfigSet * cs ) { if ( ! cs ) { return in ; } struct NeoMutt * n = mutt_mem_calloc ( 1 , sizeof ( * NeoMutt ) ) ; TAILQ_INIT ( & n -> accounts ) ; n -> notify = notify_new ( ) ; n -> sub = cs_subset_new ( NULL , NULL , n -> notify ) ; n -> sub -> cs = cs ; n -> sub -> scope = SET_SCOPE_NEOMUTT ; return n ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cros_usbpd_charger_get_num_ports ( struct charger_data * charger ) { struct ec_response_charge_port_count resp ; int ret ; ret = cros_usbpd_charger_ec_command ( charger , 0 , EC_CMD_CHARGE_PORT_COUNT , NULL , 0 , & resp , sizeof ( resp ) ) ; return resp . port_count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned long parman_lsort_new_index_find ( struct parman * parman , struct parman_prio * prio ) { list_for_each_entry_from_reverse ( , , ) { return parman_prio_last_index ( prio ) + 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xgpio_probe ( struct platform_device * pdev ) { struct xgpio_instance * chip ; int status = 0 ; struct device_node * np = pdev -> dev . of_node ; u32 is_dual ; chip = devm_kzalloc ( & pdev -> dev , sizeof ( * chip ) , GFP_KERNEL ) ; platform_set_drvdata ( pdev , chip ) ; of_property_read_u32 ( np , \"xlnx,dout-default\" , & chip -> gpio_state [ 0 ] ) ; if ( of_property_read_u32 ( np , \"xlnx,tri-default\" , & chip -> gpio_dir [ 0 ] ) ) { chip -> gpio_dir [ 0 ] = 0xFFFFFFFF ; } if ( of_property_read_u32 ( np , \"xlnx,gpio-width\" , & chip -> gpio_width [ 0 ] ) ) { chip -> gpio_width [ 0 ] = 32 ; } spin_lock_init ( & chip -> gpio_lock [ 0 ] ) ; if ( of_property_read_u32 ( np , \"xlnx,is-dual\" , & is_dual ) ) { is_dual = 0 ; } if ( is_dual ) { of_property_read_u32 ( np , \"xlnx,dout-default-2\" , & chip -> gpio_state [ 1 ] ) ; if ( of_property_read_u32 ( np , \"xlnx,tri-default-2\" , & chip -> gpio_dir [ 1 ] ) ) { chip -> gpio_dir [ 1 ] = 0xFFFFFFFF ; } if ( of_property_read_u32 ( np , \"xlnx,gpio2-width\" , & chip -> gpio_width [ 1 ] ) ) { chip -> gpio_width [ 1 ] = 32 ; } spin_lock_init ( & chip -> gpio_lock [ 1 ] ) ; } chip -> mmchip . gc . ngpio = chip -> gpio_width [ 0 ] + chip -> gpio_width [ 1 ] ; chip -> mmchip . gc . parent = & pdev -> dev ; chip -> mmchip . gc . direction_input = xgpio_dir_in ; chip -> mmchip . gc . direction_output = xgpio_dir_out ; chip -> mmchip . gc . get = xgpio_get ; chip -> mmchip . gc . set = xgpio_set ; chip -> mmchip . gc . set_multiple = xgpio_set_multiple ; chip -> mmchip . save_regs = xgpio_save_regs ; status = of_mm_gpiochip_add_data ( np , & chip -> mmchip , chip ) ; if ( status ) { pr_err ( \"%s: error in probe function with status %d\\n\" , np -> full_name , status ) ; return status ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int snd_emu1010_fpga_write ( struct snd_emu10k1 * emu , u32 reg , u32 value ) { unsigned long flags ; reg += 0x40 ; if ( value > 0x3f ) { return 1 ; } spin_lock_irqsave ( & emu -> emu_lock , flags ) ; outl ( reg , emu -> port + A_IOCFG ) ; udelay ( 10 ) ; outl ( reg | 0x80 , emu -> port + A_IOCFG ) ; udelay ( 10 ) ; outl ( value , emu -> port + A_IOCFG ) ; udelay ( 10 ) ; outl ( value | 0x80 , emu -> port + A_IOCFG ) ; spin_unlock_irqrestore ( & emu -> emu_lock , flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int radeon_atpx_validate ( struct radeon_atpx * atpx ) { u32 valid_bits = 0 ; if ( atpx -> functions . px_params ) { union acpi_object * info ; struct atpx_px_params output ; size_t size ; info = radeon_atpx_call ( atpx -> handle , ATPX_FUNCTION_GET_PX_PARAMETERS , NULL ) ; if ( ! info ) { return - EIO ; } memset ( & output , 0 , sizeof ( output ) ) ; size = * ( u16 * ) info -> buffer . pointer ; if ( size < 10 ) { printk ( \"ATPX buffer is too small: %zu\\n\" , size ) ; return - EINVAL ; } size = min ( sizeof ( output ) , size ) ; memcpy ( & output , info -> buffer . pointer , size ) ; valid_bits = output . flags & output . valid_flags ; kfree ( info ) ; } if ( valid_bits & ATPX_SEPARATE_MUX_FOR_I2C ) { atpx -> functions . i2c_mux_cntl = true ; atpx -> functions . disp_mux_cntl = true ; } if ( valid_bits & ( ATPX_CRT1_RGB_SIGNAL_MUXED | ATPX_TV_SIGNAL_MUXED | ATPX_DFP_SIGNAL_MUXED ) ) { atpx -> functions . disp_mux_cntl = true ; } if ( valid_bits & ( ATPX_DYNAMIC_PX_SUPPORTED | ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED ) ) { atpx -> functions . power_cntl = true ; } atpx -> is_hybrid = false ; if ( valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED ) { printk ( \"ATPX Hybrid Graphics\\n\" ) ; atpx -> functions . power_cntl = ! radeon_atpx_priv . bridge_pm_usable ; atpx -> is_hybrid = true ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test_checkout_typechange__checkout_with_conflicts ( void ) { int i ; git_object * obj ; git_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT ; notify_counts cts = { 0 } ; opts . notify_flags = GIT_CHECKOUT_NOTIFY_CONFLICT | GIT_CHECKOUT_NOTIFY_UNTRACKED ; opts . notify_cb = notify_counter ; opts . notify_payload = & cts ; for ( i = 0 ; g_typechange_oids [ i ] != NULL ; ++ i ) { cl_git_pass ( git_revparse_single ( & obj , g_repo , g_typechange_oids [ i ] ) ) ; force_create_file ( \"typechanges/a/blocker\" ) ; force_create_file ( \"typechanges/b\" ) ; force_create_file ( \"typechanges/c/sub/sub/file\" ) ; git_futils_rmdir_r ( \"typechanges/d\" , NULL , GIT_RMDIR_REMOVE_FILES ) ; p_mkdir ( \"typechanges/d\" , 0777 ) ; force_create_file ( \"typechanges/untracked\" ) ; cl_git_pass ( git_submodule_foreach ( g_repo , make_submodule_dirty , NULL ) ) ; opts . checkout_strategy = GIT_CHECKOUT_SAFE ; cl_git_fail ( git_checkout_tree ( g_repo , obj , & opts ) ) ; cl_assert_equal_i ( cts . conflicts , g_typechange_expected_conflicts [ i ] ) ; cl_assert_equal_i ( cts . untracked , g_typechange_expected_untracked [ i ] ) ; cl_assert_equal_i ( cts . dirty , 0 ) ; cl_assert_equal_i ( cts . updates , 0 ) ; cl_assert_equal_i ( cts . ignored , 0 ) ; opts . checkout_strategy = GIT_CHECKOUT_FORCE | GIT_CHECKOUT_REMOVE_UNTRACKED ; memset ( & cts , 0 , sizeof ( cts ) ) ; cl_assert ( git_fs_path_exists ( \"typechanges/untracked\" ) ) ; cl_git_pass ( git_checkout_tree ( g_repo , obj , & opts ) ) ; cl_assert_equal_i ( 0 , cts . conflicts ) ; cl_assert ( ! git_fs_path_exists ( \"typechanges/untracked\" ) ) ; cl_git_pass ( git_repository_set_head_detached ( g_repo , git_object_id ( obj ) ) ) ; assert_workdir_matches_tree ( g_repo , git_object_id ( obj ) , NULL , true ) ; git_object_free ( obj ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void cayman_dma_vm_set_pages ( struct radeon_device * rdev , struct radeon_ib * ib , uint64_t pe , uint64_t addr , unsigned count , uint32_t incr , uint32_t flags ) { uint64_t value ; unsigned ndw ; while ( count ) { ndw = count * 2 ; if ( ndw > 0xFFFFE ) { ndw = 0xFFFFE ; } if ( flags & R600_PTE_VALID ) { value = addr ; } else { value = 0 ; } ib -> ptr [ ib -> length_dw ++ ] = DMA_PTE_PDE_PACKET ( ndw ) ; ib -> ptr [ ib -> length_dw ++ ] = pe ; ib -> ptr [ ib -> length_dw ++ ] = upper_32_bits ( pe ) & 0xff ; ib -> ptr [ ib -> length_dw ++ ] = flags ; ib -> ptr [ ib -> length_dw ++ ] = 0 ; ib -> ptr [ ib -> length_dw ++ ] = value ; ib -> ptr [ ib -> length_dw ++ ] = upper_32_bits ( value , NULL ) ; ib -> ptr [ ib -> length_dw ++ ] = incr ; ib -> ptr [ ib -> length_dw ++ ] = 0 ; pe += ndw * 4 ; addr += ( ndw / 2 ) * incr ; count -= ndw / 2 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int i82875p_process_error_info ( struct mem_ctl_info * mci , struct i82875p_error_info * info , int handle_errors ) { int row , multi_chan ; multi_chan = mci -> csrows [ 0 ] -> nr_channels - 1 ; if ( ! ( info -> errsts & 0x0081 ) ) { return 0 ; } if ( ( info -> errsts ^ info -> errsts2 ) & 0x0081 ) { edac_mc_handle_error ( HW_EVENT_ERR_UNCORRECTED , mci , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 , \"UE overwrote CE\" , \"\" ) ; info -> errsts = info -> errsts2 ; } info -> eap >>= PAGE_SHIFT ; row = edac_mc_find_csrow_by_page ( mci , info -> eap ) ; if ( info -> errsts & 0x0080 ) { edac_mc_handle_error ( HW_EVENT_ERR_UNCORRECTED , mci , 1 , info -> eap , 0 , 0 , row , - 1 , - 1 , \"i82875p UE\" , \"\" ) ; } else { edac_mc_handle_error ( HW_EVENT_ERR_CORRECTED , mci , 1 , info -> eap , 0 , info -> derrsyn , row , multi_chan ?( info -> des & 0x1 ) : 0 , - 1 , \"i82875p CE\" , \"\" ) ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool update ( RCryptoJob * cj , const ut8 * buf , int len ) { const int diff = ( BLOCK_SIZE - ( len % BLOCK_SIZE ) ) % BLOCK_SIZE ; const int size = len + diff ; const int blocks = size / BLOCK_SIZE ; int i , j ; ut8 * const obuf = calloc ( 4 , size / 4 ) ; if ( ! obuf ) { return false ; } ut32 * const ibuf = calloc ( 4 , size / 4 ) ; if ( ! ibuf ) { return false ; } ut32 * const tmp = calloc ( 4 , size / 4 ) ; if ( ! tmp ) { free ( obuf ) ; free ( ibuf ) ; return false ; } for ( j = 0 ; j < len / 4 ; j ++ ) { ibuf [ j ] = r_read_le32 ( buf + 4 * j ) ; } if ( len & 0x3 ) { ut8 tail [ 4 ] { 0 } ; ; memcpy ( tail , buf + ( len & ~ 0x3 ) , len & 0x3 ) ; ibuf [ len / 4 ] = r_read_le32 ( tail ) ; } struct serpent_state * st = cj -> data ; if ( ! st ) { R_LOG_ERROR ( \"No state\" ) ; free ( obuf ) ; free ( ibuf ) ; free ( tmp ) ; return false ; } if ( cj -> dir == 0 ) { for ( i = 0 ; i < blocks ; i ++ ) { const int delta = ( BLOCK_SIZE * i ) / 4 ; serpent_encrypt ( st , ibuf + delta , tmp + delta ) ; } } if ( cj -> dir > 0 ) { for ( i = 0 ; i < blocks ; i ++ ) { const int delta = ( BLOCK_SIZE * i ) / 4 ; serpent_decrypt ( st , ibuf + delta , tmp + delta ) ; } } int k ; for ( j = 0 ; j < size / 4 ; j ++ ) { k = 4 * j ; obuf [ k ] = tmp [ j ] & 0xff ; obuf [ k + 1 ] = ( tmp [ j ] >> 8 ) & 0xff ; obuf [ k + 2 ] = ( tmp [ j ] >> 16 ) & 0xff ; obuf [ k + 3 ] = ( tmp [ j ] >> 24 ) & 0xff ; } r_crypto_job_append ( cj , obuf , size ) ; free ( obuf ) ; free ( ibuf ) ; free ( tmp ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void git_hash_sha1_ctx_cleanup ( git_hash_sha1_ctx * ctx ) { hash_win32_cleanup ( & ctx -> win32 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cert_hike ( struct peer * peer , struct cert_info * yp ) { struct cert_info * xp ; X509 * cert ; const u_char * ptr ; if ( peer -> issuer != NULL ) { free ( peer -> issuer ) ; } peer -> issuer = estrdup ( yp -> issuer ) ; xp = peer -> xinfo ; peer -> xinfo = yp ; if ( strcmp ( yp -> subject , yp -> issuer ) == 0 ) { if ( ! ( yp -> flags & CERT_TRUST ) ) { return ( XEVNT_OK ) ; } peer -> crypto |= CRYPTO_FLAG_CERT ; peer -> grpkey = yp -> grpkey ; if ( peer -> ident == NULL || ! ( peer -> crypto & CRYPTO_FLAG_MASK ) ) { peer -> crypto |= CRYPTO_FLAG_VRFY ; } } ptr = ( u_char * ) xp -> cert . ptr ; cert = d2i_X509 ( NULL , & ptr , ntohl ( xp -> cert . vallen ) ) ; if ( cert == NULL ) { xp -> flags |= CERT_ERROR ; return ( XEVNT_CRT ) ; } if ( X509_verify ( cert , yp -> pkey ) <= 0 ) { X509_free ( cert ) ; xp -> flags |= CERT_ERROR ; return ( XEVNT_VFY ) ; } X509_free ( cert ) ; if ( ( calcomp ( & ( xp -> first ) , & ( yp -> first ) ) < 0 ) || ( calcomp ( & ( xp -> first ) , & ( yp -> last ) ) > 0 ) ) { xp -> flags |= CERT_ERROR ; return ( XEVNT_PER ) ; } xp -> flags |= CERT_SIGN ; return ( XEVNT_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool do_unsigned_test ( init_ufn fn ) { bool ok = true ; int i ; for ( i = 0 ; i < 8 && ok ; i ++ ) { fn ( i ) ; ok = do_unsigned_reads ( i , NULL ) ; } return ok ; fn ( 0 ) ; return do_unsigned_reads ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xhci_priv_init_quirk ( struct usb_hcd * hcd ) { struct xhci_plat_priv * priv = hcd_to_xhci_priv ( hcd ) ; return priv -> init_quirk ( hcd ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dlt_jnpr_ether_cleanup ( tcpeditdlt_t * ctx ) { tcpeditdlt_plugin_t * plugin ; assert ( ctx ) ; if ( ( plugin = tcpedit_dlt_getplugin ( ctx , dlt_value ) ) == NULL ) { tcpedit_seterr ( ctx -> tcpedit , \"Unable to cleanup unregistered plugin %s\" , dlt_name ) ; return TCPEDIT_ERROR ; } safe_free ( plugin -> name ) ; plugin -> name = NULL ; if ( plugin -> config != NULL ) { jnpr_ether_config_t * config ; config = ( jnpr_ether_config_t * ) ctx -> encoder -> config ; tcpedit_dlt_cleanup ( config -> subctx ) ; safe_free ( plugin -> config ) ; plugin -> config = NULL ; } return TCPEDIT_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void delete_link ( struct list_link * old ) { fprintf ( stderr , \"The call to delete_link needs to be mocked!!\\n\" ) ; exit ( 1 ) ; } void * get_next ( list_link pl , char * file , int line ) { fprintf ( stderr , \"The call to get_next needs to be mocked!!\\n\" ) ; exit ( 1 ) ; } int unlock_queue ( pbs_queue * the_queue , const char * id , const char * msg , int logging ) { return ( 0 ) ; } pbs_queue * get_jobs_queue ( job * * pjob ) { return ( ( * pjob ) -> ji_qhdr ) ; } int get_svr_attr_l ( int index , long * l ) { return ( 0 ) ; } int get_svr_attr_b ( int index , bool * b ) { return ( 0 ) ; } void log_err ( int errnum , const char * routine , const char * text ) { } void log_record ( int eventtype , int objclass , const char * objname , const char * text ) { } void log_event ( int eventtype , int objclass , const char * objname , const char * text ) { } int is_whitespace ( char c ) { if ( ( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' ) || ( c == '\\r' ) || ( c == '\\f' ) ) { return ( TRUE ) ; } else { return ( FALSE ) ; } } int translate_range_string_to_vector ( const char * range_string , std :: vector ( int ) & indices ) { char * str = strdup ( range_string ) ; char * ptr = str ; int prev ; int curr ; while ( * ptr != '\\0' ) { prev = strtol ( ptr , & ptr , 10 ) ; if ( * ptr == '-' ) { ptr ++ ; curr = strtol ( ptr , & ptr , 10 ) ; while ( prev <= curr ) { indices . push_back ( prev ) ; prev ++ ; } if ( ( * ptr == ',' ) || ( is_whitespace ( * ptr ) ) ) { ptr ++ ; } } else { indices . push_back ( prev ) ; if ( ( * ptr == ',' ) || ( is_whitespace ( * ptr ) ) ) { ptr ++ ; } } } return ( PBSE_NONE ) ; } int lock_ji_mutex ( job * pjob , const char * id , const char * msg , int logging ) { return ( 0 ) ; } int unlock_ji_mutex ( job * pjob , const char * id , const char * msg , int logging ) { return ( 0 ) ; } job :: job ( ) { } job :: ~job ( ) { } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sun6i_isp_proc_init_cfg ( struct v4l2_subdev * subdev , struct v4l2_subdev_state * state ) { struct sun6i_isp_device * isp_dev = v4l2_get_subdevdata ( subdev ) ; int pad = SUN6I_ISP_PROC_PAD_SINK_CSI ; struct v4l2_mbus_framefmt * mbus_format = v4l2_subdev_get_try_format ( subdev , state , pad ) ; struct mutex * lock = & isp_dev -> proc . lock ; mutex_lock ( lock ) ; mbus_format -> code = sun6i_isp_proc_formats [ 0 ] . mbus_code ; mbus_format -> width = 1280 ; mbus_format -> height = 720 ; sun6i_isp_proc_mbus_format_prepare ( mbus_format ) ; mutex_unlock ( lock ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void rbe_remove_color ( struct rbt_tree * rbt , struct rb_entry * parent , struct rb_entry * rbe ) { struct rb_entry * tmp ; while ( ( rbe == NULL || RBE_COLOR ( rbe ) == RB_BLACK ) && rbe != RBH_ROOT ( rbt ) && parent ) { if ( RBE_LEFT ( parent ) == rbe ) { tmp = RBE_RIGHT ( parent ) ; if ( RBE_COLOR ( tmp ) == RB_RED ) { rbe_set_blackred ( tmp , parent ) ; rbe_rotate_left ( rbt , parent ) ; tmp = RBE_RIGHT ( parent ) ; } if ( ( RBE_LEFT ( tmp ) == NULL || RBE_COLOR ( RBE_LEFT ( tmp ) ) == RB_BLACK ) && ( RBE_RIGHT ( tmp ) == NULL || RBE_COLOR ( RBE_RIGHT ( tmp ) ) == RB_BLACK ) ) { RBE_COLOR ( tmp ) = RB_RED ; rbe = parent ; parent = RBE_PARENT ( rbe ) ; } else { if ( RBE_RIGHT ( tmp ) == NULL || RBE_COLOR ( RBE_RIGHT ( tmp ) ) == RB_BLACK ) { struct rb_entry * oleft ; oleft = RBE_LEFT ( tmp ) ; if ( oleft != NULL ) { RBE_COLOR ( oleft ) = RB_BLACK ; } RBE_COLOR ( tmp ) = RB_RED ; rbe_rotate_right ( rbt , tmp ) ; tmp = RBE_RIGHT ( parent ) ; } RBE_COLOR ( tmp ) = RBE_COLOR ( parent ) ; RBE_COLOR ( parent ) = RB_BLACK ; if ( RBE_RIGHT ( tmp ) ) { RBE_COLOR ( RBE_RIGHT ( tmp ) ) = RB_BLACK ; } rbe_rotate_left ( rbt , parent ) ; rbe = RBH_ROOT ( rbt ) ; break ; } } else { tmp = RBE_LEFT ( parent , NULL ) ; if ( RBE_COLOR ( tmp ) == RB_RED ) { rbe_set_blackred ( tmp , parent ) ; rbe_rotate_right ( rbt , parent ) ; tmp = RBE_LEFT ( parent ) ; } if ( ( RBE_LEFT ( tmp ) == NULL || RBE_COLOR ( RBE_LEFT ( tmp ) ) == RB_BLACK ) && ( RBE_RIGHT ( tmp ) == NULL || RBE_COLOR ( RBE_RIGHT ( tmp ) ) == RB_BLACK ) ) { RBE_COLOR ( tmp ) = RB_RED ; rbe = parent ; parent = RBE_PARENT ( rbe ) ; } else { if ( RBE_LEFT ( tmp ) == NULL || RBE_COLOR ( RBE_LEFT ( tmp ) ) == RB_BLACK ) { struct rb_entry * oright ; oright = RBE_RIGHT ( tmp ) ; if ( oright != NULL ) { RBE_COLOR ( oright ) = RB_BLACK ; } RBE_COLOR ( tmp ) = RB_RED ; rbe_rotate_left ( rbt , tmp ) ; tmp = RBE_LEFT ( parent ) ; } RBE_COLOR ( tmp ) = RBE_COLOR ( parent ) ; RBE_COLOR ( parent ) = RB_BLACK ; if ( RBE_LEFT ( tmp ) != NULL ) { RBE_COLOR ( RBE_LEFT ( tmp ) ) = RB_BLACK ; } rbe_rotate_right ( rbt , parent ) ; rbe = RBH_ROOT ( rbt ) ; break ; } } } if ( rbe != NULL ) { RBE_COLOR ( rbe ) = RB_BLACK ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline int mq_enqueue ( struct capilib_ncci * np , u16 msgid ) { struct capilib_msgidqueue * mq ; if ( ( mq = np -> msgidfree ) == NULL ) { return 0 ; } np -> msgidfree = mq -> next ; mq -> msgid = msgid ; if ( np -> msgidlast ) { np -> msgidlast -> next = mq ; } np -> msgidlast = mq ; if ( ! np -> msgidqueue ) { np -> msgidqueue = mq ; } np -> nmsg ++ ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int x25_parse_facilities ( struct sk_buff * skb , struct x25_facilities * facilities , struct x25_dte_facilities * dte_facs , unsigned long * vc_fac_mask ) { unsigned char * p ; unsigned int len ; * vc_fac_mask = 0 ; dte_facs -> calling_len = 0 ; dte_facs -> called_len = 0 ; memset ( dte_facs -> calling_ae , '\\0' , sizeof ( dte_facs -> calling_ae ) ) ; if ( ! pskb_may_pull ( skb , 1 ) ) { return 0 ; } len = skb -> data [ 0 ] ; if ( ! pskb_may_pull ( skb , 1 + len ) ) { return - 1 ; } p = skb -> data + 1 ; while ( len > 0 ) { switch ( * p & X25_FAC_CLASS_MASK ) { case X25_FAC_CLASS_A : if ( len < 2 ) { return - 1 ; } switch ( * p ) { case X25_FAC_REVERSE : if ( ( p [ 1 ] & 0x81 ) == 0x81 ) { facilities -> reverse = p [ 1 ] & 0x81 ; * vc_fac_mask |= X25_MASK_REVERSE ; break ; } if ( ( p [ 1 ] & 0x01 ) == 0x01 ) { facilities -> reverse = p [ 1 ] & 0x01 ; * vc_fac_mask |= X25_MASK_REVERSE ; break ; } if ( ( p [ 1 ] & 0x80 ) == 0x80 ) { facilities -> reverse = p [ 1 ] & 0x80 ; * vc_fac_mask |= X25_MASK_REVERSE ; break ; } if ( p [ 1 ] == 0x00 ) { facilities -> reverse = X25_DEFAULT_REVERSE ; * vc_fac_mask |= X25_MASK_REVERSE ; break ; } fallthrough ; case X25_FAC_THROUGHPUT : facilities -> throughput = p [ 1 ] ; * vc_fac_mask |= X25_MASK_THROUGHPUT ; break ; case X25_MARKER : break ; default : pr_debug ( \"unknown facility \" \"%02X, value %02X\\n\" , p [ 0 ] , p [ 1 ] ) ; break ; } p += 2 ; len -= 2 ; break ; case X25_FAC_CLASS_B : if ( len < 3 ) { return - 1 ; } switch ( * p ) { case X25_FAC_PACKET_SIZE : facilities -> pacsize_in = p [ 1 ] ; facilities -> pacsize_out = p [ 2 ] ; * vc_fac_mask |= X25_MASK_PACKET_SIZE ; break ; case X25_FAC_WINDOW_SIZE : facilities -> winsize_in = p [ 1 ] ; facilities -> winsize_out = p [ 2 ] ; * vc_fac_mask |= X25_MASK_WINDOW_SIZE ; break ; default : pr_debug ( \"unknown facility \" \"%02X, values %02X, %02X\\n\" , p [ 0 ] , p [ 1 ] , p [ 2 ] ) ; break ; } p += 3 ; len -= 3 ; break ; case X25_FAC_CLASS_C : if ( len < 4 ) { return - 1 ; } pr_debug ( \"unknown facility %02X, \" \"values %02X, %02X, %02X\\n\" , p [ 0 ] , p [ 1 ] , p [ 2 ] , p [ 3 ] ) ; p += 4 ; len -= 4 ; break ; case X25_FAC_CLASS_D : if ( len < p [ 1 ] + 2 ) { return - 1 ; } switch ( * p ) { case X25_FAC_CALLING_AE : if ( p [ 1 ] > X25_MAX_DTE_FACIL_LEN || p [ 1 ] <= 1 ) { return - 1 ; } if ( p [ 2 ] > X25_MAX_AE_LEN ) { return - 1 ; } dte_facs -> calling_len = p [ 2 ] ; memcpy ( dte_facs -> calling_ae , & p [ 3 ] , p [ 1 ] - 1 ) ; * vc_fac_mask |= X25_MASK_CALLING_AE ; break ; case X25_FAC_CALLED_AE : if ( p [ 1 ] > X25_MAX_DTE_FACIL_LEN || p [ 1 ] <= 1 ) { return - 1 ; } if ( p [ 2 ] > X25_MAX_AE_LEN ) { return - 1 ; } dte_facs -> called_len = p [ 2 ] ; memcpy ( dte_facs -> called_ae , & p [ 3 ] , p [ 1 ] - 1 ) ; * vc_fac_mask |= X25_MASK_CALLED_AE ; break ; default : pr_debug ( \"unknown facility %02X,\" \"length %d\\n\" , p [ 0 ] , p [ 1 ] ) ; break ; } len -= p [ 1 ] + 2 ; p += p [ 1 ] + 2 ; break ; } } return p - skb -> data ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __kgdb_notify ( struct die_args * args , unsigned long cmd ) { struct pt_regs * regs = args -> regs ; return NOTIFY_STOP ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int zonecfg_destroy_impl ( char * filename ) { if ( unlink ( filename ) == - 1 ) { if ( errno == EACCES ) { return ( Z_ACCES ) ; } return ( Z_MISC_FS ) ; } return ( Z_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool alx_intr_handle_misc ( struct alx_priv * alx , u32 intr ) { struct alx_hw * hw = & alx -> hw ; if ( intr & ALX_ISR_FATAL ) { netif_warn ( alx , hw , alx -> dev , \"fatal interrupt 0x%x, resetting\\n\" , intr ) ; alx_schedule_reset ( alx , NULL ) ; return true ; } if ( intr & ALX_ISR_ALERT ) { netdev_warn ( alx -> dev , \"alert interrupt: 0x%x\\n\" , intr ) ; } if ( intr & ALX_ISR_PHY ) { alx -> int_mask &= ~ ALX_ISR_PHY ; alx_write_mem32 ( hw , ALX_IMR , alx -> int_mask ) ; alx_schedule_link_check ( alx ) ; } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void getdisktype ( struct disklabel * , const char * , char * ) void find_bounds ( const struct disklabel * ) void set_bounds ( struct disklabel * ) void set_duid ( struct disklabel * ) const struct diskchunk * free_chunks ( const struct disklabel * , int ) int micmp ( const void * , const void * ) int mpequal ( char * * , char * * ) int get_bsize ( struct disklabel * , int ) int get_fsize ( struct disklabel * , int ) int get_cpg ( struct disklabel * , int ) int get_fstype ( struct disklabel * , int ) int get_mp ( const struct disklabel * , int ) int get_offset ( struct disklabel * , int ) int get_size ( struct disklabel * , int ) void zero_partitions ( struct disklabel * ) u_int64_t max_partition_size ( const struct disklabel * , int ) void display_edit ( const struct disklabel * , char ) void psize ( u_int64_t sz , char unit , const struct disklabel * lp ) char * get_token ( char * * ) int apply_unit ( double , u_char , u_int64_t * ) int parse_sizespec ( const char * , double * , char * * ) int parse_sizerange ( char * , u_int64_t * , u_int64_t * ) int parse_pct ( char * , int * ) int alignpartition ( struct disklabel * , int , u_int64_t , u_int64_t , int ) static u_int64_t starting_sector ; static u_int64_t ending_sector ; static int expert ; static int resizeok ; int editor ( int f ) { struct disklabel origlabel , lastlabel , tmplabel , newlab = lab ; struct partition * pp ; FILE * fp ; char buf [ BUFSIZ ] , * cmd , * arg ; char * * omountpoints = NULL ; char * * origmountpoints = NULL , * * tmpmountpoints = NULL ; int i , error = 0 ; if ( ! ( omountpoints = calloc ( MAXPARTITIONS , sizeof ( char * ) ) ) || ! ( origmountpoints = calloc ( MAXPARTITIONS , sizeof ( char * ) ) ) || ! ( tmpmountpoints = calloc ( MAXPARTITIONS , sizeof ( char * ) ) ) ) { errx ( 4 , \"out of memory\" ) ; } getdisktype ( & newlab , \"You need to specify a type for this disk.\" , specname ) ; find_bounds ( & newlab ) ; if ( has_overlap ( & newlab ) ) { errx ( 1 , \"can't run when there is partition overlap.\" ) ; } pp = & newlab . d_partitions [ RAW_PART ] ; if ( newlab . d_npartitions <= RAW_PART || DL_GETPSIZE ( pp ) == 0 ) { puts ( \"No 'c' partition found, adding one that spans the disk.\" ) ; if ( newlab . d_npartitions <= RAW_PART ) { newlab . d_npartitions = RAW_PART + 1 ; } DL_SETPOFFSET ( pp , 0 ) ; DL_SETPSIZE ( pp , DL_GETDSIZE ( & newlab ) ) ; pp -> p_fstype = FS_UNUSED ; pp -> p_fragblock = pp -> p_cpg = 0 ; } if ( ( newlab . d_flags & D_VENDOR ) && ! quiet ) { puts ( \"This platform requires that partition offsets/sizes \" \"be on cylinder boundaries.\\n\" \"Partition offsets/sizes will be rounded to the \" \"nearest cylinder automatically.\" ) ; } mpcopy ( origmountpoints , mountpoints ) ; origlabel = newlab ; lastlabel = newlab ; puts ( \"Label editor (enter '?' for help at any prompt)\" ) ; for ( ; ; ) { fprintf ( stdout , \"%s%s%c \" , dkname , ( memcmp ( & lab , & newlab , sizeof ( newlab ) ) == 0 ) ?\"\" : \"*\" , ( expert == 0 ) ?'>' : '#' ) ; if ( fgets ( buf , sizeof ( buf ) , stdin ) == NULL ) { putchar ( '\\n' ) ; buf [ 0 ] = 'q' ; buf [ 1 ] = '\\0' ; } if ( ( cmd = strtok ( buf , \" \\t\\r\\n\" ) ) == NULL ) { continue ; } arg = strtok ( NULL , \" \\t\\r\\n\" ) ; if ( ( * cmd != 'u' ) && ( * cmd != 'U' ) ) { tmplabel = lastlabel ; lastlabel = newlab ; mpcopy ( tmpmountpoints , omountpoints ) ; mpcopy ( omountpoints , mountpoints ) ; } switch ( * cmd ) { case '?' : case 'h' : editor_help ( ) ; break ; case 'A' : if ( ioctl ( f , DIOCGPDINFO , & newlab ) == - 1 ) { warn ( \"DIOCGPDINFO\" ) ; newlab = lastlabel ; } else { int oquiet = quiet , oexpert = expert ; aflag = 1 ; quiet = expert = 0 ; editor_allocspace ( & newlab ) ; quiet = oquiet ; expert = oexpert ; } break ; case 'a' : editor_add ( & newlab , arg ) ; break ; case 'b' : set_bounds ( & newlab ) ; break ; case 'c' : editor_change ( & newlab , arg ) ; break ; case 'D' : if ( ioctl ( f , DIOCGPDINFO , & newlab ) == - 1 ) { warn ( \"DIOCGPDINFO\" ) ; } else { dflag = 1 ; for ( i = 0 ; i < MAXPARTITIONS ; i ++ ) { free ( mountpoints [ i ] ) ; mountpoints [ i ] = NULL ; } } break ; case 'd' : editor_delete ( & newlab , arg ) ; break ; case 'e' : edit_parms ( & newlab ) ; break ; case 'i' : set_duid ( & newlab ) ; break ; case 'm' : editor_modify ( & newlab , arg ) ; break ; case 'n' : if ( ! fstabfile ) { fputs ( \"This option is not valid when run \" \"without the -F or -f flags.\\n\" , stderr ) ; break ; } editor_name ( & newlab , arg ) ; break ; case 'p' : display_edit ( & newlab , arg ?* arg : 0 ) ; break ; case 'l' : display ( stdout , & newlab , arg ?* arg : 0 , 0 ) ; break ; case 'M' : { sig_t opipe = signal ( SIGPIPE , SIG_IGN ) ; char * pager , * comm = NULL ; extern const u_char manpage [ ] ; extern const int manpage_sz ; if ( ( pager = getenv ( \"PAGER\" ) ) == NULL || * pager == '\\0' ) { pager = _PATH_LESS ; } if ( asprintf ( & comm , \"gunzip -qc|%s\" , pager ) != - 1 && ( fp = popen ( comm , \"w\" ) ) != NULL ) { ( void ) fwrite ( manpage , manpage_sz , 1 , fp ) ; pclose ( fp ) ; } else { warn ( \"unable to execute %s\" , pager ) ; } free ( comm ) ; ( void ) signal ( SIGPIPE , opipe ) ; break ; } case 'q' : if ( donothing ) { puts ( \"In no change mode, not writing label.\" ) ; done } if ( ! dflag && ! aflag && memcmp ( & lab , & newlab , sizeof ( newlab ) ) == 0 ) { puts ( \"No label changes.\" ) ; mpsave ( & newlab ) ; done } { arg = getstring ( \"Write new label?\" , \"Write the modified label to disk?\" , \"y\" ) ; } arg && tolower ( ( unsigned char ) * arg ) != 'y' && tolower ( ( unsigned char ) * arg ) != 'n' ; if ( arg && tolower ( ( unsigned char ) * arg ) == 'y' ) { if ( writelabel ( f , & newlab ) == 0 ) { newlab = lab ; done } warnx ( \"unable to write label\" ) ; } error = 1 ; done break ; case 'R' : if ( aflag && resizeok ) { editor_resize ( & newlab , arg ) ; } else { fputs ( \"Resize only implemented for auto \" \"allocated labels\\n\" , stderr ) ; } break ; case 'r' : { const struct diskchunk * chunk ; uint64_t total = 0 ; chunk = free_chunks ( & newlab , - 1 ) ; for ( ; chunk -> start != 0 || chunk -> stop != 0 ; chunk ++ ) { total += chunk -> stop - chunk -> start ; fprintf ( stderr , \"Free sectors: %16llu - %16llu \" \"(%16llu)\\n\" , chunk -> start , chunk -> stop - 1 , chunk -> stop - chunk -> start ) ; } fprintf ( stderr , \"Total free sectors: %llu.\\n\" , total ) ; break ; } case 's' : if ( arg == NULL ) { arg = getstring ( \"Filename\" , \"Name of the file to save label into.\" , NULL ) ; if ( arg == NULL || * arg == '\\0' ) { break ; } } if ( ( fp = fopen ( arg , \"w\" ) ) == NULL ) { warn ( \"cannot open %s\" , arg ) ; } else { display ( fp , & newlab , 0 , 1 ) ; ( void ) fclose ( fp ) ; } break ; case 'U' : if ( memcmp ( & newlab , & origlabel , sizeof ( newlab ) ) || ! mpequal ( mountpoints , origmountpoints ) ) { tmplabel = newlab ; newlab = origlabel ; lastlabel = tmplabel ; mpcopy ( tmpmountpoints , mountpoints ) ; mpcopy ( mountpoints , origmountpoints ) ; mpcopy ( omountpoints , tmpmountpoints ) ; } puts ( \"Original label and mount points restored.\" ) ; break ; case 'u' : tmplabel = newlab ; newlab = lastlabel ; lastlabel = tmplabel ; mpcopy ( tmpmountpoints , mountpoints ) ; mpcopy ( mountpoints , omountpoints ) ; mpcopy ( omountpoints , tmpmountpoints ) ; puts ( \"Last change undone.\" ) ; break ; case 'w' : if ( donothing ) { puts ( \"In no change mode, not writing label.\" ) ; break ; } if ( writelabel ( f , & newlab ) != 0 ) { warnx ( \"unable to write label\" ) ; } else { dflag = aflag = 0 ; newlab = lab ; } break ; case 'X' : expert = ! expert ; printf ( \"%s expert mode\\n\" , expert ?\"Entering\" : \"Exiting\" ) ; break ; case 'x' : done break ; case 'z' : zero_partitions ( & newlab ) ; break ; case '\\n' : break ; default : printf ( \"Unknown option: %c ('?' for help)\\n\" , * cmd ) ; break ; } if ( memcmp ( & newlab , & lastlabel , sizeof ( newlab ) ) == 0 && ( mpequal ( mountpoints , omountpoints ) ) ) { lastlabel = tmplabel ; mpcopy ( omountpoints , tmpmountpoints ) ; } } done mpfree ( origmountpoints ) ; mpfree ( tmpmountpoints ) ; return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int property_get_current_dns_server_internal ( sd_bus * bus , const char * path , const char * interface , const char * property , sd_bus_message * reply , void * userdata , sd_bus_error * error , bool extended ) { DnsServer * s ; assert ( reply ) ; s = * ( DnsServer * * ) userdata ; return bus_dns_server_append ( reply , s , false , extended ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fl_free_rcu ( struct rcu_head * head ) { struct ip6_flowlabel * fl = container_of ( head , ip6_flowlabel , rcu ) ; if ( fl -> share == IPV6_FL_S_PROCESS ) { put_pid ( fl -> owner . pid ) ; } kfree ( fl ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int add_cacheinfo ( unsigned int mode , const struct object_id * oid , const char * path , int stage ) { int len , option ; struct cache_entry * ce ; if ( ! verify_path ( path , mode ) ) { return error ( \"Invalid path '%s'\" , path ) ; } len = strlen ( path ) ; ce = make_empty_cache_entry ( & the_index , len ) ; oidcpy ( & ce -> oid , oid ) ; memcpy ( ce -> name , path , len ) ; ce -> ce_flags = create_ce_flags ( stage , NULL ) ; ce -> ce_namelen = len ; ce -> ce_mode = create_ce_mode ( mode ) ; if ( assume_unchanged ) { ce -> ce_flags |= CE_VALID ; } option = allow_add ?ADD_CACHE_OK_TO_ADD : 0 ; option |= allow_replace ?ADD_CACHE_OK_TO_REPLACE : 0 ; if ( add_index_entry ( & the_index , ce , option ) ) { return error ( \"%s: cannot add to the index - missing --add option?\" , path ) ; } report ( \"add '%s'\" , path ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct nhlt_acpi_table * skl_nhlt_init ( struct device * dev ) { acpi_handle handle ; union acpi_object * obj ; struct nhlt_resource_desc * nhlt_ptr = NULL ; struct nhlt_acpi_table * nhlt_table = NULL ; handle = ACPI_HANDLE ( dev ) ; if ( ! handle ) { dev_err ( dev , \"Didn't find ACPI_HANDLE\\n\" ) ; return NULL ; } obj = acpi_evaluate_dsm ( handle , OSC_UUID , 1 , 1 , NULL ) ; if ( obj && obj -> type == ACPI_TYPE_BUFFER ) { nhlt_ptr = ( nhlt_resource_desc * ) obj -> buffer . pointer ; nhlt_table = ( nhlt_acpi_table * ) memremap ( nhlt_ptr -> min_addr , nhlt_ptr -> length , MEMREMAP_WB ) ; ACPI_FREE ( obj , NULL ) ; return nhlt_table ; } dev_err ( dev , \"device specific method to extract NHLT blob failed\\n\" ) ; return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int hs_intro_received_establish_intro ( or_circuit_t * circ , const uint8_t * request , size_t request_len ) { tor_assert ( circ ) ; if ( request_len == 0 ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Empty ESTABLISH_INTRO cell.\" ) ; err } const uint8_t first_byte = request [ 0 ] ; switch ( first_byte ) { case TRUNNEL_HS_INTRO_AUTH_KEY_TYPE_LEGACY0 : case TRUNNEL_HS_INTRO_AUTH_KEY_TYPE_LEGACY1 : err case TRUNNEL_HS_INTRO_AUTH_KEY_TYPE_ED25519 : return handle_establish_intro ( circ , request , request_len ) ; default : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Unrecognized AUTH_KEY_TYPE %u.\" , first_byte ) ; err } err circuit_mark_for_close ( TO_CIRCUIT ( circ ) , END_CIRC_REASON_TORPROTOCOL ) ; return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int do_setxattr ( struct mnt_idmap * idmap , struct dentry * dentry , struct xattr_ctx * ctx ) { return vfs_setxattr ( idmap , dentry , ctx -> kname -> name , ctx -> kvalue , ctx -> size , ctx -> flags ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mrpc_cmd_submit ( struct switchtec_dev * stdev ) { struct switchtec_user * stuser ; if ( stdev -> mrpc_busy ) { return ; } stuser = list_entry ( stdev -> mrpc_queue . next , switchtec_user , list ) ; if ( stdev -> dma_mrpc ) { stdev -> dma_mrpc -> status = SWITCHTEC_MRPC_STATUS_INPROGRESS ; memset ( stdev -> dma_mrpc -> data , 0xFF , SWITCHTEC_MRPC_PAYLOAD_SIZE ) ; } stuser_set_state ( stuser , MRPC_RUNNING ) ; stdev -> mrpc_busy = 1 ; memcpy_toio ( & stdev -> mmio_mrpc -> input_data , stuser -> data , stuser -> data_len ) ; flush_wc_buf ( stdev ) ; iowrite32 ( stuser -> cmd , & stdev -> mmio_mrpc -> cmd ) ; schedule_delayed_work ( & stdev -> mrpc_timeout , msecs_to_jiffies ( 500 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void test_format_text_perf ( void ) { char * str ; int i ; double start_utime , start_stime , end_utime , end_stime , utime_ms , stime_ms ; const char * text = \"The quick brown fox\\tjumps over the lazy \\001dog\" UTF8_HORIZONTAL_ELLIPSIS \"\\n\" ; RESOURCE_USAGE_START ; for ( i = 0 ; i < LOOP_COUNT ; i ++ ) { str = format_text_string ( NULL , text ) ; } RESOURCE_USAGE_END ; g_test_minimized_result ( utime_ms + stime_ms , \"format_text_string(): u %.3f ms s %.3f ms\" , utime_ms , stime_ms ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __smp_rescan_cpus ( struct sclp_core_info * info , int sysfs_add ) { struct pcpu * pcpu ; cpumask_t avail ; int cpu , nr , i , j ; u16 address ; nr = 0 ; cpumask_xor ( & avail , cpu_possible_mask , cpu_present_mask ) ; cpu = cpumask_first ( & avail ) ; for ( i = 0 ; ( i < info -> combined ) && ( cpu < nr_cpu_ids ) ; i ++ ) { address = info -> core [ i ] . core_id << smp_cpu_mt_shift ; for ( j = 0 ; j <= smp_cpu_mtid ; j ++ ) { if ( pcpu_find_address ( cpu_present_mask , address + j ) ) { continue ; } pcpu = pcpu_devices + cpu ; pcpu -> address = address + j ; pcpu -> state = ( cpu >= info -> configured * ( smp_cpu_mtid + 1 ) ) ?CPU_STATE_STANDBY : CPU_STATE_CONFIGURED ; smp_cpu_set_polarization ( cpu , POLARIZATION_UNKNOWN ) ; set_cpu_present ( cpu , true ) ; if ( sysfs_add && smp_add_present_cpu ( cpu ) != 0 ) { set_cpu_present ( cpu , false ) ; } else { nr ++ ; } cpu = cpumask_next ( cpu , & avail ) ; if ( cpu >= nr_cpu_ids ) { break ; } } } return nr ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( nf_dup_netdev_egress ) ; int nft_fwd_dup_netdev_offload ( struct nft_offload_ctx * ctx , struct nft_flow_rule * flow , enum flow_action_id id , int oif ) { struct flow_action_entry * entry ; struct net_device * dev ; dev = dev_get_by_index ( ctx -> net , oif ) ; entry = & flow -> rule -> action . entries [ ctx -> num_actions ++ ] ; entry -> id = id ; entry -> dev = dev ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mlx5e_post_meter_mtu_destroy ( struct mlx5e_post_meter_priv * post_meter ) { mlx5e_post_meter_mtu_fg_destroy ( post_meter ) ; mlx5e_post_meter_mtu_table_destroy ( post_meter ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void xmlCtxtDumpEntityDecl ( xmlDebugCtxtPtr ctxt , xmlEntityPtr ent ) { xmlCtxtDumpSpaces ( ctxt , NULL ) ; if ( ent == NULL ) { if ( ! ctxt -> check ) { fprintf ( ctxt -> output , \"Entity declaration is NULL\\n\" ) ; } return ; } if ( ent -> type != XML_ENTITY_DECL ) { xmlDebugErr ( ctxt , XML_CHECK_NOT_ENTITY_DECL , \"Node is not an entity declaration\" ) ; return ; } if ( ent -> name != NULL ) { if ( ! ctxt -> check ) { fprintf ( ctxt -> output , \"ENTITYDECL(\" ) ; xmlCtxtDumpString ( ctxt , ent -> name ) ; fprintf ( ctxt -> output , \")\" ) ; } } else { xmlDebugErr ( ctxt , XML_CHECK_NO_NAME , \"Entity declaration has no name\" ) ; } if ( ! ctxt -> check ) { switch ( ent -> etype ) { case XML_INTERNAL_GENERAL_ENTITY : fprintf ( ctxt -> output , \", internal\\n\" ) ; break ; case XML_EXTERNAL_GENERAL_PARSED_ENTITY : fprintf ( ctxt -> output , \", external parsed\\n\" ) ; break ; case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY : fprintf ( ctxt -> output , \", unparsed\\n\" ) ; break ; case XML_INTERNAL_PARAMETER_ENTITY : fprintf ( ctxt -> output , \", parameter\\n\" ) ; break ; case XML_EXTERNAL_PARAMETER_ENTITY : fprintf ( ctxt -> output , \", external parameter\\n\" ) ; break ; case XML_INTERNAL_PREDEFINED_ENTITY : fprintf ( ctxt -> output , \", predefined\\n\" ) ; break ; } if ( ent -> ExternalID ) { xmlCtxtDumpSpaces ( ctxt ) ; fprintf ( ctxt -> output , \" ExternalID=%s\\n\" , ( char * ) ent -> ExternalID ) ; } if ( ent -> SystemID ) { xmlCtxtDumpSpaces ( ctxt ) ; fprintf ( ctxt -> output , \" SystemID=%s\\n\" , ( char * ) ent -> SystemID ) ; } if ( ent -> URI != NULL ) { xmlCtxtDumpSpaces ( ctxt ) ; fprintf ( ctxt -> output , \" URI=%s\\n\" , ( char * ) ent -> URI ) ; } if ( ent -> content ) { xmlCtxtDumpSpaces ( ctxt ) ; fprintf ( ctxt -> output , \" content=\" ) ; xmlCtxtDumpString ( ctxt , ent -> content ) ; fprintf ( ctxt -> output , \"\\n\" ) ; } } xmlCtxtGenericNodeCheck ( ctxt , ( xmlNodePtr ) ent ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pstore_mkfile ( struct dentry * root , struct pstore_record * record ) { struct dentry * dentry ; struct inode * inode ; int rc = 0 ; char name [ PSTORE_NAMELEN ] ; struct pstore_private * , * pos ; size_t size = record -> size + record -> ecc_notice_size ; rc = - EEXIST ; mutex_lock ( & records_list_lock ) ; list_for_each_entry ( , , ) { if ( pos -> record -> type == record -> type && pos -> record -> id == record -> id && pos -> record -> psi == record -> psi ) { fail } } rc = - ENOMEM ; inode = pstore_get_inode ( root -> d_sb ) ; if ( ! inode ) { fail } inode -> i_mode = S_IFREG | 0444 ; inode -> i_fop = & pstore_file_operations ; scnprintf ( name , sizeof ( name ) , \"%s-%s-%llu%s\" , pstore_type_to_name ( record -> type ) , record -> psi -> name , record -> id , record -> compressed ?\".enc.z\" : \"\" ) ; private = kzalloc ( sizeof ( * private ) , GFP_KERNEL ) ; if ( ! private ) { fail_inode } dentry = d_alloc_name ( root , name ) ; if ( ! dentry ) { fail_private } private -> dentry = dentry ; private -> record = record ; inode -> i_size = private -> total_size = size ; inode -> i_private = private ; if ( record -> time . tv_sec ) { inode -> i_mtime = inode -> i_ctime = record -> time ; } d_add ( dentry , inode ) ; list_add ( & private -> list , & records_list ) ; mutex_unlock ( & records_list_lock ) ; return 0 ; fail_private free_pstore_private ( private ) ; fail_inode iput ( inode ) ; fail mutex_unlock ( & records_list_lock ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static const char * cg_path [ ] { \"/\" \"/parent\" \"/parent/child1\" \"/parent/child2\" } ; ; static int cg_fd [ ] { - 1 - 1 - 1 - 1 } ; ; static unsigned long long cg_id [ ] { 0 0 0 0 } ; ; static char expected_output [ 64 ] ; static int setup_cgroups ( void ) { int fd , i = 0 ; for ( i = 0 ; i < NUM_CGROUPS ; i ++ ) { fd = create_and_get_cgroup ( cg_path [ i ] ) ; if ( fd < 0 ) { return fd ; } cg_fd [ i ] = fd ; cg_id [ i ] = get_cgroup_id ( cg_path [ i ] , NULL ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline struct pvc_device * find_pvc ( hdlc_device * hdlc , u16 dlci ) { struct pvc_device * pvc = state ( hdlc ) -> first_pvc ; while ( pvc ) { if ( pvc -> dlci > dlci ) { return NULL ; } pvc = pvc -> next ; } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int qed_iscsi_acquire_conn ( struct qed_dev * cdev , u32 * handle , u32 * fw_cid , void __iomem * * p_doorbell ) { struct qed_hash_iscsi_con * hash_con ; int rc ; hash_con = kmalloc ( sizeof ( * hash_con ) , GFP_ATOMIC ) ; if ( ! hash_con ) { return - ENOMEM ; } rc = qed_iscsi_acquire_connection ( QED_AFFIN_HWFN ( cdev ) , NULL , & hash_con -> con ) ; if ( rc ) { DP_NOTICE ( cdev , \"Failed to acquire Connection\\n\" ) ; kfree ( hash_con ) ; return rc ; } * handle = hash_con -> con -> icid ; * fw_cid = hash_con -> con -> fw_cid ; hash_add ( cdev -> connections , & hash_con -> node , * handle ) ; if ( p_doorbell ) { * p_doorbell = qed_iscsi_get_db_addr ( QED_AFFIN_HWFN ( cdev ) , * handle ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int handle_conflicting_encoders ( struct drm_atomic_state * state , bool disable_conflicting_encoders ) { struct drm_connector_state * new_conn_state ; struct drm_connector * connector ; struct drm_connector_list_iter conn_iter ; struct drm_encoder * encoder ; unsigned int encoder_mask = 0 ; int i , ret = 0 ; for_each_new_connector_in_state ( , , , ) { const struct drm_connector_helper_funcs * funcs = connector -> helper_private ; struct drm_encoder * new_encoder ; if ( funcs -> atomic_best_encoder ) { new_encoder = funcs -> atomic_best_encoder ( connector , state ) ; } if ( funcs -> best_encoder ) { new_encoder = funcs -> best_encoder ( connector ) ; } else { new_encoder = drm_connector_get_single_encoder ( connector ) ; } if ( new_encoder ) { if ( encoder_mask & drm_encoder_mask ( new_encoder ) ) { drm_dbg_atomic ( connector -> dev , \"[ENCODER:%d:%s] on [CONNECTOR:%d:%s]already assigned\\n\" , new_encoder -> base . id , new_encoder -> name , connector -> base . id , connector -> name ) ; return - EINVAL ; } encoder_mask |= drm_encoder_mask ( new_encoder ) ; } } if ( ! encoder_mask ) { return 0 ; } drm_connector_list_iter_begin ( state -> dev , & conn_iter ) ; drm_for_each_connector_iter ( , ) { struct drm_crtc_state * crtc_state ; if ( drm_atomic_get_new_connector_state ( state , connector ) ) { continue ; } encoder = connector -> state -> best_encoder ; if ( ! encoder || ! ( encoder_mask & drm_encoder_mask ( encoder ) ) ) { continue ; } if ( ! disable_conflicting_encoders ) { drm_dbg_atomic ( connector -> dev , \"[ENCODER:%d:%s] in use on [CRTC:%d:%s]by [CONNECTOR:%d:%s]\\n\" , encoder -> base . id , encoder -> name , connector -> state -> crtc -> base . id , connector -> state -> crtc -> name , connector -> base . id , connector -> name ) ; ret = - EINVAL ; out } new_conn_state = drm_atomic_get_connector_state ( state , connector ) ; if ( IS_ERR ( new_conn_state ) ) { ret = PTR_ERR ( new_conn_state ) ; out } drm_dbg_atomic ( connector -> dev , \"[ENCODER:%d:%s] in use on [CRTC:%d:%s], disabling [CONNECTOR:%d:%s]\\n\" , encoder -> base . id , encoder -> name , new_conn_state -> crtc -> base . id , new_conn_state -> crtc -> name , connector -> base . id , connector -> name ) ; crtc_state = drm_atomic_get_new_crtc_state ( state , new_conn_state -> crtc ) ; ret = drm_atomic_set_crtc_for_connector ( new_conn_state , NULL ) ; if ( ret ) { out } if ( ! crtc_state -> connector_mask ) { ret = drm_atomic_set_mode_prop_for_crtc ( crtc_state , NULL ) ; if ( ret < 0 ) { out } crtc_state -> active = false ; } } out drm_connector_list_iter_end ( & conn_iter ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int add_info_ref ( const char * path , const struct object_id * oid , int flag UNUSED , void * cb_data ) { struct update_info_ctx * uic = cb_data ; struct object * o = parse_object ( the_repository , oid ) ; if ( uic_printf ( uic , \"%s\t%s\\n\" , oid_to_hex ( oid ) , path ) < 0 ) { return - 1 ; } if ( o -> type == OBJ_TAG ) { o = deref_tag ( the_repository , o , path , 0 ) ; if ( o ) { if ( uic_printf ( uic , \"%s\t%s^{}\\n\" , oid_to_hex ( & o -> oid ) , path ) < 0 ) { return - 1 ; } } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _initWinsock ( ) { static int s_initialized = 0 ; if ( ! s_initialized ) { static WSADATA wsadata ; int err = WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsadata ) ; if ( err != 0 ) { errno = _wsaErrorToErrno ( err , NULL ) ; return 0 ; } s_initialized = 1 ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _nc_ungetmouse ( SCREEN * sp , MEVENT * aevent ) { int result = ERR ; T ( ( T_CALLED ( \"ungetmouse(%p)\" ) , aevent ) ) ; if ( aevent != 0 && sp != 0 ) { MEVENT * eventp = sp -> _mouse_eventp ; * eventp = * aevent ; sp -> _mouse_eventp = NEXT ( eventp , NULL ) ; result = _nc_ungetch ( sp , KEY_MOUSE ) ; } returnCode ( result ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hns_set_pauseparam ( struct net_device * net_dev , struct ethtool_pauseparam * param ) { struct hns_nic_priv * priv = netdev_priv ( net_dev ) ; struct hnae_handle * h ; struct hnae_ae_ops * ops ; h = priv -> ae_handle ; ops = h -> dev -> ops ; return ops -> set_pauseparam ( priv -> ae_handle , param -> autoneg , param -> rx_pause , param -> tx_pause ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static TmEcode UnixManager ( ThreadVars * th_v , void * thread_data ) { int ret ; SCLogDebug ( \"%s started...\" , th_v -> name ) ; StatsSetupPrivate ( th_v ) ; th_v -> cap_flags = 0 ; SCDropCaps ( th_v , NULL ) ; TmThreadsSetFlag ( th_v , THV_INIT_DONE | THV_RUNNING ) ; while ( 1 ) { ret = UnixMain ( & command ) ; if ( ret == 0 ) { SCLogError ( \"Fatal error on unix socket\" ) ; } if ( ( ret == 0 ) || ( TmThreadsCheckFlag ( th_v , THV_KILL ) ) ) { UnixClient * item ; UnixClient * titem ; TAILQ_FOREACH_SAFE ( , , , ) { close ( item -> fd ) ; SCFree ( item ) ; } StatsSyncCounters ( th_v ) ; break ; } UnixCommandBackgroundTasks ( & command ) ; } return TM_ECODE_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void nhgc_delete_nexthops ( struct nexthop_group_cmd * nhgc ) { struct nexthop * nexthop ; nexthop = nhgc -> nhg . nexthop ; while ( nexthop ) { struct nexthop * next = nexthop_next ( nexthop ) ; _nexthop_del ( & nhgc -> nhg , nexthop ) ; if ( nhg_hooks . del_nexthop ) { nhg_hooks . del_nexthop ( nhgc , nexthop ) ; } nexthop = next ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int lxml_get_notification_parameters ( entity_t * entity , xmlNodePtr np ) { char * event = NULL ; char * * pgs = NULL ; char * * p ; char * pgname = NULL ; xmlNodePtr cursor ; int32_t tset , t ; size_t sz = max_scf_name_len + 1 ; int count ; int r = - 1 ; for ( count = 0 , cursor = np -> xmlChildrenNode ; cursor != NULL ; cursor = cursor -> next ) { if ( lxml_ignorable_block ( cursor ) ) { continue ; } if ( lxml_xlate_element ( cursor -> name ) == SC_EVENT ) { xmlChar * s ; count ++ ; if ( count > 1 ) { uu_die ( gettext ( \"Can't have more than 1 element \" \"event in a notification parameter\\n\" ) ) ; } s = xmlGetProp ( cursor , ( xmlChar * ) value_attr ) ; if ( s == NULL || ( event = strdup ( ( char * ) s ) ) == NULL ) { uu_die ( gettext ( \"couldn't allocate memory\" ) ) ; } xmlFree ( s ) ; } } pgs = tokenize ( event , \",\" ) ; switch ( tset = check_tokens ( pgs ) ) { case INVALID_TOKENS : uu_die ( gettext ( \"Invalid input.\\n\" ) ) ; case MIXED_TOKENS : semerr ( gettext ( \"Can't mix SMF and FMA event definitions\\n\" ) ) ; out case FMA_TOKENS : if ( entity -> sc_etype != SVCCFG_INSTANCE_OBJECT || strcmp ( entity -> sc_fmri , SCF_NOTIFY_PARAMS_INST ) != 0 ) { semerr ( gettext ( \"Non-SMF transition events must go to %s\\n\" ) , SCF_NOTIFY_PARAMS_INST ) ; out } pgname = safe_malloc ( sz ) ; for ( p = pgs ; * p ; ++ p ) { if ( snprintf ( pgname , sz , \"%s,%s\" , de_tag ( * p ) , SCF_NOTIFY_PG_POSTFIX ) >= sz ) { uu_die ( gettext ( \"event name too long: %s\\n\" ) , * p ) ; } lxml_get_event ( entity , pgname , np ) ; } break ; default : if ( entity -> sc_etype == SVCCFG_SERVICE_OBJECT && strcmp ( entity -> sc_fmri , SCF_SERVICE_GLOBAL ) == 0 ) { semerr ( gettext ( \"Can't set events for global service\\n\" ) ) ; out } for ( t = 0x1 ; t < SCF_STATE_ALL ; t <<= 1 ) { if ( t & tset ) { lxml_get_event ( entity , tset_to_string ( t ) , np ) ; } if ( ( t << 16 ) & tset ) { lxml_get_event ( entity , tset_to_string ( t << 16 ) , np ) ; } } } r = 0 ; out free ( pgs ) ; free ( event ) ; return ( r ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int channel_write ( struct cgi_request * r , void * buf , size_t count ) { int ret ; if ( r -> active == MK_FALSE ) { return - 1 ; } MK_TRACE ( \"channel write: %d bytes\" , count ) ; mk_stream_in_raw ( & r -> sr -> stream , buf , count , NULL , NULL ) ; ret = mk_api -> channel_flush ( r -> sr -> session -> channel ) ; if ( ret & MK_CHANNEL_ERROR ) { r -> active = MK_FALSE ; cgi_finish ( r ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct clk * at91_clk_i2s_mux_register ( const char * name , struct clk * * parents , unsigned int num_parents , uint8_t bus_id ) { struct clk_i2s_mux * i2s_ck = NULL ; struct clk * clk = NULL ; clk = clk_alloc ( name , & clk_i2s_mux_ops , parents , num_parents ) ; if ( ! clk ) { return in ; } i2s_ck = calloc ( 1 , sizeof ( * i2s_ck ) ) ; if ( ! i2s_ck ) { clk_free ( clk ) ; return NULL ; } i2s_ck -> bus_id = bus_id ; i2s_ck -> sfr_base = sam_sfr_base ( ) ; clk -> priv = i2s_ck ; if ( clk_register ( clk ) ) { clk_free ( clk ) ; free ( i2s_ck ) ; return NULL ; } return clk ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void kfd_smi_event_queue_restore_rescheduled ( struct mm_struct * mm ) { struct kfd_process * p ; int i ; p = kfd_lookup_process_by_mm ( mm ) ; for ( i = 0 ; i < p -> n_pdds ; i ++ ) { struct kfd_process_device * pdd = p -> pdds [ i ] ; kfd_smi_event_add ( p -> lead_thread -> pid , pdd -> dev , KFD_SMI_EVENT_QUEUE_RESTORE , \"%lld -%d %x %c\\n\" , ktime_get_boottime_ns ( ) , p -> lead_thread -> pid , pdd -> dev -> id , 'R' ) ; } kfd_unref_process ( p ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int s5p_mfc_buf_init ( struct vb2_buffer * vb ) { struct vb2_v4l2_buffer * vbuf = to_vb2_v4l2_buffer ( vb ) ; struct vb2_queue * vq = vb -> vb2_queue ; struct s5p_mfc_ctx * ctx = fh_to_ctx ( vq -> drv_priv ) ; unsigned int i ; int ret ; if ( vq -> type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ) { ret = check_vb_with_fmt ( ctx -> dst_fmt , vb ) ; i = vb -> index ; ctx -> dst_bufs [ i ] . b = vbuf ; ctx -> dst_bufs [ i ] . cookie . stream = vb2_dma_contig_plane_dma_addr ( vb , 0 ) ; ctx -> dst_bufs_cnt ++ ; } if ( vq -> type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ) { ret = check_vb_with_fmt ( ctx -> src_fmt , vb ) ; if ( ret < 0 ) { return ret ; } i = vb -> index ; ctx -> src_bufs [ i ] . b = vbuf ; ctx -> src_bufs [ i ] . cookie . raw . luma = vb2_dma_contig_plane_dma_addr ( vb , 0 ) ; ctx -> src_bufs [ i ] . cookie . raw . chroma = vb2_dma_contig_plane_dma_addr ( vb , 1 ) ; ctx -> src_bufs_cnt ++ ; } else { mfc_err ( \"invalid queue type: %d\\n\" , vq -> type ) ; return - EINVAL ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int runcmd_setenv ( const char * name , const char * value ) int update_environment ( char * name , char * value , int set ) int runcmd_open ( const char * cmd , int * pfd , int * pfderr , char * * env , void * iobreg ( int , int , void * ) , void * iobregarg ) { char * * argv = NULL ; int argc = 0 ; int cmd2strv_errors ; size_t cmdlen ; pid_t pid ; int i = 0 ; if ( ! pids ) { runcmd_init ( ) ; } if ( cmd == NULL || pfd == NULL || pfderr == NULL ) { return RUNCMD_EINVAL ; } cmdlen = strlen ( cmd ) ; argv = calloc ( ( cmdlen / 2 ) + 5 , sizeof ( char * ) ) ; if ( ! argv ) { return RUNCMD_EALLOC ; } cmd2strv_errors = runcmd_cmd2strv ( cmd , & argc , argv ) ; if ( cmd2strv_errors == RUNCMD_EALLOC ) { return RUNCMD_EALLOC ; } if ( cmd2strv_errors ) { free ( argv [ 0 ] ) ; argv [ 0 ] = \"/bin/sh\" ; argv [ 1 ] = \"-c\" ; argv [ 2 ] = strdup ( cmd ) ; if ( ! argv [ 2 ] ) { free ( argv ) ; return RUNCMD_EALLOC ; } argv [ 3 ] = NULL ; } if ( pipe ( pfd ) < 0 ) { free ( ! cmd2strv_errors ?argv [ 0 ] : argv [ 2 ] ) ; free ( argv ) ; return RUNCMD_EFD ; } if ( pipe ( pfderr ) < 0 ) { free ( ! cmd2strv_errors ?argv [ 0 ] : argv [ 2 ] ) ; free ( argv ) ; close ( pfd [ 0 ] ) ; close ( pfd [ 1 ] ) ; return RUNCMD_EFD ; } if ( iobreg ) { iobreg ( pfd [ 0 ] , pfderr [ 0 ] , iobregarg ) ; } pid = fork ( ) ; if ( pid < 0 ) { free ( ! cmd2strv_errors ?argv [ 0 ] : argv [ 2 ] ) ; free ( argv ) ; close ( pfd [ 0 ] ) ; close ( pfd [ 1 ] ) ; close ( pfderr [ 0 ] ) ; close ( pfderr [ 1 ] ) ; return RUNCMD_EFORK ; } if ( pid == 0 ) { int exit_status = EXIT_SUCCESS ; if ( setpgid ( getpid ( ) , getpid ( ) ) == - 1 ) { exit_status = errno ; fprintf ( stderr , \"setpgid(...) errno %d: %s\\n\" , errno , strerror ( errno ) ) ; child_error_exit } close ( pfd [ 0 ] ) ; if ( pfd [ 1 ] != STDOUT_FILENO ) { if ( dup2 ( pfd [ 1 ] , STDOUT_FILENO ) == - 1 ) { exit_status = errno ; fprintf ( stderr , \"dup2(pfd[1], STDOUT_FILENO) errno %d: %s\\n\" , errno , strerror ( errno ) ) ; child_error_exit } close ( pfd [ 1 ] ) ; } close ( pfderr [ 0 ] ) ; if ( pfderr [ 1 ] != STDERR_FILENO ) { if ( dup2 ( pfderr [ 1 ] , STDERR_FILENO ) == - 1 ) { exit_status = errno ; fprintf ( stderr , \"dup2(pfderr[1], STDERR_FILENO) errno %d: %s\\n\" , errno , strerror ( errno ) ) ; child_error_exit } close ( pfderr [ 1 ] ) ; } for ( i = 0 ; i < maxfd ; i ++ ) { if ( pids [ i ] > 0 ) { close ( i ) ; } } if ( env ) { for ( ; env [ 0 ] && env [ 1 ] ; env += 2 ) { if ( runcmd_setenv ( env [ 0 ] , env [ 1 ] ) == - 1 ) { exit_status = errno ; fprintf ( stderr , \"runcmd_setenv(%s, ...) errno %d: %s\\n\" , env [ 0 ] , errno , strerror ( errno ) ) ; child_error_exit } } } i = 0 ; if ( ! cmd2strv_errors ) { char * ev ; for ( ; i < argc && ( ev = strchr ( argv [ i ] , '=' ) ) ; ++ i ) { if ( * ev ) { * ev ++ = '\\0' ; } if ( runcmd_setenv ( argv [ i ] , ev ) == - 1 ) { exit_status = errno ; fprintf ( stderr , \"runcmd_setenv(%s, ev) errno %d: %s\\n\" , argv [ i ] , errno , strerror ( errno ) ) ; child_error_exit } } if ( i == argc ) { exit_status = EXIT_FAILURE ; fprintf ( stderr , \"No command after variables.\\n\" ) ; child_error_exit } } execvp ( argv [ i ] , argv + i ) ; exit_status = errno ; fprintf ( stderr , \"execvp(%s, ...) failed. errno is %d: %s\\n\" , argv [ i ] , errno , strerror ( errno ) ) ; child_error_exit free ( ! cmd2strv_errors ?argv [ 0 ] : argv [ 2 ] ) ; free ( argv ) ; _exit ( exit_status ) ; } close ( pfd [ 1 ] ) ; close ( pfderr [ 1 ] ) ; free ( ! cmd2strv_errors ?argv [ 0 ] : argv [ 2 ] ) ; free ( argv ) ; pids [ pfd [ 0 ] ] = pid ; return pfd [ 0 ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ath6kl_close ( struct net_device * dev ) { struct ath6kl_vif * vif = netdev_priv ( dev ) ; netif_stop_queue ( dev ) ; ath6kl_cfg80211_stop ( vif , NULL ) ; clear_bit ( WLAN_ENABLED , & vif -> flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "G_DEFINE_ABSTRACT_TYPE ( VipsBandary , vips_bandary , VIPS_TYPE_CONVERSION ) ; static int vips_bandary_stop ( void * vseq , void * a , void * b ) { VipsBandarySequence * seq = ( VipsBandarySequence * ) vseq ; if ( seq -> ir ) { int i ; for ( i = 0 ; seq -> ir [ i ] ; i ++ ) { VIPS_UNREF ( seq -> ir [ i ] ) ; } VIPS_FREE ( seq -> ir , NULL ) ; } VIPS_FREE ( seq -> p ) ; VIPS_FREE ( seq -> pixels ) ; VIPS_FREE ( seq ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * disk_read_func ( unsigned long long , int , int ) NULL ; int print_possibilities ; static int do_completion ; static int unique ; static char * unique_string ; int fsmax ; struct fsys_entry fsys_table [ NUM_FSYS + 1 ] { { \"tftp\" tftp_mount tftp_read tftp_dir tftp_close 0 } { \"fat\" fat_mount fat_read fat_dir 0 0 } { \"ext2fs\" ext2fs_mount ext2fs_read ext2fs_dir 0 0 } { \"minix\" minix_mount minix_read minix_dir 0 0 } { \"reiserfs\" reiserfs_mount reiserfs_read reiserfs_dir 0 reiserfs_embed } { \"vstafs\" vstafs_mount vstafs_read vstafs_dir 0 0 } { \"jfs\" jfs_mount jfs_read jfs_dir 0 jfs_embed } { \"xfs\" xfs_mount xfs_read xfs_dir 0 0 } { \"ufs\" ufs_mount ufs_read ufs_dir 0 ufs_embed } { \"ufs2\" ufs2_mount ufs2_read ufs2_dir 0 ufs2_embed } { \"zfs\" zfs_mount zfs_read zfs_open 0 zfs_embed } { \"iso9660\" iso9660_mount iso9660_read iso9660_dir 0 0 } { \"ffs\" ffs_mount ffs_read ffs_dir 0 ffs_embed } { 0 0 0 0 0 0 } } ; ; unsigned long current_drive = GRUB_INVALID_DRIVE ; unsigned long current_partition ; cfs_time_t boot_part_addr = 0 ; int bsd_evil_hack ; int fsys_type = NUM_FSYS ; static int block_file = 0 ; unsigned long long part_start ; unsigned long long part_length ; int current_slice ; char current_rootpool [ MAXNAMELEN ] ; char current_bootfs [ MAXNAMELEN ] ; uint64_t current_bootfs_obj ; char current_bootpath [ MAXPATHLEN ] ; char current_devid [ MAXPATHLEN ] ; uint64_t current_bootguid ; uint64_t current_bootvdev ; int is_zfs_mount ; unsigned long best_drive ; unsigned long best_part ; int find_best_root ; int buf_drive = - 1 ; unsigned long long buf_track ; struct geometry buf_geom ; int filepos ; int filemax ; static inline unsigned long grub_log2 ( unsigned long word ) { volatile return word ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "git_filter * create_reverse_filter ( const char * attrs ) { git_filter * filter = git__calloc ( 1 , sizeof ( git_filter ) ) ; filter -> version = GIT_FILTER_VERSION ; filter -> attributes = attrs ; filter -> shutdown = reverse_filter_free ; filter -> stream = reverse_filter_stream ; return filter ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int nullf_read ( BIO * b , char * out , int outl ) { int ret = 0 ; if ( b -> next_bio == NULL ) { return ( 0 ) ; } ret = BIO_read ( b -> next_bio , out , outl ) ; BIO_clear_retry_flags ( b ) ; BIO_copy_next_retry ( b ) ; return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool do_realloc ( struct buf * buf , size_t at_least ) { char * new ; buf -> alloc += BUF_CHUNK_SIZE ; if ( at_least >= BUF_CHUNK_SIZE ) { buf -> alloc += at_least ; } new = realloc ( buf -> buf , buf -> alloc ) ; buf -> buf = new ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dwarf_get_relocation_info ( Dwarf_P_Debug dbg , Dwarf_Signed * elf_section_index , Dwarf_Signed * elf_section_index_link , Dwarf_Unsigned * relocation_buffer_count , Dwarf_Relocation_Data * reldata_buffer , Dwarf_Error * error ) { int next = dbg -> de_reloc_next_to_return ; if ( dbg -> de_flags & DW_DLC_SYMBOLIC_RELOCATIONS ) { int i ; for ( i = next ; i < NUM_DEBUG_SECTIONS ; ++ i ) { Dwarf_P_Per_Reloc_Sect prel = & dbg -> de_reloc_sect [ i ] ; int elf_sect_num = dbg -> de_elf_sects [ i ] ; if ( prel -> pr_reloc_total_count > 0 ) { dbg -> de_reloc_next_to_return = i + 1 ; * elf_section_index = prel -> pr_sect_num_of_reloc_sect ; * elf_section_index_link = elf_sect_num ; * relocation_buffer_count = prel -> pr_reloc_total_count ; * reldata_buffer = ( Dwarf_Relocation_Data ) ( prel -> pr_first_block -> rb_data ) ; return DW_DLV_OK ; } } DWARF_P_DBG_ERROR ( dbg , DW_DLE_REL_ALLOC , DW_DLV_ERROR ) ; } return DW_DLV_NO_ENTRY ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void update_desc_ctrlp ( descriptor_t * descp , controller_t * newctrlp ) { for ( ; newctrlp ; newctrlp = newctrlp -> next ) { if ( libdiskmgt_str_eq ( descp -> p . controller -> name , newctrlp -> name ) ) { descp -> p . controller = newctrlp ; return ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static uint32_t vega20_ih_doorbell_rptr ( struct amdgpu_ih_ring * ih ) { int ih_doorbell_rtpr = 0 ; if ( ih -> use_doorbell ) { ih_doorbell_rtpr = REG_SET_FIELD ( ih_doorbell_rtpr , IH_DOORBELL_RPTR , OFFSET , ih -> doorbell_index ) ; ih_doorbell_rtpr = REG_SET_FIELD ( ih_doorbell_rtpr , IH_DOORBELL_RPTR , ENABLE , 1 ) ; } else { ih_doorbell_rtpr = REG_SET_FIELD ( ih_doorbell_rtpr , IH_DOORBELL_RPTR , ENABLE , 0 ) ; } return ih_doorbell_rtpr ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int handle_gso_encap ( struct sk_buff * skb , bool ipv4 , int encap_len ) { int next_hdr_offset ; void * next_hdr ; __u8 protocol ; if ( ! ( skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_TCPV4 | SKB_GSO_TCPV6 ) ) ) { return - ENOTSUPP ; } if ( ipv4 ) { protocol = ip_hdr ( skb ) -> protocol ; next_hdr_offset = sizeof ( iphdr ) ; next_hdr = skb_network_header ( skb ) + next_hdr_offset ; } else { protocol = ipv6_hdr ( skb ) -> nexthdr ; next_hdr_offset = sizeof ( ipv6hdr ) ; next_hdr = skb_network_header ( skb ) + next_hdr_offset ; } switch ( protocol ) { case IPPROTO_GRE : next_hdr_offset += sizeof ( gre_base_hdr ) ; if ( ( ( gre_base_hdr * ) next_hdr ) -> flags & GRE_CSUM ) { return handle_gso_type ( skb , SKB_GSO_GRE_CSUM , encap_len ) ; } return handle_gso_type ( skb , SKB_GSO_GRE , encap_len ) ; case IPPROTO_UDP : next_hdr_offset += sizeof ( udphdr ) ; if ( next_hdr_offset > encap_len ) { return - EINVAL ; } if ( ( ( udphdr * ) next_hdr ) -> check ) { return handle_gso_type ( skb , SKB_GSO_UDP_TUNNEL_CSUM , encap_len ) ; } return handle_gso_type ( skb , SKB_GSO_UDP_TUNNEL , encap_len ) ; case IPPROTO_IP : case IPPROTO_IPV6 : if ( ipv4 ) { return handle_gso_type ( skb , SKB_GSO_IPXIP4 , encap_len ) ; } else { return handle_gso_type ( skb , SKB_GSO_IPXIP6 , encap_len ) ; } default : return - EPROTONOSUPPORT ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "hostlist_t hostlist_copy ( const hostlist_t hl ) { int i ; hostlist_t new ; if ( ! hl ) { return NULL ; } LOCK_HOSTLIST ( hl , NULL ) ; if ( ! ( new = hostlist_new ( ) ) ) { done } new -> nranges = hl -> nranges ; new -> nhosts = hl -> nhosts ; if ( new -> nranges > new -> size ) { hostlist_resize ( new , new -> nranges ) ; } for ( i = 0 ; i < hl -> nranges ; i ++ ) { new -> hr [ i ] = hostrange_copy ( hl -> hr [ i ] ) ; } done UNLOCK_HOSTLIST ( hl ) ; return new ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void sdio_free_func_cis ( struct sdio_func * func ) { struct sdio_func_tuple * tuple , * victim ; tuple = func -> tuples ; while ( tuple && tuple != func -> card -> tuples ) { victim = tuple ; tuple = tuple -> next ; } func -> tuples = NULL ; put_device ( & func -> card -> dev ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int blk_mq_init_bitmaps ( struct sbitmap_queue * bitmap_tags , struct sbitmap_queue * breserved_tags , unsigned int queue_depth , unsigned int reserved , int node , int alloc_policy ) { unsigned int depth = queue_depth - reserved ; bool round_robin = alloc_policy == BLK_TAG_ALLOC_RR ; if ( bt_alloc ( breserved_tags , reserved , round_robin , node ) ) { free_bitmap_tags } return 0 ; free_bitmap_tags sbitmap_queue_free ( bitmap_tags ) ; return - ENOMEM ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ch341_set_baudrate_lcr ( struct usb_device * dev , struct ch341_private * priv , speed_t baud_rate , u8 lcr ) { int val ; int r ; val = ch341_get_divisor ( priv , baud_rate ) ; if ( val < 0 ) { return - EINVAL ; } if ( priv -> version > 0x27 ) { val |= BIT ( 7 ) ; } r = ch341_control_out ( dev , CH341_REQ_WRITE_REG , CH341_REG_DIVISOR << 8 | CH341_REG_PRESCALER , val ) ; if ( r ) { return r ; } if ( priv -> version < 0x30 ) { return 0 ; } r = ch341_control_out ( dev , CH341_REQ_WRITE_REG , CH341_REG_LCR2 << 8 | CH341_REG_LCR , lcr ) ; if ( r ) { return r ; } return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void opj_pi_update_decode_poc ( opj_pi_iterator_t * p_pi , opj_tcp_t * p_tcp , OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) { OPJ_UINT32 pino ; OPJ_UINT32 l_bound ; opj_pi_iterator_t * l_current_pi = 00 ; opj_poc_t * l_current_poc = 0 ; OPJ_ARG_NOT_USED ( p_max_res ) ; assert ( p_pi != 00 ) ; assert ( p_tcp != 00 ) ; l_bound = p_tcp -> numpocs + 1 ; l_current_pi = p_pi ; l_current_poc = p_tcp -> pocs ; for ( pino = 0 ; pino < l_bound ; ++ pino ) { l_current_pi -> poc . prg = l_current_poc -> prg ; l_current_pi -> first = 1 ; l_current_pi -> poc . resno0 = l_current_poc -> resno0 ; l_current_pi -> poc . compno0 = l_current_poc -> compno0 ; l_current_pi -> poc . precno0 = 0 ; l_current_pi -> poc . resno1 = l_current_poc -> resno1 ; l_current_pi -> poc . compno1 = l_current_poc -> compno1 ; l_current_pi -> poc . layno1 = opj_uint_min ( l_current_poc -> layno1 , p_tcp -> numlayers ) ; l_current_pi -> poc . precno1 = p_max_precision ; ++ l_current_pi ; ++ l_current_poc ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static size_t __process_echoes ( struct tty_struct * tty ) { struct n_tty_data * ldata = tty -> disc_data ; int space , old_space ; size_t tail ; unsigned char c ; old_space = space = tty_write_room ( tty ) ; tail = ldata -> echo_tail ; while ( ldata -> echo_commit != tail ) { c = echo_buf ( ldata , tail ) ; if ( c == ECHO_OP_START ) { unsigned char op ; int no_space_left = 0 ; op = echo_buf ( ldata , tail + 1 ) ; switch ( op ) { unsigned int num_chars , num_bs ; case ECHO_OP_ERASE_TAB : num_chars = echo_buf ( ldata , tail + 2 ) ; if ( ! ( num_chars & 0x80 ) ) { num_chars += ldata -> canon_column ; } num_bs = 8 - ( num_chars & 7 ) ; if ( num_bs > space ) { no_space_left = 1 ; break ; } space -= num_bs ; while ( num_bs -- ) { tty_put_char ( tty , '\\b' ) ; if ( ldata -> column > 0 ) { ldata -> column -- ; } } tail += 3 ; break ; case ECHO_OP_SET_CANON_COL : ldata -> canon_column = ldata -> column ; tail += 2 ; break ; case ECHO_OP_MOVE_BACK_COL : if ( ldata -> column > 0 ) { ldata -> column -- ; } tail += 2 ; break ; case ECHO_OP_START : if ( ! space ) { no_space_left = 1 ; break ; } tty_put_char ( tty , ECHO_OP_START ) ; ldata -> column ++ ; space -- ; tail += 2 ; break ; default : if ( space < 2 ) { no_space_left = 1 ; break ; } tty_put_char ( tty , '^' ) ; tty_put_char ( tty , op ^ 0100 ) ; ldata -> column += 2 ; space -= 2 ; tail += 2 ; } if ( no_space_left ) { break ; } } else { if ( O_OPOST ( tty ) ) { int retval = do_output_char ( c , tty , space ) ; if ( retval < 0 ) { break ; } space -= retval ; } else { tty_put_char ( tty , c ) ; space -= 1 ; } tail += 1 ; } } while ( ldata -> echo_commit - tail >= ECHO_DISCARD_WATERMARK ) { if ( echo_buf ( ldata , tail ) == ECHO_OP_START ) { if ( echo_buf ( ldata , tail + 1 ) == ECHO_OP_ERASE_TAB ) { tail += 3 ; } else { tail += 2 ; } } else { tail ++ ; } } ldata -> echo_tail = tail ; return old_space - space ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int get_file_format ( const char * filename ) { unsigned int i ; static const char * extension [ ] { \"pgx\" \"pnm\" \"pgm\" \"ppm\" \"bmp\" \"tif\" \"raw\" \"tga\" \"png\" \"j2k\" \"jp2\" \"jpt\" \"j2c\" \"jpc\" } ; ; static const int format [ ] { PGX_DFMT PXM_DFMT PXM_DFMT PXM_DFMT BMP_DFMT TIF_DFMT RAW_DFMT TGA_DFMT PNG_DFMT J2K_CFMT JP2_CFMT JPT_CFMT J2K_CFMT J2K_CFMT } ; ; char * ext = strrchr ( filename , '.' ) ; ext ++ ; if ( ext ) { for ( i = 0 ; i < sizeof ( format ) / sizeof ( * format ) ; i ++ ) { if ( _strnicmp ( ext , extension [ i ] , 3 ) == 0 ) { return format [ i ] ; } } } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int nand_verify_page_oob ( struct mtd_info * mtd , struct mtd_oob_ops * ops , loff_t ofs ) { int rval ; struct mtd_oob_ops vops ; size_t verlen = mtd -> writesize + mtd -> oobsize ; memcpy ( & vops , ops , sizeof ( vops ) ) ; vops . datbuf = memalign ( ARCH_DMA_MINALIGN , verlen ) ; vops . oobbuf = vops . datbuf + mtd -> writesize ; rval = mtd_read_oob ( mtd , ofs , & vops ) ; if ( ! rval ) { rval = memcmp ( ops -> datbuf , vops . datbuf , vops . len ) ; } if ( ! rval ) { rval = memcmp ( ops -> oobbuf , vops . oobbuf , vops . ooblen ) ; } free ( vops . datbuf ) ; return rval ?- EIO : 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "buflist_config_read ( ) { int rc ; rc = weechat_config_read ( buflist_config_file ) ; if ( rc == WEECHAT_CONFIG_READ_OK ) { buflist_config_change_sort ( NULL , NULL , NULL ) ; buflist_config_change_signals_refresh ( NULL , NULL ) ; buflist_config_change_format ( NULL , NULL , NULL ) ; } return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int snd_riptide_initialize ( struct snd_riptide * chip ) { struct cmdif * cif ; unsigned int device_id ; int err ; if ( snd_BUG_ON ( ! chip ) ) { return - EINVAL ; } cif = chip -> cif ; if ( ! cif ) { cif = kmalloc ( sizeof ( cmdif ) , GFP_KERNEL ) ; if ( ! cif ) { return - ENOMEM ; } cif -> hwport = ( riptideport * ) chip -> port ; spin_lock_init ( & cif -> lock ) ; chip -> cif = cif ; } cif -> is_reset = 0 ; err = riptide_reset ( cif , chip ) ; if ( err ) { return err ; } device_id = chip -> device_id ; switch ( device_id ) { case 0x4310 : case 0x4320 : case 0x4330 : snd_printdd ( \"Modem enable?\\n\" ) ; SEND_SETDPLL ( cif ) ; break ; } snd_printdd ( \"Enabling MPU IRQs\\n\" ) ; if ( chip -> rmidi ) { SET_EMPUIRQ ( cif -> hwport ) ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void amdgpu_virt_add_bad_page ( struct amdgpu_device * adev , uint64_t bp_block_offset , uint32_t bp_block_size ) { struct eeprom_table_record bp ; uint64_t retired_page ; uint32_t bp_idx , bp_cnt ; if ( bp_block_size ) { bp_cnt = bp_block_size / sizeof ( uint64_t ) ; for ( bp_idx = 0 ; bp_idx < bp_cnt ; bp_idx ++ ) { retired_page = * ( uint64_t * ) ( adev -> mman . fw_vram_usage_va + bp_block_offset + bp_idx * sizeof ( uint64_t ) ) ; bp . retired_page = retired_page ; amdgpu_virt_ras_add_bps ( adev , & bp , 1 ) ; amdgpu_virt_ras_reserve_bps ( adev ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void duck ( int ) static void face_and_move_direction ( int , int ) static int go_for_ammo ( char ) static void ottolook ( int , struct item * ) static void look_around ( void ) static int stop_look ( struct item * , char , int , int ) static void wander ( void ) static void _panic ( const char * , int , const char * ) int otto ( int y , int x , char face , char * buf , size_t buflen ) { int i ; if ( usleep ( Otto_pause ) < 0 ) { panic ( \"usleep\" ) ; } switch ( face ) { case '^' : facing = NORTH ; break ; case '<' : facing = WEST ; break ; case 'v' : facing = SOUTH ; break ; case '>' : facing = EAST ; break ; default : panic ( \"unknown face\" ) ; } row = y ; col = x ; been_there [ row ] [ col ] |= 1 << facing ; comlen = 0 ; look_around ( ) ; for ( i = 0 ; i < NUMDIRECTIONS ; i ++ ) { if ( strchr ( OPPONENT , flbr [ i ] . what ) != NULL ) { attack ( i , & flbr [ i ] ) ; memset ( been_there , 0 , sizeof been_there ) ; done } } if ( strchr ( SHOTS , bitem . what ) != NULL && ! ( bitem . what & ON_SIDE ) ) { duck ( BACK , NULL ) ; memset ( been_there , 0 , sizeof been_there ) ; } if ( go_for_ammo ( BOOT_PAIR ) ) { memset ( been_there , 0 , sizeof been_there ) ; } if ( go_for_ammo ( BOOT ) ) { memset ( been_there , 0 , sizeof been_there ) ; } if ( go_for_ammo ( GMINE ) ) { memset ( been_there , 0 , sizeof been_there ) ; } if ( go_for_ammo ( MINE ) ) { memset ( been_there , 0 , sizeof been_there ) ; } else { wander ( ) ; } done if ( comlen ) { if ( comlen > buflen ) { panic ( \"not enough buffer space\" ) ; } memcpy ( buf , command , comlen ) ; } return comlen ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int groupmember ( gid_t gid , const cred_t * cr ) { return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "EXPORT_SYMBOL ( mn10300_icache_inv , NULL ) ; EXPORT_SYMBOL ( mn10300_icache_inv_range ) ; EXPORT_SYMBOL ( mn10300_icache_inv_range2 ) ; EXPORT_SYMBOL ( mn10300_icache_inv_page ) ; EXPORT_SYMBOL ( mn10300_dcache_inv ) ; EXPORT_SYMBOL ( mn10300_dcache_inv_range ) ; EXPORT_SYMBOL ( mn10300_dcache_inv_range2 ) ; EXPORT_SYMBOL ( mn10300_dcache_inv_page ) ; EXPORT_SYMBOL ( mn10300_dcache_flush ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_inv ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_inv_range ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_inv_range2 ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_inv_page ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_range ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_range2 ) ; EXPORT_SYMBOL ( mn10300_dcache_flush_page ) ; asmlinkage long sys_cacheflush ( unsigned long start , unsigned long end ) { if ( end < start ) { return - EINVAL ; } flush_icache_range ( start , end ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned int intel_plane_data_rate ( const struct intel_crtc_state * crtc_state , const struct intel_plane_state * plane_state , int color_plane ) { const struct drm_framebuffer * fb = plane_state -> hw . fb ; return intel_plane_pixel_rate ( crtc_state , plane_state ) * fb -> format -> cpp [ color_plane ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "module_param ( dev , int , S_IRUGO ) ; MODULE_PARM_DESC ( dev , \"MTD device number to use\" ) ; static struct mtd_info * mtd ; static unsigned char * iobuf ; static unsigned char * iobuf1 ; static unsigned char * bbt ; static int pgsize ; static int ebcnt ; static int pgcnt ; static int read_eraseblock_by_page ( int ebnum ) { int i , ret , err = 0 ; loff_t addr = ( loff_t ) ebnum * mtd -> erasesize ; void * buf = iobuf ; void * oobbuf = iobuf1 ; for ( i = 0 ; i < pgcnt ; i ++ ) { ret = mtdtest_read ( mtd , addr , pgsize , buf ) ; if ( ret ) { if ( ! err ) { err = ret ; } } if ( mtd -> oobsize ) { struct mtd_oob_ops ops ; ops . mode = MTD_OPS_PLACE_OOB ; ops . len = 0 ; ops . retlen = 0 ; ops . ooblen = mtd -> oobsize ; ops . oobretlen = 0 ; ops . ooboffs = 0 ; ops . datbuf = NULL ; ops . oobbuf = oobbuf ; ret = mtd_read_oob ( mtd , addr , & ops ) ; if ( ( ret && ! mtd_is_bitflip ( ret ) ) || ops . oobretlen != mtd -> oobsize ) { pr_err ( \"error: read oob failed at \" \"%#llx\\n\" , ( long long ) addr ) ; if ( ! err ) { err = ret ; } if ( ! err ) { err = - EINVAL ; } } oobbuf += mtd -> oobsize ; } addr += pgsize ; buf += pgsize ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __exchange_data_block ( struct inode * src_inode , struct inode * dst_inode , pgoff_t src , pgoff_t dst , pgoff_t len , bool full ) { block_t * src_blkaddr ; int * do_replace ; pgoff_t olen ; int ret ; while ( len ) { olen = min ( ( pgoff_t ) 4 * ADDRS_PER_BLOCK , len ) ; src_blkaddr = kvzalloc ( sizeof ( block_t ) * olen , GFP_KERNEL ) ; if ( ! src_blkaddr ) { return - ENOMEM ; } do_replace = kvzalloc ( sizeof ( int ) * olen , GFP_KERNEL ) ; if ( ! do_replace ) { return - ENOMEM ; } ret = __read_out_blkaddrs ( src_inode , src_blkaddr , do_replace , src , olen ) ; if ( ret ) { roll_back } ret = __clone_blkaddrs ( src_inode , dst_inode , src_blkaddr , do_replace , src , dst , olen , full ) ; if ( ret ) { roll_back } src += olen ; dst += olen ; len -= olen ; kvfree ( src_blkaddr ) ; kvfree ( do_replace ) ; } return 0 ; roll_back __roll_back_blkaddrs ( src_inode , src_blkaddr , do_replace , src , len ) ; kvfree ( src_blkaddr ) ; kvfree ( do_replace ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int efi_get_conf_table ( struct boot_params * bp , unsigned long * cfg_tbl_pa , unsigned int * cfg_tbl_len ) { unsigned long sys_tbl_pa ; enum efi_type et ; int ret ; sys_tbl_pa = efi_get_system_table ( bp ) ; if ( ! sys_tbl_pa ) { return - EINVAL ; } et = efi_get_type ( bp ) ; if ( et == EFI_TYPE_64 ) { efi_system_table_64_t * stbl = ( efi_system_table_64_t * ) sys_tbl_pa ; struct efi_setup_data * esd ; esd = get_kexec_setup_data ( bp , et ) ; * cfg_tbl_pa = esd ?esd -> tables : stbl -> tables ; * cfg_tbl_len = stbl -> nr_tables ; } if ( et == EFI_TYPE_32 ) { efi_system_table_32_t * stbl = ( efi_system_table_32_t * ) sys_tbl_pa ; * cfg_tbl_pa = stbl -> tables ; * cfg_tbl_len = stbl -> nr_tables ; } else { return - EINVAL ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ehci_handle_ue ( ehci_state_t * ehcip ) void ehci_handle_frame_list_rollover ( ehci_state_t * ehcip ) void ehci_handle_endpoint_reclaimation ( ehci_state_t * ehcip ) void ehci_traverse_active_qtd_list ( ehci_state_t * ehcip ) static ehci_qtd_t * ehci_create_done_qtd_list ( ehci_state_t * ehcip ) static usb_cr_t ehci_parse_error ( ehci_state_t * ehcip , ehci_qtd_t * qtd ) usb_cr_t ehci_check_for_error ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd , uint_t ctrl ) static usb_cr_t ehci_check_for_short_xfer ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd ) void ehci_handle_error ( ehci_state_t * ehcip , ehci_qtd_t * qtd , usb_cr_t error ) static void ehci_cleanup_data_underrun ( ehci_state_t * ehcip , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd ) static void ehci_handle_normal_qtd ( ehci_state_t * ehcip , ehci_qtd_t * qtd , ehci_trans_wrapper_t * tw ) void ehci_handle_ctrl_qtd ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd , void * ) void ehci_handle_bulk_qtd ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd , void * ) void ehci_handle_intr_qtd ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd , void * ) static void ehci_handle_one_xfer_completion ( ehci_state_t * ehcip , ehci_trans_wrapper_t * tw ) static void ehci_sendup_qtd_message ( ehci_state_t * ehcip , ehci_pipe_private_t * pp , ehci_trans_wrapper_t * tw , ehci_qtd_t * qtd , usb_cr_t error ) void ehci_handle_ue ( ehci_state_t * ehcip ) { usb_frame_number_t before_frame_number , after_frame_number ; ASSERT ( mutex_owned ( & ehcip -> ehci_int_mutex ) ) ; USB_DPRINTF_L3 ( PRINT_MASK_INTR , ehcip -> ehci_log_hdl , \"ehci_handle_ue: Handling of UE interrupt\" ) ; before_frame_number = ehci_get_current_frame_number ( ehcip ) ; drv_usecwait ( EHCI_TIMEWAIT ) ; after_frame_number = ehci_get_current_frame_number ( ehcip ) ; USB_DPRINTF_L3 ( PRINT_MASK_INTR , ehcip -> ehci_log_hdl , \"ehci_handle_ue: Before Frame Number 0x%llx \" \"After Frame Number 0x%llx\" , ( unsigned long long ) before_frame_number , ( unsigned long long ) after_frame_number ) ; if ( after_frame_number > before_frame_number ) { Set_OpReg ( ehci_interrupt , ( Get_OpReg ( ehci_interrupt ) & ~ EHCI_INTR_HOST_SYSTEM_ERROR ) ) ; return ; } if ( ( ehci_do_soft_reset ( ehcip ) ) != USB_SUCCESS ) { USB_DPRINTF_L0 ( PRINT_MASK_INTR , ehcip -> ehci_log_hdl , \"Unrecoverable USB Hardware Error\" ) ; Set_OpReg ( ehci_interrupt , ( Get_OpReg ( ehci_interrupt ) & ~ EHCI_INTR_HOST_SYSTEM_ERROR ) ) ; Set_OpReg ( ehci_config_flag , EHCI_CONFIG_FLAG_CLASSIC ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vcn_v1_0_sw_init ( void * handle ) { struct amdgpu_ring * ring ; int i , r ; struct amdgpu_device * adev = ( amdgpu_device * ) handle ; r = amdgpu_irq_add_id ( adev , SOC15_IH_CLIENTID_VCN , VCN_1_0__SRCID__UVD_SYSTEM_MESSAGE_INTERRUPT , & adev -> vcn . inst -> irq ) ; for ( i = 0 ; i < adev -> vcn . num_enc_rings ; ++ i ) { r = amdgpu_irq_add_id ( adev , SOC15_IH_CLIENTID_VCN , i + VCN_1_0__SRCID__UVD_ENC_GENERAL_PURPOSE , & adev -> vcn . inst -> irq ) ; if ( r ) { return r ; } } r = amdgpu_vcn_sw_init ( adev ) ; if ( r ) { return r ; } adev -> vcn . idle_work . work . func = vcn_v1_0_idle_work_handler ; amdgpu_vcn_setup_ucode ( adev ) ; r = amdgpu_vcn_resume ( adev ) ; if ( r ) { return r ; } ring = & adev -> vcn . inst -> ring_dec ; sprintf ( ring -> name , \"vcn_dec\" ) ; r = amdgpu_ring_init ( adev , ring , 512 , & adev -> vcn . inst -> irq , 0 , AMDGPU_RING_PRIO_DEFAULT , NULL ) ; if ( r ) { return r ; } adev -> vcn . internal . scratch9 = adev -> vcn . inst -> external . scratch9 = SOC15_REG_OFFSET ( UVD , 0 , mmUVD_SCRATCH9 ) ; adev -> vcn . internal . data0 = adev -> vcn . inst -> external . data0 = SOC15_REG_OFFSET ( UVD , 0 , mmUVD_GPCOM_VCPU_DATA0 ) ; adev -> vcn . internal . data1 = adev -> vcn . inst -> external . data1 = SOC15_REG_OFFSET ( UVD , 0 , mmUVD_GPCOM_VCPU_DATA1 ) ; adev -> vcn . internal . cmd = adev -> vcn . inst -> external . cmd = SOC15_REG_OFFSET ( UVD , 0 , mmUVD_GPCOM_VCPU_CMD ) ; adev -> vcn . internal . nop = adev -> vcn . inst -> external . nop = SOC15_REG_OFFSET ( UVD , 0 , mmUVD_NO_OP ) ; for ( i = 0 ; i < adev -> vcn . num_enc_rings ; ++ i ) { enum amdgpu_ring_priority_level hw_prio = amdgpu_vcn_get_enc_ring_prio ( i ) ; ring = & adev -> vcn . inst -> ring_enc [ i ] ; sprintf ( ring -> name , \"vcn_enc%d\" , i ) ; r = amdgpu_ring_init ( adev , ring , 512 , & adev -> vcn . inst -> irq , 0 , hw_prio , NULL ) ; if ( r ) { return r ; } } adev -> vcn . pause_dpg_mode = vcn_v1_0_pause_dpg_mode ; if ( amdgpu_vcnfw_log ) { volatile struct amdgpu_fw_shared * fw_shared = adev -> vcn . inst -> fw_shared . cpu_addr ; fw_shared -> present_flag_0 = 0 ; amdgpu_vcn_fwlog_init ( adev -> vcn . inst ) ; } r = jpeg_v1_0_sw_init ( handle ) ; return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void usage ( void ) { fprintf ( stderr , \"Usage:\\n\" ) ; fprintf ( stderr , \"    %s [options] mailbox...\\n\" , argv0 ) ; fprintf ( stderr , \"\\n%s\\n\" , \"Options:\\n\" \"    -C alt_config       # alternate config file\\n\" \"    -v                  # verbose\\n\" ) ; exit ( EX_USAGE , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "paddr_t vgafb_mmap ( void * v , off_t off , int prot ) { struct vgafb_softc * sc = v ; if ( off & PGOFSET ) { return ( - 1 ) ; } switch ( sc -> sc_mode ) { case WSDISPLAYIO_MODE_MAPPED : if ( sc -> sc_mmio_size == 0 ) { return ( - 1 ) ; } if ( off >= sc -> sc_mem_addr && off < ( sc -> sc_mem_addr + sc -> sc_mem_size ) ) { return ( bus_space_mmap ( sc -> sc_mem_t , sc -> sc_mem_addr , off - sc -> sc_mem_addr , prot , BUS_SPACE_MAP_LINEAR ) ) ; } if ( off >= sc -> sc_mmio_addr && off < ( sc -> sc_mmio_addr + sc -> sc_mmio_size ) ) { return ( bus_space_mmap ( sc -> sc_mem_t , sc -> sc_mmio_addr , off - sc -> sc_mmio_addr , prot , BUS_SPACE_MAP_LINEAR ) ) ; } break ; case WSDISPLAYIO_MODE_DUMBFB : if ( off >= 0 && off < sc -> sc_mem_size ) { return ( bus_space_mmap ( sc -> sc_mem_t , sc -> sc_mem_addr , off , prot , BUS_SPACE_MAP_LINEAR ) ) ; } break ; } return ( - 1 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; EQContext * eq = ctx -> priv ; AVFrame * out ; int64_t pos = in -> pkt_pos ; const AVPixFmtDescriptor * desc ; int i ; out = ff_get_video_buffer ( outlink , inlink -> w , inlink -> h ) ; if ( ! out ) { return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; desc = av_pix_fmt_desc_get ( inlink -> format ) ; eq -> var_values [ VAR_N ] = inlink -> frame_count_out ; eq -> var_values [ VAR_POS ] = pos == - 1 ?NAN : pos ; eq -> var_values [ VAR_T ] = TS2T ( in -> pts , inlink -> time_base ) ; if ( eq -> eval_mode == EVAL_MODE_FRAME ) { set_gamma ( eq ) ; set_contrast ( eq ) ; set_brightness ( eq ) ; set_saturation ( eq ) ; } for ( i = 0 ; i < desc -> nb_components ; i ++ ) { int w = inlink -> w ; int h = inlink -> h ; if ( i == 1 || i == 2 ) { w = AV_CEIL_RSHIFT ( w , desc -> log2_chroma_w ) ; h = AV_CEIL_RSHIFT ( h , desc -> log2_chroma_h ) ; } if ( i == 3 || ! eq -> param [ i ] . adjust ) { av_image_copy_plane ( out -> data [ i ] , out -> linesize [ i ] , in -> data [ i ] , in -> linesize [ i ] , w , h ) ; } else { eq -> param [ i ] . adjust ( & eq -> param [ i ] , out -> data [ i ] , out -> linesize [ i ] , in -> data [ i ] , in -> linesize [ i ] , w , h ) ; } } av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "const char * cpc_getusage ( int cpuver ) { switch ( cpuver ) { case CPC_ULTRA1 : case CPC_ULTRA2 : case CPC_ULTRA3 : case CPC_ULTRA3_PLUS : case CPC_ULTRA3_I : case CPC_ULTRA4_PLUS : return ( \"pic0=<event0>,pic1=<event1>\" \"[,sys] \" \"[,nouser]\" ) ; default : return ( NULL ) ; } } keyval { char * kv_token ; int * kv_action ( const char * , const struct keyval * , int , char * , uint64_t * ) int kv_mask ; int kv_shift ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * devm_krealloc ( struct device * dev , void * ptr , size_t new_size , gfp_t gfp ) { size_t total_new_size , total_old_size ; struct devres * old_dr , * new_dr ; unsigned long flags ; if ( unlikely ( ! new_size ) ) { devm_kfree ( dev , ptr ) ; return ZERO_SIZE_PTR ; } if ( unlikely ( ZERO_OR_NULL_PTR ( ptr ) ) ) { return devm_kmalloc ( dev , new_size , gfp ) ; } if ( WARN_ON ( is_kernel_rodata ( ( unsigned long ) ptr ) ) ) { return NULL ; } if ( ! check_dr_size ( new_size , & total_new_size ) ) { return NULL ; } total_old_size = ksize ( container_of ( ptr , devres , data ) ) ; if ( total_old_size == 0 ) { WARN ( 1 , \"Pointer doesn't point to dynamically allocated memory.\" ) ; return NULL ; } if ( total_new_size <= total_old_size ) { return ptr ; } new_dr = alloc_dr ( devm_kmalloc_release , total_new_size , gfp , dev_to_node ( dev ) ) ; if ( ! new_dr ) { return in ; } spin_lock_irqsave ( & dev -> devres_lock , flags ) ; old_dr = find_dr ( dev , devm_kmalloc_release , devm_kmalloc_match , ptr ) ; if ( ! old_dr ) { spin_unlock_irqrestore ( & dev -> devres_lock , flags ) ; kfree ( new_dr ) ; WARN ( 1 , \"Memory chunk not managed or managed by a different device.\" ) ; return NULL ; } replace_dr ( dev , & old_dr -> node , & new_dr -> node ) ; spin_unlock_irqrestore ( & dev -> devres_lock , flags ) ; memcpy ( new_dr -> data , old_dr -> data , total_old_size - offsetof ( devres , data ) ) ; kfree ( old_dr ) ; return new_dr -> data ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "FLAC__bool FLAC__bitreader_read_rice_signed_block ( FLAC__BitReader * br , int vals [ ] , uint32_t nvals , uint32_t parameter ) { uint32_t cwords , words , lsbs , msbs , x , y , limit ; uint32_t ucbits ; brword b ; int * val , * end ; FLAC__ASSERT ( 0 != br ) ; FLAC__ASSERT ( 0 != br -> buffer ) ; FLAC__ASSERT ( FLAC__BITS_PER_WORD >= 32 ) ; FLAC__ASSERT ( parameter < 32 ) ; limit = UINT32_MAX >> parameter ; val = vals ; end = vals + nvals ; if ( parameter == 0 ) { while ( val < end ) { * val ++ = ( int ) ( msbs >> 1 ) ^ - ( int ) ( msbs & 1 ) ; } return true ; } FLAC__ASSERT ( parameter > 0 ) ; cwords = br -> consumed_words ; words = br -> words ; if ( cwords >= words ) { x = 0 ; process_tail } ucbits = FLAC__BITS_PER_WORD - br -> consumed_bits ; b = br -> buffer [ cwords ] << br -> consumed_bits ; while ( val < end ) { x = y = COUNT_ZERO_MSBS2 ( b ) ; if ( x == FLAC__BITS_PER_WORD ) { x = ucbits ; { cwords ++ ; if ( cwords >= words ) { incomplete_msbs } b = br -> buffer [ cwords ] ; y = COUNT_ZERO_MSBS2 ( b ) ; x += y ; } y == FLAC__BITS_PER_WORD ; } b <<= y ; b <<= 1 ; ucbits = ( ucbits - x - 1 ) % FLAC__BITS_PER_WORD ; msbs = x ; if ( x > limit ) { return false ; } x = ( FLAC__uint32 ) ( b >> ( FLAC__BITS_PER_WORD - parameter ) ) ; if ( parameter <= ucbits ) { ucbits -= parameter ; b <<= parameter ; } else { cwords ++ ; if ( cwords >= words ) { incomplete_lsbs } b = br -> buffer [ cwords ] ; ucbits += FLAC__BITS_PER_WORD - parameter ; x |= ( FLAC__uint32 ) ( b >> ucbits ) ; b <<= FLAC__BITS_PER_WORD - ucbits ; } lsbs = x ; x = ( msbs << parameter ) | lsbs ; * val ++ = ( int ) ( x >> 1 ) ^ - ( int ) ( x & 1 ) ; continue ; process_tail { if ( 0 ) { incomplete_msbs br -> consumed_bits = 0 ; br -> consumed_words = cwords ; } if ( ! FLAC__bitreader_read_unary_unsigned ( br , & msbs ) ) { return false ; } msbs += x ; x = ucbits = 0 ; if ( 0 ) { incomplete_lsbs br -> consumed_bits = 0 ; br -> consumed_words = cwords ; } if ( ! FLAC__bitreader_read_raw_uint32 ( br , & lsbs , parameter - ucbits ) ) { return false ; } lsbs = x | lsbs ; x = ( msbs << parameter ) | lsbs ; * val ++ = ( int ) ( x >> 1 ) ^ - ( int ) ( x & 1 ) ; x = 0 ; cwords = br -> consumed_words ; words = br -> words ; ucbits = FLAC__BITS_PER_WORD - br -> consumed_bits ; b = cwords < br -> capacity ?br -> buffer [ cwords ] << br -> consumed_bits : 0 ; } cwords >= words && val < end ; } if ( ucbits == 0 && cwords < words ) { cwords ++ ; ucbits = FLAC__BITS_PER_WORD ; } br -> consumed_bits = FLAC__BITS_PER_WORD - ucbits ; br -> consumed_words = cwords ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test_fentry_fexit ( void ) { struct fentry_test_lskel * fentry_skel = NULL ; struct fexit_test_lskel * fexit_skel = NULL ; __u64 * fentry_res , * fexit_res ; int err , prog_fd , i ; LIBBPF_OPTS ( bpf_test_run_opts , topts ) ; fentry_skel = fentry_test_lskel__open_and_load ( ) ; if ( ! ASSERT_OK_PTR ( fentry_skel , \"fentry_skel_load\" ) ) { close_prog } fexit_skel = fexit_test_lskel__open_and_load ( ) ; if ( ! ASSERT_OK_PTR ( fexit_skel , \"fexit_skel_load\" ) ) { close_prog } err = fentry_test_lskel__attach ( fentry_skel ) ; if ( ! ASSERT_OK ( err , \"fentry_attach\" ) ) { close_prog } err = fexit_test_lskel__attach ( fexit_skel ) ; if ( ! ASSERT_OK ( err , \"fexit_attach\" ) ) { close_prog } prog_fd = fexit_skel -> progs . test1 . prog_fd ; err = bpf_prog_test_run_opts ( prog_fd , & topts ) ; ASSERT_OK ( err , \"ipv6 test_run\" ) ; ASSERT_OK ( topts . retval , \"ipv6 test retval\" ) ; fentry_res = ( __u64 * ) fentry_skel -> bss ; fexit_res = ( __u64 * ) fexit_skel -> bss ; printf ( \"%lld\\n\" , fentry_skel -> bss -> test1_result ) ; for ( i = 0 ; i < 8 ; i ++ ) { ASSERT_EQ ( fentry_res [ i ] , 1 , \"fentry result\" ) ; ASSERT_EQ ( fexit_res [ i ] , 1 , \"fexit result\" ) ; } close_prog fexit_test_lskel__destroy ( fexit_skel ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "off_t get_file_size ( const char * file_name ) { int statbuf ; if ( stat ( file_name , & statbuf ) < 0 ) { if ( errno == ENOENT ) { fprintf ( stderr , \"'%s': No such file\\n\" , file_name ) ; } else { fprintf ( stderr , \"Warning: could not locate '%s'.  reason: %s\\n\" , file_name , strerror ( errno ) ) ; } } if ( ! S_ISREG ( statbuf . st_mode ) ) { fprintf ( stderr , \"Warning: '%s' is not an ordinary file\\n\" , file_name ) ; } else { return statbuf . st_size ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int qxl_gem_prime_vmap ( struct drm_gem_object * obj , struct iosys_map * map ) { struct qxl_bo * bo = gem_to_qxl_bo ( obj ) ; int ret ; ret = qxl_bo_vmap_locked ( bo , map ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static const char * register_translate_name_hook ( cmd_parms * cmd , void * _cfg , const char * file , const char * function , const char * when ) { const char * err = ap_check_cmd_context ( cmd , NOT_IN_DIRECTORY | NOT_IN_FILES | NOT_IN_HTACCESS ) ; int apr_hook_when = APR_HOOK_MIDDLE ; if ( when ) { if ( ! strcasecmp ( when , \"early\" ) ) { apr_hook_when = AP_LUA_HOOK_FIRST ; } if ( ! strcasecmp ( when , \"late\" ) ) { apr_hook_when = AP_LUA_HOOK_LAST ; } else { return \"Third argument must be 'early' or 'late'\" ; } } return register_named_file_function_hook ( \"translate_name\" , cmd , _cfg , file , function , apr_hook_when ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "heap16 * heap16_init ( heap16 * heap , uint16_t space , uint16_t large , uint8_t flags ) { align_space16 ( space ) ; if ( large > space ) { large = space ; } heap -> space = space ; heap -> large = large ; heap -> flags = flags ; return heap ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( pgd_cache_init ) ; static inline pgd_t * _pgd_alloc ( void ) { return kmem_cache_alloc ( pgd_cache , PGALLOC_GFP ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static DECLARE_DELAYED_WORK ( work , do_softint ) ; static void do_softint ( struct work_struct * work ) { int absx = 0 , absy = 0 ; u8 scpdr ; int touched = 0 ; if ( __raw_readb ( PHDR ) & PHDR_TS_PEN_DOWN ) { scpdr = __raw_readb ( SCPDR ) ; scpdr |= SCPDR_TS_SCAN_ENABLE ; scpdr &= ~ SCPDR_TS_SCAN_Y ; __raw_writeb ( scpdr , SCPDR ) ; udelay ( 30 ) ; absy = adc_single ( ADC_CHANNEL_TS_Y ) ; scpdr = __raw_readb ( SCPDR ) ; scpdr |= SCPDR_TS_SCAN_Y ; scpdr &= ~ SCPDR_TS_SCAN_X ; __raw_writeb ( scpdr , SCPDR ) ; udelay ( 30 ) ; absx = adc_single ( ADC_CHANNEL_TS_X ) ; scpdr = __raw_readb ( SCPDR ) ; scpdr |= SCPDR_TS_SCAN_X ; scpdr &= ~ SCPDR_TS_SCAN_ENABLE ; __raw_writeb ( scpdr , SCPDR ) ; udelay ( 100 ) ; touched = __raw_readb ( PHDR ) & PHDR_TS_PEN_DOWN ; } if ( touched ) { input_report_key ( hp680_ts_dev , BTN_TOUCH , 1 ) ; input_report_abs ( hp680_ts_dev , ABS_X , absx ) ; input_report_abs ( hp680_ts_dev , ABS_Y , absy ) ; } else { input_report_key ( hp680_ts_dev , BTN_TOUCH , 0 ) ; } input_sync ( hp680_ts_dev , NULL ) ; enable_irq ( HP680_TS_IRQ ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int use_connection ( struct ipc_server_thread_data * server_thread_data ) { int ret ; ret = do_io ( server_thread_data ) ; FlushFileBuffers ( server_thread_data -> hPipe ) ; DisconnectNamedPipe ( server_thread_data -> hPipe , NULL ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void rtmp_log ( int level , const char * fmt , va_list args ) { switch ( level ) { default : case RTMP_LOGCRIT : level = AV_LOG_FATAL ; break ; case RTMP_LOGERROR : level = AV_LOG_ERROR ; break ; case RTMP_LOGWARNING : level = AV_LOG_WARNING ; break ; case RTMP_LOGINFO : level = AV_LOG_INFO ; break ; case RTMP_LOGDEBUG : level = AV_LOG_VERBOSE ; break ; case RTMP_LOGDEBUG2 : level = AV_LOG_DEBUG ; break ; } av_vlog ( level , fmt , args ) ; av_log ( NULL , level , \"\\n\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int connect_tty ( void ) { char * connector ; int fdflags ; struct stat statbuf ; char numbuf [ 16 ] ; strlcpy ( ppp_devname , devnam , MAXPATHLEN ) ; pty_master = - 1 ; pty_slave = - 1 ; real_ttyfd = - 1 ; if ( using_pty || record_file != NULL ) { if ( ! get_pty ( & pty_master , & pty_slave , ppp_devname , uid ) ) { error ( \"Couldn't allocate pseudo-tty\" ) ; ppp_set_status ( EXIT_FATAL_ERROR , NULL ) ; return - 1 ; } set_up_tty ( pty_slave , 1 ) ; } ppp_set_status ( EXIT_LOCK_FAILED ) ; if ( lockflag && ! privopen ) { if ( lock ( devnam ) < 0 ) { errret } locked = 1 ; } got_sigterm = 0 ; connector = doing_callback ?callback_script : connect_script ; if ( devnam [ 0 ] != 0 ) { for ( ; ; ) { int err , prio ; prio = privopen ?OPRIO_ROOT : tty_options [ 0 ] . priority ; if ( prio < OPRIO_ROOT && seteuid ( uid ) == - 1 ) { error ( \"Unable to drop privileges before opening %s: %m\\n\" , devnam ) ; ppp_set_status ( EXIT_OPEN_FAILED ) ; errret } real_ttyfd = open ( devnam , O_NONBLOCK | O_RDWR , 0 ) ; err = errno ; if ( prio < OPRIO_ROOT && seteuid ( 0 ) == - 1 ) { fatal ( \"Unable to regain privileges\" ) ; } if ( real_ttyfd >= 0 ) { break ; } errno = err ; if ( err != EINTR ) { error ( \"Failed to open %s: %m\" , devnam ) ; ppp_set_status ( EXIT_OPEN_FAILED ) ; } if ( ! persist || err != EINTR ) { errret } } ttyfd = real_ttyfd ; if ( ( fdflags = fcntl ( ttyfd , F_GETFL ) ) == - 1 || fcntl ( ttyfd , F_SETFL , fdflags & ~ O_NONBLOCK ) < 0 ) { warn ( \"Couldn't reset non-blocking mode on device: %m\" ) ; } if ( fstat ( ttyfd , & statbuf ) < 0 || fchmod ( ttyfd , statbuf . st_mode & ~ ( S_IWGRP | S_IWOTH ) ) < 0 ) { warn ( \"Couldn't restrict write permissions to %s: %m\" , devnam ) ; } else { tty_mode = statbuf . st_mode ; } set_up_tty ( ttyfd , ( ( connector != NULL && connector [ 0 ] != 0 ) || initializer != NULL ) ) ; } ppp_set_status ( EXIT_PTYCMD_FAILED ) ; if ( ptycommand != NULL ) { if ( record_file != NULL ) { int ipipe [ 2 ] , opipe [ 2 ] , ok ; if ( pipe ( ipipe ) < 0 || pipe ( opipe ) < 0 ) { fatal ( \"Couldn't create pipes for record option: %m\" ) ; } ( void ) fcntl ( ipipe [ 0 ] , F_SETFD , FD_CLOEXEC ) ; ( void ) fcntl ( opipe [ 1 ] , F_SETFD , FD_CLOEXEC ) ; ok = device_script ( ptycommand , opipe [ 0 ] , ipipe [ 1 ] , 1 ) == 0 && start_charshunt ( ipipe [ 0 ] , opipe [ 1 ] ) ; close ( ipipe [ 0 ] ) ; close ( ipipe [ 1 ] ) ; close ( opipe [ 0 ] ) ; close ( opipe [ 1 ] ) ; if ( ! ok ) { errret } } else { if ( device_script ( ptycommand , pty_master , pty_master , 1 ) < 0 ) { errret } } } if ( pty_socket != NULL ) { int fd = open_socket ( pty_socket ) ; if ( fd < 0 ) { errret } if ( ! start_charshunt ( fd , fd ) ) { errret } close ( fd ) ; } if ( notty ) { if ( ! start_charshunt ( 0 , 1 ) ) { errret } dup2 ( fd_devnull , 0 ) ; dup2 ( fd_devnull , 1 ) ; if ( log_to_fd == 1 ) { log_to_fd = - 1 ; } if ( log_to_fd != 2 ) { dup2 ( fd_devnull , 2 ) ; } } if ( record_file != NULL ) { int fd = dup ( ttyfd ) ; if ( ! start_charshunt ( fd , fd ) ) { errret } } if ( using_pty || record_file != NULL ) { ttyfd = pty_slave ; close ( pty_master ) ; pty_master = - 1 ; } if ( ( connector && connector [ 0 ] ) || initializer ) { if ( real_ttyfd != - 1 ) { if ( ! default_device && modem ) { setdtr ( real_ttyfd , 0 ) ; sleep ( 1 ) ; setdtr ( real_ttyfd , 1 ) ; } } if ( initializer && initializer [ 0 ] ) { if ( device_script ( initializer , ttyfd , ttyfd , 0 ) < 0 ) { error ( \"Initializer script failed\" ) ; ppp_set_status ( EXIT_INIT_FAILED ) ; errretf } if ( got_sigterm ) { disconnect_tty ( ) ; errretf } info ( \"Serial port initialized.\" ) ; } if ( connector && connector [ 0 ] ) { if ( device_script ( connector , ttyfd , ttyfd , 0 ) < 0 ) { error ( \"Connect script failed\" ) ; ppp_set_status ( EXIT_CONNECT_FAILED ) ; errretf } if ( got_sigterm ) { disconnect_tty ( ) ; errretf } info ( \"Serial connection established.\" ) ; } if ( real_ttyfd != - 1 ) { set_up_tty ( real_ttyfd , 0 ) ; } if ( doing_callback == CALLBACK_DIALIN ) { connector = NULL ; } } if ( connector == NULL && modem && devnam [ 0 ] != 0 ) { int i ; for ( ; ; ) { if ( ( i = open ( devnam , O_RDWR ) ) >= 0 ) { break ; } if ( errno != EINTR ) { error ( \"Failed to reopen %s: %m\" , devnam ) ; ppp_set_status ( EXIT_OPEN_FAILED ) ; } if ( ! persist || errno != EINTR || hungup || got_sigterm ) { errret } } close ( i ) ; } slprintf ( numbuf , sizeof ( numbuf ) , \"%d\" , baud_rate ) ; ppp_script_setenv ( \"SPEED\" , numbuf , 0 ) ; if ( welcomer && welcomer [ 0 ] ) { if ( device_script ( welcomer , ttyfd , ttyfd , 0 ) < 0 ) { warn ( \"Welcome script failed\" ) ; } } if ( connector != NULL || ptycommand != NULL || pty_socket != NULL ) { listen_time = connect_delay ; } return ttyfd ; errretf if ( real_ttyfd >= 0 ) { tcflush ( real_ttyfd , TCIOFLUSH ) ; } errret if ( pty_master >= 0 ) { close ( pty_master ) ; pty_master = - 1 ; } ttyfd = - 1 ; if ( got_sigterm ) { asked_to_quit = 1 ; } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int synaptics_i2c_remove ( struct i2c_client * client ) { struct synaptics_i2c * touch = i2c_get_clientdata ( client ) ; if ( ! polling_req ) { free_irq ( client -> irq , touch ) ; } input_unregister_device ( touch -> input ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct symbol * sym_find ( const char * name ) { struct symbol * symbol = NULL ; int hash = 0 ; if ( ! name ) { return in ; } if ( name [ 0 ] && ! name [ 1 ] ) { switch ( name [ 0 ] ) { case 'y' : return & symbol_yes ; case 'm' : return & symbol_mod ; case 'n' : return & symbol_no ; } } hash = strhash ( name ) % SYMBOL_HASHSIZE ; for ( symbol = symbol_hash [ hash ] ; symbol ; symbol = symbol -> next ) { if ( symbol -> name && ! strcmp ( symbol -> name , name ) && ! ( symbol -> flags & SYMBOL_CONST ) ) { break ; } } return symbol ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void versal_realize ( DeviceState * dev , Error * * errp ) { Versal * s = XLNX_VERSAL ( dev ) ; qemu_irq pic [ XLNX_VERSAL_NR_IRQS ] ; versal_create_apu_cpus ( s ) ; versal_create_apu_gic ( s , pic ) ; versal_create_uarts ( s , pic ) ; versal_create_usbs ( s , pic ) ; versal_create_gems ( s , pic ) ; versal_create_admas ( s , pic ) ; versal_create_sds ( s , pic ) ; versal_create_pmc_apb_irq_orgate ( s , pic ) ; versal_create_rtc ( s , pic ) ; versal_create_xrams ( s , pic ) ; versal_create_bbram ( s , pic ) ; versal_create_efuse ( s , pic ) ; versal_create_pmc_iou_slcr ( s , pic ) ; versal_create_ospi ( s , pic ) ; versal_map_ddr ( s ) ; versal_unimp ( s ) ; memory_region_init_ram ( & s -> lpd . mr_ocm , OBJECT ( s ) , \"ocm\" , MM_OCM_SIZE , & error_abort ) ; memory_region_add_subregion_overlap ( & s -> mr_ps , MM_OCM , & s -> lpd . mr_ocm , 0 ) ; memory_region_add_subregion_overlap ( & s -> fpd . apu . mr , 0 , & s -> mr_ps , 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void st_debug ( st_debug_level_t level , lcollection_t * lcol , char * msg , ... ) { va_list alist ; char * buf ; size_t len ; if ( get_message_priority ( ) < ( ( level == STDL_HIGH ) ?RCM_DEBUG_HIGH : RCM_DEBUG ) ) { return ; } len = strlen ( msg ) + LINELEN ; buf = malloc ( len ) ; ( void ) snprintf ( buf , len , \"%s %s scanner %s\" , ( lcol -> lcol_id . rcid_type == RCIDT_PROJECT ?\"project\" : \"zone\" ) , lcol -> lcol_name , msg ) ; va_start ( alist , msg ) ; vdprintfe ( RCM_DEBUG , buf , alist ) ; va_end ( alist ) ; free ( buf ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int btrfs_tree_mod_log_insert_move ( struct extent_buffer * eb , int dst_slot , int src_slot , int nr_items ) { struct tree_mod_elem * tm = NULL ; struct tree_mod_elem * * tm_list = NULL ; int ret = 0 ; int i ; bool locked = false ; if ( ! tree_mod_need_log ( eb -> fs_info , eb ) ) { return 0 ; } tm_list = kcalloc ( nr_items , sizeof ( tree_mod_elem * ) , GFP_NOFS ) ; if ( ! tm_list ) { return - ENOMEM ; } tm = kzalloc ( sizeof ( * tm ) , GFP_NOFS ) ; if ( ! tm ) { ret = - ENOMEM ; free_tms } tm -> logical = eb -> start ; tm -> slot = src_slot ; tm -> move . dst_slot = dst_slot ; tm -> move . nr_items = nr_items ; tm -> op = BTRFS_MOD_LOG_MOVE_KEYS ; for ( i = 0 ; i + dst_slot < src_slot && i < nr_items ; i ++ ) { tm_list [ i ] = alloc_tree_mod_elem ( eb , i + dst_slot , BTRFS_MOD_LOG_KEY_REMOVE_WHILE_MOVING ) ; if ( ! tm_list [ i ] ) { ret = - ENOMEM ; free_tms } } if ( tree_mod_dont_log ( eb -> fs_info , eb ) ) { free_tms } locked = true ; for ( i = 0 ; i + dst_slot < src_slot && i < nr_items ; i ++ ) { ret = tree_mod_log_insert ( eb -> fs_info , tm_list [ i ] ) ; if ( ret ) { free_tms } } ret = tree_mod_log_insert ( eb -> fs_info , tm ) ; if ( ret ) { free_tms } write_unlock ( & eb -> fs_info -> tree_mod_log_lock ) ; return 0 ; free_tms for ( i = 0 ; i < nr_items ; i ++ ) { if ( tm_list [ i ] && ! RB_EMPTY_NODE ( & tm_list [ i ] -> node ) ) { rb_erase ( & tm_list [ i ] -> node , & eb -> fs_info -> tree_mod_log ) ; } kfree ( tm_list [ i ] ) ; } if ( locked ) { write_unlock ( & eb -> fs_info -> tree_mod_log_lock ) ; } kfree ( tm_list ) ; kfree ( tm ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ends_with_optional_cr ( const char * l , long s , long i ) { int complete = s && l [ s - 1 ] == '\\n' ; if ( complete ) { s -- ; } if ( complete && s == i + 1 && l [ i ] == '\\r' ) { return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void match_function_call ( struct expression * expr ) { struct expression * tmp ; FOR_EACH_PTR ( , ) { set_parent ( tmp , & ok ) ; } END_FOR_EACH_PTR ( tmp , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void bad_input ( void * * state ) { xmlNode * xml = string2xml ( str1 ) ; pcmk__assert_asserts ( pcmk__xe_foreach_child ( xml , NULL , NULL , NULL ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool try_wait_for_completion ( struct completion * x ) { unsigned long flags ; bool ret = true ; raw_spin_lock_irqsave ( & x -> wait . lock , flags ) ; if ( ! x -> done ) { ret = false ; } if ( x -> done != UINT_MAX ) { x -> done -- ; } raw_spin_unlock_irqrestore ( & x -> wait . lock , flags ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * * vhci_to_phci ( char * vhci_name , int * num_paths ) { sv_iocdata_t ioc ; uint_t npaths ; int n ; char * * phci_list = NULL ; char * node_name , * at ; char vhci_name_buf [ MAXPATHLEN ] ; logdmsg ( ( \"vhci_to_phci: vchi_name =  %s\\n\" , vhci_name ) ) ; * num_paths = 0 ; ( void ) strlcpy ( vhci_name_buf , vhci_name , MAXPATHLEN ) ; bzero ( & ioc , sizeof ( sv_iocdata_t ) ) ; ioc . client = vhci_name_buf ; ioc . ret_elem = & npaths ; if ( vhci_ctl ( & ioc , SCSI_VHCI_GET_CLIENT_MULTIPATH_INFO ) != 0 || npaths == 0 ) { logdmsg ( ( \"vhci_to_phci: vhci_ctl failed to get npaths: %s\\n\" , strerror ( errno ) ) ) ; return ( NULL ) ; } bzero ( & ioc , sizeof ( sv_iocdata_t ) ) ; ioc . client = vhci_name_buf ; ioc . buf_elem = npaths ; ioc . ret_elem = & npaths ; if ( ( ioc . ret_buf = ( sv_path_info_t * ) calloc ( npaths , sizeof ( sv_path_info_t ) ) ) == NULL ) { return ( NULL ) ; } if ( vhci_ctl ( & ioc , SCSI_VHCI_GET_CLIENT_MULTIPATH_INFO ) != 0 || npaths == 0 ) { logdmsg ( ( \"vhci_to_phci: vhci_ctl failed: %s\\n\" , strerror ( errno ) ) ) ; out } if ( ioc . buf_elem < npaths ) { npaths = ioc . buf_elem ; } if ( ( node_name = strrchr ( vhci_name_buf , '/' ) ) == NULL || ( at = strchr ( node_name , '@' ) ) == NULL ) { out } node_name ++ ; * at = '\\0' ; if ( ( phci_list = calloc ( npaths + 1 , sizeof ( char * ) ) ) == NULL ) { out } if ( ( n = add_to_phci_list ( phci_list , ioc . ret_buf , npaths , MDI_PATHINFO_STATE_ONLINE , node_name ) ) <= 0 ) { out } * num_paths = n ; logdmsg ( ( \"vhci_to_phci: phci list:\\n\" ) ) ; log_pathlist ( phci_list ) ; return ( phci_list ) ; out free ( ioc . ret_buf ) ; if ( phci_list ) { free_pathlist ( phci_list ) ; } return ( NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int validate_change ( struct cpuset * cur , struct cpuset * trial ) { struct cgroup_subsys_state * css ; struct cpuset * c , * par ; int ret ; rcu_read_lock ( ) ; if ( ! is_in_v2_mode ( ) ) { ret = validate_change_legacy ( cur , trial ) ; } if ( ret ) { out } if ( cur == & top_cpuset ) { out } par = parent_cs ( cur ) ; ret = - ENOSPC ; if ( ( cgroup_is_populated ( cur -> css . cgroup ) || cur -> attach_in_progress ) ) { if ( ! cpumask_empty ( cur -> cpus_allowed ) && cpumask_empty ( trial -> cpus_allowed ) ) { out } if ( ! nodes_empty ( cur -> mems_allowed ) && nodes_empty ( trial -> mems_allowed ) ) { out } } ret = - EBUSY ; if ( is_cpu_exclusive ( cur ) && ! cpuset_cpumask_can_shrink ( cur -> cpus_allowed , trial -> cpus_allowed ) ) { out } ret = - EINVAL ; cpuset_for_each_child ( , , ) { if ( ( is_cpu_exclusive ( trial ) || is_cpu_exclusive ( c ) ) && c != cur && cpumask_intersects ( trial -> cpus_allowed , c -> cpus_allowed ) ) { out } if ( ( is_mem_exclusive ( trial ) || is_mem_exclusive ( c ) ) && c != cur && nodes_intersects ( trial -> mems_allowed , c -> mems_allowed ) ) { out } } ret = 0 ; out rcu_read_unlock ( ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool wm_hubs_dcs_cache_get ( struct snd_soc_codec * codec , struct wm_hubs_dcs_cache * * entry ) { struct wm_hubs_data * hubs = snd_soc_codec_get_drvdata ( codec ) ; struct wm_hubs_dcs_cache * cache ; unsigned int left , right ; left = snd_soc_read ( codec , WM8993_LEFT_OUTPUT_VOLUME ) ; left &= WM8993_HPOUT1L_VOL_MASK ; right = snd_soc_read ( codec , WM8993_RIGHT_OUTPUT_VOLUME ) ; right &= WM8993_HPOUT1R_VOL_MASK ; list_for_each_entry ( , , ) { * entry = cache ; return true ; } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void per_cpu_init ( void ) { int cpu = smp_processor_id ( ) ; nasid_t nasid = get_nasid ( ) ; clear_c0_status ( ST0_IM ) ; per_hub_init ( nasid , NULL ) ; pr_info ( \"CPU %d clock is %dMHz.\\n\" , cpu , sn_cpu_info [ cpu ] . p_speed ) ; install_ipi ( ) ; install_cpu_nmi_handler ( cputoslice ( cpu ) ) ; enable_percpu_irq ( IP27_HUB_PEND0_IRQ , IRQ_TYPE_NONE ) ; enable_percpu_irq ( IP27_HUB_PEND1_IRQ , IRQ_TYPE_NONE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t qio_channel_websock_readv ( QIOChannel * ioc , const struct iovec * iov , size_t niov , int * * fds , size_t * nfds , Error * * errp ) { QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( ioc ) ; size_t i ; ssize_t got = 0 ; ssize_t ret ; if ( wioc -> io_err ) { error_propagate ( errp , error_copy ( wioc -> io_err ) ) ; return - 1 ; } if ( ! wioc -> rawinput . offset ) { ret = qio_channel_websock_read_wire ( QIO_CHANNEL_WEBSOCK ( ioc ) , errp ) ; } for ( i = 0 ; i < niov ; i ++ ) { size_t want = iov [ i ] . iov_len ; if ( want > ( wioc -> rawinput . offset - got ) ) { want = ( wioc -> rawinput . offset - got ) ; } memcpy ( iov [ i ] . iov_base , wioc -> rawinput . buffer + got , want ) ; got += want ; if ( want < iov [ i ] . iov_len ) { break ; } } buffer_advance ( & wioc -> rawinput , got ) ; qio_channel_websock_set_watch ( wioc ) ; return got ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void metag_internal_irq_shutdown ( struct irq_data * data ) { metag_internal_irq_mask ( data , NULL ) ; metag_internal_irq_ack ( data ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void spa_async_remove ( spa_t * spa , vdev_t * vd ) { int c ; if ( vd -> vdev_remove_wanted ) { vd -> vdev_remove_wanted = B_FALSE ; vd -> vdev_delayed_close = B_FALSE ; vdev_set_state ( vd , B_FALSE , VDEV_STATE_REMOVED , VDEV_AUX_NONE ) ; vd -> vdev_stat . vs_read_errors = 0 ; vd -> vdev_stat . vs_write_errors = 0 ; vdev_state_dirty ( vd -> vdev_top ) ; } for ( c = 0 ; c < vd -> vdev_children ; c ++ ) { spa_async_remove ( spa , vd -> vdev_child [ c ] ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ml_get_combo_effect ( struct ml_device * ml , unsigned long * effect_handled , struct ff_effect * combo_effect ) { struct ff_effect * effect ; struct ml_effect_state * state ; int effect_type ; int i ; for ( i = 0 ; i < FF_MEMLESS_EFFECTS ; i ++ ) { if ( __test_and_set_bit ( i , effect_handled ) ) { continue ; } state = & ml -> states [ i ] ; effect = state -> effect ; if ( ! test_bit ( FF_EFFECT_STARTED , & state -> flags ) ) { continue ; } if ( time_before ( jiffies , state -> play_at ) ) { continue ; } effect_type = get_compatible_type ( ml -> dev -> ff , effect -> type ) ; if ( combo_effect -> type != effect_type ) { if ( combo_effect -> type != 0 ) { __clear_bit ( i , effect_handled ) ; continue ; } combo_effect -> type = effect_type ; } if ( __test_and_clear_bit ( FF_EFFECT_ABORTING , & state -> flags ) ) { __clear_bit ( FF_EFFECT_PLAYING , & state -> flags ) ; __clear_bit ( FF_EFFECT_STARTED , & state -> flags ) ; } if ( effect -> replay . length && time_after_eq ( jiffies , state -> stop_at ) ) { __clear_bit ( FF_EFFECT_PLAYING , & state -> flags ) ; if ( -- state -> count <= 0 ) { __clear_bit ( FF_EFFECT_STARTED , & state -> flags ) ; } else { state -> play_at = jiffies + msecs_to_jiffies ( effect -> replay . delay ) ; state -> stop_at = state -> play_at + msecs_to_jiffies ( effect -> replay . length ) ; } } else { __set_bit ( FF_EFFECT_PLAYING , & state -> flags ) ; state -> adj_at = jiffies ; ml_combine_effects ( combo_effect , state , ml -> gain ) ; } } return combo_effect -> type != 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void snd_dg00x_proc_init ( struct snd_dg00x * dg00x ) { struct snd_info_entry * root , * entry ; root = snd_info_create_card_entry ( dg00x -> card , \"firewire\" , dg00x -> card -> proc_root ) ; if ( root == NULL ) { return ; } root -> mode = S_IFDIR | S_IRUGO | S_IXUGO ; if ( snd_info_register ( root ) < 0 ) { return ; } entry = snd_info_create_card_entry ( dg00x -> card , \"clock\" , root ) ; if ( entry == NULL ) { snd_info_free_entry ( root ) ; return ; } snd_info_set_text_ops ( entry , dg00x , proc_read_clock ) ; if ( snd_info_register ( entry ) < 0 ) { snd_info_free_entry ( entry ) ; snd_info_free_entry ( root ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GPMF_ERR GPMF_Reserved ( uint32_t key ) { if ( key == GPMF_KEY_DEVICE_ID ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_DEVICE_NAME ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_STREAM ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_STREAM_NAME ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_SI_UNITS ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_UNITS ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_SCALE ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TYPE ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TOTAL_SAMPLES ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TICK ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TOCK ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_EMPTY_PAYLOADS ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_REMARK ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_MATRIX ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_ORIENTATION_IN ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_ORIENTATION_OUT ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TIME_STAMP ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TIME_STAMPS ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_PREFORMATTED ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_TEMPERATURE_C ) { return GPMF_ERROR_RESERVED ; } if ( key == GPMF_KEY_FREESPACE ) { return GPMF_ERROR_RESERVED ; } return GPMF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long kvm_arm_num_regs ( struct kvm_vcpu * vcpu ) { cfs_time_t res = 0 ; res += num_core_regs ( vcpu ) ; res += num_sve_regs ( vcpu ) ; res += kvm_arm_num_sys_reg_descs ( vcpu ) ; res += kvm_arm_get_fw_num_regs ( vcpu ) ; res += NUM_TIMER_REGS ; return res ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t show_temp_input ( struct device * dev , struct device_attribute * dev_attr , char * buf ) { long temp ; struct max6639_data * data = max6639_update_device ( dev ) ; struct sensor_device_attribute * attr = to_sensor_dev_attr ( dev_attr ) ; temp = data -> temp [ attr -> index ] * 125 ; return sprintf ( buf , \"%ld\\n\" , temp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void udbg_opal_putc ( char c ) { unsigned int termno = hvc_opal_boot_termno ; int count = - 1 ; if ( c == '\\n' ) { udbg_opal_putc ( '\\r' ) ; } { switch ( hvc_opal_boot_priv . proto ) { case HV_PROTOCOL_RAW : count = opal_put_chars ( termno , & c , 1 ) ; break ; case HV_PROTOCOL_HVSI : count = hvc_opal_hvsi_put_chars ( termno , & c , 1 ) ; break ; } opal_flush_console ( termno , NULL ) ; } count == 0 || count == - EAGAIN ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "SpaprTceTable * spapr_tce_new_table ( DeviceState * owner , uint32_t liobn ) { SpaprTceTable * tcet ; gchar * tmp ; if ( spapr_tce_find_by_liobn ( liobn ) ) { error_report ( \"Attempted to create TCE table with duplicate\" \" LIOBN 0x%x\" , liobn ) ; return NULL ; } tcet = SPAPR_TCE_TABLE ( object_new ( TYPE_SPAPR_TCE_TABLE ) ) ; tcet -> liobn = liobn ; tmp = g_strdup_printf ( \"tce-table-%x\" , liobn ) ; object_property_add_child ( OBJECT ( owner ) , tmp , OBJECT ( tcet ) ) ; object_unref ( OBJECT ( tcet ) ) ; qdev_realize ( DEVICE ( tcet ) , NULL , NULL ) ; return tcet ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void generate_password ( char * * pw , int num_classes , ... ) void random_password ( char * pw , size_t len ) { { OtpKey newkey ; krb5_generate_random_block ( & newkey , sizeof ( newkey ) ) ; otp_print_stddict ( newkey , pw , len ) ; strlwr ( pw , NULL ) ; } char * pass ; generate_password ( & pass , 3 , \"abcdefghijklmnopqrstuvwxyz\" , 7 , \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , 2 , \"@$%&*()-+=:,/<>1234567890\" , 1 ) ; strlcpy ( pw , pass , len ) ; len = strlen ( pass ) ; memset_s ( pass , len , 0 , len ) ; free ( pass ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cubic_cb_init ( struct cc_var * ccv ) { struct cubic * cubic_data ; cubic_data = kmem_zalloc ( sizeof ( cubic ) , KM_NOSLEEP ) ; if ( cubic_data == NULL ) { return ( ENOMEM ) ; } cubic_data -> t_last_cong = gethrtime ( ) ; cubic_data -> min_rtt_nsecs = TCPTV_SRTTBASE ; ccv -> cc_data = cubic_data ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int netdev_nl_dev_get_doit ( struct sk_buff * skb , struct genl_info * info ) { struct net_device * netdev ; struct sk_buff * rsp ; u32 ifindex ; int err ; if ( GENL_REQ_ATTR_CHECK ( info , NETDEV_A_DEV_IFINDEX ) ) { return - EINVAL ; } ifindex = nla_get_u32 ( info -> attrs [ NETDEV_A_DEV_IFINDEX ] , NULL ) ; rsp = genlmsg_new ( GENLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! rsp ) { return - ENOMEM ; } rtnl_lock ( ) ; netdev = __dev_get_by_index ( genl_info_net ( info ) , ifindex ) ; if ( netdev ) { err = netdev_nl_dev_fill ( netdev , rsp , info -> snd_portid , info -> snd_seq , 0 , info -> genlhdr -> cmd ) ; } else { err = - ENODEV ; } rtnl_unlock ( ) ; if ( err ) { err_free_msg } return genlmsg_reply ( rsp , info ) ; err_free_msg nlmsg_free ( rsp ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int nfp_shared_buf_register ( struct nfp_pf * pf ) { struct devlink * devlink = priv_to_devlink ( pf ) ; unsigned int i , num_entries , entry_sz ; struct nfp_cpp_area * sb_desc_area ; u8 __iomem * sb_desc ; int n , err ; if ( ! pf -> mbox ) { return 0 ; } n = nfp_pf_rtsym_read_optional ( pf , NFP_SHARED_BUF_COUNT_SYM_NAME , 0 ) ; if ( n <= 0 ) { return n ; } num_entries = n ; sb_desc = nfp_pf_map_rtsym ( pf , \"sb_tbl\" , NFP_SHARED_BUF_TABLE_SYM_NAME , num_entries * sizeof ( pf -> shared_bufs [ 0 ] ) , & sb_desc_area ) ; if ( IS_ERR ( sb_desc ) ) { return PTR_ERR ( sb_desc ) ; } entry_sz = nfp_cpp_area_size ( sb_desc_area ) / num_entries ; pf -> shared_bufs = kmalloc_array ( num_entries , sizeof ( pf -> shared_bufs [ 0 ] ) , GFP_KERNEL ) ; if ( ! pf -> shared_bufs ) { err = - ENOMEM ; err_release_area } for ( i = 0 ; i < num_entries ; i ++ ) { struct nfp_shared_buf * sb = & pf -> shared_bufs [ i ] ; memcpy_fromio ( sb , sb_desc + i * entry_sz , sizeof ( * sb ) ) ; err = devlink_sb_register ( devlink , le32_to_cpu ( sb -> id ) , le32_to_cpu ( sb -> size ) , le16_to_cpu ( sb -> ingress_pools_count ) , le16_to_cpu ( sb -> egress_pools_count ) , le16_to_cpu ( sb -> ingress_tc_count ) , le16_to_cpu ( sb -> egress_tc_count ) ) ; if ( err ) { err_unreg_prev } } pf -> num_shared_bufs = num_entries ; nfp_cpp_area_release_free ( sb_desc_area ) ; return 0 ; err_unreg_prev while ( i -- ) { devlink_sb_unregister ( devlink , le32_to_cpu ( pf -> shared_bufs [ i ] . id ) ) ; } err_release_area nfp_cpp_area_release_free ( sb_desc_area ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int xfs_bmap_count_blocks ( struct xfs_trans * tp , struct xfs_inode * ip , int whichfork , xfs_extnum_t * nextents , xfs_filblks_t * count ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_ifork * ifp = xfs_ifork_ptr ( ip , whichfork ) ; struct xfs_btree_cur * cur ; xfs_extlen_t btblocks = 0 ; int error ; * nextents = 0 ; * count = 0 ; if ( ! ifp ) { return 0 ; } switch ( ifp -> if_format ) { case XFS_DINODE_FMT_BTREE : error = xfs_iread_extents ( tp , ip , whichfork ) ; cur = xfs_bmbt_init_cursor ( mp , tp , ip , whichfork ) ; error = xfs_btree_count_blocks ( cur , & btblocks ) ; xfs_btree_del_cursor ( cur , error ) ; if ( error ) { return error ; } * count += btblocks - 1 ; fallthrough ; case XFS_DINODE_FMT_EXTENTS : * nextents = xfs_bmap_count_leaves ( ifp , count ) ; break ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned int mlxsw_sp2_acl_bf_index_get ( struct mlxsw_sp_acl_bf * bf , struct mlxsw_sp_acl_atcam_region * aregion , struct mlxsw_sp_acl_atcam_entry * aentry ) { int bf_key [ MLXSW_SP2_BLOOM_KEY_LEN ] ; u8 bf_size ; mlxsw_sp2_acl_bf_key_encode ( aregion , aentry , bf_key , & bf_size ) ; return mlxsw_sp2_acl_bf_crc ( bf_key , bf_size ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pvr2_eeprom_analyze ( struct pvr2_hdw * hdw ) { u8 * eeprom ; struct tveeprom tvdata ; memset ( & tvdata , 0 , sizeof ( tvdata ) ) ; eeprom = pvr2_eeprom_fetch ( hdw ) ; if ( ! eeprom ) { return - EINVAL ; } tveeprom_hauppauge_analog ( & tvdata , eeprom ) ; trace_eeprom ( \"eeprom assumed v4l tveeprom module\" ) ; trace_eeprom ( \"eeprom direct call results:\" ) ; trace_eeprom ( \"has_radio=%d\" , tvdata . has_radio ) ; trace_eeprom ( \"tuner_type=%d\" , tvdata . tuner_type ) ; trace_eeprom ( \"tuner_formats=0x%x\" , tvdata . tuner_formats ) ; trace_eeprom ( \"audio_processor=%d\" , tvdata . audio_processor ) ; trace_eeprom ( \"model=%d\" , tvdata . model ) ; trace_eeprom ( \"revision=%d\" , tvdata . revision ) ; trace_eeprom ( \"serial_number=%d\" , tvdata . serial_number ) ; trace_eeprom ( \"rev_str=%s\" , tvdata . rev_str ) ; hdw -> tuner_type = tvdata . tuner_type ; hdw -> tuner_updated = ! 0 ; hdw -> serial_number = tvdata . serial_number ; hdw -> std_mask_eeprom = tvdata . tuner_formats ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ipoib_cm_create_srq ( struct net_device * dev , int max_sge ) { struct ipoib_dev_priv * priv = ipoib_priv ( dev ) ; struct ib_srq_init_attr srq_init_attr = { . srq_type = IB_SRQT_BASIC . attr = { . max_wr = ipoib_recvq_size . max_sge = max_sge } } ; priv -> cm . srq = ib_create_srq ( priv -> pd , & srq_init_attr ) ; if ( IS_ERR ( priv -> cm . srq ) ) { if ( PTR_ERR ( priv -> cm . srq ) != - EOPNOTSUPP ) { pr_warn ( \"%s: failed to allocate SRQ, error %ld\\n\" , priv -> ca -> name , PTR_ERR ( priv -> cm . srq ) ) ; } return ; } priv -> cm . srq_ring = vzalloc ( array_size ( ipoib_recvq_size , sizeof ( * priv -> cm . srq_ring ) ) ) ; if ( ! priv -> cm . srq_ring ) { ib_destroy_srq ( priv -> cm . srq ) ; priv -> cm . srq = NULL ; return ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int serial_pre_remove ( struct udevice * dev ) { struct serial_dev_priv * upriv = dev_get_uclass_priv ( dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sha256_update ( struct sha256_state * sctx , const u8 * data , unsigned int len ) { unsigned int partial , done ; const u8 * src ; partial = sctx -> count & 0x3f ; sctx -> count += len ; done = 0 ; src = data ; if ( ( partial + len ) > 63 ) { if ( partial ) { done = - partial ; memcpy ( sctx -> buf + partial , data , done + 64 ) ; src = sctx -> buf ; } { sha256_transform ( sctx -> state , src ) ; done += 64 ; src = data + done ; } done + 63 < len ; } memcpy ( sctx -> buf + partial , src , len - done ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int same_token ( struct trailer_item * a , struct arg_item * b ) { size_t a_len , b_len , min_len ; a_len = token_len_without_separator ( a -> token , strlen ( a -> token ) ) ; b_len = token_len_without_separator ( b -> token , strlen ( b -> token ) ) ; min_len = ( a_len > b_len ) ?b_len : a_len ; return ! strncasecmp ( a -> token , b -> token , min_len ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int armada_370_xp_timer_dying_cpu ( unsigned int cpu ) { struct clock_event_device * evt = per_cpu_ptr ( armada_370_xp_evt , cpu ) ; evt -> set_state_shutdown ( evt , NULL ) ; disable_percpu_irq ( evt -> irq ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void map_free ( struct map_page * map , const char * test_name , const char * map_name ) { unsigned char * p = map -> start ; int i ; for ( i = sizeof ( long ) ; i > 0 ; i -- ) { if ( p [ sizeof ( long ) - i ] != 0xff - i ) { errx ( 1 , \"%s: %s underrun %d\\n\" , test_name , map_name , i ) ; } } for ( i = sizeof ( long ) ; i > 0 ; i -- ) { if ( p [ map -> size - i ] != 0xff - i ) { errx ( 1 , \"%s: %s overrun %lu\\n\" , test_name , map_name , ( unsigned long ) map -> size - i ) ; } } free ( map -> start ) ; int ret ; ret = munmap ( map -> start , map -> size ) ; if ( ret < 0 ) { err ( 1 , \"munmap\" ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "dcret_t dnlc_dir_start ( dcanchor_t * dcap , uint_t num_entries ) { dircache_t * dcp ; if ( ! dnlc_dir_enable || ( num_entries < dnlc_dir_min_size ) ) { return ( DNOCACHE ) ; } mutex_enter ( & dc_head . dch_lock ) ; mutex_enter ( & dcap -> dca_lock ) ; if ( dcap -> dca_dircache == DC_RET_LOW_MEM ) { dcap -> dca_dircache = NULL ; mutex_exit ( & dcap -> dca_lock ) ; mutex_exit ( & dc_head . dch_lock ) ; return ( DNOMEM ) ; } if ( dcap -> dca_dircache != NULL ) { mutex_exit ( & dcap -> dca_lock ) ; mutex_exit ( & dc_head . dch_lock ) ; return ( DNOCACHE ) ; } if ( ( dcp = kmem_zalloc ( sizeof ( dircache_t ) , KM_NOSLEEP ) ) == NULL ) { error } if ( ( dcp -> dc_namehash = kmem_zalloc ( sizeof ( dcentry_t * ) , KM_NOSLEEP ) ) == NULL ) { error } if ( ( dcp -> dc_freehash = kmem_zalloc ( sizeof ( dcfree_t * ) , KM_NOSLEEP ) ) == NULL ) { error } dcp -> dc_anchor = dcap ; dcap -> dca_dircache = dcp ; dcp -> dc_next = dc_head . dch_next ; dcp -> dc_prev = ( dircache_t * ) & dc_head ; dcp -> dc_next -> dc_prev = dcp ; dc_head . dch_next = dcp ; mutex_exit ( & dcap -> dca_lock ) ; mutex_exit ( & dc_head . dch_lock ) ; ncs . ncs_cur_dirs . value . ui64 ++ ; ncs . ncs_dirs_cached . value . ui64 ++ ; return ( DOK ) ; error if ( dcp != NULL ) { if ( dcp -> dc_namehash ) { kmem_free ( dcp -> dc_namehash , sizeof ( dcentry_t * ) ) ; } kmem_free ( dcp , sizeof ( dircache_t ) ) ; } mutex_exit ( & dcap -> dca_lock ) ; mutex_exit ( & dc_head . dch_lock ) ; ncs . ncs_dir_start_nm . value . ui64 ++ ; return ( DNOCACHE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ex_wn ( SCR * sp , EXCMD * cmdp ) { if ( exwr ( sp , cmdp , WN ) ) { return ( 1 ) ; } if ( file_m3 ( sp , 0 ) ) { return ( 1 ) ; } return ( ex_next ( sp , cmdp ) ) ; } int ex_wq ( SCR * sp , EXCMD * cmdp ) { int force ; if ( exwr ( sp , cmdp , WQ ) ) { return ( 1 ) ; } if ( file_m3 ( sp , 0 ) ) { return ( 1 ) ; } force = FL_ISSET ( cmdp -> iflags , E_C_FORCE ) ; if ( ex_ncheck ( sp , force ) ) { return ( 1 ) ; } F_SET ( sp , force ?SC_EXIT_FORCE : SC_EXIT ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int max8997_battery_get_property ( struct power_supply * psy , enum power_supply_property psp , union power_supply_propval * val ) { struct charger_data * charger = power_supply_get_drvdata ( psy ) ; struct i2c_client * i2c = charger -> iodev -> i2c ; int ret ; u8 reg ; switch ( psp ) { case POWER_SUPPLY_PROP_STATUS : val -> intval = 0 ; ret = max8997_read_reg ( i2c , MAX8997_REG_STATUS4 , & reg ) ; if ( ( reg & ( 1 << 0 ) ) == 0x1 ) { val -> intval = POWER_SUPPLY_STATUS_FULL ; } break ; case POWER_SUPPLY_PROP_PRESENT : val -> intval = 0 ; ret = max8997_read_reg ( i2c , MAX8997_REG_STATUS4 , & reg ) ; if ( ret ) { return ret ; } if ( ( reg & ( 1 << 2 ) ) == 0x0 ) { val -> intval = 1 ; } break ; case POWER_SUPPLY_PROP_ONLINE : val -> intval = 0 ; ret = max8997_read_reg ( i2c , MAX8997_REG_STATUS4 , & reg ) ; if ( ret ) { return ret ; } if ( reg & ( 1 << 1 ) ) { val -> intval = 1 ; } break ; default : return - EINVAL ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void svc_pool_map_set_cpumask ( struct task_struct * task , unsigned int pidx ) { struct svc_pool_map * m = & svc_pool_map ; int node = m -> pool_to [ pidx ] ; WARN_ON_ONCE ( m -> count == 0 ) ; if ( m -> count == 0 ) { return ; } switch ( m -> mode ) { case SVC_POOL_PERCPU : { set_cpus_allowed_ptr ( task , cpumask_of ( node ) ) ; break ; } case SVC_POOL_PERNODE : { set_cpus_allowed_ptr ( task , cpumask_of_node ( node ) ) ; break ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int gost2814789_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t inl ) { size_t i , bl ; bl = ctx -> cipher -> block_size ; inl -= bl ; for ( i = 0 ; i <= inl ; i += bl ) { Gost2814789_ecb_encrypt ( in + i , out + i , & ( ( EVP_GOST2814789_CTX * ) ctx -> cipher_data ) -> ks , ctx -> encrypt ) ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "const struct cvb_table * tegra_cvb_add_opp_table ( struct device * dev , const struct cvb_table * tables , size_t count , int process_id , int speedo_id , int speedo_value , unsigned long max_freq ) { size_t i ; int ret ; for ( i = 0 ; i < count ; i ++ ) { const struct cvb_table * table = & tables [ i ] ; if ( table -> process_id != - 1 && table -> process_id != process_id ) { continue ; } ret = build_opp_table ( dev , table , speedo_value , max_freq ) ; return ret ?ERR_PTR ( ret ) : table ; } return ERR_PTR ( - EINVAL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static long cfset_ioctl_start ( unsigned long arg , struct file * file ) { struct s390_ctrset_start __user * ustart ; struct s390_ctrset_start start ; struct cfset_request * preq ; void __user * umask ; unsigned int len ; int ret = 0 ; size_t need ; if ( file -> private_data ) { return - EBUSY ; } ustart = ( s390_ctrset_start __user * ) arg ; if ( copy_from_user ( & start , ustart , sizeof ( start ) ) ) { return - EFAULT ; } if ( start . version != S390_HWCTR_START_VERSION ) { return - EINVAL ; } if ( start . counter_sets & ~ ( cpumf_ctr_ctl [ CPUMF_CTR_SET_BASIC ] | cpumf_ctr_ctl [ CPUMF_CTR_SET_USER ] | cpumf_ctr_ctl [ CPUMF_CTR_SET_CRYPTO ] | cpumf_ctr_ctl [ CPUMF_CTR_SET_EXT ] | cpumf_ctr_ctl [ CPUMF_CTR_SET_MT_DIAG ] ) ) { return - EINVAL ; } if ( ! start . counter_sets ) { return - EINVAL ; } preq = kzalloc ( sizeof ( * preq ) , GFP_KERNEL ) ; if ( ! preq ) { return - ENOMEM ; } cpumask_clear ( & preq -> mask ) ; len = min_t ( u64 , start . cpumask_len , cpumask_size ( ) ) ; umask = ( void __user * ) start . cpumask ; if ( copy_from_user ( & preq -> mask , umask , len ) ) { return - EFAULT ; } if ( cpumask_empty ( & preq -> mask ) ) { kfree ( preq ) ; return - EINVAL ; } need = cfset_needspace ( start . counter_sets ) ; if ( put_user ( need , & ustart -> data_bytes ) ) { kfree ( preq ) ; return - EFAULT ; } preq -> ctrset = start . counter_sets ; ret = cfset_all_start ( preq ) ; if ( ! ret ) { cfset_session_add ( preq ) ; file -> private_data = preq ; debug_sprintf_event ( cf_dbg , 4 , \"%s set %#lx need %ld ret %d\\n\" , __func__ , preq -> ctrset , need , ret ) ; } else { kfree ( preq ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int st_uvis25_set_enable ( struct st_uvis25_hw * hw , bool enable ) { int err ; err = regmap_update_bits ( hw -> regmap , ST_UVIS25_REG_CTRL1_ADDR , ST_UVIS25_REG_ODR_MASK , enable ) ; hw -> enabled = enable ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void px_ib_delete_ino_pil ( px_ib_t * ib_p , px_ino_pil_t * ipil_p ) { px_ino_t * ino_p = ipil_p -> ipil_ino_p ; ushort_t pil = ipil_p -> ipil_pil ; px_ino_pil_t * prev , * next ; ASSERT ( MUTEX_HELD ( & ib_p -> ib_ino_lst_mutex ) ) ; if ( ino_p -> ino_ipil_p == ipil_p ) { ino_p -> ino_ipil_p = ipil_p -> ipil_next_p ; } else { for ( prev = next = ino_p -> ino_ipil_p ; next != ipil_p ; prev = next , next = next -> ipil_next_p ) { } if ( prev ) { prev -> ipil_next_p = ipil_p -> ipil_next_p ; } } kmem_free ( ipil_p , sizeof ( px_ino_pil_t ) ) ; if ( ( -- ino_p -> ino_ipil_size ) && ( ino_p -> ino_lopil == pil ) ) { for ( next = ino_p -> ino_ipil_p , pil = next -> ipil_pil ; next ; next = next -> ipil_next_p ) { if ( pil > next -> ipil_pil ) { pil = next -> ipil_pil ; } } ino_p -> ino_lopil = pil ; } ino_p -> ino_lopil = 0 ; if ( ino_p -> ino_msiq_p ) { return ; } if ( ib_p -> ib_ino_lst == ino_p ) { ib_p -> ib_ino_lst = ino_p -> ino_next_p ; } else { px_ino_t * list = ib_p -> ib_ino_lst ; for ( ; list -> ino_next_p != ino_p ; list = list -> ino_next_p ) { } list -> ino_next_p = ino_p -> ino_next_p ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int virDomainObjInitJob ( virDomainJobObj * job , virDomainObjPrivateJobCallbacks * cb , virDomainJobDataPrivateDataCallbacks * jobDataPrivateCb ) { job -> cb = g_memdup ( cb , sizeof ( * cb ) ) ; job -> jobDataPrivateCb = g_memdup ( jobDataPrivateCb , sizeof ( * jobDataPrivateCb ) ) ; if ( virCondInit ( & job -> cond ) < 0 ) { return - 1 ; } if ( virCondInit ( & job -> asyncCond ) < 0 ) { virCondDestroy ( & job -> cond ) ; return - 1 ; } if ( job -> cb && job -> cb -> allocJobPrivate && ! ( job -> privateData = job -> cb -> allocJobPrivate ( ) ) ) { virCondDestroy ( & job -> cond ) ; virCondDestroy ( & job -> asyncCond ) ; return - 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct drm_plane_state * atmel_hlcdc_plane_atomic_duplicate_state ( struct drm_plane * p ) { struct atmel_hlcdc_plane_state * state = drm_plane_state_to_atmel_hlcdc_plane_state ( p -> state ) ; struct atmel_hlcdc_plane_state * copy ; copy = kmemdup ( state , sizeof ( * state ) , GFP_KERNEL ) ; if ( ! copy ) { return in ; } if ( atmel_hlcdc_plane_alloc_dscrs ( p , copy ) ) { kfree ( copy ) ; return NULL ; } if ( copy -> base . fb ) { drm_framebuffer_get ( copy -> base . fb ) ; } return & copy -> base ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mtk_pinconf_adv_pull_set ( struct mtk_pinctrl * hw , const struct mtk_pin_desc * desc , bool pullup , u32 arg ) { int err ; err = mtk_hw_set_value ( hw , desc , PINCTRL_PIN_REG_R0 , arg & 1 ) ; err = mtk_hw_set_value ( hw , desc , PINCTRL_PIN_REG_R1 , ! ! ( arg & 2 ) ) ; if ( err ) { return 0 ; } arg = pullup ?0 : 1 ; err = mtk_hw_set_value ( hw , desc , PINCTRL_PIN_REG_PUPD , arg ) ; if ( err == - ENOTSUPP ) { if ( hw -> soc -> bias_set ) { err = hw -> soc -> bias_set ( hw , desc , pullup ) ; if ( err ) { return err ; } } else { err = mtk_pinconf_bias_set_rev1 ( hw , desc , pullup ) ; if ( err ) { err = mtk_pinconf_bias_set ( hw , desc , pullup ) ; } } } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hi847_set_stream ( struct v4l2_subdev * sd , int enable ) { struct hi847 * hi847 = to_hi847 ( sd ) ; struct i2c_client * client = v4l2_get_subdevdata ( sd ) ; int ret = 0 ; if ( hi847 -> streaming == enable ) { return 0 ; } if ( enable ) { ret = pm_runtime_get_sync ( & client -> dev ) ; if ( ret < 0 ) { pm_runtime_put_noidle ( & client -> dev ) ; mutex_unlock ( & hi847 -> mutex ) ; return ret ; } ret = hi847_start_streaming ( hi847 ) ; if ( ret ) { enable = 0 ; hi847_stop_streaming ( hi847 ) ; pm_runtime_put ( & client -> dev ) ; } } else { hi847_stop_streaming ( hi847 ) ; pm_runtime_put ( & client -> dev ) ; } hi847 -> streaming = enable ; mutex_unlock ( & hi847 -> mutex ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void cpu_loop ( CPUSPARCState * env ) { CPUState * cs = env_cpu ( env ) ; int trapnr ; abi_long ret ; while ( 1 ) { cpu_exec_start ( cs ) ; trapnr = cpu_exec ( cs ) ; cpu_exec_end ( cs ) ; process_queued_cpu_work ( cs , NULL ) ; if ( env -> cc_op != CC_OP_FLAGS ) { cpu_get_psr ( env ) ; } switch ( trapnr ) { case 0x88 : case 0x90 : case 0x110 : case 0x16d : ret = do_syscall ( env , env -> gregs [ 1 ] , env -> regwptr [ 0 ] , env -> regwptr [ 1 ] , env -> regwptr [ 2 ] , env -> regwptr [ 3 ] , env -> regwptr [ 4 ] , env -> regwptr [ 5 ] , 0 , 0 ) ; if ( ret == - QEMU_ERESTARTSYS || ret == - QEMU_ESIGRETURN ) { break ; } if ( ( abi_ulong ) ret >= ( abi_ulong ) ( - 515 ) ) { env -> xcc |= PSR_CARRY ; env -> psr |= PSR_CARRY ; ret = - ret ; } else { env -> xcc &= ~ PSR_CARRY ; env -> psr &= ~ PSR_CARRY ; } env -> regwptr [ 0 ] = ret ; env -> pc = env -> npc ; env -> npc = env -> npc + 4 ; break ; case 0x83 : case 0x103 : flush_windows ( env ) ; env -> pc = env -> npc ; env -> npc = env -> npc + 4 ; break ; case TT_WIN_OVF : save_window ( env ) ; break ; case TT_WIN_UNF : restore_window ( env ) ; break ; case TT_SPILL : save_window ( env ) ; break ; case TT_FILL : restore_window ( env ) ; break ; case 0x16e : flush_windows ( env ) ; sparc64_get_context ( env ) ; break ; case 0x16f : flush_windows ( env ) ; sparc64_set_context ( env ) ; break ; case EXCP_INTERRUPT : break ; case TT_ILL_INSN : force_sig_fault ( TARGET_SIGILL , TARGET_ILL_ILLOPC , env -> pc ) ; break ; case EXCP_DEBUG : force_sig_fault ( TARGET_SIGTRAP , TARGET_TRAP_BRKPT , env -> pc ) ; break ; case EXCP_ATOMIC : cpu_exec_step_atomic ( cs ) ; break ; default : fprintf ( stderr , \"Unhandled trap: 0x%x\\n\" , trapnr ) ; cpu_dump_state ( cs , stderr , 0 ) ; exit ( EXIT_FAILURE ) ; } process_pending_signals ( env ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int module_callback ( void * cbdata , int socktype , struct sockaddr * sa ) { struct module_callback_data * d = cbdata ; size_t addrlen ; k5_transport transport ; if ( sa -> sa_family == AF_INET ) { addrlen = sizeof ( sockaddr_in ) ; } if ( sa -> sa_family == AF_INET6 ) { addrlen = sizeof ( sockaddr_in6 ) ; } else { return 0 ; } transport = ( socktype == SOCK_STREAM ) ?TCP : UDP ; if ( add_addr_to_list ( d -> list , transport , sa -> sa_family , addrlen , sa ) != 0 ) { d -> out_of_mem = 1 ; return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t viafb_vt1636_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char buf [ 30 ] , * value , * pbuf ; struct IODATA reg_val ; unsigned long length , i ; length = count > 30 ?30 : count ; if ( copy_from_user ( & buf [ 0 ] , buffer , length ) ) { return - EFAULT ; } buf [ length - 1 ] = '\\0' ; pbuf = & buf [ 0 ] ; switch ( viaparinfo -> chip_info -> lvds_chip_info . lvds_chip_name ) { case VT1636_LVDS : for ( i = 0 ; i < 2 ; i ++ ) { value = strsep ( & pbuf , \" \" ) ; if ( value != NULL ) { if ( kstrtou8 ( value , 0 , & reg_val . Data ) < 0 ) { return - EINVAL ; } switch ( i ) { case 0 : reg_val . Index = 0x08 ; reg_val . Mask = 0x0f ; viafb_gpio_i2c_write_mask_lvds ( viaparinfo -> lvds_setting_info , & viaparinfo -> chip_info -> lvds_chip_info , reg_val ) ; break ; case 1 : reg_val . Index = 0x09 ; reg_val . Mask = 0x1f ; viafb_gpio_i2c_write_mask_lvds ( viaparinfo -> lvds_setting_info , & viaparinfo -> chip_info -> lvds_chip_info , reg_val ) ; break ; default : break ; } } else { break ; } } break ; default : break ; } switch ( viaparinfo -> chip_info -> lvds_chip_info2 . lvds_chip_name ) { case VT1636_LVDS : for ( i = 0 ; i < 2 ; i ++ ) { value = strsep ( & pbuf , \" \" ) ; if ( value != NULL ) { if ( kstrtou8 ( value , 0 , & reg_val . Data ) < 0 ) { return - EINVAL ; } switch ( i ) { case 0 : reg_val . Index = 0x08 ; reg_val . Mask = 0x0f ; viafb_gpio_i2c_write_mask_lvds ( viaparinfo -> lvds_setting_info2 , & viaparinfo -> chip_info -> lvds_chip_info2 , reg_val ) ; break ; case 1 : reg_val . Index = 0x09 ; reg_val . Mask = 0x1f ; viafb_gpio_i2c_write_mask_lvds ( viaparinfo -> lvds_setting_info2 , & viaparinfo -> chip_info -> lvds_chip_info2 , reg_val ) ; break ; default : break ; } } else { break ; } } break ; default : break ; } return count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void dc_producer_end_signal ( Producer * producer , CircularBuffer * circular_buf ) { Node * node = & circular_buf -> list [ producer -> idx ] ; gf_mx_p ( node -> mutex , NULL ) ; node -> marked = 2 ; gf_sema_notify ( node -> consumers_semaphore , node -> num_consumers_waiting ) ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_DASH , ( \"producer %s sends end signal %d \\n\" , producer -> name , producer -> idx ) ) ; gf_mx_v ( node -> mutex ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "__weak __alias ( \"sw_crypto_acipher_rsassa_verify\" ) ; TEE_Result sw_crypto_acipher_rsassa_verify ( uint32_t algo , struct rsa_public_key * key , int salt_len , const uint8_t * msg , size_t msg_len , const uint8_t * sig , size_t sig_len ) { TEE_Result res ; uint32_t bigint_size ; int hash_size ; int stat , ltc_hashindex , ltc_res , ltc_rsa_algo ; rsa_key ltc_key = { . type = PK_PUBLIC . e = key -> e . N = key -> n } ; struct ftmn ftmn = { } ; FTMN_CALLEE_SWAP_HASH ( FTMN_FUNC_HASH ( \"crypto_acipher_rsassa_verify\" ) ) ; if ( algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { res = tee_alg_get_digest_size ( TEE_DIGEST_HASH_TO_ALGO ( algo ) , & hash_size ) ; if ( res != TEE_SUCCESS ) { err } if ( msg_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; err } } bigint_size = ltc_mp . unsigned_size ( ltc_key . N ) ; if ( sig_len < bigint_size ) { res = TEE_ERROR_SIGNATURE_INVALID ; err } if ( algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { res = tee_algo_to_ltc_hashindex ( algo , & ltc_hashindex ) ; if ( res != TEE_SUCCESS ) { err } } switch ( algo ) { case TEE_ALG_RSASSA_PKCS1_V1_5 : ltc_rsa_algo = LTC_PKCS_1_V1_5_NA1 ; break ; case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : ltc_rsa_algo = LTC_PKCS_1_V1_5 ; break ; case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : ltc_rsa_algo = LTC_PKCS_1_PSS ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; err } FTMN_PUSH_LINKED_CALL ( & ftmn , FTMN_FUNC_HASH ( \"rsa_verify_hash_ex\" ) ) ; ltc_res = rsa_verify_hash_ex ( sig , sig_len , msg , msg_len , ltc_rsa_algo , ltc_hashindex , salt_len , & stat , & ltc_key ) ; res = convert_ltc_verify_status ( ltc_res , stat ) ; if ( res ) { FTMN_SET_CHECK_RES_NOT_ZERO ( & ftmn , FTMN_INCR0 , res ) ; } else { FTMN_SET_CHECK_RES_FROM_CALL ( & ftmn , FTMN_INCR0 , 0 ) ; } FTMN_POP_LINKED_CALL ( & ftmn ) ; FTMN_CALLEE_DONE_CHECK ( & ftmn , FTMN_INCR0 , FTMN_STEP_COUNT ( 1 ) , res ) ; return res ; err FTMN_CALLEE_DONE_NOT_ZERO ( res ) ; return res ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "u8 acpi_ev_is_pci_root_bridge ( struct acpi_namespace_node * node ) { acpi_status status ; struct acpi_pnp_device_id * hid ; struct acpi_pnp_device_id_list * cid ; u32 i ; u8 match ; status = acpi_ut_execute_HID ( node , & hid ) ; if ( ACPI_FAILURE ( status ) ) { return ( FALSE ) ; } match = acpi_ut_is_pci_root_bridge ( hid -> string ) ; ACPI_FREE ( hid , NULL ) ; if ( match ) { return ( TRUE ) ; } status = acpi_ut_execute_CID ( node , & cid ) ; if ( ACPI_FAILURE ( status ) ) { return ( FALSE ) ; } for ( i = 0 ; i < cid -> count ; i ++ ) { if ( acpi_ut_is_pci_root_bridge ( cid -> ids [ i ] . string ) ) { ACPI_FREE ( cid ) ; return ( TRUE ) ; } } ACPI_FREE ( cid ) ; return ( FALSE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MODULE_DEVICE_TABLE ( of , mmp_tdma_dt_ids ) ; static int mmp_tdma_probe ( struct platform_device * pdev ) { enum mmp_tdma_type type ; const struct of_device_id * of_id ; struct mmp_tdma_device * tdev ; int i , ret ; int irq = 0 , irq_num = 0 ; int chan_num = TDMA_CHANNEL_NUM ; struct gen_pool * pool = NULL ; of_id = of_match_device ( mmp_tdma_dt_ids , & pdev -> dev ) ; if ( of_id ) { type = ( mmp_tdma_type ) of_id -> data ; } else { type = platform_get_device_id ( pdev ) -> driver_data ; } tdev = devm_kzalloc ( & pdev -> dev , sizeof ( * tdev ) , GFP_KERNEL ) ; tdev -> dev = & pdev -> dev ; for ( i = 0 ; i < chan_num ; i ++ ) { if ( platform_get_irq ( pdev , i ) > 0 ) { irq_num ++ ; } } tdev -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( tdev -> base ) ) { return PTR_ERR ( tdev -> base ) ; } INIT_LIST_HEAD ( & tdev -> device . channels ) ; pool = of_gen_pool_get ( pdev -> dev . of_node , \"asram\" , 0 ) ; if ( ! pool ) { dev_err ( & pdev -> dev , \"asram pool not available\\n\" ) ; return - ENOMEM ; } if ( irq_num != chan_num ) { irq = platform_get_irq ( pdev , 0 ) ; ret = devm_request_irq ( & pdev -> dev , irq , mmp_tdma_int_handler , IRQF_SHARED , \"tdma\" , tdev ) ; if ( ret ) { return ret ; } } for ( i = 0 ; i < chan_num ; i ++ ) { irq = ( irq_num != chan_num ) ?0 : platform_get_irq ( pdev , i ) ; ret = mmp_tdma_chan_init ( tdev , i , irq , type , pool ) ; if ( ret ) { return ret ; } } dma_cap_set ( DMA_SLAVE , tdev -> device . cap_mask ) ; dma_cap_set ( DMA_CYCLIC , tdev -> device . cap_mask ) ; tdev -> device . dev = & pdev -> dev ; tdev -> device . device_alloc_chan_resources = mmp_tdma_alloc_chan_resources ; tdev -> device . device_free_chan_resources = mmp_tdma_free_chan_resources ; tdev -> device . device_prep_dma_cyclic = mmp_tdma_prep_dma_cyclic ; tdev -> device . device_tx_status = mmp_tdma_tx_status ; tdev -> device . device_issue_pending = mmp_tdma_issue_pending ; tdev -> device . device_config = mmp_tdma_config ; tdev -> device . device_pause = mmp_tdma_pause_chan ; tdev -> device . device_resume = mmp_tdma_resume_chan ; tdev -> device . device_terminate_all = mmp_tdma_terminate_all ; tdev -> device . copy_align = DMAENGINE_ALIGN_8_BYTES ; tdev -> device . directions = BIT ( DMA_DEV_TO_MEM ) | BIT ( DMA_MEM_TO_DEV ) ; if ( type == MMP_AUD_TDMA ) { tdev -> device . max_burst = SZ_128 ; tdev -> device . src_addr_widths = BIT ( DMA_SLAVE_BUSWIDTH_4_BYTES ) ; tdev -> device . dst_addr_widths = BIT ( DMA_SLAVE_BUSWIDTH_4_BYTES ) ; } if ( type == PXA910_SQU ) { tdev -> device . max_burst = SZ_32 ; } tdev -> device . residue_granularity = DMA_RESIDUE_GRANULARITY_BURST ; tdev -> device . descriptor_reuse = true ; dma_set_mask ( & pdev -> dev , DMA_BIT_MASK ( 64 ) ) ; platform_set_drvdata ( pdev , tdev ) ; ret = dmaenginem_async_device_register ( & tdev -> device ) ; if ( ret ) { dev_err ( tdev -> device . dev , \"unable to register\\n\" ) ; return ret ; } if ( pdev -> dev . of_node ) { ret = of_dma_controller_register ( pdev -> dev . of_node , mmp_tdma_xlate , tdev ) ; if ( ret ) { dev_err ( tdev -> device . dev , \"failed to register controller\\n\" ) ; return ret ; } } dev_info ( tdev -> device . dev , \"initialized\\n\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void irq_process_pending_llist ( struct idxd_irq_entry * irq_entry ) { struct idxd_desc * desc , * t ; struct llist_node * head ; head = llist_del_all ( & irq_entry -> pending_llist ) ; llist_for_each_entry_safe ( , , , ) { u8 status = desc -> completion -> status & DSA_COMP_STATUS_MASK ; if ( status ) { if ( unlikely ( desc -> completion -> status == IDXD_COMP_DESC_ABORT ) ) { idxd_dma_complete_txd ( desc , IDXD_COMPLETE_ABORT , true ) ; continue ; } idxd_dma_complete_txd ( desc , IDXD_COMPLETE_NORMAL , true ) ; } else { spin_lock ( & irq_entry -> list_lock ) ; list_add_tail ( & desc -> list , & irq_entry -> work_list ) ; spin_unlock ( & irq_entry -> list_lock ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void BVChangeBC ( BitmapView * bv , BDFChar * bc , int fitit ) { char * title ; char buf [ 300 ] ; BVUnlinkView ( bv ) ; bv -> bc = bc ; bv -> next = bc -> views ; bc -> views = bv ; if ( fitit ) { BVFit ( bv ) ; } else { BVNewScale ( bv ) ; } BVRefreshImage ( bv ) ; title = BVMakeTitles ( bv , bc , buf ) ; GDrawSetWindowTitles8 ( bv -> gw , buf , title ) ; BVPaletteChangedChar ( bv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void lov_io_sub_inherit ( struct cl_io * io , struct lov_io * lio , int stripe , loff_t start , loff_t end ) { struct lov_stripe_md * lsm = lio -> lis_object -> lo_lsm ; struct cl_io * parent = lio -> lis_cl . cis_io ; switch ( io -> ci_type ) { case CIT_SETATTR : { io -> u . ci_setattr . sa_attr = parent -> u . ci_setattr . sa_attr ; io -> u . ci_setattr . sa_attr_flags = parent -> u . ci_setattr . sa_attr_flags ; io -> u . ci_setattr . sa_valid = parent -> u . ci_setattr . sa_valid ; io -> u . ci_setattr . sa_stripe_index = stripe ; io -> u . ci_setattr . sa_parent_fid = parent -> u . ci_setattr . sa_parent_fid ; if ( cl_io_is_trunc ( io ) ) { loff_t new_size = parent -> u . ci_setattr . sa_attr . lvb_size ; new_size = lov_size_to_stripe ( lsm , new_size , stripe ) ; io -> u . ci_setattr . sa_attr . lvb_size = new_size ; } break ; } case CIT_DATA_VERSION : { io -> u . ci_data_version . dv_data_version = 0 ; io -> u . ci_data_version . dv_flags = parent -> u . ci_data_version . dv_flags ; break ; } case CIT_FAULT : { struct cl_object * obj = parent -> ci_obj ; loff_t off = cl_offset ( obj , parent -> u . ci_fault . ft_index ) ; io -> u . ci_fault = parent -> u . ci_fault ; off = lov_size_to_stripe ( lsm , off , stripe ) ; io -> u . ci_fault . ft_index = cl_index ( obj , off ) ; break ; } case CIT_FSYNC : { io -> u . ci_fsync . fi_start = start ; io -> u . ci_fsync . fi_end = end ; io -> u . ci_fsync . fi_fid = parent -> u . ci_fsync . fi_fid ; io -> u . ci_fsync . fi_mode = parent -> u . ci_fsync . fi_mode ; break ; } case CIT_READ : case CIT_WRITE : { io -> u . ci_wr . wr_sync = cl_io_is_sync_write ( parent , NULL ) ; if ( cl_io_is_append ( parent ) ) { io -> u . ci_wr . wr_append = 1 ; } else { io -> u . ci_rw . crw_pos = start ; io -> u . ci_rw . crw_count = end - start ; } break ; } default : break ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int em28xx_ir_resume ( struct em28xx * dev ) { struct em28xx_IR * ir = dev -> ir ; dev_info ( & dev -> intf -> dev , \"Resuming input extension\\n\" ) ; if ( ir ) { schedule_delayed_work ( & ir -> work , msecs_to_jiffies ( ir -> polling ) ) ; } if ( dev -> num_button_polling_addresses ) { schedule_delayed_work ( & dev -> buttons_query_work , msecs_to_jiffies ( dev -> button_polling_interval ) ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ksr_kxlibssl_seed ( const void * buf , int num ) { ksr_kxlibssl_init ( ) ; if ( _ksr_kxlibssl_local_lock == 0 || _ksr_kxlibssl_local_method == 0 ) { return ; } lock_get ( _ksr_kxlibssl_local_lock ) ; _ksr_kxlibssl_local_method -> seed ( buf , num ) ; lock_release ( _ksr_kxlibssl_local_lock ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rsu_check_complete ( struct m10bmc_sec * sec , u32 * doorbell_reg ) { u32 progress , status ; if ( m10bmc_sec_progress_status ( sec , doorbell_reg , & progress , & status ) ) { return - EIO ; } if ( ! rsu_status_ok ( status ) ) { return - EINVAL ; } if ( rsu_progress_busy ( progress ) ) { return - EAGAIN ; } return - EINVAL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void long_everything1 ( void ) { struct MsgBuf msgbuf ; strcpy ( tmp , \"@tag0=value0;tag1=value1;tag2=value2;tag3=value3;tag4=value4;tag5=value5;tag6=value6;tag7=value7;tag8=value8;tag9=value9;tag10=value10;tag11=value11;tag12=value12;tag13=value13;tag14=\" ) ; strcat ( tmp , MKTEXT ( 328 ) ) ; strcat ( tmp , \" PRIVMSG #test A B C D E F G H I J K L \" ) ; strcat ( tmp , MKTEXT ( 472 ) ) ; is_int ( 512 + 510 , strlen ( tmp ) , MSG ) ; if ( is_int ( 0 , msgbuf_parse ( & msgbuf , tmp ) , MSG ) ) { if ( is_int ( 15 , msgbuf . n_tags , MSG ) ) { is_string ( \"tag0\" , msgbuf . tags [ 0 ] . key , MSG ) ; is_string ( \"value0\" , msgbuf . tags [ 0 ] . value , MSG ) ; is_string ( \"tag1\" , msgbuf . tags [ 1 ] . key , MSG ) ; is_string ( \"value1\" , msgbuf . tags [ 1 ] . value , MSG ) ; is_string ( \"tag2\" , msgbuf . tags [ 2 ] . key , MSG ) ; is_string ( \"value2\" , msgbuf . tags [ 2 ] . value , MSG ) ; is_string ( \"tag3\" , msgbuf . tags [ 3 ] . key , MSG ) ; is_string ( \"value3\" , msgbuf . tags [ 3 ] . value , MSG ) ; is_string ( \"tag4\" , msgbuf . tags [ 4 ] . key , MSG ) ; is_string ( \"value4\" , msgbuf . tags [ 4 ] . value , MSG ) ; is_string ( \"tag5\" , msgbuf . tags [ 5 ] . key , MSG ) ; is_string ( \"value5\" , msgbuf . tags [ 5 ] . value , MSG ) ; is_string ( \"tag6\" , msgbuf . tags [ 6 ] . key , MSG ) ; is_string ( \"value6\" , msgbuf . tags [ 6 ] . value , MSG ) ; is_string ( \"tag7\" , msgbuf . tags [ 7 ] . key , MSG ) ; is_string ( \"value7\" , msgbuf . tags [ 7 ] . value , MSG ) ; is_string ( \"tag8\" , msgbuf . tags [ 8 ] . key , MSG ) ; is_string ( \"value8\" , msgbuf . tags [ 8 ] . value , MSG ) ; is_string ( \"tag9\" , msgbuf . tags [ 9 ] . key , MSG ) ; is_string ( \"value9\" , msgbuf . tags [ 9 ] . value , MSG ) ; is_string ( \"tag10\" , msgbuf . tags [ 10 ] . key , MSG ) ; is_string ( \"value10\" , msgbuf . tags [ 10 ] . value , MSG ) ; is_string ( \"tag11\" , msgbuf . tags [ 11 ] . key , MSG ) ; is_string ( \"value11\" , msgbuf . tags [ 11 ] . value , MSG ) ; is_string ( \"tag12\" , msgbuf . tags [ 12 ] . key , MSG ) ; is_string ( \"value12\" , msgbuf . tags [ 12 ] . value , MSG ) ; is_string ( \"tag13\" , msgbuf . tags [ 13 ] . key , MSG ) ; is_string ( \"value13\" , msgbuf . tags [ 13 ] . value , MSG ) ; is_string ( \"tag14\" , msgbuf . tags [ 14 ] . key , MSG ) ; is_string ( MKTEXT ( 328 ) , msgbuf . tags [ 14 ] . value , MSG ) ; } is_string ( \"PRIVMSG\" , msgbuf . cmd , MSG ) ; if ( is_int ( 15 , msgbuf . n_para , MSG ) ) { is_string ( \"PRIVMSG\" , msgbuf . para [ 0 ] , MSG ) ; is_string ( \"#test\" , msgbuf . para [ 1 ] , MSG ) ; is_string ( \"A\" , msgbuf . para [ 2 ] , MSG ) ; is_string ( \"B\" , msgbuf . para [ 3 ] , MSG ) ; is_string ( \"C\" , msgbuf . para [ 4 ] , MSG ) ; is_string ( \"D\" , msgbuf . para [ 5 ] , MSG ) ; is_string ( \"E\" , msgbuf . para [ 6 ] , MSG ) ; is_string ( \"F\" , msgbuf . para [ 7 ] , MSG ) ; is_string ( \"G\" , msgbuf . para [ 8 ] , MSG ) ; is_string ( \"H\" , msgbuf . para [ 9 ] , MSG ) ; is_string ( \"I\" , msgbuf . para [ 10 ] , MSG ) ; is_string ( \"J\" , msgbuf . para [ 11 ] , MSG ) ; is_string ( \"K\" , msgbuf . para [ 12 ] , MSG ) ; is_string ( \"L\" , msgbuf . para [ 13 ] , MSG ) ; is_string ( MKTEXT ( 472 ) , msgbuf . para [ 14 ] , MSG ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t policy_update ( int binop , const char __user * buf , size_t size , loff_t * pos , struct aa_ns * ns ) { ssize_t error ; struct aa_loaddata * data ; struct aa_profile * profile = aa_current_profile ( ) ; const char * op = binop == PROF_ADD ?OP_PROF_LOAD : OP_PROF_REPL ; error = aa_may_manage_policy ( profile , ns , op ) ; data = aa_simple_write_to_buffer ( buf , size , size , pos ) ; error = PTR_ERR ( data ) ; if ( ! IS_ERR ( data ) ) { error = aa_replace_profiles ( ns ?ns : profile -> ns , profile , binop , data ) ; aa_put_loaddata ( data ) ; } return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int psc_ac97_of_remove ( struct platform_device * op ) { mpc5200_audio_dma_destroy ( op ) ; snd_soc_unregister_component ( & op -> dev ) ; snd_soc_set_ac97_ops ( NULL , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int intel_tcc_set_offset ( int cpu , int offset ) { u32 low , high ; int err ; if ( offset ( 0 || offset ) 0x3f ) { return - EINVAL ; } if ( cpu < 0 ) { err = rdmsr_safe ( MSR_IA32_TEMPERATURE_TARGET , & low , & high ) ; } else { err = rdmsr_safe_on_cpu ( cpu , MSR_IA32_TEMPERATURE_TARGET , & low , & high ) ; } if ( low & BIT ( 31 ) ) { return - EPERM ; } low &= ~ ( 0x3f << 24 ) ; low |= offset << 24 ; if ( cpu < 0 ) { return wrmsr_safe ( MSR_IA32_TEMPERATURE_TARGET , low , high ) ; } else { return wrmsr_safe_on_cpu ( cpu , MSR_IA32_TEMPERATURE_TARGET , low , high ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * cconvert ( char * string ) { register int c ; register char * retptr = retbuffer ; retbuffer [ 0 ] = '\\0' ; while ( c = * string ++ ) { c &= 0377 ; if ( c >= 0200 ) { ( void ) sprintf ( retptr , \"\\\\%.3o\" , c ) ; retptr += 4 ; } if ( c == '\\033' ) { ( void ) sprintf ( retptr , \"\\\\E\" ) ; retptr += 2 ; } if ( c == '\\t' ) { ( void ) sprintf ( retptr , \"\\\\t\" ) ; retptr += 2 ; } if ( c == '\\b' ) { ( void ) sprintf ( retptr , \"\\\\b\" ) ; retptr += 2 ; } if ( c == '\\f' ) { ( void ) sprintf ( retptr , \"\\\\f\" ) ; retptr += 2 ; } if ( c == '\\n' ) { ( void ) sprintf ( retptr , \"\\\\n\" ) ; retptr += 2 ; } if ( c == '\\r' ) { ( void ) sprintf ( retptr , \"\\\\r\" ) ; retptr += 2 ; } if ( c == ':' ) { ( void ) sprintf ( retptr , \"\\\\072\" ) ; retptr += 4 ; } if ( c == '^' ) { ( void ) sprintf ( retptr , \"\\\\^\" ) ; retptr += 2 ; } if ( c == BACKSLASH ) { ( void ) sprintf ( retptr , BACKBACK ) ; retptr += 2 ; } if ( c < ' ' || c == 0177 ) { ( void ) sprintf ( retptr , \"^%c\" , c ^ 0100 ) ; retptr += 2 ; } else { ( void ) sprintf ( retptr , \"%c\" , c ) ; retptr ++ ; } } * retptr = '\\0' ; return ( retbuffer ) ; } char * cexpand ( char * str ) { char padbuffer [ 512 ] ; char * retptr ; retptr = rmpadding ( str , padbuffer , ( int * ) 0 ) ; ( void ) sprintf ( ret2buffer , \"%s%s\" , padbuffer , cconvert ( retptr ) ) ; return ( ret2buffer ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ParseDefinitionsAndWriteOutput ( void ) { char new_prefix [ 64 ] ; char * second_underscore = NULL ; char type [ 1000 ] ; char name [ 1000 ] ; char value [ 1000 ] ; char extra [ 1000 ] ; char line_in [ MAX_LINE_SIZE ] ; int pending = FALSE ; int prefix_len = 0 ; while ( ! feof ( f_dwarf_in ) ) { char * fgbad = 0 ; errno = 0 ; fgbad = fgets ( line_in , sizeof ( line_in ) , f_dwarf_in ) ; if ( ! fgbad ) { if ( feof ( f_dwarf_in ) ) { break ; } fprintf ( stderr , \"Error reading dwarf.h!. Errno %d\\n\" , errno ) ; exit ( 1 ) ; } if ( is_skippable_line ( line_in ) ) { continue ; } sscanf ( line_in , \"%s %s %s %s\" , type , name , value , extra ) ; if ( strcmp ( type , \"#define\" ) || strncmp ( name , prefix_root , prefix_root_len ) ) { continue ; } second_underscore = strchr ( name + prefix_root_len , '_' ) ; prefix_len = ( int ) ( second_underscore - name ) ; safe_strncpy ( new_prefix , sizeof ( new_prefix ) , name , prefix_len ) ; new_prefix [ prefix_len ] = 0 ; if ( strcmp ( prefix , new_prefix ) ) { if ( pending ) { GenerateOneSet ( ) ; } pending = TRUE ; strcpy ( prefix , new_prefix ) ; } if ( array_count >= ARRAY_SIZE ) { printf ( \"Too many entries for current group_array size of %d\" , ARRAY_SIZE ) ; exit ( 1 ) ; } ++ second_underscore ; { cfs_time_t v = strtoul ( value , NULL , 16 ) ; if ( strlen ( second_underscore ) >= MAX_NAME_LEN ) { printf ( \"Too long a name %s for max len %d\\n\" , second_underscore , MAX_NAME_LEN ) ; exit ( 1 ) ; } strcpy ( group_array [ array_count ] . name , second_underscore ) ; group_array [ array_count ] . value = v ; group_array [ array_count ] . original_position = array_count ; ++ array_count ; } } if ( pending ) { GenerateOneSet ( ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int isci_suspend ( struct device * dev ) { struct pci_dev * pdev = to_pci_dev ( dev ) ; struct isci_host * ihost ; int i ; for_each_isci_host ( , , ) { sas_suspend_ha ( & ihost -> sas_ha ) ; isci_host_deinit ( ihost , NULL ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int xfrm4_mode_tunnel_input ( struct xfrm_state * x , struct sk_buff * skb ) { int err = - EINVAL ; if ( XFRM_MODE_SKB_CB ( skb ) -> protocol != IPPROTO_IPIP ) { out } if ( ! pskb_may_pull ( skb , sizeof ( iphdr ) ) ) { out } err = skb_unclone ( skb , GFP_ATOMIC ) ; if ( err ) { out } if ( x -> props . flags & XFRM_STATE_DECAP_DSCP ) { ipv4_copy_dscp ( XFRM_MODE_SKB_CB ( skb ) -> tos , ipip_hdr ( skb ) ) ; } if ( ! ( x -> props . flags & XFRM_STATE_NOECN ) ) { ipip_ecn_decapsulate ( skb ) ; } skb_reset_network_header ( skb ) ; skb_mac_header_rebuild ( skb , NULL ) ; err = 0 ; out return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "Char * dcanon ( Char * cp , Char * p ) { Char * sp ; Char * p1 , * p2 ; bool slash ; Char link [ PATH_MAX ] ; char tlink [ PATH_MAX ] ; int cc ; Char * newcp ; if ( * cp != '/' ) { Char tmpdir [ PATH_MAX ] ; p1 = value ( STRcwd ) ; if ( p1 == NULL || * p1 != '/' ) { abort ( ) ; } if ( Strlen ( p1 ) + Strlen ( cp ) + 1 >= PATH_MAX ) { abort ( ) ; } ( void ) Strlcpy ( tmpdir , p1 , sizeof tmpdir / sizeof ( Char ) ) ; ( void ) Strlcat ( tmpdir , STRslash , sizeof tmpdir / sizeof ( Char ) ) ; ( void ) Strlcat ( tmpdir , cp , sizeof tmpdir / sizeof ( Char ) ) ; cp = p = Strsave ( tmpdir ) ; } while ( * p ) { sp = p ; while ( * ++ p == '/' ) { continue ; } if ( p != ++ sp ) { for ( p1 = sp , p2 = p ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } } p = sp ; slash = 0 ; while ( * p ) { if ( * ++ p == '/' ) { slash = 1 ; * p = 0 ; break ; } } if ( * sp == '\\0' ) { if ( -- sp == cp ) { break ; } else { * sp = '\\0' ; } } if ( sp [ 0 ] == '.' && sp [ 1 ] == 0 ) { if ( slash ) { for ( p1 = sp , p2 = p + 1 ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = -- sp ; } if ( -- sp != cp ) { * sp = '\\0' ; } } if ( sp [ 0 ] == '.' && sp [ 1 ] == '.' && sp [ 2 ] == 0 ) { * -- sp = 0 ; if ( sp != cp && ! adrof ( STRignore_symlinks ) && ( cc = readlink ( short2str ( cp ) , tlink , sizeof tlink - 1 ) ) >= 0 ) { tlink [ cc ] = '\\0' ; ( void ) Strlcpy ( link , str2short ( tlink ) , sizeof link / sizeof ( Char ) ) ; if ( slash ) { * p = '/' ; } * ( p = sp ) = '/' ; for ( p1 = p ; * p1 ++ ; ) { continue ; } if ( * link != '/' ) { while ( * -- sp != '/' ) { continue ; } sp ++ ; * sp = 0 ; p1 = newcp = xreallocarray ( NULL , ( sp - cp ) + cc + ( p1 - p ) , sizeof ( Char ) ) ; for ( p2 = cp ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = link ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = p ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = sp - cp - 1 + newcp ; } else { p1 = newcp = xreallocarray ( NULL , cc + ( p1 - p ) , sizeof ( Char ) ) ; for ( p2 = link ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = p ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = newcp ; } free ( cp ) ; cp = newcp ; continue ; } * sp = '/' ; if ( sp != cp ) { while ( * -- sp != '/' ) { continue ; } } if ( slash ) { for ( p1 = sp + 1 , p2 = p + 1 ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = sp ; } if ( cp == sp ) { * ++ sp = '\\0' ; } else { * sp = '\\0' ; } } else { if ( sp != cp && adrof ( STRchase_symlinks ) && ! adrof ( STRignore_symlinks ) && ( cc = readlink ( short2str ( cp ) , tlink , sizeof tlink - 1 ) ) >= 0 ) { tlink [ cc ] = '\\0' ; ( void ) Strlcpy ( link , str2short ( tlink ) , sizeof link / sizeof ( Char ) ) ; if ( slash ) { * p = '/' ; } sp = p ; for ( p1 = p ; * p1 ++ ; ) { continue ; } if ( * link != '/' ) { while ( * -- sp != '/' ) { continue ; } sp ++ ; * sp = 0 ; p1 = newcp = xreallocarray ( NULL , ( sp - cp ) + cc + ( p1 - p ) , sizeof ( Char ) ) ; for ( p2 = cp ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = link ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = p ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = sp - cp - 1 + newcp ; } else { p1 = newcp = xreallocarray ( NULL , cc + ( p1 - p ) , sizeof ( Char ) ) ; for ( p2 = link ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } for ( p1 -- , p2 = p ; ( * p1 ++ = * p2 ++ ) != '\\0' ; ) { continue ; } p = newcp ; } free ( cp ) ; cp = newcp ; continue ; } if ( slash ) { * p = '/' ; } } } p1 = value ( STRhome ) ; cc = Strlen ( p1 ) ; if ( p1 && * p1 == '/' && ( Strncmp ( p1 , cp , cc ) != 0 || ( cp [ cc ] != '/' && cp [ cc ] != '\\0' ) ) ) { static ino_t home_ino = - 1 ; static dev_t home_dev = - 1 ; static Char * home_ptr = NULL ; struct stat statbuf ; if ( home_ptr != p1 && stat ( short2str ( p1 ) , & statbuf ) != - 1 ) { home_dev = statbuf . st_dev ; home_ino = statbuf . st_ino ; home_ptr = p1 ; } Strlcpy ( link , cp , sizeof link / sizeof ( Char ) ) ; p2 = link ; for ( sp = NULL ; * p2 && stat ( short2str ( p2 ) , & statbuf ) != - 1 ; ) { if ( statbuf . st_dev == home_dev && statbuf . st_ino == home_ino ) { sp = ( Char * ) - 1 ; break ; } if ( ( sp = Strrchr ( p2 , '/' ) ) != NULL ) { * sp = '\\0' ; } } if ( * p2 && sp == ( Char * ) - 1 ) { newcp = Strspl ( p1 , cp + Strlen ( p2 ) ) ; free ( cp ) ; cp = newcp ; } } return cp ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int board_eth_init ( struct bd_info * bis ) { uint32_t base = IMX_FEC_BASE ; struct mii_dev * bus = NULL ; struct phy_device * phydev = NULL ; int ret ; gpio_request ( WL12XX_WL_IRQ_GP , \"wifi_irq\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 30 ) , \"rgmii_rxc\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 25 ) , \"rgmii_rd0\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 27 ) , \"rgmii_rd1\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 28 ) , \"rgmii_rd2\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 29 ) , \"rgmii_rd3\" ) ; gpio_request ( IMX_GPIO_NR ( 6 , 24 ) , \"rgmii_rx_ctl\" ) ; gpio_request ( IMX_GPIO_NR ( 3 , 23 ) , \"rgmii_reset_sabrelite\" ) ; gpio_request ( IMX_GPIO_NR ( 1 , 27 ) , \"rgmii_reset_nitrogen6x\" ) ; setup_iomux_enet ( ) ; bus = fec_get_miibus ( base , - 1 ) ; if ( ! bus ) { return - EINVAL ; } phydev = phy_find_by_mask ( bus , ( 0xf << 4 ) ) ; if ( ! phydev ) { ret = - EINVAL ; free_bus } printf ( \"using phy at %d\\n\" , phydev -> addr ) ; ret = fec_probe ( bis , - 1 , base , bus , phydev ) ; if ( ret ) { free_phydev } return 0 ; free_phydev free ( phydev ) ; free_bus return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int enqueue_packet ( RTPDemuxContext * s , uint8_t * buf , int len ) { uint16_t seq = AV_RB16 ( buf + 2 ) ; RTPPacket * * cur = & s -> queue , * packet ; while ( * cur ) { int16_t diff = seq - ( * cur ) -> seq ; if ( diff < 0 ) { break ; } cur = & ( * cur ) -> next ; } packet = av_mallocz ( sizeof ( * packet ) ) ; packet -> recvtime = av_gettime_relative ( ) ; packet -> seq = seq ; packet -> len = len ; packet -> buf = buf ; packet -> next = * cur ; * cur = packet ; s -> queue_len ++ ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned int arm_cmn_get_index ( u64 x [ ] , unsigned int pos ) { return ( x [ pos / 32 ] >> ( ( pos % 32 ) * 2 ) ) & 3 ; } arm_cmn_event_attr { struct device_attribute attr ; enum cmn_model model ; enum cmn_node_type type ; enum cmn_filter_select fsel ; int eventid ; u8 occupid ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dpaa2_switch_acl_entry_add ( struct dpaa2_switch_filter_block * filter_block , struct dpaa2_switch_acl_entry * entry ) { struct dpsw_acl_entry_cfg * acl_entry_cfg = & entry -> cfg ; struct ethsw_core * ethsw = filter_block -> ethsw ; struct dpsw_acl_key * acl_key = & entry -> key ; struct device * dev = ethsw -> dev ; u8 * cmd_buff ; int err ; cmd_buff = kzalloc ( DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE , GFP_KERNEL ) ; if ( ! cmd_buff ) { return - ENOMEM ; } dpsw_acl_prepare_entry_cfg ( acl_key , cmd_buff ) ; acl_entry_cfg -> key_iova = dma_map_single ( dev , cmd_buff , DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE , DMA_TO_DEVICE ) ; if ( unlikely ( dma_mapping_error ( dev , acl_entry_cfg -> key_iova ) ) ) { dev_err ( dev , \"DMA mapping failed\\n\" ) ; return - EFAULT ; } err = dpsw_acl_add_entry ( ethsw -> mc_io , 0 , ethsw -> dpsw_handle , filter_block -> acl_id , acl_entry_cfg ) ; dma_unmap_single ( dev , acl_entry_cfg -> key_iova , sizeof ( cmd_buff ) , DMA_TO_DEVICE ) ; if ( err ) { dev_err ( dev , \"dpsw_acl_add_entry() failed %d\\n\" , err ) ; kfree ( cmd_buff ) ; return err ; } kfree ( cmd_buff ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void gru_unload_context ( struct gru_thread_state * gts , int savestate ) { struct gru_state * gru = gts -> ts_gru ; struct gru_context_configuration_handle * cch ; int ctxnum = gts -> ts_ctxnum ; if ( ! is_kernel_context ( gts ) ) { zap_vma_ptes ( gts -> ts_vma , UGRUADDR ( gts ) , GRU_GSEG_PAGESIZE ) ; } cch = get_cch ( gru -> gs_gru_base_vaddr , ctxnum ) ; gru_dbg ( grudev , \"gts %p, cbrmap 0x%lx, dsrmap 0x%lx\\n\" , gts , gts -> ts_cbr_map , gts -> ts_dsr_map ) ; lock_cch_handle ( cch , NULL ) ; if ( cch_interrupt_sync ( cch ) ) { BUG ( ) ; } if ( ! is_kernel_context ( gts ) ) { gru_unload_mm_tracker ( gru , gts ) ; } if ( savestate ) { gru_unload_context_data ( gts -> ts_gdata , gru -> gs_gru_base_vaddr , ctxnum , gts -> ts_cbr_map , gts -> ts_dsr_map ) ; gts -> ts_data_valid = 1 ; } if ( cch_deallocate ( cch ) ) { BUG ( ) ; } unlock_cch_handle ( cch ) ; gru_free_gru_context ( gts ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void zclient_flush_data ( struct thread * thread ) { struct zclient * zclient = THREAD_ARG ( thread ) ; if ( zclient -> sock < 0 ) { return ; } switch ( buffer_flush_available ( zclient -> wb , zclient -> sock ) ) { case BUFFER_ERROR : flog_err ( EC_LIB_ZAPI_SOCKET , \"%s: buffer_flush_available failed on zclient fd %d, closing\" , __func__ , zclient -> sock ) ; zclient_failed ( zclient ) ; return ; case BUFFER_PENDING : zclient -> t_write = NULL ; thread_add_write ( zclient -> master , zclient_flush_data , zclient , zclient -> sock , & zclient -> t_write ) ; break ; case BUFFER_EMPTY : if ( zclient -> zebra_buffer_write_ready ) { * zclient -> zebra_buffer_write_ready ( ) ; } break ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void fabricd_lsp_free ( struct isis_lsp * lsp ) { XFREE ( MTYPE_FABRICD_FLOODING_INFO , lsp -> flooding_interface ) ; for ( enum isis_tx_type type = TX_LSP_NORMAL ; type <= TX_LSP_CIRCUIT_SCOPED ; type ++ ) { list_delete ( & lsp -> flooding_neighbors [ type ] ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool sdhci_acpi_byt_defer ( struct device * dev ) { if ( ! soc_intel_is_byt ( ) ) { return false ; } sdhci_acpi_byt_setting ( dev ) ; return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void mailimap_xlist_extension_data_free ( struct mailimap_extension_data * ext_data ) { if ( ext_data -> ext_data != NULL ) { mailimap_mailbox_list_free ( ( mailimap_mailbox_list * ) ext_data -> ext_data ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int import_schema ( table_p tp ) { int rc , len1 , len2 ; char line1 [ MAX_ROW_SIZE ] ; char line2 [ MAX_ROW_SIZE ] ; char fn [ MAX_FILENAME_SIZE ] ; FILE * fp = NULL ; rc = 0 ; if ( ! schema_dir ) { fprintf ( stderr , \"[import_schema]: null schema dir.\\n\" ) ; return 1 ; } if ( ! tp ) { fprintf ( stderr , \"[import_schema]: null table parameter.\\n\" ) ; return 1 ; } memset ( fn , 0 , MAX_FILENAME_SIZE ) ; strcat ( fn , schema_dir ) ; strcat ( fn , \"/\" ) ; strcat ( fn , tp -> name ) ; fp = fopen ( fn , \"r\" ) ; if ( ! fp ) { fprintf ( stderr , \"[import_schema]: FAILED to open def schema file: %s.\\n\" , fn ) ; return 1 ; } while ( fgets ( line1 , MAX_ROW_SIZE , fp ) != NULL ) { if ( fgets ( line2 , MAX_ROW_SIZE , fp ) != NULL ) { len1 = strlen ( line1 ) - 1 ; len2 = strlen ( line2 ) - 1 ; line1 [ len1 ] = 0 ; line2 [ len2 ] = 0 ; if ( ( rc = _insert ( tp -> db , line1 , line2 , len1 , len2 ) ) != 0 ) { fprintf ( stderr , \"[import_schema]: FAILED to write schema def into table: %s.\\n\" , tp -> name ) ; done } } else { fprintf ( stderr , \"[import_schema]: FAILED to read schema def value in table: %s.\\n\" , tp -> name ) ; done } } done fclose ( fp , NULL ) ; return rc ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mlxsw_sp_qdisc_destroy ( struct mlxsw_sp_port * mlxsw_sp_port , struct mlxsw_sp_qdisc * mlxsw_sp_qdisc ) { struct mlxsw_sp_qdisc * root_qdisc = & mlxsw_sp_port -> qdisc -> root_qdisc ; int err_hdroom = 0 ; int err = 0 ; int i ; if ( root_qdisc == mlxsw_sp_qdisc ) { struct mlxsw_sp_hdroom hdroom = * mlxsw_sp_port -> hdroom ; hdroom . mode = MLXSW_SP_HDROOM_MODE_DCB ; mlxsw_sp_hdroom_prios_reset_buf_idx ( & hdroom ) ; mlxsw_sp_hdroom_bufs_reset_lossiness ( & hdroom ) ; mlxsw_sp_hdroom_bufs_reset_sizes ( mlxsw_sp_port , & hdroom ) ; err_hdroom = mlxsw_sp_hdroom_configure ( mlxsw_sp_port , & hdroom ) ; } if ( ! mlxsw_sp_qdisc -> ops ) { return 0 ; } for ( i = 0 ; i < mlxsw_sp_qdisc -> num_classes ; i ++ ) { mlxsw_sp_qdisc_destroy ( mlxsw_sp_port , & mlxsw_sp_qdisc -> qdiscs [ i ] ) ; } mlxsw_sp_qdisc_reduce_parent_backlog ( mlxsw_sp_qdisc ) ; if ( mlxsw_sp_qdisc -> ops -> destroy ) { err = mlxsw_sp_qdisc -> ops -> destroy ( mlxsw_sp_port , mlxsw_sp_qdisc ) ; } if ( mlxsw_sp_qdisc -> ops -> clean_stats ) { mlxsw_sp_qdisc -> ops -> clean_stats ( mlxsw_sp_port , mlxsw_sp_qdisc ) ; } mlxsw_sp_qdisc -> handle = TC_H_UNSPEC ; mlxsw_sp_qdisc -> ops = NULL ; mlxsw_sp_qdisc -> num_classes = 0 ; kfree ( mlxsw_sp_qdisc -> qdiscs ) ; mlxsw_sp_qdisc -> qdiscs = NULL ; return err_hdroom ?: err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t ltc2945_value_show ( struct device * dev , struct device_attribute * da , char * buf ) { struct sensor_device_attribute * attr = to_sensor_dev_attr ( da ) ; long long value ; value = ltc2945_reg_to_val ( dev , attr -> index ) ; return sysfs_emit ( buf , \"%lld\\n\" , value ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int vgic_v4_init ( struct kvm * kvm ) { struct vgic_dist * dist = & kvm -> arch . vgic ; struct kvm_vcpu * vcpu ; int nr_vcpus , ret ; unsigned long i ; if ( ! kvm_vgic_global_state . has_gicv4 ) { return 0 ; } if ( dist -> its_vm . vpes ) { return 0 ; } nr_vcpus = atomic_read ( & kvm -> online_vcpus ) ; dist -> its_vm . vpes = kcalloc ( nr_vcpus , sizeof ( * dist -> its_vm . vpes ) , GFP_KERNEL_ACCOUNT ) ; dist -> its_vm . nr_vpes = nr_vcpus ; kvm_for_each_vcpu ( , , ) dist -> its_vm . vpes [ i ] = & vcpu -> arch . vgic_cpu . vgic_v3 . its_vpe ; ret = its_alloc_vcpu_irqs ( & dist -> its_vm ) ; if ( ret < 0 ) { kvm_err ( \"VPE IRQ allocation failure\\n\" ) ; kfree ( dist -> its_vm . vpes ) ; dist -> its_vm . nr_vpes = 0 ; dist -> its_vm . vpes = NULL ; return ret ; } kvm_for_each_vcpu ( , , ) { int irq = dist -> its_vm . vpes [ i ] -> irq ; unsigned long irq_flags = DB_IRQ_FLAGS ; if ( kvm_vgic_global_state . has_gicv4_1 ) { irq_flags &= ~ IRQ_NOAUTOEN ; } irq_set_status_flags ( irq , irq_flags ) ; ret = vgic_v4_request_vpe_irq ( vcpu , irq ) ; if ( ret ) { kvm_err ( \"failed to allocate vcpu IRQ%d\\n\" , irq ) ; dist -> its_vm . nr_vpes = i ; break ; } } if ( ret ) { vgic_v4_teardown ( kvm ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void downlist_inform_clients ( void ) { struct qb_list_head * iter , * tmp_iter ; struct process_info * left_pi ; qb_map_t * group_map ; struct cpg_name cpg_group ; mar_cpg_name_t group ; confchg_data { struct cpg_name cpg_group ; mar_cpg_address_t left_list [ CPG_MEMBERS_MAX ] ; int left_list_entries ; struct qb_list_head list ; } , * pcd qb_map_iter_t * miter ; int i , size ; downlist_log ( \"my downlist\" , & g_req_exec_cpg_downlist ) ; group_map = qb_skiplist_create ( ) ; qb_list_for_each_safe ( , , ) { struct process_info * pi = qb_list_entry ( iter , process_info , list ) ; left_pi = NULL ; for ( i = 0 ; i < g_req_exec_cpg_downlist . left_nodes ; i ++ ) { if ( pi -> nodeid == g_req_exec_cpg_downlist . nodeids [ i ] ) { left_pi = pi ; break ; } } if ( left_pi ) { marshall_from_mar_cpg_name_t ( & cpg_group , & left_pi -> group ) ; cpg_group . value [ cpg_group . length ] = 0 ; pcd = ( confchg_data * ) qb_map_get ( group_map , cpg_group . value ) ; if ( pcd == NULL ) { pcd = ( confchg_data * ) calloc ( 1 , sizeof ( confchg_data ) ) ; memcpy ( & pcd -> cpg_group , & cpg_group , sizeof ( cpg_name ) ) ; qb_map_put ( group_map , pcd -> cpg_group . value , pcd ) ; } size = pcd -> left_list_entries ; pcd -> left_list [ size ] . nodeid = left_pi -> nodeid ; pcd -> left_list [ size ] . pid = left_pi -> pid ; pcd -> left_list [ size ] . reason = CONFCHG_CPG_REASON_NODEDOWN ; pcd -> left_list_entries ++ ; qb_list_del ( & left_pi -> list ) ; } } miter = qb_map_iter_create ( group_map ) ; while ( qb_map_iter_next ( miter , ( void * * ) & pcd ) ) { marshall_to_mar_cpg_name_t ( & group , & pcd -> cpg_group ) ; log_printf ( LOG_DEBUG , \"left_list_entries:%d\" , pcd -> left_list_entries ) ; for ( i = 0 ; i < pcd -> left_list_entries ; i ++ ) { log_printf ( LOG_DEBUG , \"left_list[%d] group:%s, ip:%s, pid:%d\" , i , cpg_print_group_name ( & group ) , ( char * ) api -> totem_ifaces_print ( pcd -> left_list [ i ] . nodeid ) , pcd -> left_list [ i ] . pid ) ; } notify_lib_joinlist ( & group , 0 , NULL , pcd -> left_list_entries , pcd -> left_list , MESSAGE_RES_CPG_CONFCHG_CALLBACK ) ; free ( pcd ) ; } qb_map_iter_free ( miter ) ; qb_map_destroy ( group_map ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void iw_send_thrspy_event ( struct net_device * dev , struct iw_spy_data * spydata , unsigned char * address , struct iw_quality * wstats ) { union iwreq_data wrqu ; struct iw_thrspy threshold ; wrqu . data . length = 1 ; memcpy ( threshold . addr . sa_data , address , ETH_ALEN ) ; threshold . addr . sa_family = ARPHRD_ETHER ; threshold . qual = * wstats ; threshold . low = spydata -> spy_thr_low ; threshold . high = spydata -> spy_thr_high ; wireless_send_event ( dev , SIOCGIWTHRSPY , & wrqu , ( char * ) & threshold ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mlx90632_get_refresh_rate ( struct mlx90632_data * data , int * refresh_rate ) { unsigned int meas1 ; int ret ; ret = regmap_read ( data -> regmap , MLX90632_EE_MEDICAL_MEAS1 , & meas1 ) ; * refresh_rate = MLX90632_REFRESH_RATE ( meas1 ) ; return ret ; } static const int mlx90632_freqs [ ] [ 2 ] { { 0 500000 } { 1 0 } { 2 0 } { 4 0 } { 8 0 } { 16 0 } { 32 0 } { 64 0 } } ; ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t rs_sta_dbgfs_scale_table_read ( struct file * file , char __user * user_buf , size_t count , loff_t * ppos ) { char * buff ; int desc = 0 ; int i = 0 ; int index = 0 ; ssize_t ret ; struct iwl_lq_sta * lq_sta = file -> private_data ; struct iwl_priv * priv ; struct iwl_scale_tbl_info * tbl = & ( lq_sta -> lq_info [ lq_sta -> active_tbl ] ) ; priv = lq_sta -> drv ; buff = kmalloc ( 1024 , GFP_KERNEL ) ; desc += sprintf ( buff + desc , \"sta_id %d\\n\" , lq_sta -> lq . sta_id ) ; desc += sprintf ( buff + desc , \"failed=%d success=%d rate=0%X\\n\" , lq_sta -> total_failed , lq_sta -> total_success , lq_sta -> active_legacy_rate ) ; desc += sprintf ( buff + desc , \"fixed rate 0x%X\\n\" , lq_sta -> dbg_fixed_rate ) ; desc += sprintf ( buff + desc , \"valid_tx_ant %s%s%s\\n\" , ( priv -> nvm_data -> valid_tx_ant & ANT_A ) ?\"ANT_A,\" : \"\" , ( priv -> nvm_data -> valid_tx_ant & ANT_B ) ?\"ANT_B,\" : \"\" , ( priv -> nvm_data -> valid_tx_ant & ANT_C ) ?\"ANT_C\" : \"\" ) ; desc += sprintf ( buff + desc , \"lq type %s\\n\" , ( is_legacy ( tbl -> lq_type ) ) ?\"legacy\" : \"HT\" ) ; if ( is_Ht ( tbl -> lq_type ) ) { desc += sprintf ( buff + desc , \" %s\" , ( is_siso ( tbl -> lq_type ) ) ?\"SISO\" : ( ( is_mimo2 ( tbl -> lq_type ) ) ?\"MIMO2\" : \"MIMO3\" ) ) ; desc += sprintf ( buff + desc , \" %s\" , ( tbl -> is_ht40 ) ?\"40MHz\" : \"20MHz\" ) ; desc += sprintf ( buff + desc , \" %s %s %s\\n\" , ( tbl -> is_SGI ) ?\"SGI\" : \"\" , ( lq_sta -> is_green ) ?\"GF enabled\" : \"\" , ( lq_sta -> is_agg ) ?\"AGG on\" : \"\" ) ; } desc += sprintf ( buff + desc , \"last tx rate=0x%X\\n\" , lq_sta -> last_rate_n_flags ) ; desc += sprintf ( buff + desc , \"general:\" \"flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\\n\" , lq_sta -> lq . general_params . flags , lq_sta -> lq . general_params . mimo_delimiter , lq_sta -> lq . general_params . single_stream_ant_msk , lq_sta -> lq . general_params . dual_stream_ant_msk ) ; desc += sprintf ( buff + desc , \"agg:\" \"time_limit=%d dist_start_th=%d frame_cnt_limit=%d\\n\" , le16_to_cpu ( lq_sta -> lq . agg_params . agg_time_limit ) , lq_sta -> lq . agg_params . agg_dis_start_th , lq_sta -> lq . agg_params . agg_frame_cnt_limit ) ; desc += sprintf ( buff + desc , \"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\\n\" , lq_sta -> lq . general_params . start_rate_index [ 0 ] , lq_sta -> lq . general_params . start_rate_index [ 1 ] , lq_sta -> lq . general_params . start_rate_index [ 2 ] , lq_sta -> lq . general_params . start_rate_index [ 3 ] ) ; for ( i = 0 ; i < LINK_QUAL_MAX_RETRY_NUM ; i ++ ) { index = iwl_hwrate_to_plcp_idx ( le32_to_cpu ( lq_sta -> lq . rs_table [ i ] . rate_n_flags ) ) ; if ( is_legacy ( tbl -> lq_type ) ) { desc += sprintf ( buff + desc , \" rate[%d] 0x%X %smbps\\n\" , i , le32_to_cpu ( lq_sta -> lq . rs_table [ i ] . rate_n_flags ) , iwl_rate_mcs [ index ] . mbps ) ; } else { desc += sprintf ( buff + desc , \" rate[%d] 0x%X %smbps (%s)\\n\" , i , le32_to_cpu ( lq_sta -> lq . rs_table [ i ] . rate_n_flags ) , iwl_rate_mcs [ index ] . mbps , iwl_rate_mcs [ index ] . mcs ) ; } } ret = simple_read_from_buffer ( user_buf , count , ppos , buff , desc ) ; kfree ( buff ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( hda_codec_i915_display_power , SND_SOC_SOF_HDA_AUDIO_CODEC_I915 ) ; int hda_codec_i915_init ( struct snd_sof_dev * sdev ) { struct hdac_bus * bus = sof_to_bus ( sdev ) ; int ret ; if ( IS_ENABLED ( CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT ) && sof_debug_check_flag ( SOF_DBG_FORCE_NOCODEC ) ) { return 0 ; } ret = snd_hdac_i915_init ( bus ) ; snd_hdac_display_power ( bus , HDA_CODEC_IDX_CONTROLLER , true ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int aspeed_g5_sig_expr_eval ( struct aspeed_pinmux_data * ctx , const struct aspeed_sig_expr * expr , bool enabled ) { int ret ; int i ; for ( i = 0 ; i < expr -> ndescs ; i ++ ) { const struct aspeed_sig_desc * desc = & expr -> descs [ i ] ; struct regmap * map ; map = aspeed_g5_acquire_regmap ( ctx , desc -> ip ) ; if ( IS_ERR ( map ) ) { dev_err ( ctx -> dev , \"Failed to acquire regmap for IP block %d\\n\" , desc -> ip ) ; return PTR_ERR ( map ) ; } ret = aspeed_sig_desc_eval ( desc , enabled , ctx -> maps [ desc -> ip ] ) ; } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void i915_restore_display ( struct drm_i915_private * dev_priv ) { struct pci_dev * pdev = dev_priv -> drm . pdev ; if ( ! HAS_DISPLAY ( dev_priv ) ) { return ; } intel_restore_swf ( dev_priv ) ; if ( GRAPHICS_VER ( dev_priv ) == 4 ) { pci_write_config_word ( pdev , GCDGMBUS , dev_priv -> regfile . saveGCDGMBUS ) ; } if ( GRAPHICS_VER ( dev_priv ) <= 4 ) { intel_de_write ( dev_priv , DSPARB , dev_priv -> regfile . saveDSPARB ) ; } intel_vga_redisable ( dev_priv , NULL ) ; intel_gmbus_reset ( dev_priv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int odp_actions_from_string ( const char * s , const struct simap * port_names , struct ofpbuf * actions ) { size_t old_size ; if ( ! strcasecmp ( s , \"drop\" ) ) { nl_msg_put_u32 ( actions , OVS_ACTION_ATTR_DROP , XLATE_OK ) ; return 0 ; } struct parse_odp_context context = ( parse_odp_context ) { . port_names = port_names } ; old_size = actions -> size ; for ( ; ; ) { int retval ; s += strspn ( s , delimiters ) ; retval = parse_odp_action ( & context , s , actions ) ; if ( retval >= 0 && nl_attr_oversized ( actions -> size - NLA_HDRLEN ) ) { retval = - E2BIG ; } if ( retval < 0 || ! strchr ( delimiters , s [ retval ] ) ) { actions -> size = old_size ; return - retval ; } s += retval ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void http_decode ( char * s ) { char * t ; int i , j , k ; t = g_new ( char , strlen ( s ) + 1 ) ; for ( i = j = 0 ; s [ i ] ; i ++ , j ++ ) { if ( s [ i ] == '%' ) { if ( sscanf ( s + i + 1 , \"%2x\" , & k ) ) { t [ j ] = k ; i += 2 ; } else { * t = 0 ; break ; } } else { t [ j ] = s [ i ] ; } } t [ j ] = 0 ; strcpy ( s , t ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bebob_probe ( struct fw_unit * unit , const struct ieee1394_device_id * entry ) { unsigned int card_index ; struct snd_card * card ; struct snd_bebob * bebob ; const struct snd_bebob_spec * spec ; int err ; if ( entry -> vendor_id == VEN_FOCUSRITE && entry -> model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH ) { spec = get_saffire_spec ( unit ) ; } if ( entry -> vendor_id == VEN_MAUDIO && entry -> model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH && ! check_audiophile_booted ( unit ) ) { spec = NULL ; } else { spec = ( const snd_bebob_spec * ) entry -> driver_data ; } if ( spec == NULL ) { if ( entry -> vendor_id == VEN_MAUDIO || entry -> vendor_id == VEN_BRIDGECO ) { return snd_bebob_maudio_load_firmware ( unit ) ; } else { return - ENODEV ; } } mutex_lock ( & devices_mutex ) ; for ( card_index = 0 ; card_index < SNDRV_CARDS ; card_index ++ ) { if ( ! test_bit ( card_index , devices_used ) && enable [ card_index ] ) { break ; } } if ( card_index >= SNDRV_CARDS ) { mutex_unlock ( & devices_mutex ) ; return - ENOENT ; } err = snd_card_new ( & unit -> device , index [ card_index ] , id [ card_index ] , THIS_MODULE , sizeof ( * bebob ) , & card ) ; if ( err < 0 ) { mutex_unlock ( & devices_mutex ) ; return err ; } card -> private_free = bebob_card_free ; set_bit ( card_index , devices_used ) ; mutex_unlock ( & devices_mutex ) ; bebob = card -> private_data ; bebob -> unit = fw_unit_get ( unit ) ; dev_set_drvdata ( & unit -> device , bebob ) ; bebob -> card = card ; bebob -> card_index = card_index ; bebob -> spec = spec ; spin_lock_init ( & bebob -> lock ) ; init_waitqueue_head ( & bebob -> hwdep_wait ) ; err = name_device ( bebob ) ; if ( err < 0 ) { error } err = detect_quirks ( bebob , entry ) ; if ( err < 0 ) { error } if ( bebob -> spec == & maudio_special_spec ) { if ( entry -> model_id == MODEL_MAUDIO_FW1814 ) { err = snd_bebob_maudio_special_discover ( bebob , true ) ; } else { err = snd_bebob_maudio_special_discover ( bebob , false ) ; } } else { err = snd_bebob_stream_discover ( bebob ) ; } if ( err < 0 ) { error } err = snd_bebob_stream_init_duplex ( bebob ) ; if ( err < 0 ) { error } snd_bebob_proc_init ( bebob ) ; if ( bebob -> midi_input_ports > 0 || bebob -> midi_output_ports > 0 ) { err = snd_bebob_create_midi_devices ( bebob ) ; if ( err < 0 ) { error } } err = snd_bebob_create_pcm_devices ( bebob ) ; if ( err < 0 ) { error } err = snd_bebob_create_hwdep_device ( bebob ) ; if ( err < 0 ) { error } err = snd_card_register ( card ) ; if ( err < 0 ) { error } if ( entry -> vendor_id == VEN_MAUDIO && ( entry -> model_id == MODEL_MAUDIO_FW1814 || entry -> model_id == MODEL_MAUDIO_PROJECTMIX ) ) { fw_schedule_bus_reset ( fw_parent_device ( bebob -> unit ) -> card , false , true ) ; } return 0 ; error snd_card_free ( card ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tonumeral ( const expdesc * e , TValue * v ) { switch ( e -> k ) { case VKINT : if ( v ) { setivalue ( v , e -> u . ival ) ; } return 1 ; case VKFLT : if ( v ) { setfltvalue ( v , e -> u . nval ) ; } return 1 ; default : return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void wil_p2p_listen_expired ( struct work_struct * work ) { struct wil_p2p_info * p2p = container_of ( work , wil_p2p_info , discovery_expired_work ) ; struct wil6210_priv * wil = container_of ( p2p , wil6210_priv , p2p ) ; u8 started ; wil_dbg_misc ( wil , \"p2p_listen_expired\\n\" ) ; started = wil_p2p_stop_discovery ( wil ) ; mutex_unlock ( & wil -> mutex ) ; if ( started ) { mutex_lock ( & wil -> p2p_wdev_mutex ) ; cfg80211_remain_on_channel_expired ( wil -> radio_wdev , p2p -> cookie , & p2p -> listen_chan , GFP_KERNEL ) ; wil -> radio_wdev = wil -> wdev ; mutex_unlock ( & wil -> p2p_wdev_mutex ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "extern List resolve_ctls_from_dns_srv ( void ) { struct __res_state res ; ns_msg handle ; ns_rr rr ; unsigned char answer [ 512 ] ; int len ; List controllers ; if ( res_ninit ( & res ) ) { error ( \"%s: res_ninit error: %m\" , __func__ ) ; return NULL ; } if ( ( len = res_nsearch ( & res , SRV_RECORD , C_IN , T_SRV , answer , sizeof ( answer ) ) ) < 0 ) { error ( \"%s: res_nsearch error: %s\" , __func__ , hstrerror ( h_errno ) ) ; return NULL ; } if ( ns_initparse ( answer , len , & handle ) < 0 ) { error ( \"%s: ns_initparse error: %m\" , __func__ ) ; return NULL ; } controllers = list_create ( xfree_ptr ) ; for ( int i = 0 ; i < ns_msg_count ( handle , ns_s_an ) ; i ++ ) { ctl_entry_t * ctl ; if ( ns_parserr ( & handle , ns_s_an , i , & rr ) < 0 ) { error ( \"%s: ns_parserr\" , __func__ ) ; continue ; } if ( ns_rr_type ( rr ) != T_SRV ) { continue ; } ctl = xmalloc ( sizeof ( * ctl ) ) ; ctl -> priority = ns_get16 ( ns_rr_rdata ( rr ) ) ; ctl -> port = ns_get16 ( ns_rr_rdata ( rr ) + 2 * NS_INT16SZ ) ; if ( dn_expand ( ns_msg_base ( handle ) , ns_msg_end ( handle ) , ns_rr_rdata ( rr ) + 3 * NS_INT16SZ , ctl -> hostname , sizeof ( ctl -> hostname ) ) < 0 ) { continue ; } list_push ( controllers , ctl ) ; } if ( ! list_count ( controllers ) ) { error ( \"%s: no SRV records located\" , __func__ ) ; FREE_NULL_LIST ( controllers ) ; } else { list_sort ( controllers , _sort_controllers ) ; } return controllers ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int AAH_NAME ( int ch ) { { save_ch ( ch ) ; ch = next_ch ( ) ; } isNAME ( ch ) ; back_ch_not_white ( ch , NULL ) ; tokenType = TOKEN_NAME ; return ( DONE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int onetouch_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct us_data * us ; int result ; result = usb_stor_probe1 ( & us , intf , id , ( id - onetouch_usb_ids ) + onetouch_unusual_dev_list , & onetouch_host_template ) ; result = usb_stor_probe2 ( us ) ; return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int setup_ima_buffer ( const struct kimage * image , void * fdt , int chosen_node ) { int ret , addr_cells , size_cells , entry_size ; u8 value [ 16 ] ; remove_ima_buffer ( fdt , chosen_node ) ; if ( ! image -> arch . ima_buffer_size ) { return 0 ; } ret = get_addr_size_cells ( & addr_cells , & size_cells ) ; if ( ret ) { return ret ; } entry_size = 4 * ( addr_cells + size_cells ) ; ret = write_number ( value , image -> arch . ima_buffer_addr , addr_cells ) ; if ( ret ) { return ret ; } ret = write_number ( value + 4 * addr_cells , image -> arch . ima_buffer_size , size_cells ) ; if ( ret ) { return ret ; } ret = fdt_setprop ( fdt , chosen_node , \"linux,ima-kexec-buffer\" , value , entry_size ) ; if ( ret < 0 ) { return - EINVAL ; } ret = fdt_add_mem_rsv ( fdt , image -> arch . ima_buffer_addr , image -> arch . ima_buffer_size ) ; if ( ret ) { return - EINVAL ; } pr_debug ( \"IMA buffer at 0x%llx, size = 0x%zx\\n\" , image -> arch . ima_buffer_addr , image -> arch . ima_buffer_size ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void rds_loop_kill_conns ( struct net * net ) { struct rds_loop_connection * lc , * _lc ; LIST_HEAD ( tmp_list ) ; spin_lock_irq ( & loop_conns_lock ) ; list_for_each_entry_safe ( , , , ) { struct net * c_net = read_pnet ( & lc -> conn -> c_net ) ; if ( net != c_net ) { continue ; } list_move_tail ( & lc -> loop_node , & tmp_list ) ; } spin_unlock_irq ( & loop_conns_lock ) ; list_for_each_entry_safe ( , , , ) { WARN_ON ( lc -> conn -> c_passive ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int si476x_core_cmd_get_property ( struct si476x_core * core , u16 property ) { int err ; int resp [ CMD_GET_PROPERTY_NRESP ] ; const u8 args [ CMD_GET_PROPERTY_NARGS ] { 0x00 msb ( property ) lsb ( property ) } ; ; err = si476x_core_send_command ( core , CMD_GET_PROPERTY , args , ARRAY_SIZE ( args ) , resp , ARRAY_SIZE ( resp ) , SI476X_DEFAULT_TIMEOUT ) ; if ( err < 0 ) { return err ; } else { return get_unaligned_be16 ( resp + 2 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long * vcpu_spsr32 ( const struct kvm_vcpu * vcpu ) { cfs_time_t mode = * vcpu_cpsr ( vcpu ) & COMPAT_PSR_MODE_MASK ; switch ( mode ) { case COMPAT_PSR_MODE_SVC : mode = KVM_SPSR_SVC ; break ; case COMPAT_PSR_MODE_ABT : mode = KVM_SPSR_ABT ; break ; case COMPAT_PSR_MODE_UND : mode = KVM_SPSR_UND ; break ; case COMPAT_PSR_MODE_IRQ : mode = KVM_SPSR_IRQ ; break ; case COMPAT_PSR_MODE_FIQ : mode = KVM_SPSR_FIQ ; break ; default : BUG ( ) ; } return ( unsigned long * ) & vcpu_gp_regs ( vcpu ) -> spsr [ mode ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "extern void scontrol_print_federation ( void ) { void * fed = NULL ; if ( ! slurm_load_federation ( & fed ) ) { slurm_print_federation ( fed ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct uacce_device * uacce_alloc ( struct device * parent , struct uacce_interface * interface ) { unsigned int flags = interface -> flags ; struct uacce_device * uacce ; int ret ; uacce = kzalloc ( sizeof ( uacce_device ) , GFP_KERNEL ) ; if ( ! uacce ) { return ERR_PTR ( - ENOMEM ) ; } flags = uacce_enable_sva ( parent , flags ) ; uacce -> parent = parent ; uacce -> flags = flags ; uacce -> ops = interface -> ops ; ret = xa_alloc ( & uacce_xa , & uacce -> dev_id , uacce , xa_limit_32b , GFP_KERNEL ) ; if ( ret < 0 ) { err_with_uacce } INIT_LIST_HEAD ( & uacce -> queues ) ; device_initialize ( & uacce -> dev ) ; uacce -> dev . devt = MKDEV ( MAJOR ( uacce_devt ) , uacce -> dev_id ) ; uacce -> dev . class = uacce_class ; uacce -> dev . groups = uacce_dev_groups ; uacce -> dev . parent = uacce -> parent ; uacce -> dev . release = uacce_release ; dev_set_name ( & uacce -> dev , \"%s-%d\" , interface -> name , uacce -> dev_id ) ; return uacce ; err_with_uacce uacce_disable_sva ( uacce ) ; kfree ( uacce ) ; return ERR_PTR ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int asfrtp_parse_sdp_line ( AVFormatContext * s , int stream_index , PayloadContext * asf , const char * line ) { if ( av_strstart ( line , \"stream:\" , & line ) ) { RTSPState * rt = s -> priv_data ; s -> streams [ stream_index ] -> id = strtol ( line , NULL , 10 ) ; if ( rt -> asf_ctx ) { int i ; for ( i = 0 ; i < rt -> asf_ctx -> nb_streams ; i ++ ) { if ( s -> streams [ stream_index ] -> id == rt -> asf_ctx -> streams [ i ] -> id ) { avcodec_parameters_copy ( s -> streams [ stream_index ] -> codecpar , rt -> asf_ctx -> streams [ i ] -> codecpar ) ; s -> streams [ stream_index ] -> need_parsing = rt -> asf_ctx -> streams [ i ] -> need_parsing ; avpriv_set_pts_info ( s -> streams [ stream_index ] , 32 , 1 , 1000 ) ; } } } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int thread_lat_cmp ( struct list_head * list , struct work_atoms * l , struct work_atoms * r ) { struct sort_dimension * sort ; int ret = 0 ; BUG_ON ( list_empty ( list ) ) ; list_for_each_entry ( , , ) { ret = sort -> cmp ( l , r ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * ssh_connection_hash ( const char * thishost , const char * host , const char * portstr , const char * user ) { struct ssh_digest_ctx * md ; u_char conn_hash [ SSH_DIGEST_MAX_LENGTH ] ; if ( ( md = ssh_digest_start ( SSH_DIGEST_SHA1 ) ) == NULL || ssh_digest_update ( md , thishost , strlen ( thishost ) ) < 0 || ssh_digest_update ( md , host , strlen ( host ) ) < 0 || ssh_digest_update ( md , portstr , strlen ( portstr ) ) < 0 || ssh_digest_update ( md , user , strlen ( user ) ) < 0 || ssh_digest_final ( md , conn_hash , sizeof ( conn_hash ) ) < 0 ) { fatal_f ( \"mux digest failed\" ) ; } return tohex ( conn_hash , ssh_digest_bytes ( SSH_DIGEST_SHA1 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned long vmw_mob_calculate_pt_pages ( unsigned long data_pages ) { unsigned long data_size = data_pages * PAGE_SIZE ; cfs_time_t tot_size = 0 ; while ( likely ( data_size > PAGE_SIZE ) ) { data_size = DIV_ROUND_UP ( data_size , PAGE_SIZE ) ; data_size *= VMW_PPN_SIZE ; tot_size += PFN_ALIGN ( data_size ) ; } return tot_size >> PAGE_SHIFT ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "main ( int argc , char * * argv ) { gdImagePtr im ; FILE * in , * out ; int cs , fmt ; if ( argc != 5 ) { fprintf ( stderr , \"Usage: pngtogd2 filename.png filename.gd2 cs fmt\\n\" ) ; fprintf ( stderr , \"       where cs is the chunk size\\n\" ) ; fprintf ( stderr , \"       fmt is 1 for raw, 2 for compressed\\n\" ) ; exit ( 1 ) ; } in = fopen ( argv [ 1 ] , \"rb\" ) ; if ( ! in ) { fprintf ( stderr , \"Input file does not exist!\\n\" ) ; exit ( 1 ) ; } im = gdImageCreateFromPng ( in ) ; fclose ( in ) ; if ( ! im ) { fprintf ( stderr , \"Input is not in PNG format!\\n\" ) ; exit ( 1 ) ; } out = fopen ( argv [ 2 ] , \"wb\" ) ; if ( ! out ) { fprintf ( stderr , \"Output file cannot be written to!\\n\" ) ; gdImageDestroy ( im ) ; exit ( 1 ) ; } cs = atoi ( argv [ 3 ] ) ; fmt = atoi ( argv [ 4 ] ) ; gdImageGd2 ( im , out , cs , fmt ) ; fclose ( out , NULL ) ; gdImageDestroy ( im ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static DEVICE_ATTR_RW ( direction ) ; static ssize_t value_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct gpiod_data * data = dev_get_drvdata ( dev ) ; struct gpio_desc * desc = data -> desc ; int status ; mutex_lock ( & data -> mutex ) ; status = sprintf ( buf , \"%d\\n\" , gpiod_get_value_cansleep ( desc ) ) ; mutex_unlock ( & data -> mutex ) ; return status ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int X509_STORE_add_object ( X509_STORE * store , X509_OBJECT * obj ) { int ret = 0 ; CRYPTO_w_lock ( CRYPTO_LOCK_X509_STORE , NULL ) ; if ( X509_OBJECT_retrieve_match ( store -> objs , obj ) != NULL ) { ret = 1 ; out } if ( sk_X509_OBJECT_push ( store -> objs , obj ) <= 0 ) { X509error ( ERR_R_MALLOC_FAILURE ) ; out } obj = NULL ; ret = 1 ; out CRYPTO_w_unlock ( CRYPTO_LOCK_X509_STORE ) ; X509_OBJECT_free ( obj ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MP_STATUS MP_AssignLogicalUnitToTPG ( MP_OID tpgOid , MP_OID luOid ) { MP_AssignLogicalUnitToTPGFn PassFunc ; MP_UINT32 index ; MP_STATUS status ; if ( ( status = validate_object ( tpgOid , MP_OBJECT_TYPE_TARGET_PORT_GROUP , MP_OBJECT_TYPE_MATCH ) ) != MP_STATUS_SUCCESS ) { return ( status ) ; } if ( ( status = validate_object ( luOid , MP_OBJECT_TYPE_MULTIPATH_LU , MP_OBJECT_TYPE_MATCH ) ) != MP_STATUS_SUCCESS ) { return ( status ) ; } ( void ) pthread_mutex_lock ( & mp_lib_mutex ) ; index = tpgOid . ownerId - 1 ; if ( plugintable [ index ] . hdlPlugin != NULL ) { PassFunc = ( MP_AssignLogicalUnitToTPGFn ) dlsym ( plugintable [ index ] . hdlPlugin , \"MP_AssignLogicalUnitToTPG\" ) ; if ( PassFunc != NULL ) { status = PassFunc ( tpgOid , luOid ) ; } else { status = MP_STATUS_UNSUPPORTED ; } } else { status = MP_STATUS_FAILED ; } ( void ) pthread_mutex_unlock ( & mp_lib_mutex ) ; return ( status ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t qp_enqueue_locked ( struct vmci_queue * produce_q , struct vmci_queue * consume_q , const u64 produce_q_size , const void * buf , size_t buf_size , vmci_memcpy_to_queue_func memcpy_to_queue ) { s64 free_space ; u64 tail ; size_t written ; ssize_t result ; result = qp_map_queue_headers ( produce_q , consume_q ) ; free_space = vmci_q_header_free_space ( produce_q -> q_header , consume_q -> q_header , produce_q_size ) ; if ( free_space == 0 ) { return VMCI_ERROR_QUEUEPAIR_NOSPACE ; } if ( free_space < VMCI_SUCCESS ) { return ( ssize_t ) free_space ; } written = ( size_t ) ( free_space > buf_size ?buf_size : free_space ) ; tail = vmci_q_header_producer_tail ( produce_q -> q_header ) ; if ( likely ( tail + written < produce_q_size ) ) { result = memcpy_to_queue ( produce_q , tail , buf , 0 , written ) ; } else { const size_t tmp = ( size_t ) ( produce_q_size - tail ) ; result = memcpy_to_queue ( produce_q , tail , buf , 0 , tmp ) ; if ( result >= VMCI_SUCCESS ) { result = memcpy_to_queue ( produce_q , 0 , buf , tmp , written - tmp ) ; } } if ( result < VMCI_SUCCESS ) { return result ; } vmci_q_header_add_producer_tail ( produce_q -> q_header , written , produce_q_size ) ; return written ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int uwb_radio_change_channel ( struct uwb_rc * rc , int channel ) { int ret ; struct device * dev = & rc -> uwb_dev . dev ; dev_dbg ( dev , \"%s: channel = %d, rc->beaconing = %d\\n\" , __func__ , channel , rc -> beaconing ) ; if ( channel == - 1 ) { uwb_radio_channel_changed ( rc , channel ) ; } if ( channel != rc -> beaconing ) { if ( rc -> beaconing != - 1 && channel != - 1 ) { ret = uwb_radio_change_channel ( rc , - 1 ) ; if ( ret < 0 ) { return ret ; } } ret = uwb_rc_beacon ( rc , channel , 0 ) ; } if ( channel != - 1 ) { uwb_radio_channel_changed ( rc , rc -> beaconing ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nwamd_sysevent_events_fini ( void ) { if ( sysevent_handle != NULL ) { nwamd_escalate ( ) ; sysevent_unbind_handle ( sysevent_handle , NULL ) ; nwamd_deescalate ( ) ; } sysevent_handle = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int shm_regcomp ( shm_regex_t * preg , const char * regex , int cflags ) { malloc_hook_t * orig_malloc_hook ; realloc_hook_t * orig_realloc_hook ; free_hook_t * orig_free_hook ; int ret ; replace_malloc_hooks ( ) ; ret = regcomp ( & preg -> regexp , regex , cflags ) ; restore_malloc_hooks ( ) ; if ( ret ) { lock_destroy ( & preg -> lock ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int memconsole_probe ( struct coreboot_device * dev ) { struct cbmem_cons * tmp_cbmc ; tmp_cbmc = memremap ( dev -> cbmem_ref . cbmem_addr , sizeof ( * tmp_cbmc ) , MEMREMAP_WB ) ; cbmem_console_size = tmp_cbmc -> size_dont_access_after_boot ; cbmem_console = devm_memremap ( & dev -> dev , dev -> cbmem_ref . cbmem_addr , cbmem_console_size + sizeof ( * cbmem_console ) , MEMREMAP_WB ) ; memunmap ( tmp_cbmc ) ; if ( IS_ERR ( cbmem_console ) ) { return PTR_ERR ( cbmem_console ) ; } memconsole_setup ( memconsole_coreboot_read ) ; return memconsole_sysfs_init ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct stp_policy_node * __stp_policy_node_lookup ( struct stp_policy * policy , char * s ) { struct stp_policy_node * policy_node , * ret ; struct list_head * head = & policy -> group . cg_children ; struct config_item * item ; char * start , * end = s ; if ( list_empty ( head ) ) { return NULL ; } item = list_entry ( head -> next , config_item , ci_entry ) ; ret = to_stp_policy_node ( item ) ; next for ( ; ; ) { start = strsep ( & end , \"/\" ) ; if ( ! start ) { break ; } list_for_each_entry ( , , ) { policy_node = to_stp_policy_node ( item ) ; if ( ! strcmp ( start , policy_node -> group . cg_item . ci_name ) ) { ret = policy_node ; if ( ! end ) { out } head = & policy_node -> group . cg_children ; next } } break ; } out return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void send_handler ( struct ib_mad_agent * agent , struct ib_mad_send_wc * send_wc ) { struct ib_umad_file * file = agent -> context ; struct ib_umad_packet * packet = send_wc -> send_buf -> context [ 0 ] ; dequeue_send ( file , packet ) ; rdma_destroy_ah ( packet -> msg -> ah , RDMA_DESTROY_AH_SLEEPABLE ) ; ib_free_send_mad ( packet -> msg ) ; if ( send_wc -> status == IB_WC_RESP_TIMEOUT_ERR ) { packet -> length = IB_MGMT_MAD_HDR ; packet -> mad . hdr . status = ETIMEDOUT ; } kfree ( packet ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hwdownload_filter_frame ( AVFilterLink * link , AVFrame * input ) { AVFilterContext * avctx = link -> dst ; AVFilterLink * outlink = avctx -> outputs [ 0 ] ; HWDownloadContext * ctx = avctx -> priv ; AVFrame * output = NULL ; int err ; if ( ! ctx -> hwframes_ref || ! input -> hw_frames_ctx ) { av_log ( ctx , AV_LOG_ERROR , \"Input frames must have hardware context.\\n\" ) ; err = AVERROR ( EINVAL ) ; fail } if ( ( void * ) ctx -> hwframes != input -> hw_frames_ctx -> data ) { av_log ( ctx , AV_LOG_ERROR , \"Input frame is not the in the configured \" \"hwframe context.\\n\" ) ; err = AVERROR ( EINVAL ) ; fail } output = ff_get_video_buffer ( outlink , ctx -> hwframes -> width , ctx -> hwframes -> height ) ; if ( ! output ) { err = AVERROR ( ENOMEM ) ; fail } err = av_hwframe_transfer_data ( output , input , 0 ) ; if ( err < 0 ) { av_log ( ctx , AV_LOG_ERROR , \"Failed to download frame: %d.\\n\" , err ) ; fail } output -> width = outlink -> w ; output -> height = outlink -> h ; err = av_frame_copy_props ( output , input ) ; if ( err < 0 ) { fail } return ff_filter_frame ( avctx -> outputs [ 0 ] , output ) ; fail av_frame_free ( & input ) ; av_frame_free ( & output ) ; return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ff_nvdec_decode_uninit ( AVCodecContext * avctx ) { NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; av_freep ( & ctx -> bitstream ) ; av_freep ( & ctx -> bitstream_internal ) ; ctx -> bitstream_len = 0 ; ctx -> bitstream_allocated = 0 ; av_freep ( & ctx -> slice_offsets ) ; ctx -> nb_slices = 0 ; av_buffer_unref ( & ctx -> decoder_ref ) ; av_buffer_pool_uninit ( & ctx -> decoder_pool ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int pca_extract_dir ( PathCache * pc , const char * path , const char * * nextp ) { const char * pptr ; const char * sptr ; int escaped ; if ( pca_expand_tilde ( pc , path , strlen ( path ) , 0 , & pptr ) ) { return 1 ; } sptr = pptr ; while ( * pptr && ( escaped || * pptr != ':' ) ) { escaped = ! escaped && * pptr ++ == '\\\\' ; } if ( _pn_append_to_path ( pc -> path , sptr , pptr - sptr , 1 ) == NULL ) { _err_record_msg ( pc -> err , \"Insufficient memory to record directory name\" , END_ERR_MSG ) ; return 1 ; } { int dirlen = strlen ( pc -> path -> name ) ; if ( dirlen < FS_DIR_SEP_LEN || strncmp ( pc -> path -> name + dirlen - FS_DIR_SEP_LEN , FS_DIR_SEP , FS_DIR_SEP_LEN ) != 0 ) { if ( _pn_append_to_path ( pc -> path , FS_DIR_SEP , FS_DIR_SEP_LEN , 0 ) == NULL ) { _err_record_msg ( pc -> err , \"Insufficient memory to record directory name\" , END_ERR_MSG ) ; return 1 ; } } } if ( * pptr == ':' ) { pptr ++ ; } * nextp = pptr ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void gfs2_delete_debugfs_file ( struct gfs2_sbd * sdp ) { if ( sdp -> debugfs_dir ) { if ( sdp -> debugfs_dentry_glocks ) { debugfs_remove ( sdp -> debugfs_dentry_glocks ) ; sdp -> debugfs_dentry_glocks = NULL ; } if ( sdp -> debugfs_dentry_glstats ) { debugfs_remove ( sdp -> debugfs_dentry_glstats , NULL ) ; sdp -> debugfs_dentry_glstats = NULL ; } if ( sdp -> debugfs_dentry_sbstats ) { debugfs_remove ( sdp -> debugfs_dentry_sbstats ) ; sdp -> debugfs_dentry_sbstats = NULL ; } debugfs_remove ( sdp -> debugfs_dir ) ; sdp -> debugfs_dir = NULL ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int upload ( CURL * curlhandle , const char * remotepath , const char * localpath , long timeout , long tries ) { FILE * f ; long uploaded_len = 0 ; CURLcode r = CURLE_GOT_NOTHING ; int c ; f = fopen ( localpath , \"rb\" ) ; if ( ! f ) { perror ( NULL ) ; return 0 ; } curl_easy_setopt ( curlhandle , CURLOPT_UPLOAD , 1L ) ; curl_easy_setopt ( curlhandle , CURLOPT_URL , remotepath ) ; if ( timeout ) { curl_easy_setopt ( curlhandle , CURLOPT_SERVER_RESPONSE_TIMEOUT , timeout ) ; } curl_easy_setopt ( curlhandle , CURLOPT_HEADERFUNCTION , getcontentlengthfunc ) ; curl_easy_setopt ( curlhandle , CURLOPT_HEADERDATA , & uploaded_len ) ; curl_easy_setopt ( curlhandle , CURLOPT_WRITEFUNCTION , discardfunc ) ; curl_easy_setopt ( curlhandle , CURLOPT_READFUNCTION , readfunc ) ; curl_easy_setopt ( curlhandle , CURLOPT_READDATA , f ) ; curl_easy_setopt ( curlhandle , CURLOPT_FTPPORT , \"-\" ) ; curl_easy_setopt ( curlhandle , CURLOPT_FTP_CREATE_MISSING_DIRS , 1L ) ; curl_easy_setopt ( curlhandle , CURLOPT_VERBOSE , 1L ) ; for ( c = 0 ; ( r != CURLE_OK ) && ( c < tries ) ; c ++ ) { if ( c ) { curl_easy_setopt ( curlhandle , CURLOPT_NOBODY , 1L ) ; curl_easy_setopt ( curlhandle , CURLOPT_HEADER , 1L ) ; r = curl_easy_perform ( curlhandle ) ; curl_easy_setopt ( curlhandle , CURLOPT_NOBODY , 0L ) ; curl_easy_setopt ( curlhandle , CURLOPT_HEADER , 0L ) ; fseek ( f , uploaded_len , SEEK_SET ) ; curl_easy_setopt ( curlhandle , CURLOPT_APPEND , 1L ) ; } else { curl_easy_setopt ( curlhandle , CURLOPT_APPEND , 0L ) ; } r = curl_easy_perform ( curlhandle ) ; } fclose ( f ) ; if ( r == CURLE_OK ) { return 1 ; } else { fprintf ( stderr , \"%s\\n\" , curl_easy_strerror ( r ) ) ; return 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void p9_read_work ( struct work_struct * work ) { __poll_t n ; int err ; struct p9_conn * m ; m = container_of ( work , p9_conn , rq ) ; p9_debug ( P9_DEBUG_TRANS , \"start mux %p pos %zd\\n\" , m , m -> rc . offset ) ; if ( ! m -> rc . sdata ) { m -> rc . sdata = m -> tmp_buf ; m -> rc . offset = 0 ; m -> rc . capacity = P9_HDRSZ ; } clear_bit ( Rpending , & m -> wsched ) ; p9_debug ( P9_DEBUG_TRANS , \"read mux %p pos %zd size: %zd = %zd\\n\" , m , m -> rc . offset , m -> rc . capacity , m -> rc . capacity - m -> rc . offset ) ; err = p9_fd_read ( m -> client , m -> rc . sdata + m -> rc . offset , m -> rc . capacity - m -> rc . offset ) ; p9_debug ( P9_DEBUG_TRANS , \"mux %p got %d bytes\\n\" , m , err ) ; if ( err == - EAGAIN ) { end_clear } if ( err <= 0 ) { error } m -> rc . offset += err ; if ( ( ! m -> rreq ) && ( m -> rc . offset == m -> rc . capacity ) ) { p9_debug ( P9_DEBUG_TRANS , \"got new header\\n\" ) ; m -> rc . size = P9_HDRSZ ; err = p9_parse_header ( & m -> rc , & m -> rc . size , NULL , NULL , 0 ) ; if ( err ) { p9_debug ( P9_DEBUG_ERROR , \"error parsing header: %d\\n\" , err ) ; error } p9_debug ( P9_DEBUG_TRANS , \"mux %p pkt: size: %d bytes tag: %d\\n\" , m , m -> rc . size , m -> rc . tag ) ; m -> rreq = p9_tag_lookup ( m -> client , m -> rc . tag ) ; if ( ! m -> rreq || ( m -> rreq -> status != REQ_STATUS_SENT ) ) { p9_debug ( P9_DEBUG_ERROR , \"Unexpected packet tag %d\\n\" , m -> rc . tag ) ; err = - EIO ; error } if ( m -> rc . size > m -> rreq -> rc . capacity ) { p9_debug ( P9_DEBUG_ERROR , \"requested packet size too big: %d for tag %d with capacity %zd\\n\" , m -> rc . size , m -> rc . tag , m -> rreq -> rc . capacity ) ; err = - EIO ; error } if ( ! m -> rreq -> rc . sdata ) { p9_debug ( P9_DEBUG_ERROR , \"No recv fcall for tag %d (req %p), disconnecting!\\n\" , m -> rc . tag , m -> rreq ) ; p9_req_put ( m -> client , m -> rreq ) ; m -> rreq = NULL ; err = - EIO ; error } m -> rc . sdata = m -> rreq -> rc . sdata ; memcpy ( m -> rc . sdata , m -> tmp_buf , m -> rc . capacity ) ; m -> rc . capacity = m -> rc . size ; } if ( ( m -> rreq ) && ( m -> rc . offset == m -> rc . capacity ) ) { p9_debug ( P9_DEBUG_TRANS , \"got new packet\\n\" ) ; m -> rreq -> rc . size = m -> rc . offset ; spin_lock ( & m -> req_lock ) ; if ( m -> rreq -> status == REQ_STATUS_SENT ) { list_del ( & m -> rreq -> req_list ) ; p9_client_cb ( m -> client , m -> rreq , REQ_STATUS_RCVD ) ; } if ( m -> rreq -> status == REQ_STATUS_FLSHD ) { p9_debug ( P9_DEBUG_TRANS , \"Ignore replies associated with a cancelled request\\n\" ) ; } else { spin_unlock ( & m -> req_lock ) ; p9_debug ( P9_DEBUG_ERROR , \"Request tag %d errored out while we were reading the reply\\n\" , m -> rc . tag ) ; err = - EIO ; error } spin_unlock ( & m -> req_lock ) ; m -> rc . sdata = NULL ; m -> rc . offset = 0 ; m -> rc . capacity = 0 ; p9_req_put ( m -> client , m -> rreq ) ; m -> rreq = NULL ; } end_clear clear_bit ( Rworksched , & m -> wsched ) ; if ( ! list_empty ( & m -> req_list ) ) { if ( test_and_clear_bit ( Rpending , & m -> wsched ) ) { n = EPOLLIN ; } else { n = p9_fd_poll ( m -> client , NULL , NULL ) ; } if ( ( n & EPOLLIN ) && ! test_and_set_bit ( Rworksched , & m -> wsched ) ) { p9_debug ( P9_DEBUG_TRANS , \"sched read work %p\\n\" , m ) ; schedule_work ( & m -> rq ) ; } } return ; error p9_conn_cancel ( m , err ) ; clear_bit ( Rworksched , & m -> wsched ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * ECDH_get_ex_data ( EC_KEY * d , int idx ) { ECDH_DATA * ecdh ; ecdh = ecdh_check ( d , NULL ) ; if ( ecdh == NULL ) { return NULL ; } return ( CRYPTO_get_ex_data ( & ecdh -> ex_data , idx ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void test_router_dump_router_to_string_no_bridge_distribution_method ( void * arg ) { const char * needle = \"bridge-distribution-request any\" ; or_options_t * options = get_options_mutable ( ) ; routerinfo_t * router = NULL ; curve25519_keypair_t ntor_keypair ; ed25519_keypair_t signing_keypair ; ed25519_keypair_t identity_keypair ; char * desc = NULL ; char * found = NULL ; ( void ) arg ; crypto_pk_t * ident_key = pk_generate ( 0 ) ; crypto_pk_t * tap_key = pk_generate ( 0 ) ; options -> ORPort_set = 1 ; options -> BridgeRelay = 1 ; tt_int_op ( 0 , OP_EQ , curve25519_keypair_generate ( & ntor_keypair , 0 ) ) ; tt_int_op ( 0 , OP_EQ , ed25519_keypair_generate ( & signing_keypair , 0 ) ) ; tt_int_op ( 0 , OP_EQ , ed25519_keypair_generate ( & identity_keypair , 0 ) ) ; router = rtr_tests_gen_routerinfo ( ident_key , tap_key ) ; tt_ptr_op ( router , OP_NE , NULL ) ; router -> cache_info . signing_key_cert = tor_cert_create_ed25519 ( & identity_keypair , CERT_TYPE_ID_SIGNING , & signing_keypair . pubkey , time ( NULL ) , 86400 , CERT_FLAG_INCLUDE_SIGNING_KEY ) ; router -> onion_curve25519_pkey = & ntor_keypair . pubkey ; desc = router_dump_router_to_string ( router , ident_key , tap_key , & ntor_keypair , & signing_keypair ) ; tt_ptr_op ( desc , OP_NE , NULL ) ; found = strstr ( desc , needle ) ; tt_ptr_op ( found , OP_NE , NULL ) ; done if ( router ) { router -> onion_curve25519_pkey = NULL ; } routerinfo_free ( router ) ; tor_free ( desc ) ; crypto_pk_free ( ident_key ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static rx_handler_result_t bond_handle_frame ( struct sk_buff * * pskb ) { struct sk_buff * skb = * pskb ; struct slave * slave ; struct bonding * bond ; int * recv_probe ( const struct sk_buff * , struct bonding * , struct slave * ) int ret = RX_HANDLER_ANOTHER ; skb = skb_share_check ( skb , GFP_ATOMIC ) ; * pskb = skb ; slave = bond_slave_get_rcu ( skb -> dev ) ; bond = slave -> bond ; recv_probe = READ_ONCE ( bond -> recv_probe ) ; if ( recv_probe ) { ret = recv_probe ( skb , bond , slave ) ; if ( ret == RX_HANDLER_CONSUMED ) { consume_skb ( skb ) ; return ret ; } } if ( bond_should_deliver_exact_match ( skb , slave , bond ) ) { if ( is_link_local_ether_addr ( eth_hdr ( skb ) -> h_dest ) ) { return RX_HANDLER_PASS ; } return RX_HANDLER_EXACT ; } skb -> dev = bond -> dev ; if ( BOND_MODE ( bond ) == BOND_MODE_ALB && netif_is_bridge_port ( bond -> dev ) && skb -> pkt_type == PACKET_HOST ) { if ( unlikely ( skb_cow_head ( skb , skb -> data - skb_mac_header ( skb ) ) ) ) { kfree_skb ( skb ) ; return RX_HANDLER_CONSUMED ; } bond_hw_addr_copy ( eth_hdr ( skb ) -> h_dest , bond -> dev -> dev_addr , bond -> dev -> addr_len ) ; } return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int snd_gusmax_mixer ( struct snd_wss * chip ) { struct snd_card * card = chip -> card ; struct snd_ctl_elem_id id1 , id2 ; int err ; memset ( & id2 , 0 , sizeof ( id2 ) ) ; id1 . iface = id2 . iface = SNDRV_CTL_ELEM_IFACE_MIXER ; strcpy ( id1 . name , \"Aux Playback Switch\" ) ; strcpy ( id2 . name , \"Synth Playback Switch\" ) ; if ( ( err = snd_ctl_rename_id ( card , & id1 , & id2 ) ) < 0 ) { return err ; } strcpy ( id1 . name , \"Aux Playback Volume\" ) ; strcpy ( id2 . name , \"Synth Playback Volume\" ) ; if ( ( err = snd_ctl_rename_id ( card , & id1 , & id2 ) ) < 0 ) { return err ; } strcpy ( id1 . name , \"Aux Playback Switch\" ) ; id1 . index = 1 ; strcpy ( id2 . name , \"CD Playback Switch\" ) ; if ( ( err = snd_ctl_rename_id ( card , & id1 , & id2 ) ) < 0 ) { return err ; } strcpy ( id1 . name , \"Aux Playback Volume\" ) ; strcpy ( id2 . name , \"CD Playback Volume\" ) ; if ( ( err = snd_ctl_rename_id ( card , & id1 , & id2 ) ) < 0 ) { return err ; } if ( snd_mixer_group_rename ( mixer , SNDRV_MIXER_IN_MONO , 0 , SNDRV_MIXER_IN_MIC , 0 ) < 0 ) { __error } if ( snd_mixer_elem_rename ( mixer , SNDRV_MIXER_IN_MONO , 0 , SNDRV_MIXER_ETYPE_INPUT , SNDRV_MIXER_IN_MIC , 0 ) < 0 ) { __error } if ( snd_mixer_elem_rename ( mixer , \"Mono Capture Volume\" , 0 , SNDRV_MIXER_ETYPE_VOLUME1 , \"Mic Capture Volume\" , 0 ) < 0 ) { __error } if ( snd_mixer_elem_rename ( mixer , \"Mono Capture Switch\" , 0 , SNDRV_MIXER_ETYPE_SWITCH1 , \"Mic Capture Switch\" , 0 ) < 0 ) { __error } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ubi_leb_write ( struct ubi_volume_desc * desc , int lnum , const void * buf , int offset , int len ) { struct ubi_volume * vol = desc -> vol ; struct ubi_device * ubi = vol -> ubi ; int vol_id = vol -> vol_id ; dbg_gen ( \"write %d bytes to LEB %d:%d:%d\" , len , vol_id , lnum , offset ) ; if ( desc -> mode == UBI_READONLY || vol -> vol_type == UBI_STATIC_VOLUME ) { return - EROFS ; } if ( ! ubi_leb_valid ( vol , lnum ) || offset < 0 || len ( 0 || offset + len ) vol -> usable_leb_size || offset & ( ubi -> min_io_size - 1 ) || len & ( ubi -> min_io_size - 1 ) ) { return - EINVAL ; } if ( vol -> upd_marker ) { return - EBADF ; } if ( len == 0 ) { return 0 ; } return ubi_eba_write_leb ( ubi , vol , lnum , buf , offset , len ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static DECLARE_RWSEM ( cxl_memdev_rwsem ) ; static int cxl_mem_major ; static DEFINE_IDA ( cxl_memdev_ida ) ; static void cxl_memdev_release ( struct device * dev ) { struct cxl_memdev * cxlmd = to_cxl_memdev ( dev ) ; ida_free ( & cxl_memdev_ida , cxlmd -> id ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static errcode_t parse_include_dir ( const char * dirname , struct profile_node * root_section ) { errcode_t retval = 0 ; char * * fnames , * pathname ; int i ; if ( k5_dir_filenames ( dirname , & fnames ) != 0 ) { return PROF_FAIL_INCLUDE_DIR ; } for ( i = 0 ; fnames != NULL && fnames [ i ] != NULL ; i ++ ) { if ( ! valid_name ( fnames [ i ] ) ) { continue ; } if ( asprintf ( & pathname , \"%s/%s\" , dirname , fnames [ i ] ) < 0 ) { retval = ENOMEM ; break ; } retval = parse_include_file ( pathname , root_section ) ; if ( retval ) { break ; } } k5_free_filenames ( fnames ) ; return retval ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool sysmmu_block ( struct sysmmu_drvdata * data ) { int i = 120 ; writel ( CTRL_BLOCK , data -> sfrbase + REG_MMU_CTRL ) ; while ( ( i > 0 ) && ! ( readl ( data -> sfrbase + REG_MMU_STATUS ) & 1 ) ) { -- i ; } if ( ! ( readl ( data -> sfrbase + REG_MMU_STATUS ) & 1 ) ) { sysmmu_unblock ( data , NULL ) ; return false ; } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static gboolean dissect_PNMRRT_Data_heur ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) { guint16 u16FrameID = GPOINTER_TO_UINT ( data ) ; proto_item * item ; proto_tree * mrrt_tree ; int offset = 0 ; guint32 u32SubStart ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"PN-MRRT\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; item = proto_tree_add_protocol_format ( tree , proto_pn_mrrt , tvb , 0 , 0 , \"PROFINET MRRT, \" ) ; mrrt_tree = proto_item_add_subtree ( item , ett_pn_mrrt ) ; u32SubStart = offset ; offset = dissect_PNMRRT_PDU ( tvb , offset , pinfo , mrrt_tree , item ) ; proto_item_set_len ( item , offset - u32SubStart ) ; return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct i2c_adapter * intel_gpio_create ( struct drm_psb_private * dev_priv , u32 pin ) { static const int map_pin_to_reg [ ] { 0 GPIOB GPIOA GPIOC GPIOD GPIOE 0 GPIOF } ; ; struct intel_gpio * gpio ; if ( pin >= ARRAY_SIZE ( map_pin_to_reg ) || ! map_pin_to_reg [ pin ] ) { return NULL ; } gpio = kzalloc ( sizeof ( intel_gpio ) , GFP_KERNEL ) ; if ( gpio == NULL ) { return NULL ; } gpio -> reg = map_pin_to_reg [ pin ] ; gpio -> dev_priv = dev_priv ; snprintf ( gpio -> adapter . name , sizeof ( gpio -> adapter . name ) , \"gma500 GPIO%c\" , \"?BACDE?F\" [ pin ] ) ; gpio -> adapter . owner = THIS_MODULE ; gpio -> adapter . algo_data = & gpio -> algo ; gpio -> adapter . dev . parent = dev_priv -> dev . dev ; gpio -> algo . setsda = set_data ; gpio -> algo . setscl = set_clock ; gpio -> algo . getsda = get_data ; gpio -> algo . getscl = get_clock ; gpio -> algo . udelay = I2C_RISEFALL_TIME ; gpio -> algo . timeout = usecs_to_jiffies ( 2200 ) ; gpio -> algo . data = gpio ; if ( i2c_bit_add_bus ( & gpio -> adapter ) ) { out_free } return & gpio -> adapter ; out_free return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int falcon_read_firmware ( struct falcon * falcon , const char * name ) { int err ; err = request_firmware ( & falcon -> firmware . firmware , name , falcon -> dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ceph_fscache_register_fs ( struct ceph_fs_client * fsc , struct fs_context * fc ) { const struct ceph_fsid * fsid = & fsc -> client -> fsid ; const char * fscache_uniq = fsc -> mount_options -> fscache_uniq ; size_t uniq_len = fscache_uniq ?strlen ( fscache_uniq ) : 0 ; char * name ; int err = 0 ; name = kasprintf ( GFP_KERNEL , \"ceph,%pU%s%s\" , fsid , uniq_len ?\",\" : \"\" , uniq_len ?fscache_uniq : \"\" ) ; if ( ! name ) { return - ENOMEM ; } fsc -> fscache = fscache_acquire_volume ( name , NULL , NULL , 0 ) ; if ( IS_ERR_OR_NULL ( fsc -> fscache ) ) { errorfc ( fc , \"Unable to register fscache cookie for %s\" , name ) ; err = fsc -> fscache ?PTR_ERR ( fsc -> fscache ) : - EOPNOTSUPP ; fsc -> fscache = NULL ; } return err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void sw_fmd_fini ( fmd_hdl_t * hdl ) { const struct sw_subinfo * * subinfo ; struct sw_modspecific * msinfo ; int i ; msinfo = ( sw_modspecific * ) fmd_hdl_getspecific ( hdl ) ; subinfo = * msinfo -> swms_subinfo ; ( void ) pthread_mutex_lock ( & msinfo -> swms_timerlock ) ; for ( i = 0 ; i < SW_TIMER_MAX ; i ++ ) { fmd_timer_remove ( hdl , msinfo -> swms_timers [ i ] . swt_timerid ) ; msinfo -> swms_timers [ i ] . swt_state = SW_TMR_RMVD ; } ( void ) pthread_mutex_unlock ( & msinfo -> swms_timerlock ) ; ( void ) pthread_mutex_destroy ( & msinfo -> swms_timerlock ) ; for ( i = 0 ; i < msinfo -> swms_dispcnt ; i ++ ) { const struct sw_subinfo * sip = subinfo [ i ] ; if ( ( * msinfo -> swms_disptbl ) [ i ] == NULL ) { continue ; } if ( sip -> swsub_fini != NULL ) { * sip -> swsub_fini ( hdl ) ; } } fmd_hdl_free ( hdl , msinfo -> swms_disptbl , SW_SUB_MAX * sizeof ( sw_disp * ) ) ; fmd_hdl_setspecific ( hdl , NULL ) ; fmd_hdl_free ( hdl , msinfo , sizeof ( * msinfo ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int kvm_set_irq_routing ( struct kvm * kvm , const struct kvm_irq_routing_entry * ue , unsigned nr , unsigned flags ) { kvm_irq_routing_table * new , * old ; struct kvm_kernel_irq_routing_entry * e ; u32 i , j , nr_rt_entries = 0 ; int r ; for ( i = 0 ; i < nr ; ++ i ) { nr_rt_entries = max ( nr_rt_entries , ue [ i ] . gsi ) ; } nr_rt_entries += 1 ; new = kzalloc ( sizeof ( * new ) + ( nr_rt_entries * sizeof ( hlist_head ) ) , GFP_KERNEL ) ; if ( ! new ) { return - ENOMEM ; } new -> nr_rt_entries = nr_rt_entries ; for ( i = 0 ; i < KVM_NR_IRQCHIPS ; i ++ ) { for ( j = 0 ; j < KVM_IRQCHIP_NUM_PINS ; j ++ ) { new -> chip [ i ] [ j ] = - 1 ; } } for ( i = 0 ; i < nr ; ++ i ) { r = - ENOMEM ; e = kzalloc ( sizeof ( * e ) , GFP_KERNEL ) ; if ( ! e ) { out } r = - EINVAL ; switch ( ue -> type ) { case KVM_IRQ_ROUTING_MSI : if ( ue -> flags & ~ KVM_MSI_VALID_DEVID ) { free_entry } break ; default : if ( ue -> flags ) { free_entry } break ; } r = setup_routing_entry ( kvm , new , e , ue ) ; if ( r ) { free_entry } ++ ue ; } mutex_lock ( & kvm -> irq_lock ) ; old = kvm -> irq_routing ; rcu_assign_pointer ( kvm -> irq_routing , new ) ; kvm_irq_routing_update ( kvm ) ; kvm_arch_irq_routing_update ( kvm ) ; mutex_unlock ( & kvm -> irq_lock ) ; kvm_arch_post_irq_routing_update ( kvm ) ; synchronize_srcu_expedited ( & kvm -> irq_srcu ) ; new = old ; r = 0 ; out free_entry kfree ( e ) ; out free_irq_routing_table ( new ) ; return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void CVGridFitChar ( CharView * cv ) { void * single_glyph_context ; SplineFont * sf = cv -> b . sc -> parent ; int layer = CVLayer ( ( CharViewBase * ) cv ) ; SplinePointListsFree ( cv -> b . gridfit ) ; FreeType_FreeRaster ( cv -> raster ) ; cv -> raster = NULL ; single_glyph_context = _FreeTypeFontContext ( sf , cv -> b . sc , NULL , layer , sf -> layers [ layer ] . order2 ?ff_ttf : ff_otf , 0 , NULL ) ; if ( single_glyph_context == NULL ) { LogError ( _ ( \"Freetype rasterization failed.\\n\" ) ) ; return ; } if ( cv -> b . sc -> layers [ layer ] . refs != NULL ) { SCNumberPoints ( cv -> b . sc , layer ) ; } cv -> raster = FreeType_GetRaster ( single_glyph_context , cv -> b . sc -> orig_pos , cv -> ft_pointsizey , cv -> ft_pointsizex , cv -> ft_dpi , cv -> ft_depth ) ; cv -> b . gridfit = FreeType_GridFitChar ( single_glyph_context , cv -> b . sc -> orig_pos , cv -> ft_pointsizey , cv -> ft_pointsizex , cv -> ft_dpi , & cv -> b . ft_gridfitwidth , cv -> b . sc , cv -> ft_depth , true ) ; FreeTypeFreeContext ( single_glyph_context ) ; GDrawRequestExpose ( cv -> v , NULL , false ) ; if ( cv -> b . sc -> instructions_out_of_date && cv -> b . sc -> ttf_instrs_len != 0 ) { ff_post_notice ( _ ( \"Instructions out of date\" ) , _ ( \"The points have been changed. This may mean that the truetype instructions now refer to the wrong points and they may cause unexpected results.\" ) ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gd_update_geometry_hints ( VirtualConsole * vc ) { GtkDisplayState * s = vc -> s ; GdkWindowHints mask = 0 ; GdkGeometry geo = { } ; GtkWidget * geo_widget = NULL ; GtkWindow * geo_window ; if ( vc -> type == GD_VC_GFX ) { if ( s -> free_scale ) { geo . min_width = surface_width ( vc -> gfx . ds ) * VC_SCALE_MIN ; geo . min_height = surface_height ( vc -> gfx . ds ) * VC_SCALE_MIN ; mask |= GDK_HINT_MIN_SIZE ; } else { geo . min_width = surface_width ( vc -> gfx . ds ) * vc -> gfx . scale_x ; geo . min_height = surface_height ( vc -> gfx . ds ) * vc -> gfx . scale_y ; mask |= GDK_HINT_MIN_SIZE ; } geo_widget = vc -> gfx . drawing_area ; gtk_widget_set_size_request ( geo_widget , geo . min_width , geo . min_height ) ; } if ( vc -> type == GD_VC_VTE ) { VteTerminal * term = VTE_TERMINAL ( vc -> vte . terminal ) ; GtkBorder padding = { 0 } ; gtk_style_context_get_padding ( gtk_widget_get_style_context ( vc -> vte . terminal ) , gtk_widget_get_state_flags ( vc -> vte . terminal ) , & padding ) ; { GtkBorder * ib = NULL ; gtk_widget_style_get ( vc -> vte . terminal , \"inner-border\" , & ib , NULL ) ; if ( ib ) { padding = * ib ; gtk_border_free ( ib ) ; } } geo . width_inc = vte_terminal_get_char_width ( term ) ; geo . height_inc = vte_terminal_get_char_height ( term ) ; mask |= GDK_HINT_RESIZE_INC ; geo . base_width = geo . width_inc ; geo . base_height = geo . height_inc ; mask |= GDK_HINT_BASE_SIZE ; geo . min_width = geo . width_inc * VC_TERM_X_MIN ; geo . min_height = geo . height_inc * VC_TERM_Y_MIN ; mask |= GDK_HINT_MIN_SIZE ; geo . base_width += padding . left + padding . right ; geo . base_height += padding . top + padding . bottom ; geo . min_width += padding . left + padding . right ; geo . min_height += padding . top + padding . bottom ; geo_widget = vc -> vte . terminal ; } geo_window = GTK_WINDOW ( vc -> window ?vc -> window : s -> window ) ; gtk_window_set_geometry_hints ( geo_window , geo_widget , & geo , mask ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ath11k_mgmt_rx_event ( struct ath11k_base * ab , struct sk_buff * skb ) { struct mgmt_rx_event_params rx_ev = { 0 } ; struct ath11k * ar ; struct ieee80211_rx_status * status = IEEE80211_SKB_RXCB ( skb ) ; struct ieee80211_hdr * hdr ; u16 fc ; struct ieee80211_supported_band * sband ; if ( ath11k_pull_mgmt_rx_params_tlv ( ab , skb , & rx_ev ) != 0 ) { ath11k_warn ( ab , \"failed to extract mgmt rx event\" ) ; dev_kfree_skb ( skb ) ; return ; } ath11k_dbg ( ab , ATH11K_DBG_MGMT , \"mgmt rx event status %08x\\n\" , rx_ev . status ) ; rcu_read_lock ( ) ; ar = ath11k_mac_get_ar_by_pdev_id ( ab , rx_ev . pdev_id ) ; if ( ! ar ) { ath11k_warn ( ab , \"invalid pdev_id %d in mgmt_rx_event\\n\" , rx_ev . pdev_id ) ; dev_kfree_skb ( skb ) ; exit } if ( ( test_bit ( ATH11K_CAC_RUNNING , & ar -> dev_flags ) ) || ( rx_ev . status & ( WMI_RX_STATUS_ERR_DECRYPT | WMI_RX_STATUS_ERR_KEY_CACHE_MISS | WMI_RX_STATUS_ERR_CRC ) ) ) { dev_kfree_skb ( skb ) ; exit } if ( rx_ev . status & WMI_RX_STATUS_ERR_MIC ) { status -> flag |= RX_FLAG_MMIC_ERROR ; } if ( rx_ev . chan_freq >= ATH11K_MIN_6G_FREQ && rx_ev . chan_freq <= ATH11K_MAX_6G_FREQ ) { status -> band = NL80211_BAND_6GHZ ; status -> freq = rx_ev . chan_freq ; } if ( rx_ev . channel >= 1 && rx_ev . channel <= 14 ) { status -> band = NL80211_BAND_2GHZ ; } if ( rx_ev . channel >= 36 && rx_ev . channel <= ATH11K_MAX_5G_CHAN ) { status -> band = NL80211_BAND_5GHZ ; } else { WARN_ON_ONCE ( 1 ) ; dev_kfree_skb ( skb ) ; exit } if ( rx_ev . phy_mode == MODE_11B && ( status -> band == NL80211_BAND_5GHZ || status -> band == NL80211_BAND_6GHZ ) ) { ath11k_dbg ( ab , ATH11K_DBG_WMI , \"wmi mgmt rx 11b (CCK) on 5/6GHz, band = %d\\n\" , status -> band ) ; } sband = & ar -> mac . sbands [ status -> band ] ; if ( status -> band != NL80211_BAND_6GHZ ) { status -> freq = ieee80211_channel_to_frequency ( rx_ev . channel , status -> band ) ; } status -> signal = rx_ev . snr + ATH11K_DEFAULT_NOISE_FLOOR ; status -> rate_idx = ath11k_mac_bitrate_to_idx ( sband , rx_ev . rate / 100 ) ; hdr = ( ieee80211_hdr * ) skb -> data ; fc = le16_to_cpu ( hdr -> frame_control ) ; status -> flag |= RX_FLAG_SKIP_MONITOR ; if ( ieee80211_has_protected ( hdr -> frame_control ) && ! is_multicast_ether_addr ( ieee80211_get_DA ( hdr ) ) ) { status -> flag |= RX_FLAG_DECRYPTED ; if ( ! ieee80211_is_robust_mgmt_frame ( skb ) ) { status -> flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED ; hdr -> frame_control = __cpu_to_le16 ( fc & ~ IEEE80211_FCTL_PROTECTED ) ; } } if ( ieee80211_is_beacon ( hdr -> frame_control ) ) { ath11k_mac_handle_beacon ( ar , skb ) ; } ath11k_dbg ( ab , ATH11K_DBG_MGMT , \"event mgmt rx skb %pK len %d ftype %02x stype %02x\\n\" , skb , skb -> len , fc & IEEE80211_FCTL_FTYPE , fc & IEEE80211_FCTL_STYPE ) ; ath11k_dbg ( ab , ATH11K_DBG_MGMT , \"event mgmt rx freq %d band %d snr %d, rate_idx %d\\n\" , status -> freq , status -> band , status -> signal , status -> rate_idx ) ; ieee80211_rx_ni ( ar -> hw , skb ) ; exit rcu_read_unlock ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int osst_chk_result ( struct osst_tape * STp , struct osst_request * SRpnt ) { char * name = tape_name ( STp ) ; int result = SRpnt -> result ; u8 * sense = SRpnt -> sense , scode ; const char * stp ; struct st_cmdstatus * cmdstatp ; cmdstatp = & STp -> buffer -> cmdstat ; osst_analyze_sense ( SRpnt , cmdstatp ) ; if ( cmdstatp -> have_sense ) { scode = STp -> buffer -> cmdstat . sense_hdr . sense_key ; } else { scode = 0 ; } if ( debugging ) { printk ( OSST_DEB_MSG \"%s:D: Error: %x, cmd: %x %x %x %x %x %x\\n\" , name , result , SRpnt -> cmd [ 0 ] , SRpnt -> cmd [ 1 ] , SRpnt -> cmd [ 2 ] , SRpnt -> cmd [ 3 ] , SRpnt -> cmd [ 4 ] , SRpnt -> cmd [ 5 ] ) ; if ( scode ) { printk ( OSST_DEB_MSG \"%s:D: Sense: %02x, ASC: %02x, ASCQ: %02x\\n\" , name , scode , sense [ 12 ] , sense [ 13 ] ) ; } if ( cmdstatp -> have_sense ) { __scsi_print_sense ( STp -> device , name , SRpnt -> sense , SCSI_SENSE_BUFFERSIZE ) ; } } if ( cmdstatp -> have_sense && ( scode != NO_SENSE && scode != RECOVERED_ERROR && scode != BLANK_CHECK && scode != VOLUME_OVERFLOW && SRpnt -> cmd [ 0 ] != MODE_SENSE && SRpnt -> cmd [ 0 ] != TEST_UNIT_READY ) ) { if ( cmdstatp -> have_sense ) { printk ( KERN_WARNING \"%s:W: Command with sense data:\\n\" , name ) ; __scsi_print_sense ( STp -> device , name , SRpnt -> sense , SCSI_SENSE_BUFFERSIZE ) ; } else { static int notyetprinted = 1 ; printk ( KERN_WARNING \"%s:W: Warning %x (driver bt 0x%x, host bt 0x%x).\\n\" , name , result , driver_byte ( result ) , host_byte ( result ) ) ; if ( notyetprinted ) { notyetprinted = 0 ; printk ( KERN_INFO \"%s:I: This warning may be caused by your scsi controller,\\n\" , name ) ; printk ( KERN_INFO \"%s:I: it has been reported with some Buslogic cards.\\n\" , name ) ; } } } STp -> pos_unknown |= STp -> device -> was_reset ; if ( cmdstatp -> have_sense && scode == RECOVERED_ERROR ) { STp -> recover_count ++ ; STp -> recover_erreg ++ ; if ( debugging ) { if ( SRpnt -> cmd [ 0 ] == READ_6 ) { stp = \"read\" ; } if ( SRpnt -> cmd [ 0 ] == WRITE_6 ) { stp = \"write\" ; } else { stp = \"ioctl\" ; } printk ( OSST_DEB_MSG \"%s:D: Recovered %s error (%d).\\n\" , name , stp , STp -> recover_count ) ; } if ( ( sense [ 2 ] & 0xe0 ) == 0 ) { return 0 ; } } return ( - EIO ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ar933x_pinctrl_probe ( struct udevice * dev ) { struct ar933x_pinctrl_priv * priv = dev_get_priv ( dev ) ; fdt_addr_t addr ; addr = dev_read_addr ( dev ) ; priv -> regs = map_physmem ( addr , AR71XX_GPIO_SIZE , MAP_NOCACHE ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ACPI_STATUS pci_process_acpi_device ( ACPI_HANDLE hdl , UINT32 level , void * ctx , void * * rv ) { ACPI_DEVICE_INFO * adi ; int busnum ; pci_prd_acpi_cb_t * cb = ctx ; if ( ACPI_FAILURE ( AcpiGetObjectInfo ( hdl , & adi ) ) ) { return ( AE_OK ) ; } if ( ! ( adi -> Valid & ACPI_VALID_HID ) ) { return ( AE_OK ) ; } if ( strncmp ( adi -> HardwareId . String , PCI_ROOT_HID_STRING , sizeof ( PCI_ROOT_HID_STRING ) ) && strncmp ( adi -> HardwareId . String , PCI_EXPRESS_ROOT_HID_STRING , sizeof ( PCI_EXPRESS_ROOT_HID_STRING ) ) ) { AcpiOsFree ( adi ) ; return ( AE_OK ) ; } AcpiOsFree ( adi ) ; if ( ACPI_SUCCESS ( acpica_get_busno ( hdl , & busnum ) ) ) { if ( busnum < 0 ) { dcmn_err ( CE_NOTE , \"pci_process_acpi_device: invalid _BBN 0x%x\" , busnum ) ; return ( AE_CTRL_DEPTH ) ; } if ( cb -> ppac_func ( ( uint32_t ) busnum , cb -> ppac_arg ) ) { return ( AE_CTRL_DEPTH ) ; } return ( AE_CTRL_TERMINATE ) ; } return ( AE_OK ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool ExprResolveGroup ( struct xkb_context * ctx , const ExprDef * expr , xkb_layout_index_t * group_rtrn ) { bool ok ; int result ; ok = ExprResolveIntegerLookup ( ctx , expr , & result , SimpleLookup , groupNames ) ; if ( result <= 0 || result > XKB_MAX_GROUPS ) { log_err ( ctx , \"Group index %u is out of range (1..%d)\\n\" , result , XKB_MAX_GROUPS ) ; return false ; } * group_rtrn = ( xkb_layout_index_t ) result ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * scandev_devno_to_devpath ( dev_t devno ) { struct dir_list * list = NULL , * new_list = NULL ; char * devname = NULL ; const char * * dir ; for ( dir = devdirs ; * dir ; dir ++ ) { add_to_dirlist ( * dir , NULL , & list ) ; } while ( list ) { struct dir_list * current = list ; list = list -> next ; DBG ( DEVNO , ul_debug ( \"directory %s\" , current -> name ) ) ; blkid__scan_dir ( current -> name , devno , & new_list , & devname ) ; free ( current -> name ) ; if ( devname ) { break ; } if ( list == NULL ) { list = new_list ; new_list = NULL ; } } free_dirlist ( & list ) ; free_dirlist ( & new_list ) ; return devname ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void select_bad_process ( struct oom_control * oc ) { if ( is_memcg_oom ( oc ) ) { mem_cgroup_scan_tasks ( oc -> memcg , oom_evaluate_task , oc ) ; } else { struct task_struct * p ; rcu_read_lock ( ) ; for_each_process ( ) rcu_read_unlock ( ) ; } oc -> chosen_points = oc -> chosen_points * 1000 / oc -> totalpages ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void drm_global_init ( void ) { int i ; for ( i = 0 ; i < DRM_GLOBAL_NUM ; ++ i ) { struct drm_global_item * item = & glob [ i ] ; item -> object = NULL ; item -> refcount = 0 ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ev_image_accessible_ref_state_set ( ) { AtkStateSet * state_set ; AtkStateSet * copy_set ; AtkStateSet * page_accessible_state_set ; EvImageAccessible * self ; EvViewAccessible * view_accessible ; gint page ; self = EV_IMAGE_ACCESSIBLE ( atk_object ) ; state_set = ATK_OBJECT_CLASS ( ev_image_accessible_parent_class ) -> ref_state_set ( atk_object ) ; page_accessible_state_set = atk_object_ref_state_set ( ATK_OBJECT ( self -> priv -> page ) ) ; copy_set = atk_state_set_or_sets ( state_set , page_accessible_state_set ) ; atk_state_set_remove_state ( copy_set , ATK_STATE_FOCUSABLE ) ; atk_state_set_remove_state ( copy_set , ATK_STATE_FOCUSED ) ; view_accessible = ev_page_accessible_get_view_accessible ( self -> priv -> page ) ; page = ev_page_accessible_get_page ( self -> priv -> page ) ; if ( ! ev_view_accessible_is_doc_rect_showing ( view_accessible , page , & self -> priv -> area ) ) { atk_state_set_remove_state ( copy_set , ATK_STATE_SHOWING ) ; } g_object_unref ( state_set ) ; g_object_unref ( page_accessible_state_set ) ; return copy_set ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gen7_emit_media_object ( struct batch_chunk * batch , unsigned int media_object_index ) { unsigned int x_offset = ( media_object_index % 16 ) * 64 ; unsigned int y_offset = ( media_object_index / 16 ) * 16 ; int pkt = 6 + 3 ; u32 * cs ; cs = batch_alloc_items ( batch , 8 , pkt ) ; * cs ++ = MEDIA_OBJECT | ( pkt - 2 ) ; * cs ++ = 0 ; * cs ++ = 0 ; * cs ++ = 0 ; * cs ++ = 0 ; * cs ++ = 0 ; * cs ++ = y_offset << 16 | x_offset ; * cs ++ = 0 ; * cs ++ = GT3_INLINE_DATA_DELAYS ; batch_advance ( batch , cs ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int read_eeprom ( struct ventana_board_info * info ) { int i ; int chksum ; char baseboard ; int type ; unsigned char * buf = ( unsigned char * ) info ; if ( gsc_i2c_read ( BOARD_EEPROM_ADDR , 0x00 , 1 , buf , sizeof ( * info ) ) ) { puts ( \"EEPROM: Failed to read EEPROM\\n\" ) ; return GW_UNKNOWN ; } if ( info -> model [ 0 ] != 'G' || info -> model [ 1 ] != 'W' ) { puts ( \"EEPROM: Invalid Model in EEPROM\\n\" ) ; print_hex_dump_bytes ( \"\" , DUMP_PREFIX_OFFSET , buf , sizeof ( * info ) ) ; return GW_UNKNOWN ; } for ( chksum = 0 , i = 0 ; i < sizeof ( * info ) - 2 ; i ++ ) { chksum += buf [ i ] ; } if ( ( info -> chksum [ 0 ] != chksum >> 8 ) || ( info -> chksum [ 1 ] != ( chksum & 0xff ) ) ) { puts ( \"EEPROM: Failed EEPROM checksum\\n\" ) ; print_hex_dump_bytes ( \"\" , DUMP_PREFIX_OFFSET , buf , sizeof ( * info ) ) ; return GW_UNKNOWN ; } baseboard = info -> model [ 3 ] ; if ( strncasecmp ( ( const char * ) info -> model , \"GW5400-A\" , 8 ) == 0 ) { baseboard = '0' ; } type = GW_UNKNOWN ; switch ( baseboard ) { case '0' : type = GW54proto ; break ; case '1' : type = GW51xx ; break ; case '2' : type = GW52xx ; break ; case '3' : type = GW53xx ; break ; case '4' : type = GW54xx ; break ; case '5' : if ( info -> model [ 4 ] == '1' ) { type = GW551x ; break ; } if ( info -> model [ 4 ] == '2' ) { type = GW552x ; break ; } if ( info -> model [ 4 ] == '3' ) { type = GW553x ; break ; } break ; case '6' : if ( info -> model [ 4 ] == '0' ) { type = GW560x ; } break ; case '9' : if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '1' ) { type = GW5901 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '2' ) { type = GW5902 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '3' ) { type = GW5903 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '4' ) { type = GW5904 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '5' ) { type = GW5905 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '6' ) { type = GW5906 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '7' ) { type = GW5907 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '8' ) { type = GW5908 ; } if ( info -> model [ 4 ] == '0' && info -> model [ 5 ] == '9' ) { type = GW5909 ; } if ( info -> model [ 4 ] == '1' && info -> model [ 5 ] == '0' ) { type = GW5910 ; } if ( info -> model [ 4 ] == '1' && info -> model [ 5 ] == '2' ) { type = GW5912 ; } if ( info -> model [ 4 ] == '1' && info -> model [ 5 ] == '3' ) { type = GW5913 ; } break ; default : printf ( \"EEPROM: Unknown model in EEPROM: %s\\n\" , info -> model ) ; print_hex_dump_bytes ( \"\" , DUMP_PREFIX_OFFSET , buf , sizeof ( * info ) ) ; break ; } return type ; } struct ventana_eeprom_config econfig [ ] { { \"eth0\" \"ethernet0\" EECONFIG_ETH0 } { \"usb0\" NULL EECONFIG_USB0 } { \"usb1\" NULL EECONFIG_USB1 } { \"mmc0\" NULL EECONFIG_SD0 } { \"mmc1\" NULL EECONFIG_SD1 } { \"mmc2\" NULL EECONFIG_SD2 } { \"mmc3\" NULL EECONFIG_SD3 } { } } ; ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "__RCSID ( \"$NetBSD: fnmatch.c,v 1.24 2011/01/31 19:10:18 christos Exp $\" ) ; static inline int foldcase ( int ch , int flags ) { return ch ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int gcm_gen_table ( mbedtls_gcm_context * ctx ) { int ret , i , j ; uint64_t hi , lo ; uint64_t vl , vh ; unsigned char h [ 16 ] ; size_t olen = 0 ; if ( ( ret = mbedtls_cipher_update ( & ctx -> cipher_ctx , h , 16 , h , & olen ) ) != 0 ) { return ( ret ) ; } hi = MBEDTLS_GET_UINT32_BE ( h , 0 ) ; lo = MBEDTLS_GET_UINT32_BE ( h , 4 ) ; vh = ( uint64_t ) hi << 32 | lo ; hi = MBEDTLS_GET_UINT32_BE ( h , 8 ) ; lo = MBEDTLS_GET_UINT32_BE ( h , 12 ) ; vl = ( uint64_t ) hi << 32 | lo ; ctx -> HL [ 8 ] = vl ; ctx -> HH [ 8 ] = vh ; if ( mbedtls_aesni_has_support ( MBEDTLS_AESNI_CLMUL ) ) { return ( 0 ) ; } ctx -> HH [ 0 ] = 0 ; ctx -> HL [ 0 ] = 0 ; for ( i = 4 ; i > 0 ; i >>= 1 ) { uint32_t T = ( vl & 1 ) * 0xe1000000U ; vl = ( vh << 63 ) | ( vl >> 1 ) ; vh = ( vh >> 1 ) ^ ( ( uint64_t ) T << 32 ) ; ctx -> HL [ i ] = vl ; ctx -> HH [ i ] = vh ; } for ( i = 2 ; i <= 8 ; i *= 2 ) { uint64_t * HiL = ctx -> HL + i , * HiH = ctx -> HH + i ; vh = * HiH ; vl = * HiL ; for ( j = 1 ; j < i ; j ++ ) { HiH [ j ] = vh ^ ctx -> HH [ j ] ; HiL [ j ] = vl ^ ctx -> HL [ j ] ; } } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned tpg_calc_buffer_line ( const struct tpg_data * tpg , unsigned y , unsigned field ) { y += tpg -> compose . top ; switch ( field ) { case V4L2_FIELD_SEQ_TB : return y / 2 ; case V4L2_FIELD_SEQ_BT : if ( y & 1 ) { return y / 2 ; } return tpg -> buf_height / 2 + y / 2 ; default : return y ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool comm_session_exists ( pcep_socket_comm_handle * socket_comm_handle , pcep_socket_comm_session * socket_comm_session ) { return ( ordered_list_find ( socket_comm_handle -> session_list , socket_comm_session ) != NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ice_vf_vsi_cfg_dvm_legacy_vlan_mode ( struct ice_vsi * vsi ) { struct ice_vsi_vlan_ops * vlan_ops ; struct ice_vf * vf = vsi -> vf ; struct device * dev ; dev = ice_pf_to_dev ( vf -> pf ) ; if ( ! ice_is_dvm_ena ( & vsi -> back -> hw ) || ice_vf_is_port_vlan_ena ( vf ) ) { return ; } vlan_ops = & vsi -> outer_vlan_ops ; vlan_ops -> dis_rx_filtering = ice_vsi_dis_rx_vlan_filtering ; vlan_ops -> ena_rx_filtering = noop_vlan ; vlan_ops -> dis_tx_filtering = ice_vsi_dis_tx_vlan_filtering ; vlan_ops -> ena_tx_filtering = noop_vlan ; if ( vlan_ops -> dis_rx_filtering ( vsi ) ) { dev_dbg ( dev , \"Failed to disable Rx VLAN filtering for old VF without VIRTCHNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } if ( vlan_ops -> dis_tx_filtering ( vsi ) ) { dev_dbg ( dev , \"Failed to disable Tx VLAN filtering for old VF without VIRTHCNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } vlan_ops -> dis_stripping = ice_vsi_dis_outer_stripping ; vlan_ops -> dis_insertion = ice_vsi_dis_outer_insertion ; if ( vlan_ops -> dis_stripping ( vsi ) ) { dev_dbg ( dev , \"Failed to disable outer VLAN stripping for old VF without VIRTCHNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } if ( vlan_ops -> dis_insertion ( vsi ) ) { dev_dbg ( dev , \"Failed to disable outer VLAN insertion for old VF without VIRTCHNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } vlan_ops = & vsi -> inner_vlan_ops ; vlan_ops -> dis_stripping = ice_vsi_dis_outer_stripping ; vlan_ops -> dis_insertion = ice_vsi_dis_outer_insertion ; if ( vlan_ops -> dis_stripping ( vsi ) ) { dev_dbg ( dev , \"Failed to disable inner VLAN stripping for old VF without VIRTCHNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } if ( vlan_ops -> dis_insertion ( vsi ) ) { dev_dbg ( dev , \"Failed to disable inner VLAN insertion for old VF without VIRTCHNL_VF_OFFLOAD_VLAN_V2 support\\n\" ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct timespec64 timespec64_add_safe ( const struct timespec64 lhs , const struct timespec64 rhs ) { struct timespec64 res ; set_normalized_timespec64 ( & res , ( timeu64_t ) lhs . tv_sec + rhs . tv_sec , lhs . tv_nsec + rhs . tv_nsec ) ; if ( unlikely ( res . tv_sec < lhs . tv_sec || res . tv_sec < rhs . tv_sec ) ) { res . tv_sec = TIME64_MAX ; } return res ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int exynos_adc_enable_clk ( struct exynos_adc * info ) { int ret ; ret = clk_enable ( info -> clk ) ; if ( ret ) { dev_err ( info -> dev , \"failed enabling adc clock: %d\\n\" , ret ) ; return ret ; } if ( info -> data -> needs_sclk ) { ret = clk_enable ( info -> sclk ) ; if ( ret ) { clk_disable ( info -> clk , NULL ) ; dev_err ( info -> dev , \"failed enabling sclk_adc clock: %d\\n\" , ret ) ; return ret ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int picl_set_propval ( picl_prophdl_t proph , void * valbuf , size_t nbytes ) { door_arg_t darg ; picl_reqsetattrval_t ret_setattrval ; picl_reqsetattrval_t * inargs ; int err ; inargs = alloca ( sizeof ( picl_reqsetattrval_t ) + nbytes ) ; inargs -> cnum = PICL_CNUM_SETATTRVAL ; inargs -> attr = proph ; inargs -> bufsize = ( uint32_t ) nbytes ; if ( ( size_t ) inargs -> bufsize != nbytes ) { return ( PICL_VALUETOOBIG ) ; } ( void ) memcpy ( inargs -> valbuf , valbuf , nbytes ) ; err = trysend_req ( & darg , inargs , sizeof ( picl_reqsetattrval_t ) + nbytes , NULL , 0 , & ret_setattrval , sizeof ( picl_retsetattrval_t ) , SEND_REQ_TRYCOUNT ) ; if ( err != PICL_SUCCESS ) { return ( err ) ; } if ( darg . rbuf != ( char * ) & ret_setattrval ) { ( void ) munmap ( darg . rbuf , darg . rsize ) ; } return ( PICL_SUCCESS ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void vfio_display_finalize ( VFIOPCIDevice * vdev ) { if ( ! vdev -> dpy ) { return ; } graphic_console_close ( vdev -> dpy -> con ) ; vfio_display_dmabuf_exit ( vdev -> dpy , NULL ) ; vfio_display_region_exit ( vdev -> dpy ) ; vfio_display_edid_exit ( vdev -> dpy ) ; g_free ( vdev -> dpy ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int amdgpu_vce_get_destroy_msg ( struct amdgpu_ring * ring , uint32_t handle , bool direct , struct dma_fence * * fence ) { const unsigned ib_size_dw = 1024 ; struct amdgpu_job * job ; struct amdgpu_ib * ib ; struct dma_fence * f = NULL ; int i , r ; r = amdgpu_job_alloc_with_ib ( ring -> adev , ib_size_dw * 4 , & job ) ; ib = & job -> ibs [ 0 ] ; ib -> length_dw = 0 ; ib -> ptr [ ib -> length_dw ++ ] = 0x0000000c ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000001 ; ib -> ptr [ ib -> length_dw ++ ] = handle ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000020 ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000002 ; ib -> ptr [ ib -> length_dw ++ ] = 0xffffffff ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000001 ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000000 ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000000 ; ib -> ptr [ ib -> length_dw ++ ] = 0xffffffff ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000000 ; ib -> ptr [ ib -> length_dw ++ ] = 0x00000008 ; ib -> ptr [ ib -> length_dw ++ ] = 0x02000001 ; for ( i = ib -> length_dw ; i < ib_size_dw ; ++ i ) { ib -> ptr [ i ] = 0x0 ; } if ( direct ) { r = amdgpu_ib_schedule ( ring , 1 , ib , NULL , & f ) ; job -> fence = dma_fence_get ( f ) ; if ( r ) { err } amdgpu_job_free ( job ) ; } else { r = amdgpu_job_submit ( job , ring , & ring -> adev -> vce . entity , AMDGPU_FENCE_OWNER_UNDEFINED , & f ) ; if ( r ) { err } } if ( fence ) { * fence = dma_fence_get ( f ) ; } dma_fence_put ( f ) ; return 0 ; err amdgpu_job_free ( job ) ; return r ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int uow_read ( struct uow_softc * sc , void * buf , int len ) { usbd_status error ; int count ; if ( len > DS2490_DATAFIFOSIZE ) { printf ( \"%s: read %d bytes, xfer too big\\n\" , sc -> sc_dev . dv_xname , len ) ; return ( - 1 ) ; } usbd_setup_xfer ( sc -> sc_xfer_in , sc -> sc_ph_ibulk , sc , buf , len , USBD_SHORT_XFER_OK | USBD_SYNCHRONOUS , UOW_TIMEOUT , NULL ) ; error = usbd_transfer ( sc -> sc_xfer_in ) ; if ( error != 0 ) { printf ( \"%s: read failed, len %d: %s\\n\" , sc -> sc_dev . dv_xname , len , usbd_errstr ( error ) ) ; uow_reset ( sc , NULL ) ; return ( - 1 ) ; } usbd_get_xfer_status ( sc -> sc_xfer_in , NULL , NULL , & count , & error ) ; return ( count ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct virtqueue * virtio_mmio_setup_vq ( struct udevice * udev , unsigned int index ) { struct virtio_mmio_priv * priv = dev_get_priv ( udev ) ; struct virtqueue * vq ; int num ; int err ; writel ( index , priv -> base + VIRTIO_MMIO_QUEUE_SEL ) ; if ( readl ( priv -> base + ( priv -> version == 1 ?VIRTIO_MMIO_QUEUE_PFN : VIRTIO_MMIO_QUEUE_READY ) ) ) { err = - ENOENT ; error_available } num = readl ( priv -> base + VIRTIO_MMIO_QUEUE_NUM_MAX ) ; if ( num == 0 ) { err = - ENOENT ; error_new_virtqueue } vq = vring_create_virtqueue ( index , num , VIRTIO_MMIO_VRING_ALIGN , udev ) ; if ( ! vq ) { err = - ENOMEM ; error_new_virtqueue } writel ( virtqueue_get_vring_size ( vq ) , priv -> base + VIRTIO_MMIO_QUEUE_NUM ) ; if ( priv -> version == 1 ) { u64 q_pfn = virtqueue_get_desc_addr ( vq ) >> PAGE_SHIFT ; if ( q_pfn >> 32 ) { debug ( \"platform bug: legacy virtio-mmio must not be used with RAM above 0x%llxGB\\n\" , 0x1ULL << ( 32 + PAGE_SHIFT - 30 ) ) ; err = - E2BIG ; error_bad_pfn } writel ( PAGE_SIZE , priv -> base + VIRTIO_MMIO_QUEUE_ALIGN ) ; writel ( q_pfn , priv -> base + VIRTIO_MMIO_QUEUE_PFN ) ; } else { u64 addr ; addr = virtqueue_get_desc_addr ( vq ) ; writel ( ( u32 ) addr , priv -> base + VIRTIO_MMIO_QUEUE_DESC_LOW ) ; writel ( ( u32 ) ( addr >> 32 ) , priv -> base + VIRTIO_MMIO_QUEUE_DESC_HIGH ) ; addr = virtqueue_get_avail_addr ( vq ) ; writel ( ( u32 ) addr , priv -> base + VIRTIO_MMIO_QUEUE_AVAIL_LOW ) ; writel ( ( u32 ) ( addr >> 32 ) , priv -> base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH ) ; addr = virtqueue_get_used_addr ( vq ) ; writel ( ( u32 ) addr , priv -> base + VIRTIO_MMIO_QUEUE_USED_LOW ) ; writel ( ( u32 ) ( addr >> 32 ) , priv -> base + VIRTIO_MMIO_QUEUE_USED_HIGH ) ; writel ( 1 , priv -> base + VIRTIO_MMIO_QUEUE_READY ) ; } return vq ; error_bad_pfn vring_del_virtqueue ( vq ) ; error_new_virtqueue if ( priv -> version == 1 ) { writel ( 0 , priv -> base + VIRTIO_MMIO_QUEUE_PFN ) ; } else { writel ( 0 , priv -> base + VIRTIO_MMIO_QUEUE_READY ) ; WARN_ON ( readl ( priv -> base + VIRTIO_MMIO_QUEUE_READY ) ) ; } error_available return ERR_PTR ( err ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static inline void prom_putchar_wait ( void __iomem * reg , u32 val ) { u32 t ; { t = __raw_readl ( reg ) ; } 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int regmap_i2c_smbus_i2c_write ( void * context , const void * data , size_t count ) { struct device * dev = context ; struct i2c_client * i2c = to_i2c_client ( dev ) ; -- count ; return i2c_smbus_write_i2c_block_data ( i2c , ( ( u8 * ) data ) [ 0 ] , count , ( ( u8 * ) data + 1 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct page * ll_get_dir_page ( struct inode * dir , struct md_op_data * op_data , __u64 offset ) { struct md_callback cb_op ; struct page * page ; int rc ; cb_op . md_blocking_ast = ll_md_blocking_ast ; rc = md_read_page ( ll_i2mdexp ( dir ) , op_data , & cb_op , offset , & page ) ; return page ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pfn_is_nosave ( unsigned long pfn ) { unsigned long nosave_begin_pfn ; unsigned long nosave_end_pfn ; nosave_begin_pfn = __pa_symbol ( & __nosave_begin ) >> PAGE_SHIFT ; nosave_end_pfn = PAGE_ALIGN ( __pa_symbol ( & __nosave_end ) ) >> PAGE_SHIFT ; return pfn >= nosave_begin_pfn && pfn < nosave_end_pfn ; } restore_data_record { unsigned long jump_address ; unsigned long jump_address_phys ; cfs_time_t cr3 ; unsigned long magic ; unsigned long e820_checksum ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sx150x_probe ( struct i2c_client * client , const struct i2c_device_id * id ) { static const u32 i2c_funcs = I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WRITE_WORD_DATA ; struct device * dev = & client -> dev ; struct sx150x_pinctrl * pctl ; int ret ; if ( ! i2c_check_functionality ( client -> adapter , i2c_funcs ) ) { return - ENOSYS ; } pctl = devm_kzalloc ( dev , sizeof ( * pctl ) , GFP_KERNEL ) ; i2c_set_clientdata ( client , pctl ) ; pctl -> dev = dev ; pctl -> client = client ; if ( dev -> of_node ) { pctl -> data = of_device_get_match_data ( dev ) ; } else { pctl -> data = ( sx150x_device_data * ) id -> driver_data ; } if ( ! pctl -> data ) { return - EINVAL ; } pctl -> regmap = devm_regmap_init ( dev , NULL , pctl , & sx150x_regmap_config ) ; if ( IS_ERR ( pctl -> regmap ) ) { ret = PTR_ERR ( pctl -> regmap ) ; dev_err ( dev , \"Failed to allocate register map: %d\\n\" , ret ) ; return ret ; } mutex_init ( & pctl -> lock ) ; ret = sx150x_init_hw ( pctl ) ; if ( ret ) { return ret ; } pctl -> gpio . label = devm_kstrdup ( dev , client -> name , GFP_KERNEL ) ; pctl -> gpio . base = - 1 ; pctl -> gpio . ngpio = pctl -> data -> npins ; pctl -> gpio . get_direction = sx150x_gpio_get_direction ; pctl -> gpio . direction_input = sx150x_gpio_direction_input ; pctl -> gpio . direction_output = sx150x_gpio_direction_output ; pctl -> gpio . get = sx150x_gpio_get ; pctl -> gpio . set = sx150x_gpio_set ; pctl -> gpio . set_config = gpiochip_generic_config ; pctl -> gpio . parent = dev ; pctl -> gpio . of_node = dev -> of_node ; pctl -> gpio . can_sleep = true ; if ( pctl -> data -> model != SX150X_789 ) { pctl -> gpio . set_multiple = sx150x_gpio_set_multiple ; } ret = devm_gpiochip_add_data ( dev , & pctl -> gpio , pctl ) ; if ( ret ) { return ret ; } if ( client -> irq > 0 ) { pctl -> irq_chip . name = devm_kstrdup ( dev , client -> name , GFP_KERNEL ) ; pctl -> irq_chip . irq_mask = sx150x_irq_mask ; pctl -> irq_chip . irq_unmask = sx150x_irq_unmask ; pctl -> irq_chip . irq_set_type = sx150x_irq_set_type ; pctl -> irq_chip . irq_bus_lock = sx150x_irq_bus_lock ; pctl -> irq_chip . irq_bus_sync_unlock = sx150x_irq_bus_sync_unlock ; pctl -> irq . masked = ~ 0 ; pctl -> irq . sense = 0 ; ret = gpiochip_irqchip_add_nested ( & pctl -> gpio , & pctl -> irq_chip , 0 , handle_bad_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( dev , \"could not connect irqchip to gpiochip\\n\" ) ; return ret ; } ret = devm_request_threaded_irq ( dev , client -> irq , NULL , sx150x_irq_thread_fn , IRQF_ONESHOT | IRQF_SHARED | IRQF_TRIGGER_FALLING , pctl -> irq_chip . name , pctl ) ; if ( ret < 0 ) { return ret ; } gpiochip_set_nested_irqchip ( & pctl -> gpio , & pctl -> irq_chip , client -> irq ) ; } pctl -> pinctrl_desc . name = \"sx150x-pinctrl\" ; pctl -> pinctrl_desc . pctlops = & sx150x_pinctrl_ops ; pctl -> pinctrl_desc . confops = & sx150x_pinconf_ops ; pctl -> pinctrl_desc . pins = pctl -> data -> pins ; pctl -> pinctrl_desc . npins = pctl -> data -> npins ; pctl -> pinctrl_desc . owner = THIS_MODULE ; pctl -> pctldev = pinctrl_register ( & pctl -> pinctrl_desc , dev , pctl ) ; if ( IS_ERR ( pctl -> pctldev ) ) { dev_err ( dev , \"Failed to register pinctrl device\\n\" ) ; return PTR_ERR ( pctl -> pctldev ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void hmm_reserved_pool_exit ( void * * pool ) { unsigned long flags ; int i , ret ; unsigned int pgnr ; struct hmm_reserved_pool_info * repool_info = * pool ; if ( ! repool_info ) { return ; } spin_lock_irqsave ( & repool_info -> list_lock , flags ) ; if ( ! repool_info -> initialized ) { spin_unlock_irqrestore ( & repool_info -> list_lock , flags ) ; return ; } pgnr = repool_info -> pgnr ; repool_info -> index = 0 ; repool_info -> initialized = false ; spin_unlock_irqrestore ( & repool_info -> list_lock , flags ) ; for ( i = 0 ; i < pgnr ; i ++ ) { ret = set_pages_wb ( repool_info -> pages [ i ] , 1 ) ; if ( ret ) { dev_err ( atomisp_dev , \"set page to WB err...ret=%d\\n\" , ret ) ; } if ( ! ret ) { __free_pages ( repool_info -> pages [ i ] , 0 ) ; } } kfree ( repool_info -> pages ) ; kfree ( repool_info ) ; * pool = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void notify_waitpid_callback_by_pid ( pid_t pid , int status ) { waitpid_callback_t search , * ent ; search . pid = pid ; ent = HT_REMOVE ( process_map , & process_map , & search ) ; if ( ! ent || ! ent -> running ) { log_info ( LD_GENERAL , \"Child process %u has exited; no callback was \" \"registered\" , ( unsigned ) pid ) ; return ; } log_info ( LD_GENERAL , \"Child process %u has exited; running callback.\" , ( unsigned ) pid ) ; ent -> userfn ( status , ent -> userdata ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "MODULE_LICENSE ( \"GPL\" ) ; module_param ( ipddp_mode , int , 0 ) ; static int __init ipddp_init_module ( void ) { dev_ipddp = ipddp_init ( ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int simple_unlink ( struct inode * dir , struct dentry * dentry ) { struct inode * inode = d_inode ( dentry ) ; inode -> i_ctime = dir -> i_ctime = dir -> i_mtime = current_time ( inode ) ; drop_nlink ( inode , NULL ) ; dput ( dentry ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void swake_up_locked ( struct swait_queue_head * q ) { struct swait_queue * curr ; curr = list_first_entry ( & q -> task_list , typeof ( * curr ) , task_list ) ; wake_up_process ( curr -> task ) ; list_del_init ( & curr -> task_list ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ld9040_clear_error ( struct ld9040 * ctx ) { int ret = ctx -> error ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int lapic_set_local_intr ( struct vm * vm , int cpu , int vector ) { struct vlapic * vlapic ; cpuset_t dmask ; int error ; if ( cpu == - 1 ) { dmask = vm_active_cpus ( vm ) ; } else { CPU_SETOF ( cpu , & dmask ) ; } error = 0 ; while ( ( cpu = CPU_FFS ( & dmask ) ) != 0 ) { cpu -- ; CPU_CLR ( cpu , & dmask ) ; vlapic = vm_lapic ( vm , cpu ) ; error = vlapic_trigger_lvt ( vlapic , vector ) ; if ( error ) { break ; } } return ( error ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void CondenseV6 ( char * s ) { size_t len = strlen ( s ) ; char * p , * q ; p = s + 7 ; * p ++ = '.' ; * p ++ = '.' ; q = s + len - 7 ; while ( * q ) { * p ++ = * q ++ ; } * p = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct drm_plane_state * mdp5_plane_duplicate_state ( struct drm_plane * plane ) { struct mdp5_plane_state * mdp5_state ; if ( WARN_ON ( ! plane -> state ) ) { return in ; } mdp5_state = kmemdup ( to_mdp5_plane_state ( plane -> state ) , sizeof ( * mdp5_state ) , GFP_KERNEL ) ; if ( ! mdp5_state ) { return NULL ; } __drm_atomic_helper_plane_duplicate_state ( plane , & mdp5_state -> base ) ; return & mdp5_state -> base ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static OM_uint32 do_exported_netname ( dh_context_t ctx , OM_uint32 * minor , gss_buffer_t input , gss_name_t * output ) { const char tokid [ ] \"\\x04\\x01\" ; ; const int tokid_len = 2 ; const int OIDlen_len = 2 ; const int namelen_len = 4 ; unsigned char * p = ( unsigned char * ) input -> value ; OM_uint32 len = input -> length ; int mechoidlen ; OM_uint32 oidlen ; OM_uint32 namelen ; OM_uint32 currlen ; OM_uint32 bytes ; * minor = DH_BADARG_FAILURE ; if ( len < tokid_len + OIDlen_len + namelen_len ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( memcmp ( p , tokid , tokid_len ) != 0 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } p += tokid_len ; oidlen = ( * p ++ << 8 ) & 0xff00 ; oidlen |= * p ++ & 0xff ; if ( len < tokid_len + OIDlen_len + oidlen + namelen_len ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( * p ++ != 0x06 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } currlen = len - ( tokid_len + OIDlen_len + oidlen + namelen_len ) ; if ( ( mechoidlen = get_der_length ( & p , currlen , & bytes ) ) < 0 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( mechoidlen != ctx -> mech -> length ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( memcmp ( p , ctx -> mech -> elements , mechoidlen ) != 0 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } p += mechoidlen ; namelen = ( * p ++ << 24 ) & 0xff000000 ; namelen |= ( * p ++ << 16 ) & 0xff0000 ; namelen |= ( * p ++ << 8 ) & 0xff00 ; namelen |= * p ++ & 0xff ; if ( len < tokid_len + OIDlen_len + oidlen + namelen_len + namelen ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } oidlen = ( * p ++ << 8 ) & 0xff00 ; oidlen = * p ++ & 0xff ; if ( namelen < OIDlen_len + oidlen ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( oidlen != __DH_GSS_C_NT_NETNAME -> length ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } if ( memcmp ( p , __DH_GSS_C_NT_NETNAME -> elements , __DH_GSS_C_NT_NETNAME -> length ) != 0 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } p += oidlen ; if ( namelen != OIDlen_len + oidlen + strlen ( ( char * ) p ) + 1 ) { return ( GSS_S_DEFECTIVE_TOKEN ) ; } * output = ( gss_name_t ) strdup ( ( char * ) p ) ; if ( * output ) { * minor = 0 ; return ( GSS_S_COMPLETE ) ; } * minor = DH_NOMEM_FAILURE ; return ( GSS_S_FAILURE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int amdgpu_framebuffer_init ( struct drm_device * dev , struct amdgpu_framebuffer * rfb , const struct drm_mode_fb_cmd2 * mode_cmd , struct drm_gem_object * obj ) { int ret ; rfb -> obj = obj ; drm_helper_mode_fill_fb_struct ( dev , & rfb -> base , mode_cmd ) ; ret = drm_framebuffer_init ( dev , & rfb -> base , & amdgpu_fb_funcs ) ; if ( ret ) { return ret ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void crm_remote_peer_cache_refresh ( xmlNode * cib ) { struct refresh_data data ; crm_peer_init ( ) ; g_hash_table_foreach ( crm_remote_peer_cache , mark_dirty , NULL ) ; data . field = \"id\" ; data . has_state = TRUE ; crm_foreach_xpath_result ( cib , PCMK__XP_REMOTE_NODE_STATUS , remote_cache_refresh_helper , & data ) ; data . field = \"value\" ; data . has_state = FALSE ; crm_foreach_xpath_result ( cib , PCMK__XP_GUEST_NODE_CONFIG , remote_cache_refresh_helper , & data ) ; data . field = \"id\" ; data . has_state = FALSE ; crm_foreach_xpath_result ( cib , PCMK__XP_REMOTE_NODE_CONFIG , remote_cache_refresh_helper , & data ) ; g_hash_table_foreach_remove ( crm_remote_peer_cache , is_dirty ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int generic_exec_single ( int cpu , struct call_single_data * csd , smp_call_func_t func , void * info ) { if ( cpu == smp_processor_id ( ) ) { unsigned long flags ; csd_unlock ( csd , NULL ) ; local_irq_save ( flags ) ; func ( info ) ; local_irq_restore ( flags ) ; return 0 ; } if ( ( unsigned ) cpu >= nr_cpu_ids || ! cpu_online ( cpu ) ) { csd_unlock ( csd ) ; return - ENXIO ; } csd -> func = func ; csd -> info = info ; if ( llist_add ( & csd -> llist , & per_cpu ( call_single_queue , cpu ) ) ) { arch_send_call_function_single_ipi ( cpu ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void rzg2l_wdt_reset_assert_pm_disable ( void * data ) { struct watchdog_device * wdev = data ; struct rzg2l_wdt_priv * priv = watchdog_get_drvdata ( wdev ) ; pm_runtime_disable ( wdev -> parent ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fdomain_detach ( struct pcmcia_device * link ) { dev_dbg ( & link -> dev , \"fdomain_detach\\n\" ) ; kfree ( link -> priv ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int ea_foreach_i ( struct gfs2_inode * ip , struct buffer_head * bh , ea_call_t ea_call , void * data ) { struct gfs2_ea_header * ea , * prev = NULL ; int error = 0 ; if ( gfs2_metatype_check ( GFS2_SB ( & ip -> i_inode ) , bh , GFS2_METATYPE_EA ) ) { return - EIO ; } for ( ea = GFS2_EA_BH2FIRST ( bh ) ; ; prev = ea , ea = GFS2_EA2NEXT ( ea ) ) { if ( ! GFS2_EA_REC_LEN ( ea ) ) { fail } if ( ! ( bh -> b_data <= ( char * ) ea && ( char * ) GFS2_EA2NEXT ( ea ) <= bh -> b_data + bh -> b_size ) ) { fail } if ( ! GFS2_EATYPE_VALID ( ea -> ea_type ) ) { fail } error = ea_call ( ip , bh , ea , prev , data ) ; if ( GFS2_EA_IS_LAST ( ea ) ) { if ( ( char * ) GFS2_EA2NEXT ( ea ) != bh -> b_data + bh -> b_size ) { fail } break ; } } return error ; fail gfs2_consist_inode ( ip ) ; return - EIO ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int bcmbsc_read ( struct bcmbsc_softc * sc , uint8_t * buf , size_t buflen ) { int i , error ; for ( i = 0 ; i < buflen ; i ++ ) { error = bcmbsc_wait ( sc , BSC_S_RXD , BSC_S_RXD ) ; buf [ i ] = HREAD4 ( sc , BSC_FIFO ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "irc_init ( ) { static int done_init = FALSE ; char * buf ; if ( done_init ) { return ; } done_init = TRUE ; plugin_add ( sess , NULL , NULL , timer_plugin_init , NULL , NULL , FALSE ) ; plugin_add ( sess , NULL , NULL , identd_plugin_init , identd_plugin_deinit , NULL , FALSE ) ; if ( ! arg_skip_plugins ) { plugin_auto_load ( sess ) ; } plugin_add ( sess , NULL , NULL , dbus_plugin_init , NULL , NULL , FALSE ) ; hexchat_reinit_timers ( ) ; if ( arg_url != NULL ) { buf = g_strdup_printf ( \"server %s\" , arg_url ) ; g_free ( arg_url ) ; handle_command ( sess , buf , FALSE ) ; } if ( arg_urls != NULL ) { guint i ; for ( i = 0 ; i < g_strv_length ( arg_urls ) ; i ++ ) { buf = g_strdup_printf ( \"%s %s\" , i == 0 ?\"server\" : \"newserver\" , arg_urls [ i ] ) ; handle_command ( sess , buf , FALSE ) ; g_free ( buf ) ; } g_strfreev ( arg_urls ) ; } if ( arg_command != NULL ) { handle_command ( sess , arg_command , FALSE ) ; g_free ( arg_command ) ; } load_perform_file ( sess , \"startup.txt\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "DAT_RETURN dat_evd_enable ( IN DAT_EVD_HANDLE evd_handle ) { return ( DAT_EVD_ENABLE ( evd_handle ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void smbios_ep_initializer ( struct smbios_entry_point * smbios_ep , uint32_t staddr ) { memcpy ( smbios_ep -> eanchor , SMBIOS_ENTRY_EANCHOR , SMBIOS_ENTRY_EANCHORLEN ) ; smbios_ep -> eplen = 0x1F ; assert ( sizeof ( smbios_entry_point ) == smbios_ep -> eplen ) ; smbios_ep -> major = 2 ; smbios_ep -> minor = 6 ; smbios_ep -> revision = 0 ; memcpy ( smbios_ep -> ianchor , SMBIOS_ENTRY_IANCHOR , SMBIOS_ENTRY_IANCHORLEN ) ; smbios_ep -> staddr = staddr ; smbios_ep -> bcdrev = ( smbios_ep -> major & 0xf ) << 4 | ( smbios_ep -> minor & 0xf ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int topoprop_indicator_add ( indicator_t * * indp , char * ind_name , char * ind_action ) { indicator_t * newindp ; ind_state_t state ; char * name ; newindp = new_indicator ( state , name , ind_action ) ; link_indicator ( indp , newindp ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int greybus_uevent ( struct device * dev , struct kobj_uevent_env * env ) { struct gb_host_device * hd ; struct gb_module * module = NULL ; struct gb_interface * intf = NULL ; struct gb_control * control = NULL ; struct gb_bundle * bundle = NULL ; struct gb_svc * svc = NULL ; if ( is_gb_host_device ( dev ) ) { hd = to_gb_host_device ( dev ) ; } if ( is_gb_module ( dev ) ) { module = to_gb_module ( dev ) ; hd = module -> hd ; } if ( is_gb_interface ( dev ) ) { intf = to_gb_interface ( dev ) ; module = intf -> module ; hd = intf -> hd ; } if ( is_gb_control ( dev ) ) { control = to_gb_control ( dev ) ; intf = control -> intf ; module = intf -> module ; hd = intf -> hd ; } if ( is_gb_bundle ( dev ) ) { bundle = to_gb_bundle ( dev ) ; intf = bundle -> intf ; module = intf -> module ; hd = intf -> hd ; } if ( is_gb_svc ( dev ) ) { svc = to_gb_svc ( dev ) ; hd = svc -> hd ; } else { dev_WARN ( dev , \"uevent for unknown greybus device \\\"type\\\"!\\n\" ) ; return - EINVAL ; } if ( add_uevent_var ( env , \"BUS=%u\" , hd -> bus_id ) ) { return - ENOMEM ; } if ( module ) { if ( add_uevent_var ( env , \"MODULE=%u\" , module -> module_id ) ) { return - ENOMEM ; } } if ( intf ) { if ( add_uevent_var ( env , \"GREYBUS_ID=%08x/%08x\" , intf -> vendor_id , intf -> product_id ) ) { return - ENOMEM ; } } if ( bundle ) { if ( add_uevent_var ( env , \"BUNDLE=%u\" , bundle -> id ) ) { return - ENOMEM ; } if ( add_uevent_var ( env , \"BUNDLE_CLASS=%02x\" , bundle -> class ) ) { return - ENOMEM ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "char * topo_strdirname ( char * s ) { static char slash [ ] \"/\" ; ; static char dot [ ] \".\" ; ; char * p ; for ( p = s + strlen ( s ) ; p != s && * -- p == '/' ; ) { continue ; } if ( p == s && * p == '/' ) { return ( slash ) ; } while ( p != s ) { if ( * -- p == '/' ) { while ( * p == '/' && p != s ) { p -- ; } * ++ p = '\\0' ; return ( s ) ; } } return ( dot ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( int argc , char * * argv ) { int search_tag , i , any ; char stag [ 4 ] ; if ( argc <= 1 ) { fprintf ( stderr , \"Usage: tag files\\n\" ) ; return ( 2 ) ; } if ( strlen ( argv [ 1 ] ) > 4 || argv [ 1 ] [ 0 ] == '\\0' ) { fprintf ( stderr , \"Bad tag, must contain at least one and at most 4 characters.\\n\" ) ; return ( 2 ) ; } memset ( stag , ' ' , sizeof ( stag ) ) ; stag [ 0 ] = argv [ 1 ] [ 0 ] ; if ( argv [ 1 ] [ 1 ] != '\\0' ) { stag [ 1 ] = argv [ 1 ] [ 1 ] ; if ( argv [ 1 ] [ 2 ] != '\\0' ) { stag [ 2 ] = argv [ 1 ] [ 2 ] ; if ( argv [ 1 ] [ 3 ] != '\\0' ) { stag [ 3 ] = argv [ 1 ] [ 3 ] ; } } } search_tag = CHR ( stag [ 0 ] , stag [ 1 ] , stag [ 2 ] , stag [ 3 ] ) ; any = false ; for ( i = 2 ; i < argc ; ++ i ) { FILE * ttf = fopen ( argv [ i ] , \"rb\" ) ; if ( ttf == NULL ) { fprintf ( stderr , \"Failed to open %s\\n\" , argv [ i ] ) ; } else { if ( readttfheader ( ttf , search_tag ) ) { printf ( \"%s contains table %s\\n\" , argv [ i ] , argv [ 1 ] ) ; any = true ; } fclose ( ttf , NULL ) ; } } return ( ! any ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void qla4xxx_dump_buffer ( void * b , uint32_t size ) { int cnt ; uint8_t * c = b ; printk ( \" 0   1   2   3   4   5   6   7   8   9  Ah  Bh  Ch  Dh  Eh  \" \"Fh\\n\" ) ; printk ( \"------------------------------------------------------------\" \"--\\n\" ) ; for ( cnt = 0 ; cnt < size ; c ++ ) { printk ( \"%02x\" , * c ) ; if ( ! ( ++ cnt % 16 ) ) { printk ( \"\\n\" ) ; } else { printk ( \"  \" ) ; } } printk ( KERN_INFO \"\\n\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool ex_handler_fixup ( const struct exception_table_entry * ex , struct pt_regs * regs ) { regs -> csr_era = get_ex_fixup ( ex , NULL ) ; return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int librsvg_decode_frame ( AVCodecContext * avctx , AVFrame * frame , int * got_frame , AVPacket * pkt ) { int ret ; LibRSVGContext * s = avctx -> priv_data ; RsvgHandle * handle ; RsvgDimensionData unscaled_dimensions , dimensions ; cairo_surface_t * image ; cairo_t * crender = NULL ; GError * error = NULL ; * got_frame = 0 ; handle = rsvg_handle_new_from_data ( pkt -> data , pkt -> size , & error ) ; if ( error ) { av_log ( avctx , AV_LOG_ERROR , \"Error parsing svg!\\n\" ) ; g_error_free ( error ) ; return AVERROR_INVALIDDATA ; } rsvg_handle_get_dimensions ( handle , & dimensions ) ; rsvg_handle_get_dimensions ( handle , & unscaled_dimensions ) ; dimensions . width = s -> width ?s -> width : dimensions . width ; dimensions . height = s -> height ?s -> height : dimensions . height ; if ( s -> keep_ar && ( s -> width || s -> height ) ) { double default_ar = unscaled_dimensions . width / ( double ) unscaled_dimensions . height ; if ( ! s -> width ) { dimensions . width = lrintf ( dimensions . height * default_ar ) ; } else { dimensions . height = lrintf ( dimensions . width / default_ar ) ; } } if ( ( ret = ff_set_dimensions ( avctx , dimensions . width , dimensions . height ) ) ) { return ret ; } avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) ) { return ret ; } frame -> pict_type = AV_PICTURE_TYPE_I ; frame -> key_frame = 1 ; image = cairo_image_surface_create_for_data ( frame -> data [ 0 ] , CAIRO_FORMAT_ARGB32 , frame -> width , frame -> height , frame -> linesize [ 0 ] ) ; if ( cairo_surface_status ( image ) != CAIRO_STATUS_SUCCESS ) { return AVERROR_INVALIDDATA ; } crender = cairo_create ( image ) ; cairo_save ( crender ) ; cairo_set_operator ( crender , CAIRO_OPERATOR_CLEAR ) ; cairo_paint ( crender , NULL ) ; cairo_restore ( crender ) ; cairo_scale ( crender , dimensions . width / ( double ) unscaled_dimensions . width , dimensions . height / ( double ) unscaled_dimensions . height ) ; rsvg_handle_render_cairo ( handle , crender ) ; cairo_destroy ( crender ) ; cairo_surface_destroy ( image ) ; g_object_unref ( handle ) ; * got_frame = 1 ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int create_apid_dir ( uint64_t apid , uid_t uid , gid_t gid ) { int rc = 0 ; char * apid_dir = NULL ; apid_dir = xstrdup_printf ( LEGACY_SPOOL_DIR \"%\" PRIu64 , apid ) ; rc = mkdir ( apid_dir , 0700 ) ; if ( rc ) { CRAY_ERR ( \"mkdir %s failed: %m\" , apid_dir ) ; return SLURM_ERROR ; } rc = chown ( apid_dir , uid , gid ) ; if ( rc ) { CRAY_ERR ( \"chown %s, %u, %u failed: %m\" , apid_dir , uid , gid ) ; xfree ( apid_dir ) ; return SLURM_ERROR ; } if ( apid != SLURM_ID_HASH_LEGACY ( apid ) ) { char * oldapid_dir = xstrdup_printf ( LEGACY_SPOOL_DIR \"%\" PRIu64 , SLURM_ID_HASH_LEGACY ( apid ) ) ; if ( symlink ( apid_dir , oldapid_dir ) ) { CRAY_ERR ( \"symlink %s, %s failed: %m\" , apid_dir , oldapid_dir ) ; xfree ( apid_dir ) ; xfree ( oldapid_dir ) ; return SLURM_ERROR ; } xfree ( oldapid_dir ) ; } xfree ( apid_dir ) ; return SLURM_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int http_MakeMessage ( membuffer * buf , int http_major_version , int http_minor_version , const char * fmt , ... ) { char c ; char * s = NULL ; int num ; off_t bignum ; size_t length ; time_t * loc_time ; time_t curr_time ; struct tm date_storage ; struct tm * date ; const char * start_str ; const char * end_str ; int status_code ; const char * status_msg ; http_method_t method ; const char * method_str ; const char * url_str ; const char * temp_str ; uri_type url ; uri_type * uri_ptr ; int error_code = 0 ; va_list argp ; char tempbuf [ 200 ] ; const char * weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\" ; const char * month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\" \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\" ; int rc = 0 ; memset ( tempbuf , 0 , sizeof ( tempbuf ) ) ; va_start ( argp , fmt ) ; while ( ( c = * fmt ++ ) ) { if ( c == 's' ) { s = ( char * ) va_arg ( argp , char * ) ; assert ( s ) ; UpnpPrintf ( UPNP_ALL , HTTP , __FILE__ , __LINE__ , \"Adding a string : %s\\n\" , s ) ; if ( membuffer_append ( buf , s , strlen ( s ) ) ) { error_handler } } if ( c == 'K' ) { if ( membuffer_append ( buf , \"TRANSFER-ENCODING: chunked\\r\\n\" , strlen ( \"Transfer-Encoding: chunked\\r\\n\" ) ) ) { error_handler } } if ( c == 'G' ) { struct SendInstruction * RespInstr ; RespInstr = ( SendInstruction * ) va_arg ( argp , SendInstruction * ) ; assert ( RespInstr ) ; if ( membuffer_append ( buf , RespInstr -> RangeHeader , strlen ( RespInstr -> RangeHeader ) ) ) { error_handler } } if ( c == 'b' ) { s = ( char * ) va_arg ( argp , char * ) ; UpnpPrintf ( UPNP_ALL , HTTP , __FILE__ , __LINE__ , \"Adding a char Buffer starting with: %c\\n\" , ( int ) s [ 0 ] ) ; assert ( s ) ; length = ( size_t ) va_arg ( argp , size_t ) ; if ( membuffer_append ( buf , s , length ) ) { error_handler } } if ( c == 'c' ) { if ( membuffer_append ( buf , \"\\r\\n\" , ( size_t ) 2 ) ) { error_handler } } if ( c == 'd' ) { num = ( size_t ) va_arg ( argp , int ) ; rc = snprintf ( tempbuf , sizeof ( tempbuf ) , \"%\" PRIzu , num ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( tempbuf ) || membuffer_append ( buf , tempbuf , strlen ( tempbuf ) ) ) { error_handler } } if ( c == 'h' ) { bignum = ( off_t ) va_arg ( argp , off_t ) ; rc = snprintf ( tempbuf , sizeof ( tempbuf ) , \"%\" PRId64 , ( int64_t ) bignum ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( tempbuf ) || membuffer_append ( buf , tempbuf , strlen ( tempbuf ) ) ) { error_handler } } if ( c == 't' || c == 'D' ) { if ( c == 'D' ) { start_str = \"DATE: \" ; end_str = \"\\r\\n\" ; curr_time = time ( NULL ) ; loc_time = & curr_time ; } else { start_str = end_str = \"\" ; loc_time = ( time_t * ) va_arg ( argp , time_t * ) ; } assert ( loc_time ) ; date = http_gmtime_r ( loc_time , & date_storage ) ; if ( date == NULL ) { error_handler } rc = snprintf ( tempbuf , sizeof ( tempbuf ) , \"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\" , start_str , & weekday_str [ date -> tm_wday * 4 ] , date -> tm_mday , & month_str [ date -> tm_mon * 4 ] , date -> tm_year + 1900 , date -> tm_hour , date -> tm_min , date -> tm_sec , end_str ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( tempbuf ) || membuffer_append ( buf , tempbuf , strlen ( tempbuf ) ) ) { error_handler } } if ( c == 'L' ) { struct SendInstruction * RespInstr ; RespInstr = ( SendInstruction * ) va_arg ( argp , SendInstruction * ) ; assert ( RespInstr ) ; if ( strcmp ( RespInstr -> AcceptLanguageHeader , \"\" ) && strcmp ( WEB_SERVER_CONTENT_LANGUAGE , \"\" ) && http_MakeMessage ( buf , http_major_version , http_minor_version , \"ssc\" , \"CONTENT-LANGUAGE: \" , WEB_SERVER_CONTENT_LANGUAGE ) != 0 ) { error_handler } } if ( c == 'C' ) { if ( ( http_major_version > 1 ) || ( http_major_version == 1 && http_minor_version == 1 ) ) { if ( membuffer_append_str ( buf , \"CONNECTION: close\\r\\n\" ) ) { error_handler } } } if ( c == 'N' ) { bignum = ( off_t ) va_arg ( argp , off_t ) ; assert ( bignum >= 0 ) ; if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"shc\" , \"CONTENT-LENGTH: \" , bignum ) != 0 ) { error_handler } } if ( c == 'S' || c == 'U' ) { temp_str = ( c == 'S' ) ?\"SERVER: \" : \"USER-AGENT: \" ; get_sdk_info ( tempbuf , sizeof ( tempbuf ) ) ; if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"ss\" , temp_str , tempbuf ) != 0 ) { error_handler } } if ( c == 'X' ) { s = ( char * ) va_arg ( argp , char * ) ; assert ( s ) ; if ( membuffer_append_str ( buf , \"X-User-Agent: \" ) != 0 ) { error_handler } if ( membuffer_append ( buf , s , strlen ( s ) ) != 0 ) { error_handler } } if ( c == 'R' ) { status_code = ( int ) va_arg ( argp , int ) ; assert ( status_code > 0 ) ; rc = snprintf ( tempbuf , sizeof ( tempbuf ) , \"HTTP/%d.%d %d \" , http_major_version , http_minor_version , status_code ) ; status_msg = http_get_code_text ( status_code ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( tempbuf ) || http_MakeMessage ( buf , http_major_version , http_minor_version , \"ssc\" , tempbuf , status_msg ) != 0 ) { error_handler } } if ( c == 'B' ) { status_code = ( int ) va_arg ( argp , int ) ; rc = snprintf ( tempbuf , sizeof ( tempbuf ) , \"%s%d %s%s\" , \"<html><body><h1>\" , status_code , http_get_code_text ( status_code ) , \"</h1></body></html>\" ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( tempbuf ) ) { error_handler } bignum = ( off_t ) strlen ( tempbuf ) ; if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"NTcs\" , bignum , \"text/html\" , tempbuf ) != 0 ) { error_handler } } if ( c == 'Q' ) { method = ( http_method_t ) va_arg ( argp , http_method_t ) ; method_str = method_to_str ( method ) ; url_str = ( const char * ) va_arg ( argp , const char * ) ; num = ( size_t ) va_arg ( argp , size_t ) ; if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"ssbsdsdc\" , method_str , \" \" , url_str , num , \" HTTP/\" , http_major_version , \".\" , http_minor_version ) != 0 ) { error_handler } } if ( c == 'q' ) { method = ( http_method_t ) va_arg ( argp , http_method_t ) ; uri_ptr = ( uri_type * ) va_arg ( argp , uri_type * ) ; assert ( uri_ptr ) ; if ( http_FixUrl ( uri_ptr , & url ) != 0 ) { error_code = UPNP_E_INVALID_URL ; error_handler } if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"Q\" \"sbc\" , method , url . pathquery . buff , url . pathquery . size , \"HOST: \" , url . hostport . text . buff , url . hostport . text . size ) != 0 ) { error_handler } } if ( c == 'T' ) { temp_str = ( const char * ) va_arg ( argp , const char * ) ; if ( http_MakeMessage ( buf , http_major_version , http_minor_version , \"ssc\" , \"CONTENT-TYPE: \" , temp_str ) != 0 ) { error_handler } } else { assert ( 0 ) ; } } ExitFunction error_handler if ( ! error_code ) { error_code = UPNP_E_OUTOF_MEMORY ; } membuffer_destroy ( buf ) ; ExitFunction va_end ( argp ) ; return error_code ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "av1394_isoch_seg_t * av1394_isoch_find_seg ( av1394_inst_t * avp , offset_t off , size_t len ) { av1394_isoch_t * ip = & avp -> av_i ; av1394_ic_t * icp ; av1394_isoch_pool_t * pool ; av1394_isoch_seg_t * isp ; offset_t segoff ; int i ; for ( i = 0 ; i < NELEM ( ip -> i_ic ) ; i ++ ) { icp = ip -> i_ic [ i ] ; if ( icp == NULL ) { continue ; } if ( ( off >= icp -> ic_mmap_off ) && ( off + len <= icp -> ic_mmap_off + icp -> ic_mmap_sz ) ) { off -= icp -> ic_mmap_off ; break ; } icp = NULL ; } pool = ( icp -> ic_dir == AV1394_IR ) ?& icp -> ic_ir . ir_data_pool : & icp -> ic_it . it_data_pool ; for ( segoff = 0 , i = 0 ; i < pool -> ip_nsegs ; i ++ ) { isp = & pool -> ip_seg [ i ] ; if ( off == segoff ) { break ; } segoff += isp -> is_umem_size ; isp = NULL ; } if ( isp == NULL ) { return ( NULL ) ; } if ( len != isp -> is_umem_size ) { return ( NULL ) ; } return ( isp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( void ) { int i ; uint8_t hash_result [ 16 ] { 0 } ; ; struct AVMurMur3 * ctx = av_murmur3_alloc ( ) ; uint8_t in [ 256 ] { 0 } ; ; uint8_t * hashes = av_mallocz ( 256 * 16 ) ; for ( i = 0 ; i < 256 ; i ++ ) { in [ i ] = i ; av_murmur3_init_seeded ( ctx , 256 - i ) ; av_murmur3_update ( ctx , in , i ) ; av_murmur3_final ( ctx , hashes + 16 * i ) ; } av_murmur3_init_seeded ( ctx , 0 ) ; av_murmur3_update ( ctx , hashes , 256 * 16 ) ; av_murmur3_final ( ctx , hash_result ) ; av_freep ( & ctx ) ; printf ( \"result: 0x%\" PRIx64 \" 0x%\" PRIx64 \"\\n\" , AV_RL64 ( hash_result ) , AV_RL64 ( hash_result + 8 ) ) ; return AV_RL32 ( hash_result ) != 0x6384ba69 ; uint8_t * in = av_mallocz ( 512 * 1024 ) ; av_murmur3_init ( ctx ) ; for ( i = 0 ; i < 40 * 1024 ; i ++ ) { av_murmur3_update ( ctx , in , 512 * 1024 ) ; } av_murmur3_final ( ctx , hash_result ) ; av_free ( in ) ; return hash_result [ 0 ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool _git_branch ( Rvc * vc , const char * name ) { char * escpath = r_str_escape ( vc -> path ) ; if ( ! escpath ) { return false ; } char * escname = r_str_escape ( name ) ; if ( ! escname ) { free ( escpath ) ; return false ; } int ret = r_sys_cmdf ( \"git -C \\\"%s\\\" branch \\\"%s\\\"\" , escpath , escname ) ; free ( escpath ) ; return ! ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void * memmove ( void * dp , const void * sp , size_t n ) { unsigned char * cdp , * csp ; cdp = dp ; csp = ( unsigned char * ) sp ; if ( cdp < csp ) { { * cdp ++ = * csp ++ ; } -- n ; } else { cdp += n ; csp += n ; { * -- cdp = * -- csp ; } -- n ; } return dp ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int kiox010a_dsm ( struct device * dev , int fn_index ) { acpi_handle handle = ACPI_HANDLE ( dev ) ; guid_t kiox010a_dsm_guid ; union acpi_object * obj ; if ( ! handle ) { return - ENODEV ; } guid_parse ( \"1f339696-d475-4e26-8cad-2e9f8e6d7a91\" , & kiox010a_dsm_guid ) ; obj = acpi_evaluate_dsm ( handle , & kiox010a_dsm_guid , 1 , fn_index , NULL ) ; if ( ! obj ) { return - EIO ; } ACPI_FREE ( obj , NULL ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct auxtrace_record * intel_bts_recording_init ( int * err ) { struct perf_pmu * intel_bts_pmu = perf_pmu__find ( INTEL_BTS_PMU_NAME ) ; struct intel_bts_recording * btsr ; if ( ! intel_bts_pmu ) { return in ; } if ( setenv ( \"JITDUMP_USE_ARCH_TIMESTAMP\" , \"1\" , 1 ) ) { * err = - errno ; return NULL ; } btsr = zalloc ( sizeof ( intel_bts_recording ) ) ; if ( ! btsr ) { * err = - ENOMEM ; return NULL ; } btsr -> intel_bts_pmu = intel_bts_pmu ; btsr -> itr . recording_options = intel_bts_recording_options ; btsr -> itr . info_priv_size = intel_bts_info_priv_size ; btsr -> itr . info_fill = intel_bts_info_fill ; btsr -> itr . free = intel_bts_recording_free ; btsr -> itr . snapshot_start = intel_bts_snapshot_start ; btsr -> itr . snapshot_finish = intel_bts_snapshot_finish ; btsr -> itr . find_snapshot = intel_bts_find_snapshot ; btsr -> itr . parse_snapshot_options = intel_bts_parse_snapshot_options ; btsr -> itr . reference = intel_bts_reference ; btsr -> itr . read_finish = intel_bts_read_finish ; btsr -> itr . alignment = sizeof ( branch ) ; return & btsr -> itr ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool virStorageSourceIsSameLocation ( virStorageSource * a , virStorageSource * b ) { size_t i ; if ( a -> type == VIR_STORAGE_TYPE_VOLUME && b -> type == VIR_STORAGE_TYPE_VOLUME ) { return STREQ ( a -> srcpool -> pool , b -> srcpool -> pool ) && STREQ ( a -> srcpool -> volume , b -> srcpool -> volume ) ; } if ( virStorageSourceGetActualType ( a ) != virStorageSourceGetActualType ( b ) ) { return false ; } if ( STRNEQ_NULLABLE ( a -> path , b -> path ) || STRNEQ_NULLABLE ( a -> volume , b -> volume ) || STRNEQ_NULLABLE ( a -> snapshot , b -> snapshot ) ) { return false ; } switch ( virStorageSourceGetActualType ( a ) ) { case VIR_STORAGE_TYPE_NETWORK : if ( a -> protocol != b -> protocol || a -> nhosts != b -> nhosts ) { return false ; } for ( i = 0 ; i < a -> nhosts ; i ++ ) { if ( a -> hosts [ i ] . transport != b -> hosts [ i ] . transport || a -> hosts [ i ] . port != b -> hosts [ i ] . port || STRNEQ_NULLABLE ( a -> hosts [ i ] . name , b -> hosts [ i ] . name ) || STRNEQ_NULLABLE ( a -> hosts [ i ] . socket , b -> hosts [ i ] . socket ) ) { return false ; } } break ; case VIR_STORAGE_TYPE_NVME : if ( ! virStorageSourceNVMeDefIsEqual ( a -> nvme , b -> nvme ) ) { return false ; } break ; case VIR_STORAGE_TYPE_VHOST_USER : case VIR_STORAGE_TYPE_NONE : case VIR_STORAGE_TYPE_FILE : case VIR_STORAGE_TYPE_BLOCK : case VIR_STORAGE_TYPE_DIR : case VIR_STORAGE_TYPE_LAST : case VIR_STORAGE_TYPE_VOLUME : break ; } return true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void uniphier_ld4_sbc_init ( void ) { u32 tmp ; tmp = readl ( PC0CTRL , NULL ) ; tmp &= 0xfffffcff ; writel ( tmp , PC0CTRL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static u64 ines_txts64 ( struct ines_port * port , unsigned int words ) { int i ; u64 result ; u16 word ; word = ines_read32 ( port , ts_tx ) ; result = word ; words -- ; for ( i = 0 ; i < words ; i ++ ) { word = ines_read32 ( port , ts_tx ) ; result <<= 16 ; result |= word ; } return result ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "gimp_color_area_render ( ) { GimpColorAreaPrivate * priv = GET_PRIVATE ( area ) ; if ( ! priv -> buf ) { return ; } gimp_color_area_render_buf ( GTK_WIDGET ( area ) , priv -> type , priv -> buf , priv -> width , priv -> height , priv -> rowstride , & priv -> color ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int main ( ) { dl_iterate_phdr ( callback , NULL ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int jffs2_flash_writev ( struct jffs2_sb_info * c , const struct kvec * invecs , unsigned long count , loff_t to , size_t * retlen , uint32_t ino ) { struct jffs2_eraseblock * jeb ; size_t wbuf_retlen , donelen = 0 ; uint32_t outvec_to = to ; int ret , invec ; if ( ! jffs2_is_writebuffered ( c ) ) { return jffs2_flash_direct_writev ( c , invecs , count , to , retlen ) ; } down_write ( & c -> wbuf_sem ) ; if ( c -> wbuf_ofs == 0xFFFFFFFF ) { c -> wbuf_ofs = PAGE_DIV ( to ) ; c -> wbuf_len = PAGE_MOD ( to ) ; } if ( SECTOR_ADDR ( to ) != SECTOR_ADDR ( c -> wbuf_ofs ) ) { if ( c -> wbuf_len ) { jffs2_dbg ( 1 , \"%s(): to 0x%lx causes flush of wbuf at 0x%08x\\n\" , __func__ , ( unsigned long ) to , c -> wbuf_ofs ) ; ret = __jffs2_flush_wbuf ( c , PAD_NOACCOUNT ) ; if ( ret ) { outerr } } c -> wbuf_ofs = PAGE_DIV ( to ) ; c -> wbuf_len = PAGE_MOD ( to ) ; } if ( to != PAD ( c -> wbuf_ofs + c -> wbuf_len ) ) { pr_crit ( \"%s(): Non-contiguous write to %08lx\\n\" , __func__ , ( unsigned long ) to ) ; if ( c -> wbuf_len ) { pr_crit ( \"wbuf was previously %08x-%08x\\n\" , c -> wbuf_ofs , c -> wbuf_ofs + c -> wbuf_len ) ; } BUG ( ) ; } if ( c -> wbuf_len != PAGE_MOD ( to ) ) { c -> wbuf_len = PAGE_MOD ( to ) ; if ( ! c -> wbuf_len ) { c -> wbuf_len = c -> wbuf_pagesize ; ret = __jffs2_flush_wbuf ( c , NOPAD ) ; if ( ret ) { outerr } } } for ( invec = 0 ; invec < count ; invec ++ ) { int vlen = invecs [ invec ] . iov_len ; uint8_t * v = invecs [ invec ] . iov_base ; wbuf_retlen = jffs2_fill_wbuf ( c , v , vlen ) ; if ( c -> wbuf_len == c -> wbuf_pagesize ) { ret = __jffs2_flush_wbuf ( c , NOPAD ) ; if ( ret ) { outerr } } vlen -= wbuf_retlen ; outvec_to += wbuf_retlen ; donelen += wbuf_retlen ; v += wbuf_retlen ; if ( vlen >= c -> wbuf_pagesize ) { ret = mtd_write ( c -> mtd , outvec_to , PAGE_DIV ( vlen ) , & wbuf_retlen , v ) ; if ( ret < 0 || wbuf_retlen != PAGE_DIV ( vlen ) ) { outfile } vlen -= wbuf_retlen ; outvec_to += wbuf_retlen ; c -> wbuf_ofs = outvec_to ; donelen += wbuf_retlen ; v += wbuf_retlen ; } wbuf_retlen = jffs2_fill_wbuf ( c , v , vlen ) ; if ( c -> wbuf_len == c -> wbuf_pagesize ) { ret = __jffs2_flush_wbuf ( c , NOPAD ) ; if ( ret ) { outerr } } outvec_to += wbuf_retlen ; donelen += wbuf_retlen ; } * retlen = donelen ; if ( jffs2_sum_active ( ) ) { int res = jffs2_sum_add_kvec ( c , invecs , count , ( uint32_t ) to ) ; if ( res ) { return res ; } } if ( c -> wbuf_len && ino ) { jffs2_wbuf_dirties_inode ( c , ino ) ; } ret = 0 ; up_write ( & c -> wbuf_sem ) ; return ret ; outfile spin_lock ( & c -> erase_completion_lock ) ; jeb = & c -> blocks [ outvec_to / c -> sector_size ] ; jffs2_block_refile ( c , jeb , REFILE_ANYWAY ) ; spin_unlock ( & c -> erase_completion_lock ) ; outerr * retlen = 0 ; up_write ( & c -> wbuf_sem ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int gfxp_fb_devmap ( dev_t dev , devmap_cookie_t dhp , offset_t off , size_t len , size_t * maplen , uint_t model , void * ptr ) { struct gfxp_fb_softc * softc = ( gfxp_fb_softc * ) ptr ; return ( softc -> gfxp_ops -> devmap ( dev , dhp , off , len , maplen , model , ptr ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct otx2_cpt_engs_rsvd * find_engines_by_type ( struct otx2_cpt_eng_grp_info * eng_grp , int eng_type ) { int i ; for ( i = 0 ; i < OTX2_CPT_MAX_ETYPES_PER_GRP ; i ++ ) { if ( eng_grp -> engs [ i ] . type == eng_type ) { return & eng_grp -> engs [ i ] ; } } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ovsdb_cs_process_response ( struct ovsdb_cs * cs , struct jsonrpc_msg * msg ) { bool ok = msg -> type == JSONRPC_REPLY ; if ( ! ok && cs -> state != CS_S_SERVER_SCHEMA_REQUESTED && cs -> state != CS_S_SERVER_MONITOR_REQUESTED && cs -> state != CS_S_DATA_MONITOR_COND_REQUESTED && cs -> state != CS_S_DATA_MONITOR_COND_SINCE_REQUESTED ) { static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT ( 5 , 5 ) ; char * s = jsonrpc_msg_to_string ( msg ) ; VLOG_INFO_RL ( & rl , \"%s: received unexpected %s response in \" \"%s state: %s\" , jsonrpc_session_get_name ( cs -> session ) , jsonrpc_msg_type_to_string ( msg -> type ) , ovsdb_cs_state_to_string ( cs -> state ) , s ) ; ovsdb_cs_retry ( cs ) ; return ; } switch ( cs -> state ) { case CS_S_SERVER_SCHEMA_REQUESTED : if ( ok ) { json_destroy ( cs -> server . schema ) ; cs -> server . schema = json_clone ( msg -> result ) ; ovsdb_cs_send_monitor_request ( cs , & cs -> server , cs -> server . max_version ) ; ovsdb_cs_transition ( cs , CS_S_SERVER_MONITOR_REQUESTED ) ; } else { ovsdb_cs_send_schema_request ( cs , & cs -> data ) ; ovsdb_cs_transition ( cs , CS_S_DATA_SCHEMA_REQUESTED ) ; } break ; case CS_S_SERVER_MONITOR_REQUESTED : if ( ok ) { cs -> server . monitor_version = cs -> server . max_version ; ovsdb_cs_db_parse_monitor_reply ( & cs -> server , msg -> result , cs -> server . monitor_version ) ; if ( ovsdb_cs_check_server_db ( cs ) && cs -> set_db_change_aware ) { ovsdb_cs_send_db_change_aware ( cs ) ; } } else { ovsdb_cs_send_schema_request ( cs , & cs -> data ) ; ovsdb_cs_transition ( cs , CS_S_DATA_SCHEMA_REQUESTED ) ; } break ; case CS_S_DATA_SCHEMA_REQUESTED : json_destroy ( cs -> data . schema ) ; cs -> data . schema = json_clone ( msg -> result ) ; if ( cs -> data . max_version >= 2 ) { ovsdb_cs_send_monitor_request ( cs , & cs -> data , 2 ) ; ovsdb_cs_transition ( cs , CS_S_DATA_MONITOR_COND_REQUESTED ) ; } else { ovsdb_cs_send_monitor_request ( cs , & cs -> data , 1 ) ; ovsdb_cs_transition ( cs , CS_S_DATA_MONITOR_REQUESTED ) ; } break ; case CS_S_DATA_MONITOR_COND_SINCE_REQUESTED : if ( ! ok ) { ovsdb_cs_send_monitor_request ( cs , & cs -> data , 2 ) ; ovsdb_cs_transition ( cs , CS_S_DATA_MONITOR_COND_REQUESTED ) ; } else { cs -> data . monitor_version = 3 ; ovsdb_cs_transition ( cs , CS_S_MONITORING ) ; ovsdb_cs_db_parse_monitor_reply ( & cs -> data , msg -> result , 3 ) ; } break ; case CS_S_DATA_MONITOR_COND_REQUESTED : if ( ! ok ) { ovsdb_cs_send_monitor_request ( cs , & cs -> data , 1 ) ; ovsdb_cs_transition ( cs , CS_S_DATA_MONITOR_REQUESTED ) ; } else { cs -> data . monitor_version = 2 ; ovsdb_cs_transition ( cs , CS_S_MONITORING ) ; ovsdb_cs_db_parse_monitor_reply ( & cs -> data , msg -> result , 2 ) ; } break ; case CS_S_DATA_MONITOR_REQUESTED : cs -> data . monitor_version = 1 ; ovsdb_cs_transition ( cs , CS_S_MONITORING ) ; ovsdb_cs_db_parse_monitor_reply ( & cs -> data , msg -> result , 1 ) ; break ; case CS_S_MONITORING : ovsdb_cs_db_ack_condition ( & cs -> data ) ; ovsdb_cs_send_cond_change ( cs ) ; cs -> data . cond_seqno ++ ; break ; case CS_S_ERROR : case CS_S_RETRY : break ; default : OVS_NOT_REACHED ( ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t snd_gf1_mem_proc_dump ( struct snd_info_entry * entry , void * file_private_data , struct file * file , char __user * buf , size_t count , loff_t pos ) { struct gus_proc_private * priv = entry -> private_data ; struct snd_gus_card * gus = priv -> gus ; int err ; err = snd_gus_dram_read ( gus , buf , pos , count , priv -> rom ) ; return count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void clean_psfp_all ( void ) { clean_sfi_list ( ) ; clean_sgi_list ( ) ; clean_stream_list ( ) ; clean_psfp_sfi_bitmap ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void check_and_split_timer ( pike_list_link_t * head , unsigned int time , pike_list_link_t * split , unsigned char * mask ) { pike_list_link_t * ll ; pike_ip_node_t * node ; int b ; int i ; for ( i = 0 ; i < 32 ; mask [ i ++ ] = 0 ) { } ll = head -> next ; while ( ll != head && ( node = ll2ipnode ( ll ) ) -> expires <= time ) { LM_DBG ( \"splitting %p(%p,%p)node=%p\\n\" , ll , ll -> prev , ll -> next , node ) ; node -> flags |= NODE_EXPIRED_FLAG ; node -> flags &= ~ NODE_INTIMER_FLAG ; b = node -> branch ; ll = ll -> next ; mask [ b >> 3 ] |= ( 1 << ( b & 0x07 ) ) ; } if ( ll == head -> next ) { split -> next = split -> prev = split ; } else { split -> next = head -> next ; split -> next -> prev = split ; split -> prev = ll -> prev ; split -> prev -> next = split ; head -> next = ll ; ll -> prev = head ; } LM_DBG ( \"succeeded to split (h=%p)(p=%p,n=%p)\\n\" , head , head -> prev , head -> next ) ; return ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "test_session_id_bad ( ) { const char * bad_opts [ ] { \"{'sessionId': null}\" \"{'sessionId': 'foo'}\" \"{'sessionId': {'$numberInt': '1'}}\" \"{'sessionId': {'$numberDouble': '1'}}\" \"{'sessionId': {'$numberLong': '5000000000'}}\" \"{'sessionId': {'$numberLong': '123'}}\" NULL } ; ; const char * * bad_opt ; mongoc_client_t * client ; bson_error_t error ; bool r ; BSON_UNUSED ( ctx ) ; client = test_framework_new_default_client ( ) ; for ( bad_opt = bad_opts ; * bad_opt ; bad_opt ++ ) { r = mongoc_client_read_command_with_opts ( client , \"admin\" , tmp_bson ( \"{'ping': 1}\" ) , NULL , tmp_bson ( * bad_opt ) , NULL , & error ) ; BSON_ASSERT ( ! r ) ; ASSERT_ERROR_CONTAINS ( error , MONGOC_ERROR_COMMAND , MONGOC_ERROR_COMMAND_INVALID_ARG , \"Invalid sessionId\" ) ; } mongoc_client_destroy ( client ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _omap2_clk_allow_idle ( struct clk_hw_omap * clk ) { if ( clk -> ops && clk -> ops -> allow_idle ) { cfs_time_t irqflags ; spin_lock_irqsave ( & autoidle_spinlock , irqflags ) ; clk -> autoidle_count -- ; if ( clk -> autoidle_count == 0 ) { clk -> ops -> allow_idle ( clk ) ; } spin_unlock_irqrestore ( & autoidle_spinlock , irqflags ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void cnfstmtOptimizeIf ( struct cnfstmt * stmt ) { struct cnfstmt * t_then , * t_else ; struct cnfexpr * expr ; struct cnffunc * func ; struct funcData_prifilt * prifilt ; assert ( stmt -> nodetype == S_IF ) ; expr = stmt -> d . s_if . expr = cnfexprOptimize ( stmt -> d . s_if . expr ) ; stmt -> d . s_if . t_then = cnfstmtOptimize ( stmt -> d . s_if . t_then ) ; stmt -> d . s_if . t_else = cnfstmtOptimize ( stmt -> d . s_if . t_else ) ; if ( stmt -> d . s_if . t_then == NULL && stmt -> d . s_if . t_else == NULL ) { DBGPRINTF ( \"optimizer: if with both empty then and else - remove\\n\" ) ; cnfexprDestruct ( stmt -> d . s_if . expr ) ; stmt -> nodetype = S_NOP ; done } assert ( stmt -> nodetype == S_IF ) ; if ( stmt -> d . s_if . expr -> nodetype == 'F' ) { func = ( cnffunc * ) expr ; if ( func -> fPtr == doFunct_Prifilt ) { DBGPRINTF ( \"optimizer: change IF to PRIFILT\\n\" ) ; t_then = stmt -> d . s_if . t_then ; t_else = stmt -> d . s_if . t_else ; stmt -> nodetype = S_PRIFILT ; prifilt = ( funcData_prifilt * ) func -> funcdata ; memcpy ( stmt -> d . s_prifilt . pmask , prifilt -> pmask , sizeof ( prifilt -> pmask ) ) ; stmt -> d . s_prifilt . t_then = t_then ; stmt -> d . s_prifilt . t_else = t_else ; if ( func -> nParams == 0 ) { stmt -> printable = ( uchar * ) strdup ( \"[Optimizer Result]\" ) ; } else { stmt -> printable = ( uchar * ) es_str2cstr ( ( ( cnfstringval * ) func -> expr [ 0 ] ) -> estr , NULL ) ; } cnfexprDestruct ( expr ) ; cnfstmtOptimizePRIFilt ( stmt , NULL ) ; } } done return ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int cbs_get_u ( CBS * cbs , uint32_t * out , size_t len ) { uint32_t result = 0 ; size_t i ; const uint8_t * data ; if ( ! cbs_get ( cbs , & data , len ) ) { return 0 ; } for ( i = 0 ; i < len ; i ++ ) { result <<= 8 ; result |= data [ i ] ; } * out = result ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ApCheckRegMethod ( ) { ACPI_PARSE_OBJECT * Next ; ACPI_PARSE_OBJECT * Parent ; if ( ! ACPI_COMPARE_NAMESEG ( METHOD_NAME__REG , & Op -> Asl . NameSeg ) ) { return ; } Parent = Op -> Asl . Parent ; Next = Parent -> Asl . Child ; while ( Next ) { Next = Next -> Asl . Next ; } AslError ( ASL_WARNING , ASL_MSG_NO_REGION , Op , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int eqencoding ( const char * * a , const char * * b ) { int i ; for ( i = 0 ; a [ i ] != 0 && b [ i ] != 0 ; i ++ ) { if ( a [ i ] != b [ i ] && ( a [ i ] == 0 || b [ i ] == 0 || strcmp ( a [ i ] , b [ i ] ) != 0 ) ) { return 0 ; } } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct direct * dreaddir ( struct dirstuff * dirp ) { struct direct * dp ; diskaddr_t lbn , d ; for ( ; ; ) { if ( dirp -> loc >= ( int ) dirp -> ip -> di_size ) { return ( NULL ) ; } if ( blkoff ( & sblock , dirp -> loc ) == 0 ) { lbn = lblkno ( & sblock , dirp -> loc ) ; d = bmap ( lbn , NULL ) ; if ( d == 0 ) { return ( NULL ) ; } bread ( fsbtodb ( & sblock , d ) , dirp -> dbuf , ( int ) dblksize ( & sblock , dirp -> ip , ( int ) lbn ) ) ; } dp = ( direct * ) ( dirp -> dbuf + blkoff ( & sblock , dirp -> loc ) ) ; dirp -> loc += dp -> d_reclen ; if ( dp -> d_ino == 0 ) { continue ; } return ( dp ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int nouveau_drm_debugfs_init ( struct drm_minor * minor ) { struct dentry * dentry ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( nouveau_debugfs_files ) ; i ++ ) { dentry = debugfs_create_file ( nouveau_debugfs_files [ i ] . name , S_IRUGO | S_IWUSR , minor -> debugfs_root , minor -> dev , nouveau_debugfs_files [ i ] . fops ) ; } return drm_debugfs_create_files ( nouveau_debugfs_list , NOUVEAU_DEBUGFS_ENTRIES , minor -> debugfs_root , minor ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void init_stem_edge ( InstrCt * ct , StemData * stem , int is_l ) { real left , right , base ; struct dependent_stem * slave ; PointData * rpd = NULL ; int i , * refidx = NULL ; left = ( stem -> unit . x == 0 ) ?stem -> left . x : stem -> left . y ; right = ( stem -> unit . x == 0 ) ?stem -> right . x : stem -> right . y ; base = ( is_l ) ?left : right ; ct -> edge . base = base ; ct -> edge . refpt = - 1 ; ct -> edge . refscore = 0 ; ct -> edge . othercnt = 0 ; refidx = ( is_l ) ?& stem -> leftidx : & stem -> rightidx ; if ( * refidx != - 1 ) { rpd = & ct -> gd -> points [ * refidx ] ; } if ( rpd != NULL && ct -> diagcnt > 0 && ( ( stem -> unit . y == 1 && rpd -> x_corner == 2 ) || ( stem -> unit . x == 1 && rpd -> y_corner == 2 ) ) && has_valid_dstem ( rpd , true ) != - 1 && has_valid_dstem ( rpd , false ) != - 1 ) { * refidx = - 1 ; } for ( i = 0 ; i < ct -> gd -> realcnt ; i ++ ) { ct -> gd -> points [ i ] . ticked = false ; } assign_points_to_edge ( ct , stem , is_l , refidx ) ; for ( i = 0 ; i < stem -> dep_cnt ; i ++ ) { slave = & stem -> dependent [ i ] ; if ( slave -> dep_type == 'a' && ( ( is_l && slave -> lbase ) || ( ! is_l && ! slave -> lbase ) ) ) { if ( is_l ) { slave -> stem -> leftidx = * refidx ; } else { slave -> stem -> rightidx = * refidx ; } assign_points_to_edge ( ct , slave -> stem , is_l , refidx ) ; } } ct -> edge . refpt = * refidx ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t pdcs_osdep2_read ( struct kobject * kobj , struct kobj_attribute * attr , char * buf ) { char * out = buf ; unsigned long size ; unsigned short i ; u32 result ; size = pdcs_size - 224 ; if ( ! buf ) { return - EINVAL ; } for ( i = 0 ; i < size ; i += 4 ) { if ( unlikely ( pdc_stable_read ( PDCS_ADDR_OSD2 + i , & result , sizeof ( result ) ) != PDC_OK ) ) { return - EIO ; } out += sprintf ( out , \"0x%.8x\\n\" , result ) ; } return out - buf ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int python_msgobj_init ( void ) { Py_SET_TYPE ( & MSGtype , & PyType_Type ) ; Py_TYPE ( & MSGtype ) = & PyType_Type ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int pthread_cond_signal ( pthread_cond_t * condp ) { pthread_cond_t cond ; int count ; cond = * condp ; atomic_inc_int ( & cond -> seq ) ; count = _wake ( & cond -> seq , 1 ) ; _rthread_debug ( 5 , \"%p: cond_signal %p, %d awaken\\n\" , pthread_self ( ) , ( void * ) cond , count ) ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void bfd_sess_set_ipv4_addrs ( struct bfd_session_params * bsp , const struct in_addr * src , const struct in_addr * dst ) { if ( ! bfd_sess_address_changed ( bsp , AF_INET , ( in6_addr * ) src , ( in6_addr * ) dst ) ) { return ; } _bfd_sess_remove ( bsp ) ; bfd_source_cache_put ( bsp ) ; bsp -> args . family = AF_INET ; memset ( & bsp -> args . dst , 0 , sizeof ( bsp -> args . dst ) ) ; if ( src ) { memcpy ( & bsp -> args . src , src , sizeof ( in_addr ) ) ; } assert ( dst ) ; memcpy ( & bsp -> args . dst , dst , sizeof ( in_addr ) ) ; if ( bsp -> auto_source ) { bfd_source_cache_get ( bsp ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * winpr_get_unix_timezone_identifier_from_file ( void ) { return winpr_get_android_timezone_identifier ( ) ; FILE * fp ; char * tzid = NULL ; fp = winpr_fopen ( \"/var/db/zoneinfo\" , \"r\" ) ; fp = winpr_fopen ( \"/etc/timezone\" , \"r\" ) ; if ( NULL == fp ) { return NULL ; } tzid = winpr_read_unix_timezone_identifier_from_file ( fp ) ; fclose ( fp , NULL ) ; if ( tzid != NULL ) { WLog_DBG ( TAG , \"tzid: %s\" , tzid ) ; } return tzid ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int l2tpd_add_listener ( l2tpd * _this , int idx , struct l2tp_conf * conf , struct sockaddr * addr ) { l2tpd_listener * plistener , * plsnr ; plistener = NULL ; if ( idx == 0 && slist_length ( & _this -> listener ) > 0 ) { slist_itr_first ( & _this -> listener ) ; while ( slist_itr_has_next ( & _this -> listener ) ) { slist_itr_next ( & _this -> listener ) ; plsnr = slist_itr_remove ( & _this -> listener ) ; L2TPD_ASSERT ( plsnr != NULL ) ; L2TPD_ASSERT ( plsnr -> sock == - 1 ) ; } } L2TPD_ASSERT ( slist_length ( & _this -> listener ) == idx ) ; if ( slist_length ( & _this -> listener ) != idx ) { l2tpd_log ( _this , LOG_ERR , \"Invalid argument error on %s(): idx must be %d but %d\" , __func__ , slist_length ( & _this -> listener ) , idx ) ; fail } if ( ( plistener = calloc ( 1 , sizeof ( l2tpd_listener ) ) ) == NULL ) { l2tpd_log ( _this , LOG_ERR , \"calloc() failed in %s: %m\" , __func__ ) ; fail } L2TPD_ASSERT ( sizeof ( plistener -> bind ) >= addr -> sa_len ) ; memcpy ( & plistener -> bind , addr , addr -> sa_len ) ; if ( plistener -> bind . sin6 . sin6_port == 0 ) { plistener -> bind . sin6 . sin6_port = htons ( L2TPD_DEFAULT_UDP_PORT ) ; } plistener -> sock = - 1 ; plistener -> self = _this ; plistener -> index = idx ; plistener -> conf = conf ; strlcpy ( plistener -> tun_name , conf -> name , sizeof ( plistener -> tun_name ) ) ; if ( slist_add ( & _this -> listener , plistener ) == NULL ) { l2tpd_log ( _this , LOG_ERR , \"slist_add() failed in %s: %m\" , __func__ ) ; fail } return 0 ; fail free ( plistener ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int __niu_wait_bits_clear_mac ( struct niu * np , unsigned long reg , u64 bits , int limit , int delay ) { while ( -- limit >= 0 ) { u64 val = nr64_mac ( reg ) ; if ( ! ( val & bits ) ) { break ; } udelay ( delay , NULL ) ; } if ( limit < 0 ) { return - ENODEV ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int entropy_gather_internal ( mbedtls_entropy_context * ctx ) { int ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED ; int i ; int have_one_strong = 0 ; unsigned char buf [ MBEDTLS_ENTROPY_MAX_GATHER ] ; size_t olen ; for ( i = 0 ; i < ctx -> source_count ; i ++ ) { if ( ctx -> source [ i ] . strong == MBEDTLS_ENTROPY_SOURCE_STRONG ) { have_one_strong = 1 ; } olen = 0 ; if ( ( ret = ctx -> source [ i ] . f_source ( ctx -> source [ i ] . p_source , buf , MBEDTLS_ENTROPY_MAX_GATHER , & olen ) ) != 0 ) { cleanup } if ( olen > 0 ) { if ( ( ret = entropy_update ( ctx , ( unsigned char ) i , buf , olen ) ) != 0 ) { return ret ; } ctx -> source [ i ] . size += olen ; } } if ( have_one_strong == 0 ) { ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE ; } cleanup mbedtls_platform_zeroize ( buf , sizeof ( buf ) ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void clear_trackexithost_mappings ( const char * exitname ) { char * suffix = NULL ; if ( ! addressmap || ! exitname ) { return ; } tor_asprintf ( & suffix , \".%s.exit\" , exitname ) ; tor_strlower ( suffix ) ; STRMAP_FOREACH_MODIFY ( , , , ) { if ( ent -> source == ADDRMAPSRC_TRACKEXIT && ! strcmpend ( ent -> new_address , suffix ) ) { addressmap_ent_remove ( address , ent ) ; MAP_DEL_CURRENT ( address ) ; } } STRMAP_FOREACH_END ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int iperf_time_compare ( struct iperf_time * time1 , struct iperf_time * time2 ) { if ( time1 -> secs > time2 -> secs ) { return 1 ; } if ( time1 -> usecs < time2 -> usecs ) { return - 1 ; } if ( time1 -> usecs > time2 -> usecs ) { return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void vmm_gpt_vacate_entry ( vmm_gpt_t * gpt , uint64_t gpa ) { vmm_gpt_node_t * nodes [ MAX_GPT_LEVEL ] , * node ; node = gpt -> vgpt_root ; for ( uint_t i = 0 ; i < MAX_GPT_LEVEL ; i ++ ) { nodes [ i ] = node ; node = vmm_gpt_node_find_child ( node , gpa ) ; } for ( uint_t i = LEVEL1 ; i > 0 ; i -- ) { node = nodes [ i ] ; if ( i == LEVEL1 ) { ASSERT0 ( node -> vgn_entries [ vmm_gpt_node_index ( gpa , i ) ] ) ; ASSERT3U ( node -> vgn_ref_cnt , != , 0 ) ; node -> vgn_ref_cnt -- ; } if ( node -> vgn_ref_cnt != 0 ) { break ; } vmm_gpt_node_remove_child ( nodes [ i - 1 ] , nodes [ i ] ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "test8 ( ) { INIT_TEST2 ( 8 , \"-o\" , \"ARG\" ) ; test_optional ( argp , argc , argv , & test_args , \"ARG\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int week ( int day , int month , int year ) { int yearday ; int firstweekday ; int weekday ; int firstday ; int firstsunday ; int shift ; yearday = day_in_year ( day , month , year ) ; firstweekday = day_in_week ( 1 , 1 , year ) + 1 ; weekday = day_in_week ( day , month , year ) + 1 ; firstday = day_in_year ( 1 , 1 , year ) ; firstsunday = firstday + ( 8 - firstweekday ) ; shift = 1 ; if ( yearday < firstsunday ) { return ( 1 ) ; } if ( firstweekday > THURSDAY - 1 ) { shift = 2 ; } return ( ( ( ( yearday + 1 ) - ( weekday - 1 ) ) / 7 ) + shift ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bcm_kona_i2c_read_fifo ( struct bcm_kona_i2c_dev * dev , struct i2c_msg * msg ) { int bytes_to_read = MAX_RX_FIFO_SIZE ; unsigned int last_byte_nak = 0 ; unsigned int bytes_read = 0 ; int rc ; uint8_t * tmp_buf = msg -> buf ; while ( bytes_read < msg -> len ) { if ( msg -> len - bytes_read <= MAX_RX_FIFO_SIZE ) { last_byte_nak = 1 ; bytes_to_read = msg -> len - bytes_read ; } rc = bcm_kona_i2c_read_fifo_single ( dev , tmp_buf , bytes_to_read , last_byte_nak ) ; if ( rc < 0 ) { return - EREMOTEIO ; } bytes_read += bytes_to_read ; tmp_buf += bytes_to_read ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "br_should_route_hook_t __rcu * br_should_route_hook __read_mostly ; EXPORT_SYMBOL ( br_should_route_hook ) ; static int br_netif_receive_skb ( struct net * net , struct sock * sk , struct sk_buff * skb ) { br_drop_fake_rtable ( skb , NULL ) ; return netif_receive_skb ( skb ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "_cairo_base85_stream_create ( ) { cairo_base85_stream_t * stream ; if ( output -> status ) { return _cairo_output_stream_create_in_error ( output -> status ) ; } stream = _cairo_malloc ( sizeof ( cairo_base85_stream_t ) ) ; if ( unlikely ( stream == NULL ) ) { _cairo_error_throw ( CAIRO_STATUS_NO_MEMORY , NULL ) ; return ( cairo_output_stream_t * ) & _cairo_output_stream_nil ; } _cairo_output_stream_init ( & stream -> base , _cairo_base85_stream_write , NULL , _cairo_base85_stream_close ) ; stream -> output = output ; stream -> pending = 0 ; return & stream -> base ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int adc_match ( struct device * parent , void * match , void * aux ) { struct i2c_attach_args * ia = aux ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct protoent * pr_bynumber ( struct irs_pr * , int ) static void pr_rewind ( struct irs_pr * ) static void pr_minimize ( struct irs_pr * ) static struct __res_state * pr_res_get ( struct irs_pr * ) static void pr_res_set ( struct irs_pr * , struct __res_state * , void * ( void * ) ) struct irs_pr * irs_gen_pr ( struct irs_acc * this ) { struct gen_p * accpvt = ( gen_p * ) this -> private ; struct irs_pr * pr ; struct pvt * pvt ; if ( ! ( pr = memget ( sizeof pr ) ) ) { errno = ENOMEM ; return ( NULL ) ; } memset ( pr , 0x5e , sizeof pr ) ; if ( ! ( pvt = memget ( sizeof pvt ) ) ) { memput ( pr , sizeof pr ) ; errno = ENOMEM ; return ( NULL ) ; } pvt -> rules = accpvt -> map_rules [ irs_pr ] ; pvt -> rule = pvt -> rules ; pr -> private = pvt ; pr -> close = pr_close ; pr -> next = pr_next ; pr -> byname = pr_byname ; pr -> bynumber = pr_bynumber ; pr -> rewind = pr_rewind ; pr -> minimize = pr_minimize ; pr -> res_get = pr_res_get ; pr -> res_set = pr_res_set ; return ( pr ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "bool intel_bios_is_port_hpd_inverted ( struct drm_i915_private * dev_priv , enum port port ) { int i ; for ( i = 0 ; i < dev_priv -> vbt . child_dev_num ; i ++ ) { if ( ! dev_priv -> vbt . child_dev [ i ] . common . hpd_invert ) { continue ; } switch ( dev_priv -> vbt . child_dev [ i ] . common . dvo_port ) { case DVO_PORT_DPA : case DVO_PORT_HDMIA : if ( port == PORT_A ) { return true ; } break ; case DVO_PORT_DPB : case DVO_PORT_HDMIB : if ( port == PORT_B ) { return true ; } break ; case DVO_PORT_DPC : case DVO_PORT_HDMIC : if ( port == PORT_C ) { return true ; } break ; default : break ; } } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * srcline_from_fileline ( const char * file , unsigned int line ) { char * srcline ; if ( ! file ) { return in ; } if ( ! srcline_full_filename ) { file = gnu_basename ( file ) ; } if ( asprintf ( & srcline , \"%s:%u\" , file , line ) < 0 ) { return NULL ; } return srcline ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static krb5_error_code ctx_create_db ( krb5_context context , krb5_db2_context * dbc ) { krb5_error_code retval = 0 ; char * dbname = NULL , * polname = NULL , * plockname = NULL ; retval = ctx_allfiles ( dbc , & dbname , & dbc -> db_lf_name , & polname , & plockname ) ; if ( retval ) { return retval ; } dbc -> db_lf_file = open ( dbc -> db_lf_name , O_CREAT | O_RDWR | O_TRUNC , 0600 ) ; if ( dbc -> db_lf_file < 0 ) { retval = errno ; cleanup } retval = krb5_lock_file ( context , dbc -> db_lf_file , KRB5_LOCKMODE_EXCLUSIVE ) ; if ( retval != 0 ) { cleanup } set_cloexec_fd ( dbc -> db_lf_file ) ; dbc -> db_lock_mode = KRB5_LOCKMODE_EXCLUSIVE ; dbc -> db_locks_held = 1 ; if ( dbc -> tempdb ) { ( void ) destroy_file ( dbname ) ; ( void ) unlink ( polname ) ; ( void ) unlink ( plockname ) ; } retval = open_db ( context , dbc , O_RDWR | O_CREAT | O_EXCL , 0600 , & dbc -> db ) ; if ( retval ) { cleanup } retval = osa_adb_create_db ( polname , plockname , OSA_ADB_POLICY_DB_MAGIC ) ; if ( retval ) { cleanup } retval = osa_adb_init_db ( & dbc -> policy_db , polname , plockname , OSA_ADB_POLICY_DB_MAGIC ) ; if ( retval ) { cleanup } retval = osa_adb_get_lock ( dbc -> policy_db , KRB5_DB_LOCKMODE_EXCLUSIVE ) ; if ( retval ) { cleanup } dbc -> db_inited = 1 ; cleanup if ( retval ) { if ( dbc -> db != NULL ) { dbc -> db -> close ( dbc -> db ) ; } if ( dbc -> db_locks_held > 0 ) { ( void ) krb5_lock_file ( context , dbc -> db_lf_file , KRB5_LOCKMODE_UNLOCK ) ; } if ( dbc -> db_lf_file >= 0 ) { close ( dbc -> db_lf_file ) ; } ctx_clear ( dbc ) ; } free ( polname ) ; free ( plockname ) ; return retval ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int wm8580_i2c_probe ( struct i2c_client * i2c ) { const struct of_device_id * of_id ; struct wm8580_priv * wm8580 ; int ret , i ; wm8580 = devm_kzalloc ( & i2c -> dev , sizeof ( wm8580_priv ) , GFP_KERNEL ) ; if ( wm8580 == NULL ) { return - ENOMEM ; } wm8580 -> regmap = devm_regmap_init_i2c ( i2c , & wm8580_regmap ) ; for ( i = 0 ; i < ARRAY_SIZE ( wm8580 -> supplies ) ; i ++ ) { wm8580 -> supplies [ i ] . supply = wm8580_supply_names [ i ] ; } ret = devm_regulator_bulk_get ( & i2c -> dev , ARRAY_SIZE ( wm8580 -> supplies ) , wm8580 -> supplies ) ; if ( ret != 0 ) { dev_err ( & i2c -> dev , \"Failed to request supplies: %d\\n\" , ret ) ; return ret ; } i2c_set_clientdata ( i2c , wm8580 ) ; of_id = of_match_device ( wm8580_of_match , & i2c -> dev ) ; if ( of_id ) { wm8580 -> drvdata = of_id -> data ; } if ( ! wm8580 -> drvdata ) { dev_err ( & i2c -> dev , \"failed to find driver data\\n\" ) ; return - EINVAL ; } ret = devm_snd_soc_register_component ( & i2c -> dev , & soc_component_dev_wm8580 , wm8580_dai , ARRAY_SIZE ( wm8580_dai ) ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int nvkm_voltgpio_init ( struct nvkm_volt * volt ) { struct nvkm_subdev * subdev = & volt -> subdev ; struct nvkm_gpio * gpio = subdev -> device -> gpio ; struct dcb_gpio_func func ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( tags ) ; i ++ ) { if ( volt -> vid_mask & ( 1 << i ) ) { int ret = nvkm_gpio_find ( gpio , 0 , tags [ i ] , 0xff , & func ) ; if ( ret ) { nvkm_debug ( subdev , \"VID bit %d has no GPIO\\n\" , i ) ; volt -> vid_mask &= ~ ( 1 << i ) ; } } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "module_param ( force_size , int , 0 ) ; MODULE_PARM_DESC ( force_size , \"Force size of card in MiB (1-64)\" ) ; module_param ( setvpp , int , 0 ) ; MODULE_PARM_DESC ( setvpp , \"Set Vpp (0=Never, 1=On writes, 2=Always on, default=0)\" ) ; module_param ( vpp , int , 0 ) ; MODULE_PARM_DESC ( vpp , \"Vpp value in 1/10ths eg 33=3.3V 120=12V (Dangerous)\" ) ; module_param ( mem_type , int , 0 ) ; MODULE_PARM_DESC ( mem_type , \"Set Memory type (0=Flash, 1=RAM, 2=ROM, default=0)\" ) ; static void __iomem * remap_window ( struct map_info * map , unsigned long to ) { struct pcmciamtd_dev * dev = ( pcmciamtd_dev * ) map -> map_priv_1 ; struct resource * win = ( resource * ) map -> map_priv_2 ; unsigned int offset ; int ret ; if ( ! pcmcia_dev_present ( dev -> p_dev ) ) { pr_debug ( \"device removed\\n\" ) ; return NULL ; } offset = to & ~ ( dev -> win_size - 1 ) ; if ( offset != dev -> offset ) { pr_debug ( \"Remapping window from 0x%8.8x to 0x%8.8x\\n\" , dev -> offset , offset ) ; ret = pcmcia_map_mem_page ( dev -> p_dev , win , offset ) ; if ( ret != 0 ) { return in ; } dev -> offset = offset ; } return dev -> win_base + ( to & ( dev -> win_size - 1 ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ar5008_calib_iq ( struct athn_softc * sc ) { struct athn_iq_cal * cal ; uint32_t reg , i_coff_denom , q_coff_denom ; int32_t i_coff , q_coff ; int i , iq_corr_neg ; for ( i = 0 ; i < AR_MAX_CHAINS ; i ++ ) { cal = & sc -> calib . iq [ i ] ; cal -> pwr_meas_i += AR_READ ( sc , AR_PHY_CAL_MEAS_0 ( i ) ) ; cal -> pwr_meas_q += AR_READ ( sc , AR_PHY_CAL_MEAS_1 ( i ) ) ; cal -> iq_corr_meas += ( int32_t ) AR_READ ( sc , AR_PHY_CAL_MEAS_2 ( i ) ) ; } if ( ! AR_SREV_9280_10_OR_LATER ( sc ) && ++ sc -> calib . nsamples < AR_CAL_SAMPLES ) { ar5008_do_calib ( sc ) ; return ; } for ( i = 0 ; i < sc -> nrxchains ; i ++ ) { cal = & sc -> calib . iq [ i ] ; if ( cal -> pwr_meas_q == 0 ) { continue ; } if ( ( iq_corr_neg = cal -> iq_corr_meas < 0 ) ) { cal -> iq_corr_meas = - cal -> iq_corr_meas ; } i_coff_denom = ( cal -> pwr_meas_i / 2 + cal -> pwr_meas_q / 2 ) / 128 ; q_coff_denom = cal -> pwr_meas_q / 64 ; if ( i_coff_denom == 0 || q_coff_denom == 0 ) { continue ; } i_coff = cal -> iq_corr_meas / i_coff_denom ; q_coff = ( cal -> pwr_meas_i / q_coff_denom ) - 64 ; if ( ! iq_corr_neg ) { i_coff = 0x40 - ( i_coff & 0x3f ) ; } if ( q_coff > 15 ) { q_coff = 15 ; } if ( q_coff <= - 16 ) { q_coff = - 16 ; } DPRINTFN ( 2 , ( \"IQ calibration for chain %d\\n\" , i ) ) ; reg = AR_READ ( sc , AR_PHY_TIMING_CTRL4 ( i ) ) ; reg = RW ( reg , AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF , i_coff ) ; reg = RW ( reg , AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF , q_coff ) ; AR_WRITE ( sc , AR_PHY_TIMING_CTRL4 ( i ) , reg ) ; } AR_SETBITS ( sc , AR_PHY_TIMING_CTRL4_0 , AR_PHY_TIMING_CTRL4_IQCORR_ENABLE ) ; AR_WRITE_BARRIER ( sc ) ; sc -> cur_calib_mask &= ~ ATHN_CAL_IQ ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int gemsafe_init ( struct sc_card * card ) { int r ; gemsafe_exdata * exdata = NULL ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; card -> name = \"GemSAFE V1\" ; card -> cla = 0x00 ; exdata = ( gemsafe_exdata * ) calloc ( 1 , sizeof ( gemsafe_exdata ) ) ; if ( ! exdata ) { return SC_ERROR_OUT_OF_MEMORY ; } exdata -> aid_len = sizeof ( exdata -> aid ) ; if ( card -> type == SC_CARD_TYPE_GEMSAFEV1_GENERIC ) { r = get_conf_aid ( card , exdata -> aid , & exdata -> aid_len ) ; if ( r < 0 ) { memcpy ( exdata -> aid , gemsafe_def_aid , sizeof ( gemsafe_def_aid ) ) ; exdata -> aid_len = sizeof ( gemsafe_def_aid ) ; } } if ( card -> type == SC_CARD_TYPE_GEMSAFEV1_PTEID ) { memcpy ( exdata -> aid , gemsafe_pteid_aid , sizeof ( gemsafe_pteid_aid ) ) ; exdata -> aid_len = sizeof ( gemsafe_pteid_aid ) ; } if ( card -> type == SC_CARD_TYPE_GEMSAFEV1_SEEID ) { memcpy ( exdata -> aid , gemsafe_seeid_aid , sizeof ( gemsafe_seeid_aid ) ) ; exdata -> aid_len = sizeof ( gemsafe_seeid_aid ) ; } card -> lock_count ++ ; r = gp_select_applet ( card , exdata -> aid , exdata -> aid_len ) ; if ( r < 0 ) { sc_log ( card -> ctx , \"applet selection failed\\n\" ) ; return SC_ERROR_INVALID_CARD ; } card -> lock_count -- ; unsigned long flags ; flags = SC_ALGORITHM_RSA_PAD_PKCS1 ; flags |= SC_ALGORITHM_RSA_PAD_ISO9796 ; flags |= SC_ALGORITHM_ONBOARD_KEY_GEN ; flags |= SC_ALGORITHM_RSA_HASH_NONE ; if ( card -> type == SC_CARD_TYPE_GEMSAFEV1_PTEID || card -> type == SC_CARD_TYPE_GEMSAFEV1_SEEID ) { flags |= SC_ALGORITHM_RSA_HASH_SHA256 ; } _sc_card_add_rsa_alg ( card , 512 , flags , 0 ) ; _sc_card_add_rsa_alg ( card , 768 , flags , 0 ) ; _sc_card_add_rsa_alg ( card , 1024 , flags , 0 ) ; _sc_card_add_rsa_alg ( card , 2048 , flags , 0 ) ; _sc_card_add_rsa_alg ( card , 3072 , flags , 0 ) ; _sc_card_add_rsa_alg ( card , 4096 , flags , 0 ) ; if ( card -> type == SC_CARD_TYPE_GEMSAFEV1_PTEID || card -> type == SC_CARD_TYPE_GEMSAFEV1_SEEID ) { flags = SC_ALGORITHM_RSA_HASH_SHA1 ; flags |= SC_ALGORITHM_RSA_HASH_MD5 ; flags |= SC_ALGORITHM_RSA_HASH_MD5_SHA1 ; flags |= SC_ALGORITHM_RSA_HASH_RIPEMD160 ; _sc_card_add_rsa_alg ( card , 512 , flags , 0 ) ; } card -> caps |= SC_CARD_CAP_ISO7816_PIN_INFO ; card -> drv_data = exdata ; return SC_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int test_enumerate ( struct udev * udev , const char * subsystem ) { struct udev_enumerate * udev_enumerate ; int r ; log_info ( \"\" , __func__ ) ; log_info ( \"enumerate '%s'\" , subsystem == NULL ?\"<all>\" : subsystem ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_match_subsystem ( udev_enumerate , subsystem ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate , NULL ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'net' + duplicated scan + null + zero\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_match_subsystem ( udev_enumerate , \"net\" ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/zero\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/null\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/zero\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/null\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/zero\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/null\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/null\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/zero\" ) ; udev_enumerate_add_syspath ( udev_enumerate , \"/sys/class/mem/zero\" ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'block'\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_match_subsystem ( udev_enumerate , \"block\" ) ; r = udev_enumerate_add_match_is_initialized ( udev_enumerate ) ; if ( r < 0 ) { udev_enumerate_unref ( udev_enumerate ) ; return r ; } udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'not block'\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_nomatch_subsystem ( udev_enumerate , \"block\" ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'pci, mem, vc'\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_match_subsystem ( udev_enumerate , \"pci\" ) ; udev_enumerate_add_match_subsystem ( udev_enumerate , \"mem\" ) ; udev_enumerate_add_match_subsystem ( udev_enumerate , \"vc\" ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'subsystem'\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_scan_subsystems ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; log_info ( \"enumerate 'property IF_FS_*=filesystem'\" ) ; udev_enumerate = udev_enumerate_new ( udev ) ; if ( ! udev_enumerate ) { return - 1 ; } udev_enumerate_add_match_property ( udev_enumerate , \"ID_FS*\" , \"filesystem\" ) ; udev_enumerate_scan_devices ( udev_enumerate ) ; enumerate_print_list ( udev_enumerate ) ; udev_enumerate_unref ( udev_enumerate ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int build_iface_list ( void ) { { struct nlmsghdr nlh ; struct rtgenmsg g ; } , req int rtn = 0 ; struct nlmsghdr * nlp ; struct ifaddrmsg * ifi ; int rtl ; char buf [ NETLINK_BUFFER_SIZE ] ; char * p = buf ; int nll = 0 ; struct rtattr * rtap ; int index , i ; struct idx * entry ; struct idx * tmp ; int nl_sock = - 1 ; int families [ ] { AF_INET AF_INET6 } ; ; char name [ MAX_IF_LEN ] ; int is_link_local = 0 ; if ( ifaces == NULL ) { if ( ( ifaces = ( idxlist * ) pkg_malloc ( MAX_IFACE_NO * sizeof ( idxlist ) ) ) == NULL ) { PKG_MEM_ERROR ; return - 1 ; } memset ( ifaces , 0 , sizeof ( idxlist ) * MAX_IFACE_NO ) ; } if ( ( nl_sock = nl_bound_sock ( ) ) < 0 ) { return - 1 ; } for ( i = 0 ; i < sizeof ( families ) / sizeof ( int ) ; i ++ ) { fill_nl_req ( req , RTM_GETADDR , families [ i ] ) ; if ( send ( nl_sock , ( void * ) & req , sizeof ( req ) , 0 ) < 0 ) { LM_ERR ( \"error sending NETLINK request\\n\" ) ; error } nll = 0 ; p = buf ; while ( 1 ) { if ( ( sizeof ( buf ) - nll ) == 0 ) { LM_ERR ( \"netlink buffer overflow in build_iface_list\" ) ; error } rtn = recv ( nl_sock , p , sizeof ( buf ) - nll , 0 ) ; LM_DBG ( \"received %d byles \\n\" , rtn ) ; nlp = ( nlmsghdr * ) p ; if ( nlp -> nlmsg_type == NLMSG_DONE ) { LM_DBG ( \"done receiving netlink info \\n\" ) ; break ; } if ( nlp -> nlmsg_type == NLMSG_ERROR ) { LM_ERR ( \"Error on message to netlink\" ) ; break ; } p += rtn ; nll += rtn ; } nlp = ( nlmsghdr * ) buf ; for ( ; NLMSG_OK ( nlp , nll ) ; nlp = NLMSG_NEXT ( nlp , nll ) ) { ifi = NLMSG_DATA ( nlp ) ; if ( nlp -> nlmsg_len < NLMSG_LENGTH ( sizeof ( ifi ) ) ) { continue ; } rtap = ( rtattr * ) IFA_RTA ( ifi ) ; rtl = IFA_PAYLOAD ( nlp ) ; index = ifi -> ifa_index ; if ( index >= MAX_IFACE_NO ) { LM_ERR ( \"Invalid interface index returned: %d\\n\" , index ) ; error } entry = ( idx * ) pkg_malloc ( sizeof ( idx ) ) ; if ( entry == 0 ) { PKG_MEM_ERROR ; error } entry -> next = 0 ; entry -> family = families [ i ] ; entry -> ifa_flags = ifi -> ifa_flags ; is_link_local = 0 ; name [ 0 ] = '\\0' ; for ( ; RTA_OK ( rtap , rtl ) ; rtap = RTA_NEXT ( rtap , rtl ) ) { switch ( rtap -> rta_type ) { case IFA_ADDRESS : if ( ( * ( int * ) RTA_DATA ( rtap ) ) == htons ( 0xfe80 ) ) { LM_DBG ( \"Link Local Address, ignoring ...\\n\" ) ; is_link_local = 1 ; break ; } inet_ntop ( families [ i ] , RTA_DATA ( rtap ) , entry -> addr , MAX_IF_LEN ) ; LM_DBG ( \"iface<IFA_ADDRESS>addr is  %s\\n\" , entry -> addr ) ; break ; case IFA_LOCAL : if ( ( * ( int * ) RTA_DATA ( rtap ) ) == htons ( 0xfe80 ) ) { LM_DBG ( \"Link Local Address, ignoring ...\\n\" ) ; is_link_local = 1 ; } inet_ntop ( families [ i ] , RTA_DATA ( rtap ) , entry -> addr , MAX_IF_LEN ) ; LM_DBG ( \"iface<IFA_LOCAL>addr is %s\\n\" , entry -> addr ) ; break ; case IFA_LABEL : LM_DBG ( \"iface name is %s\\n\" , ( char * ) RTA_DATA ( rtap ) ) ; strncpy ( name , ( char * ) RTA_DATA ( rtap ) , MAX_IF_LEN - 1 ) ; name [ MAX_IF_LEN - 1 ] = '\\0' ; break ; case IFA_BROADCAST : case IFA_ANYCAST : case IFA_UNSPEC : case IFA_CACHEINFO : default : break ; } } if ( is_link_local ) { if ( sr_bind_ipv6_link_local == 0 ) { pkg_free ( entry ) ; continue ; } } if ( strlen ( ifaces [ index ] . name ) == 0 && strlen ( name ) > 0 ) { memcpy ( ifaces [ index ] . name , name , MAX_IF_LEN - 1 ) ; ifaces [ index ] . name [ MAX_IF_LEN - 1 ] = '\\0' ; } ifaces [ index ] . index = index ; if ( ifaces [ index ] . addresses == 0 ) { ifaces [ index ] . addresses = entry ; } else { for ( tmp = ifaces [ index ] . addresses ; tmp -> next ; tmp = tmp -> next ) { } tmp -> next = entry ; } } } if ( nl_sock > 0 ) { close ( nl_sock ) ; } for ( i = 0 ; i < sizeof ( families ) / sizeof ( int ) ; i ++ ) { get_flags ( families [ i ] ) ; } return 0 ; error if ( nl_sock >= 0 ) { close ( nl_sock ) ; } return - 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void gf_scene_on_node_destroyed ( void * _is , GF_Node * node ) { GF_Scene * scene = ( GF_Scene * ) _is ; gf_sc_node_destroy ( scene -> compositor , node , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int sshbuf_put ( struct sshbuf * buf , const void * v , size_t len ) { u_char * p ; int r ; if ( len != 0 ) { memcpy ( p , v , len ) ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void i915_pxp_tee_component_unbind ( struct device * i915_kdev , struct device * tee_kdev , void * data ) { struct drm_i915_private * i915 = kdev_to_i915 ( i915_kdev ) ; struct intel_pxp * pxp = i915 -> pxp ; intel_wakeref_t wakeref ; if ( intel_pxp_is_enabled ( pxp ) ) { with_intel_runtime_pm_if_in_use ( , ) intel_pxp_fini_hw ( pxp ) ; } mutex_lock ( & pxp -> tee_mutex ) ; mutex_unlock ( & pxp -> tee_mutex ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int mdc_check_slave_width ( struct mdc_chan * mchan , enum dma_transfer_direction dir ) { enum dma_slave_buswidth width ; if ( dir == DMA_MEM_TO_DEV ) { width = mchan -> config . dst_addr_width ; } else { width = mchan -> config . src_addr_width ; } switch ( width ) { case DMA_SLAVE_BUSWIDTH_1_BYTE : case DMA_SLAVE_BUSWIDTH_2_BYTES : case DMA_SLAVE_BUSWIDTH_4_BYTES : case DMA_SLAVE_BUSWIDTH_8_BYTES : break ; default : return - EINVAL ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "unsigned long long strtoull ( const char * nptr , char * * endptr , int base ) { const char * s ; unsigned long long acc , cutoff ; int c ; int neg , any , cutlim ; if ( base ( 0 || base == 1 || base ) 36 ) { if ( endptr != 0 ) { * endptr = ( char * ) nptr ; } errno = EINVAL ; return 0 ; } s = nptr ; { c = ( unsigned char ) * s ++ ; } isspace ( c ) ; if ( c == '-' ) { neg = 1 ; c = * s ++ ; } else { neg = 0 ; if ( c == '+' ) { c = * s ++ ; } } if ( ( base == 0 || base == 16 ) && c == '0' && ( * s == 'x' || * s == 'X' ) && isxdigit ( ( unsigned char ) s [ 1 ] ) ) { c = s [ 1 ] ; s += 2 ; base = 16 ; } if ( base == 0 ) { base = c == '0' ?8 : 10 ; } cutoff = ULLONG_MAX / ( unsigned long long ) base ; cutlim = ULLONG_MAX % ( unsigned long long ) base ; for ( acc = 0 , any = 0 ; ; c = ( unsigned char ) * s ++ ) { if ( isdigit ( c ) ) { c -= '0' ; } if ( isalpha ( c ) ) { c -= isupper ( c ) ?'A' - 10 : 'a' - 10 ; } else { break ; } if ( c >= base ) { break ; } if ( acc > cutoff || ( acc == cutoff && c > cutlim ) ) { any = - 1 ; acc = ULLONG_MAX ; errno = ERANGE ; } else { any = 1 ; acc *= ( unsigned long long ) base ; acc += c ; } } if ( neg && any > 0 ) { acc = - acc ; } if ( endptr != 0 ) { * endptr = ( char * ) ( any ?s - 1 : nptr ) ; } return ( acc ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "u32_t lm_ctx_rd ( lm_device_t * pdev , u32_t cid_addr , u32_t offset ) { u32_t retry_cnt ; u32_t val ; u32_t idx ; DbgBreakIf ( cid_addr > MAX_CID_ADDR || offset & 0x3 || cid_addr & CTX_MASK ) ; offset += cid_addr ; if ( CHIP_NUM ( pdev ) == CHIP_NUM_5709 ) { if ( CHIP_REV ( pdev ) == CHIP_REV_IKOS ) { retry_cnt = 1000 ; } else { retry_cnt = 25 ; } REG_WR ( pdev , context . ctx_ctx_ctrl , offset | CTX_CTX_CTRL_READ_REQ ) ; for ( idx = 0 ; idx < retry_cnt ; idx ++ ) { REG_RD ( pdev , context . ctx_ctx_ctrl , & val ) ; mm_wait ( pdev , 5 ) ; } DbgBreakIf ( idx == retry_cnt ) ; REG_RD ( pdev , context . ctx_ctx_data , & val ) ; } else { REG_WR ( pdev , context . ctx_data_adr , offset ) ; REG_RD ( pdev , context . ctx_data , & val ) ; } return val ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int verbose ; int main ( int argc , char * argv [ ] ) { int c , i , ppem = 0 , verb = 0 ; struct mft * p ; X509 * xp = NULL ; unsigned char * buf ; size_t len ; ERR_load_crypto_strings ( ) ; OpenSSL_add_all_ciphers ( ) ; OpenSSL_add_all_digests ( ) ; x509_init_oid ( ) ; while ( - 1 != ( c = getopt ( argc , argv , \"pv\" ) ) ) { switch ( c ) { case 'p' : if ( ppem ) { break ; } ppem = 1 ; break ; case 'v' : verb ++ ; break ; default : errx ( 1 , \"bad argument %c\" , c ) ; } } argv += optind ; argc -= optind ; if ( argc == 0 ) { errx ( 1 , \"argument missing\" ) ; } for ( i = 0 ; i < argc ; i ++ ) { buf = load_file ( argv [ i ] , & len ) ; if ( ( p = mft_parse ( & xp , argv [ i ] , buf , len ) ) == NULL ) { break ; } if ( verb ) { mft_print ( xp , p ) ; } if ( ppem ) { if ( ! PEM_write_X509 ( stdout , xp ) ) { errx ( 1 , \"PEM_write_X509: unable to write cert\" ) ; } } free ( buf ) ; mft_free ( p ) ; X509_free ( xp ) ; } EVP_cleanup ( ) ; CRYPTO_cleanup_all_ex_data ( ) ; ERR_free_strings ( ) ; if ( i < argc ) { errx ( 1 , \"test failed for %s\" , argv [ i ] ) ; } printf ( \"OK\\n\" ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void zfcp_fsf_open_lun_handler ( struct zfcp_fsf_req * req ) { struct zfcp_adapter * adapter = req -> adapter ; struct scsi_device * sdev = req -> data ; struct zfcp_scsi_dev * zfcp_sdev ; struct fsf_qtcb_header * header = & req -> qtcb -> header ; union fsf_status_qual * qual = & header -> fsf_status_qual ; zfcp_sdev = sdev_to_zfcp ( sdev ) ; atomic_andnot ( ZFCP_STATUS_COMMON_ACCESS_DENIED | ZFCP_STATUS_COMMON_ACCESS_BOXED , & zfcp_sdev -> status ) ; switch ( header -> fsf_status ) { case FSF_PORT_HANDLE_NOT_VALID : zfcp_erp_adapter_reopen ( adapter , 0 , \"fsouh_1\" ) ; case FSF_LUN_ALREADY_OPEN : break ; case FSF_PORT_BOXED : zfcp_erp_set_port_status ( zfcp_sdev -> port , ZFCP_STATUS_COMMON_ACCESS_BOXED ) ; zfcp_erp_port_reopen ( zfcp_sdev -> port , ZFCP_STATUS_COMMON_ERP_FAILED , \"fsouh_2\" ) ; req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_LUN_SHARING_VIOLATION : if ( qual -> word [ 0 ] ) { dev_warn ( & zfcp_sdev -> port -> adapter -> ccw_device -> dev , \"LUN 0x%Lx on port 0x%Lx is already in \" \"use by CSS%d, MIF Image ID %x\\n\" , zfcp_scsi_dev_lun ( sdev ) , ( unsigned long long ) zfcp_sdev -> port -> wwpn , qual -> fsf_queue_designator . cssid , qual -> fsf_queue_designator . hla ) ; } zfcp_erp_set_lun_status ( sdev , ZFCP_STATUS_COMMON_ERP_FAILED | ZFCP_STATUS_COMMON_ACCESS_DENIED ) ; req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_MAXIMUM_NUMBER_OF_LUNS_EXCEEDED : dev_warn ( & adapter -> ccw_device -> dev , \"No handle is available for LUN \" \"0x%016Lx on port 0x%016Lx\\n\" , ( unsigned long long ) zfcp_scsi_dev_lun ( sdev ) , ( unsigned long long ) zfcp_sdev -> port -> wwpn ) ; zfcp_erp_set_lun_status ( sdev , ZFCP_STATUS_COMMON_ERP_FAILED ) ; case FSF_INVALID_COMMAND_OPTION : req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_ADAPTER_STATUS_AVAILABLE : switch ( header -> fsf_status_qual . word [ 0 ] ) { case FSF_SQ_INVOKE_LINK_TEST_PROCEDURE : zfcp_fc_test_link ( zfcp_sdev -> port ) ; case FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED : req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; } break ; case FSF_GOOD : zfcp_sdev -> lun_handle = header -> lun_handle ; atomic_or ( ZFCP_STATUS_COMMON_OPEN , & zfcp_sdev -> status ) ; break ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void oper_free ( gpointer value ) { oper_t * oper = value ; ws_assert_magic ( oper , OPER_MAGIC ) ; if ( oper -> val1 ) { stnode_free ( oper -> val1 ) ; } if ( oper -> val2 ) { stnode_free ( oper -> val2 ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static server_t * new_server ( int fd ) { server_t * server = ss_malloc ( sizeof ( server_t ) ) ; server -> recv_ctx = ss_malloc ( sizeof ( server_ctx_t ) ) ; server -> send_ctx = ss_malloc ( sizeof ( server_ctx_t ) ) ; server -> buf = ss_malloc ( sizeof ( buffer_t ) ) ; balloc ( server -> buf , SOCKET_BUF_SIZE ) ; memset ( server -> recv_ctx , 0 , sizeof ( server_ctx_t ) ) ; memset ( server -> send_ctx , 0 , sizeof ( server_ctx_t ) ) ; server -> fd = fd ; server -> recv_ctx -> server = server ; server -> recv_ctx -> connected = 0 ; server -> send_ctx -> server = server ; server -> send_ctx -> connected = 0 ; server -> e_ctx = ss_malloc ( sizeof ( cipher_ctx_t ) ) ; server -> d_ctx = ss_malloc ( sizeof ( cipher_ctx_t ) ) ; crypto -> ctx_init ( crypto -> cipher , server -> e_ctx , 1 ) ; crypto -> ctx_init ( crypto -> cipher , server -> d_ctx , 0 ) ; ev_io_init ( & server -> recv_ctx -> io , server_recv_cb , fd , EV_READ ) ; ev_io_init ( & server -> send_ctx -> io , server_send_cb , fd , EV_WRITE ) ; ev_timer_init ( & server -> delayed_connect_watcher , delayed_connect_cb , 0.05 , 0 ) ; return server ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int gxio_usb_host_init ( gxio_usb_host_context_t * context , int usb_index , int is_ehci ) { char file [ 32 ] ; int fd ; if ( is_ehci ) { snprintf ( file , sizeof ( file ) , \"usb_host/%d/iorpc/ehci\" , usb_index ) ; } else { snprintf ( file , sizeof ( file ) , \"usb_host/%d/iorpc/ohci\" , usb_index ) ; } fd = hv_dev_open ( ( HV_VirtAddr ) file , 0 ) ; if ( fd < 0 ) { if ( fd >= GXIO_ERR_MIN && fd <= GXIO_ERR_MAX ) { return fd ; } else { return - ENODEV ; } } context -> fd = fd ; context -> mmio_base = ( void __force * ) iorpc_ioremap ( fd , 0 , HV_USB_HOST_MMIO_SIZE ) ; if ( context -> mmio_base == NULL ) { hv_dev_close ( context -> fd , NULL ) ; return - ENODEV ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int xmlReconciliateNs ( xmlDocPtr doc , xmlNodePtr tree ) { xmlNsPtr * oldNs = NULL ; xmlNsPtr * newNs = NULL ; int sizeCache = 0 ; int nbCache = 0 ; xmlNsPtr n ; xmlNodePtr node = tree ; xmlAttrPtr attr ; int ret = 0 , i ; if ( ( node == NULL ) || ( node -> type != XML_ELEMENT_NODE ) ) { return ( - 1 ) ; } if ( ( doc == NULL ) || ( doc -> type != XML_DOCUMENT_NODE ) ) { return ( - 1 ) ; } if ( node -> doc != doc ) { return ( - 1 ) ; } while ( node != NULL ) { if ( node -> ns != NULL ) { if ( sizeCache == 0 ) { sizeCache = 10 ; oldNs = ( xmlNsPtr * ) xmlMalloc ( sizeCache * sizeof ( xmlNsPtr ) ) ; if ( oldNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; return ( - 1 ) ; } newNs = ( xmlNsPtr * ) xmlMalloc ( sizeCache * sizeof ( xmlNsPtr ) ) ; if ( newNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; return ( - 1 ) ; } } for ( i = 0 ; i < nbCache ; i ++ ) { if ( oldNs [ i ] == node -> ns ) { node -> ns = newNs [ i ] ; break ; } } if ( i == nbCache ) { n = xmlNewReconciledNs ( doc , tree , node -> ns ) ; if ( n != NULL ) { if ( sizeCache <= nbCache ) { sizeCache *= 2 ; oldNs = ( xmlNsPtr * ) xmlRealloc ( oldNs , sizeCache * sizeof ( xmlNsPtr ) ) ; if ( oldNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; xmlFree ( newNs ) ; return ( - 1 ) ; } newNs = ( xmlNsPtr * ) xmlRealloc ( newNs , sizeCache * sizeof ( xmlNsPtr ) ) ; if ( newNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; xmlFree ( oldNs ) ; return ( - 1 ) ; } } newNs [ nbCache ] = n ; oldNs [ nbCache ++ ] = node -> ns ; node -> ns = n ; } } } if ( node -> type == XML_ELEMENT_NODE ) { attr = node -> properties ; while ( attr != NULL ) { if ( attr -> ns != NULL ) { if ( sizeCache == 0 ) { sizeCache = 10 ; oldNs = ( xmlNsPtr * ) xmlMalloc ( sizeCache * sizeof ( xmlNsPtr ) ) ; if ( oldNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; return ( - 1 ) ; } newNs = ( xmlNsPtr * ) xmlMalloc ( sizeCache * sizeof ( xmlNsPtr ) ) ; if ( newNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; xmlFree ( oldNs ) ; return ( - 1 ) ; } } for ( i = 0 ; i < nbCache ; i ++ ) { if ( oldNs [ i ] == attr -> ns ) { attr -> ns = newNs [ i ] ; break ; } } if ( i == nbCache ) { n = xmlNewReconciledNs ( doc , tree , attr -> ns ) ; if ( n != NULL ) { if ( sizeCache <= nbCache ) { sizeCache *= 2 ; oldNs = ( xmlNsPtr * ) xmlRealloc ( oldNs , sizeCache * sizeof ( xmlNsPtr ) ) ; if ( oldNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; xmlFree ( newNs ) ; return ( - 1 ) ; } newNs = ( xmlNsPtr * ) xmlRealloc ( newNs , sizeCache * sizeof ( xmlNsPtr ) ) ; if ( newNs == NULL ) { xmlTreeErrMemory ( \"fixing namespaces\" ) ; xmlFree ( oldNs ) ; return ( - 1 ) ; } } newNs [ nbCache ] = n ; oldNs [ nbCache ++ ] = attr -> ns ; attr -> ns = n ; } } } attr = attr -> next ; } } if ( ( node -> children != NULL ) && ( node -> type != XML_ENTITY_REF_NODE ) ) { node = node -> children ; } if ( ( node != tree ) && ( node -> next != NULL ) ) { node = node -> next ; } if ( node != tree ) { while ( node != tree ) { if ( node -> parent != NULL ) { node = node -> parent ; } if ( ( node != tree ) && ( node -> next != NULL ) ) { node = node -> next ; break ; } if ( node -> parent == NULL ) { node = NULL ; break ; } } if ( node == tree ) { node = NULL ; } } else { break ; } } if ( oldNs != NULL ) { xmlFree ( oldNs ) ; } if ( newNs != NULL ) { xmlFree ( newNs ) ; } return ( ret ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ecm_notify_complete ( struct usb_ep * ep , struct usb_request * req ) { struct f_ecm * ecm = req -> context ; struct usb_composite_dev * cdev = ecm -> port . func . config -> cdev ; struct usb_cdc_notification * event = req -> buf ; switch ( req -> status ) { case 0 : break ; case - ECONNRESET : case - ESHUTDOWN : break ; default : DBG ( cdev , \"event %02x -->%d\\n\" , event -> bNotificationType , req -> status ) ; break ; } ecm -> notify_req = req ; ecm_do_notify ( ecm ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void umc_v8_7_ecc_info_query_ras_error_address ( struct amdgpu_device * adev , void * ras_error_status ) { struct ras_err_data * err_data = ( ras_err_data * ) ras_error_status ; int umc_inst = 0 ; uint32_t ch_inst = 0 ; LOOP_UMC_INST_AND_CH ( , ) { umc_v8_7_ecc_info_query_error_address ( adev , err_data , ch_inst , umc_inst ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int virNetDevVPortProfileCheckComplete ( virNetDevVPortProfile * virtport , bool generateMissing ) { const char * missing = NULL ; switch ( virtport -> virtPortType ) { case VIR_NETDEV_VPORT_PROFILE_8021QBG : if ( ! virtport -> managerID_specified ) { missing = \"managerid\" ; } if ( ! virtport -> typeID_specified ) { missing = \"typeid\" ; } if ( ! virtport -> typeIDVersion_specified ) { missing = \"typeidversion\" ; } if ( ! virtport -> instanceID_specified ) { if ( generateMissing ) { if ( virUUIDGenerate ( virtport -> instanceID ) < 0 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"cannot generate a random uuid for instanceid\" ) ) ; return - 1 ; } virtport -> instanceID_specified = true ; } else { missing = \"instanceid\" ; } } break ; case VIR_NETDEV_VPORT_PROFILE_8021QBH : if ( ! virtport -> profileID [ 0 ] ) { missing = \"profileid\" ; } break ; case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH : if ( ! virtport -> interfaceID_specified ) { if ( generateMissing ) { if ( virUUIDGenerate ( virtport -> interfaceID ) < 0 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"cannot generate a random uuid for interfaceid\" ) ) ; return - 1 ; } virtport -> interfaceID_specified = true ; } else { missing = \"interfaceid\" ; } } break ; case VIR_NETDEV_VPORT_PROFILE_MIDONET : if ( ! virtport -> interfaceID_specified ) { missing = \"interfaceid\" ; } break ; } if ( missing ) { virReportError ( VIR_ERR_XML_ERROR , _ ( \"missing %s in<virtualport type='%s'>\" ) , missing , virNetDevVPortTypeToString ( virtport -> virtPortType ) ) ; return - 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int newcolorstack ( integer s , integer literal_mode , boolean page_start ) { colstack_type * colstack ; int colstack_num ; char * str ; init_colorstacks ( ) ; if ( colstacks_used == MAX_COLORSTACKS ) { return - 1 ; } if ( colstacks_used == colstacks_size ) { colstacks_size += STACK_INCREMENT ; xretalloc ( colstacks , colstacks_size , colstack_type ) ; } colstack_num = colstacks_used ++ ; colstack = & colstacks [ colstack_num ] ; colstack -> page_stack = NULL ; colstack -> form_stack = NULL ; colstack -> page_size = 0 ; colstack -> page_used = 0 ; colstack -> form_size = 0 ; colstack -> form_used = 0 ; colstack -> literal_mode = literal_mode ; colstack -> page_start = page_start ; str = makecstring ( s ) ; if ( * str == 0 ) { colstack -> page_current = NULL ; colstack -> form_init = NULL ; } else { colstack -> page_current = xstrdup ( str ) ; colstack -> form_current = xstrdup ( str ) ; colstack -> form_init = xstrdup ( str ) ; } return colstack_num ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ki_diameter_request ( struct sip_msg * msg , str * s_peer , int i_appid , int i_commandcode , str * s_message , int async ) { AAAMessage * req = 0 ; AAASession * session = 0 ; AAAMessage * resp = 0 ; session = cdpb . AAACreateSession ( 0 ) ; req = cdpb . AAACreateRequest ( i_appid , i_commandcode , Flag_Proxyable , session ) ; if ( session ) { cdpb . AAADropSession ( session , NULL ) ; session = 0 ; } if ( ! req ) { LM_ERR ( \"Error occurred trying to send request\\n\" ) ; return - 1 ; } if ( ! addAVPsfromJSON ( req , s_message ) ) { LM_ERR ( \"Failed to parse JSON Request\\n\" ) ; return - 1 ; } if ( s_peer && ( s_peer -> len > 0 ) ) { if ( async ) { cdpb . AAASendMessageToPeer ( req , s_peer , ( void * ) async_cdp_diameter_callback , req ) ; LM_DBG ( \"Successfully sent async diameter\\n\" ) ; return 0 ; } else { resp = cdpb . AAASendRecvMessageToPeer ( req , s_peer ) ; LM_DBG ( \"Successfully sent diameter\\n\" ) ; if ( resp && AAAmsg2json ( resp , & responsejson ) == 1 ) { return 1 ; } else { LM_ERR ( \"Failed to convert response to JSON\\n\" ) ; return - 1 ; } } } else { if ( async ) { cdpb . AAASendMessage ( req , ( void * ) async_cdp_diameter_callback , req ) ; LM_DBG ( \"Successfully sent async diameter\\n\" ) ; return 0 ; } else { resp = cdpb . AAASendRecvMessage ( req ) ; LM_DBG ( \"Successfully sent diameter\\n\" ) ; if ( resp && AAAmsg2json ( resp , & responsejson ) == 1 ) { return 1 ; } else { LM_ERR ( \"Failed to convert response to JSON\\n\" ) ; return - 1 ; } } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nicvf_cmp_queue_config ( struct nicvf * nic , struct queue_set * qs , int qidx , bool enable ) { struct cmp_queue * cq ; { u64 u ; struct cq_cfg s ; } , cq_cfg cq = & qs -> cq [ qidx ] ; cq -> enable = enable ; if ( ! cq -> enable ) { nicvf_reclaim_cmp_queue ( nic , qs , qidx ) ; return ; } nicvf_queue_reg_write ( nic , NIC_QSET_CQ_0_7_CFG , qidx , NICVF_CQ_RESET ) ; if ( ! cq -> enable ) { return ; } nicvf_queue_reg_write ( nic , NIC_QSET_CQ_0_7_BASE , qidx , ( u64 ) ( cq -> dmem . phys_base ) ) ; cq_cfg . s . reset = 0 ; cq_cfg . s . caching = 0 ; cq_cfg . s . qsize = CMP_QSIZE ; cq_cfg . s . avg_con = 0 ; nicvf_queue_reg_write ( nic , NIC_QSET_CQ_0_7_CFG , qidx , cq_cfg . u ) ; nicvf_queue_reg_write ( nic , NIC_QSET_CQ_0_7_THRESH , qidx , cq -> thresh ) ; nicvf_queue_reg_write ( nic , NIC_QSET_CQ_0_7_CFG2 , qidx , cq -> intr_timer_thresh ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "krb5_error_code krb5_auth_to_rep ( krb5_context context , krb5_tkt_authent * auth , krb5_donot_replay * rep ) { krb5_error_code retval ; rep -> cusec = auth -> authenticator -> cusec ; rep -> ctime = auth -> authenticator -> ctime ; if ( ( retval = krb5_unparse_name ( context , auth -> ticket -> server , & rep -> server ) ) ) { return retval ; } if ( ( retval = krb5_unparse_name ( context , auth -> authenticator -> client , & rep -> client ) ) ) { FREE_RC ( rep -> server , NULL ) ; return retval ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int urng_match ( struct device * parent , void * match , void * aux ) { struct usb_attach_arg * uaa = aux ; if ( urng_lookup ( uaa -> vendor , uaa -> product ) != NULL ) { return ( UMATCH_VENDOR_PRODUCT ) ; } return ( UMATCH_NONE ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int rtw_cfg80211_check_bss ( struct adapter * padapter ) { struct wlan_bssid_ex * pnetwork = & ( padapter -> mlmeextpriv . mlmext_info . network ) ; struct cfg80211_bss * bss = NULL ; struct ieee80211_channel * notify_channel = NULL ; u32 freq ; freq = rtw_ieee80211_channel_to_frequency ( pnetwork -> Configuration . DSConfig , NL80211_BAND_2GHZ ) ; notify_channel = ieee80211_get_channel ( padapter -> rtw_wdev -> wiphy , freq ) ; bss = cfg80211_get_bss ( padapter -> rtw_wdev -> wiphy , notify_channel , pnetwork -> MacAddress , pnetwork -> Ssid . Ssid , pnetwork -> Ssid . SsidLength , WLAN_CAPABILITY_ESS , WLAN_CAPABILITY_ESS ) ; cfg80211_put_bss ( padapter -> rtw_wdev -> wiphy , bss ) ; return ( bss != NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "long memfd_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { long error ; switch ( cmd ) { case F_ADD_SEALS : error = memfd_add_seals ( file , arg ) ; break ; case F_GET_SEALS : error = memfd_get_seals ( file ) ; break ; default : error = - EINVAL ; break ; } return error ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static BackgroundStatus * b2d_get_status ( Background2DStack * stack , GF_List * background_stack ) { u32 i , count ; if ( ! background_stack ) { return in ; } count = gf_list_count ( stack -> reg_stacks ) ; for ( i = 0 ; i < count ; i ++ ) { GF_List * bind_stack = ( GF_List * ) gf_list_get ( stack -> reg_stacks , i ) ; if ( bind_stack == background_stack ) { return gf_list_get ( stack -> status_stack , i ) ; } } return NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void yaffs_deinit_raw_tnodes ( struct yaffs_dev * dev ) { struct yaffs_allocator * allocator = ( yaffs_allocator * ) dev -> allocator ; struct yaffs_tnode_list * tmp ; if ( ! allocator ) { BUG ( ) ; return ; } while ( allocator -> alloc_tnode_list ) { tmp = allocator -> alloc_tnode_list -> next ; kfree ( allocator -> alloc_tnode_list -> tnodes ) ; allocator -> alloc_tnode_list = tmp ; } allocator -> free_tnodes = NULL ; allocator -> n_free_tnodes = 0 ; allocator -> n_tnodes_created = 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void fcoe_rx ( void * arg , mac_resource_handle_t mrh , mblk_t * mp , boolean_t loopback ) { fcoe_mac_t * mac = ( fcoe_mac_t * ) arg ; mblk_t * next ; fcoe_frame_t * frm ; uint32_t raw_frame_size , frame_size ; uint16_t frm_type ; while ( mp != NULL ) { next = mp -> b_next ; mp -> b_next = NULL ; frm_type = ntohs ( * ( uint16_t * ) ( ( uintptr_t ) mp -> b_rptr + 12 ) ) ; if ( frm_type != ETHERTYPE_FCOE ) { freeb ( mp ) ; mp = next ; continue ; } raw_frame_size = MBLKL ( mp ) ; frame_size = raw_frame_size - PADDING_SIZE ; frm = fcoe_allocate_frame ( & mac -> fm_eport , frame_size , mp ) ; if ( frm != NULL ) { frm -> frm_clock = CURRENT_CLOCK ; fcoe_post_frame ( frm , NULL ) ; } mp = next ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int sc27xx_led_enable ( struct sc27xx_led * leds , enum led_brightness value ) { u32 base = sc27xx_led_get_offset ( leds ) ; u32 ctrl_base = leds -> priv -> base + SC27XX_LEDS_CTRL ; u8 ctrl_shift = SC27XX_CTRL_SHIFT * leds -> line ; struct regmap * regmap = leds -> priv -> regmap ; int err ; err = regmap_update_bits ( regmap , base + SC27XX_LEDS_DUTY , SC27XX_DUTY_MASK , ( value << SC27XX_DUTY_SHIFT ) | SC27XX_MOD_MASK ) ; return regmap_update_bits ( regmap , ctrl_base , ( SC27XX_LED_RUN | SC27XX_LED_TYPE ) << ctrl_shift , ( SC27XX_LED_RUN | SC27XX_LED_TYPE ) << ctrl_shift ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int evtag_encode_tag ( struct evbuffer * evbuf , ev_uint32_t tag ) { int bytes = 0 ; ev_uint8_t data [ 5 ] ; { ev_uint8_t lower = tag & 0x7f ; tag >>= 7 ; if ( tag ) { lower |= 0x80 ; } data [ bytes ++ ] = lower ; } tag ; if ( evbuf != NULL ) { evbuffer_add ( evbuf , data , bytes ) ; } return ( bytes ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static gboolean snoop_read ( wtap * wth , wtap_rec * rec , Buffer * buf , int * err , gchar * * err_info , gint64 * data_offset ) { int padbytes ; * data_offset = file_tell ( wth -> fh ) ; padbytes = snoop_read_packet ( wth , wth -> fh , rec , buf , err , err_info ) ; if ( padbytes != 0 ) { if ( ! wtap_read_bytes ( wth -> fh , NULL , padbytes , err , err_info ) ) { return FALSE ; } } return TRUE ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void ath10k_htt_rx_free ( struct ath10k_htt * htt ) { if ( htt -> ar -> bus_param . dev_type == ATH10K_DEV_TYPE_HL ) { return ; } del_timer_sync ( & htt -> rx_ring . refill_retry_timer ) ; skb_queue_purge ( & htt -> rx_msdus_q ) ; skb_queue_purge ( & htt -> rx_in_ord_compl_q ) ; skb_queue_purge ( & htt -> tx_fetch_ind_q ) ; spin_lock_bh ( & htt -> rx_ring . lock ) ; ath10k_htt_rx_ring_free ( htt ) ; spin_unlock_bh ( & htt -> rx_ring . lock ) ; dma_free_coherent ( htt -> ar -> dev , ath10k_htt_get_rx_ring_size ( htt ) , ath10k_htt_get_vaddr_ring ( htt ) , htt -> rx_ring . base_paddr ) ; ath10k_htt_config_paddrs_ring ( htt , NULL ) ; dma_free_coherent ( htt -> ar -> dev , sizeof ( * htt -> rx_ring . alloc_idx . vaddr ) , htt -> rx_ring . alloc_idx . vaddr , htt -> rx_ring . alloc_idx . paddr ) ; htt -> rx_ring . alloc_idx . vaddr = NULL ; htt -> rx_ring . netbufs_ring = NULL ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct sk_buff * prism2_frag_cache_get ( local_info_t * local , struct ieee80211_hdr * hdr ) { struct sk_buff * skb = NULL ; u16 sc ; unsigned int frag , seq ; struct prism2_frag_entry * entry ; sc = le16_to_cpu ( hdr -> seq_ctrl ) ; frag = sc & IEEE80211_SCTL_FRAG ; seq = ( sc & IEEE80211_SCTL_SEQ ) >> 4 ; if ( frag == 0 ) { skb = dev_alloc_skb ( local -> dev -> mtu + sizeof ( ieee80211_hdr ) + 8 + 2 + 8 + ETH_ALEN ) ; entry = & local -> frag_cache [ local -> frag_next_idx ] ; local -> frag_next_idx ++ ; if ( local -> frag_next_idx >= PRISM2_FRAG_CACHE_LEN ) { local -> frag_next_idx = 0 ; } if ( entry -> skb != NULL ) { dev_kfree_skb ( entry -> skb ) ; } entry -> first_frag_time = jiffies ; entry -> seq = seq ; entry -> last_frag = frag ; entry -> skb = skb ; memcpy ( entry -> src_addr , hdr -> addr2 , ETH_ALEN ) ; memcpy ( entry -> dst_addr , hdr -> addr1 , ETH_ALEN ) ; } else { entry = prism2_frag_cache_find ( local , seq , frag , hdr -> addr2 , hdr -> addr1 ) ; if ( entry != NULL ) { entry -> last_frag = frag ; skb = entry -> skb ; } } return skb ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static uint32_t sm4Lt ( uint32_t ka ) { uint32_t bb = 0 ; uint8_t a [ 4 ] ; uint8_t b [ 4 ] ; PUT_UINT32_BE ( ka , a , 0 ) ; b [ 0 ] = sm4Sbox ( a [ 0 ] , NULL ) ; b [ 1 ] = sm4Sbox ( a [ 1 ] ) ; b [ 2 ] = sm4Sbox ( a [ 2 ] ) ; b [ 3 ] = sm4Sbox ( a [ 3 ] ) ; GET_UINT32_BE ( bb , b , 0 ) ; return bb ^ ROTL ( bb , 2 ) ^ ROTL ( bb , 10 ) ^ ROTL ( bb , 18 ) ^ ROTL ( bb , 24 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void retype_callee_arg ( RAnal * anal , const char * callee_name , bool in_stack , const char * place , int size , const char * type ) { RAnalFunction * fcn = r_anal_get_function_byname ( anal , callee_name ) ; if ( ! fcn ) { return ; } if ( in_stack ) { RAnalVar * var = r_anal_function_get_var ( fcn , R_ANAL_VAR_KIND_BPV , size - fcn -> bp_off + 8 ) ; if ( ! var ) { return ; } __var_retype ( anal , var , NULL , type , false , false ) ; } else { RRegItem * item = r_reg_get ( anal -> reg , place , - 1 ) ; if ( ! item ) { return ; } RAnalVar * rvar = r_anal_function_get_var ( fcn , R_ANAL_VAR_KIND_REG , item -> index ) ; if ( ! rvar ) { return ; } char * t = strdup ( type ) ; __var_retype ( anal , rvar , NULL , type , false , false ) ; RAnalVar * lvar = r_anal_var_get_dst_var ( rvar ) ; if ( lvar ) { __var_retype ( anal , lvar , NULL , t , false , false ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void pcmcia_intr_disestablish ( struct pcmcia_function * pf , void * ih ) { int s , reg , ihcnt , hiipl ; struct pcmcia_function * pf2 ; if ( pcmcia_mfc ( pf -> sc ) ) { ihcnt = 0 ; SIMPLEQ_FOREACH ( , , ) { if ( pf2 == pf ) { continue ; } if ( pf2 -> ih_fct ) { if ( ihcnt == 0 ) { hiipl = pf2 -> ih_ipl ; } if ( pf2 -> ih_ipl > hiipl ) { hiipl = pf2 -> ih_ipl ; } ihcnt ++ ; } } if ( ihcnt == 0 ) { if ( pf -> sc -> ih == NULL ) { panic ( \"disestablishing last function, but card has no ih\" ) ; } pcmcia_chip_intr_disestablish ( pf -> sc -> pct , pf -> sc -> pch , pf -> sc -> ih ) ; reg = pcmcia_ccr_read ( pf , PCMCIA_CCR_OPTION ) ; reg &= ~ PCMCIA_CCR_OPTION_IREQ_ENABLE ; pcmcia_ccr_write ( pf , PCMCIA_CCR_OPTION , reg ) ; pf -> ih_arg = NULL ; pf -> sc -> ih = NULL ; } if ( pf -> ih_ipl > hiipl ) { if ( pf -> sc -> ih == NULL ) { panic ( \"changing ih ipl, but card has no ih\" ) ; } s = spltty ( ) ; pcmcia_chip_intr_disestablish ( pf -> sc -> pct , pf -> sc -> pch , pf -> sc -> ih ) ; pf -> sc -> ih = pcmcia_chip_intr_establish ( pf -> sc -> pct , pf -> sc -> pch , pf , hiipl , pcmcia_card_intr , pf -> sc , NULL ) ; pf -> ih_fct = NULL ; pf -> ih_arg = NULL ; splx ( s ) ; } else { s = spltty ( ) ; pf -> ih_fct = NULL ; pf -> ih_arg = NULL ; splx ( s ) ; } } else { pcmcia_chip_intr_disestablish ( pf -> sc -> pct , pf -> sc -> pch , ih ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static char * ps ( const char * m , const char * s , size_t len ) { char * d , * s1 , * s2 , * s3 ; s1 = mkstr ( m , len ) ; s2 = mkstr ( s , len ) ; s3 = concat ( s1 , s2 ) ; free ( s1 ) ; d = concat ( \"(.?)\" , s3 ) ; free ( s3 ) ; return d ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct drm_plane_state * dm_drm_plane_duplicate_state ( struct drm_plane * plane ) { struct dm_plane_state * dm_plane_state , * old_dm_plane_state ; old_dm_plane_state = to_dm_plane_state ( plane -> state ) ; dm_plane_state = kmalloc ( sizeof ( * dm_plane_state ) , GFP_KERNEL ) ; if ( ! dm_plane_state ) { return NULL ; } __drm_atomic_helper_plane_duplicate_state ( plane , & dm_plane_state -> base ) ; if ( old_dm_plane_state -> dc_state ) { dm_plane_state -> dc_state = old_dm_plane_state -> dc_state ; dc_plane_state_retain ( dm_plane_state -> dc_state ) ; } if ( dm_plane_state -> degamma_lut ) { drm_property_blob_get ( dm_plane_state -> degamma_lut ) ; } if ( dm_plane_state -> ctm ) { drm_property_blob_get ( dm_plane_state -> ctm ) ; } dm_plane_state -> sdr_boost = old_dm_plane_state -> sdr_boost ; return & dm_plane_state -> base ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int cpr_default_setup ( int alloc ) { cprop_t * orig , * , * tail ; int len , err = 0 ; pnode_t node ; char * fmt ; if ( alloc == 0 ) { ASSERT ( new_def_info , NULL ) ; kmem_free ( new_def_info , sizeof ( * new_def_info ) ) ; new_def_info = NULL ; return ( 0 ) ; } if ( err = cpr_get_options_node ( & node ) ) { return ( err ) ; } ASSERT ( new_def_info == NULL ) ; new_def_info = kmem_zalloc ( sizeof ( * new_def_info ) , KM_SLEEP ) ; new = new_def_info -> props ; for ( orig = orig_def_info . props , tail = orig + CPR_MAXPROP ; orig < tail ; orig ++ , new ++ ) { len = prom_getproplen ( node , orig -> name ) ; if ( len < 0 || len >= ( int ) sizeof ( orig -> value ) ) { fmt = \"invalid property or length for \\\"%s\\\"\" ; err = ENXIO ; break ; } bzero ( orig -> value , sizeof ( orig -> value ) ) ; if ( prom_getprop ( node , orig -> name , orig -> value ) < 0 ) { fmt = \"cannot get \\\"%s\\\" value\" ; err = ENXIO ; break ; } new -> mod = orig -> mod = PROP_NOMOD ; ( void ) strcpy ( new -> name , orig -> name ) ; } if ( err ) { kmem_free ( new_def_info , sizeof ( * new_def_info ) ) ; new_def_info = NULL ; cpr_err ( CE_WARN , fmt , orig -> name ) ; } else { err = cpr_prop_setup ( ) ; } return ( err ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void curses_subprocess_output ( pcmk__output_t * out , int exit_status , const char * proc_stdout , const char * proc_stderr ) { if ( proc_stdout != NULL ) { printw ( \"%s\\n\" , proc_stdout ) ; } if ( proc_stderr != NULL ) { printw ( \"%s\\n\" , proc_stderr ) ; } clrtoeol ( ) ; refresh ( ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int try_start_dim_transfer ( struct hdm_channel * hdm_ch ) { u16 buf_size ; struct list_head * head = & hdm_ch -> pending_list ; struct mbo * mbo ; cfs_time_t flags ; struct dim_ch_state st ; BUG_ON ( ! hdm_ch ) ; BUG_ON ( ! hdm_ch -> is_initialized ) ; spin_lock_irqsave ( & dim_lock , flags ) ; if ( list_empty ( head ) ) { spin_unlock_irqrestore ( & dim_lock , flags ) ; return - EAGAIN ; } if ( ! dim_get_channel_state ( & hdm_ch -> ch , & st ) -> ready ) { spin_unlock_irqrestore ( & dim_lock , flags ) ; return - EAGAIN ; } mbo = list_first_entry ( head , mbo , list ) ; buf_size = mbo -> buffer_length ; if ( dim_dbr_space ( & hdm_ch -> ch ) < buf_size ) { spin_unlock_irqrestore ( & dim_lock , flags ) ; return - EAGAIN ; } BUG_ON ( mbo -> bus_address == 0 ) ; if ( ! dim_enqueue_buffer ( & hdm_ch -> ch , mbo -> bus_address , buf_size ) ) { list_del ( head -> next ) ; spin_unlock_irqrestore ( & dim_lock , flags ) ; mbo -> processed_length = 0 ; mbo -> status = MBO_E_INVAL ; mbo -> complete ( mbo ) ; return - EFAULT ; } list_move_tail ( head -> next , & hdm_ch -> started_list ) ; spin_unlock_irqrestore ( & dim_lock , flags ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sig_server_reconnect_save_status ( IRC_SERVER_CONNECT_REC * conn , IRC_SERVER_REC * server ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) || ! IS_IRC_SERVER ( server ) || ! server -> connected ) { return ; } g_free_not_null ( conn -> channels ) ; conn -> channels = irc_server_get_channels ( server ) ; conn -> usermode = g_strdup ( server -> wanted_usermode ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int smem_get_free_space ( struct udevice * dev , unsigned int host ) { struct smem_ops * ops = smem_get_ops ( dev ) ; return ops -> get_free_space ( host ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int rb_init_ssl ( void ) { int ret ; if ( ( ret = gnutls_global_init ( ) ) != GNUTLS_E_SUCCESS ) { rb_lib_log ( \"%s: gnutls_global_init: %s\" , __func__ , rb_ssl_strerror ( ret ) ) ; return 0 ; } rb_event_addish ( \"rb_gcry_random_seed\" , rb_gcry_random_seed , 300 ) ; return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void radeon_ttm_tt_unpopulate ( struct ttm_device * bdev , struct ttm_tt * ttm ) { struct radeon_device * rdev = radeon_get_rdev ( bdev ) ; struct radeon_ttm_tt * gtt = radeon_ttm_tt_to_gtt ( rdev , ttm ) ; bool slave = ! ! ( ttm -> page_flags & TTM_TT_FLAG_EXTERNAL ) ; radeon_ttm_tt_unbind ( bdev , ttm ) ; if ( gtt && gtt -> userptr ) { ttm -> page_flags &= ~ TTM_TT_FLAG_EXTERNAL ; return ; } if ( slave ) { return ; } return ttm_pool_free ( & rdev -> mman . bdev . pool , ttm ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void restore_env ( void ) { for ( int i = 0 ; i < nenviron ; i ++ ) { char * key = environment [ i ] . key , * value = environment [ i ] . value ; if ( value ) { setenv ( key , value , 1 ) ; } else { unsetenv ( key ) ; } free ( key ) ; } nenviron = 0 ; memset ( environment , 0 , sizeof ( environment ) ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int opera1_xilinx_rw ( struct usb_device * dev , u8 request , u16 value , u8 * data , u16 len , int flags ) { int ret ; u8 tmp ; u8 * buf ; unsigned int pipe = ( flags == OPERA_READ_MSG ) ?usb_rcvctrlpipe ( dev , 0 ) : usb_sndctrlpipe ( dev , 0 ) ; u8 request_type = ( flags == OPERA_READ_MSG ) ?USB_DIR_IN : USB_DIR_OUT ; buf = kmalloc ( len , GFP_KERNEL ) ; if ( flags == OPERA_WRITE_MSG ) { memcpy ( buf , data , len ) ; } ret = usb_control_msg ( dev , pipe , request , request_type | USB_TYPE_VENDOR , value , 0x0 , buf , len , 2000 ) ; if ( request == OPERA_TUNER_REQ ) { tmp = buf [ 0 ] ; if ( usb_control_msg ( dev , usb_rcvctrlpipe ( dev , 0 ) , OPERA_TUNER_REQ , USB_DIR_IN | USB_TYPE_VENDOR , 0x01 , 0x0 , buf , 1 , 2000 ) < 1 || buf [ 0 ] != 0x08 ) { ret = 0 ; out } buf [ 0 ] = tmp ; } if ( flags == OPERA_READ_MSG ) { memcpy ( data , buf , len ) ; } out kfree ( buf ) ; return ret ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int rapl_msr_write_raw ( int cpu , struct reg_action * ra ) { int ret ; ret = smp_call_function_single ( cpu , rapl_msr_update_func , ra , 1 ) ; return ra -> err ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void CG_Particle_OilSlick ( qhandle_t pshader , centity_t * cent ) { cparticle_t * p ; if ( ! pshader ) { CG_Printf ( \"CG_Particle_OilSlick == ZERO!\\n\" ) ; } if ( ! free_particles ) { return ; } p = free_particles ; free_particles = p -> next ; p -> next = active_particles ; active_particles = p ; p -> time = cg . time ; if ( cent -> currentState . angles2 [ 2 ] ) { p -> endtime = cg . time + cent -> currentState . angles2 [ 2 ] ; } else { p -> endtime = cg . time + 60000 ; } p -> startfade = p -> endtime ; p -> alpha = 1.0 ; p -> alphavel = 0 ; p -> roll = 0 ; p -> pshader = pshader ; if ( cent -> currentState . angles2 [ 0 ] || cent -> currentState . angles2 [ 1 ] ) { p -> width = cent -> currentState . angles2 [ 0 ] ; p -> height = cent -> currentState . angles2 [ 0 ] ; p -> endheight = cent -> currentState . angles2 [ 1 ] ; p -> endwidth = cent -> currentState . angles2 [ 1 ] ; } else { p -> width = 8 ; p -> height = 8 ; p -> endheight = 16 ; p -> endwidth = 16 ; } p -> type = P_FLAT_SCALEUP ; p -> snum = 1.0 ; VectorCopy ( cent -> currentState . origin , p -> org ) ; p -> org [ 2 ] += 0.55 + ( crandom ( ) * 0.5 ) ; p -> vel [ 1 ] = 0 ; p -> vel [ 2 ] = 0 ; VectorClear ( p -> accel ) ; p -> rotate = qfalse ; p -> roll = rand ( ) % 179 ; p -> alpha = 0.75 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ecma_process_all_enqueued_jobs ( ) { ecma_value_t ret = ECMA_VALUE_UNDEFINED ; while ( JERRY_CONTEXT ( job_queue_head_p ) != NULL ) { ecma_job_queue_item_t * job_p = JERRY_CONTEXT ( job_queue_head_p ) ; JERRY_CONTEXT ( job_queue_head_p ) = ecma_job_queue_get_next ( job_p ) ; ecma_fast_free_value ( ret ) ; switch ( ecma_job_queue_get_type ( job_p ) ) { case ECMA_JOB_PROMISE_REACTION : { ret = ecma_process_promise_reaction_job ( ( ecma_job_promise_reaction_t * ) job_p ) ; break ; } case ECMA_JOB_PROMISE_ASYNC_REACTION_FULFILLED : case ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED : { ret = ecma_process_promise_async_reaction_job ( ( ecma_job_promise_async_reaction_t * ) job_p ) ; break ; } case ECMA_JOB_PROMISE_ASYNC_GENERATOR : { ret = ecma_process_promise_async_generator_job ( ( ecma_job_promise_async_generator_t * ) job_p ) ; break ; } default : { JERRY_ASSERT ( ecma_job_queue_get_type ( job_p ) == ECMA_JOB_PROMISE_THENABLE ) ; ret = ecma_process_promise_resolve_thenable_job ( ( ecma_job_promise_resolve_thenable_t * ) job_p ) ; break ; } } } ecma_free_value ( ret ) ; return ECMA_VALUE_UNDEFINED ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( jbd2_journal_grab_journal_head ) ; static void __journal_remove_journal_head ( struct buffer_head * bh ) { struct journal_head * jh = bh2jh ( bh ) ; J_ASSERT_JH ( jh , jh -> b_transaction == NULL ) ; J_ASSERT_JH ( jh , jh -> b_next_transaction == NULL ) ; J_ASSERT_JH ( jh , jh -> b_cp_transaction == NULL ) ; J_ASSERT_JH ( jh , jh -> b_jlist == BJ_None ) ; J_ASSERT_BH ( bh , buffer_jbd ( bh ) ) ; J_ASSERT_BH ( bh , jh2bh ( jh ) == bh ) ; BUFFER_TRACE ( bh , \"remove journal_head\" ) ; bh -> b_private = NULL ; clear_buffer_jbd ( bh ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int find_tlb_entry ( CPUSH4State * env , target_ulong address , tlb_t * entries , uint8_t nbtlb , int use_asid ) { int match = MMU_DTLB_MISS ; uint32_t start , end ; uint8_t asid ; int i ; asid = env -> pteh & 0xff ; for ( i = 0 ; i < nbtlb ; i ++ ) { if ( ! entries [ i ] . v ) { continue ; } start = ( entries [ i ] . vpn << 10 ) & ~ ( entries [ i ] . size - 1 ) ; end = start + entries [ i ] . size - 1 ; if ( address >= start && address <= end ) { if ( match != MMU_DTLB_MISS ) { return MMU_DTLB_MULTIPLE ; } match = i ; } } return match ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static UINT audin_winmm_free ( IAudinDevice * device ) { UINT32 i ; AudinWinmmDevice * winmm = ( AudinWinmmDevice * ) device ; if ( ! winmm ) { return ERROR_INVALID_PARAMETER ; } for ( i = 0 ; i < winmm -> cFormats ; i ++ ) { free ( winmm -> ppwfx [ i ] ) ; } free ( winmm -> ppwfx ) ; free ( winmm ) ; return CHANNEL_RC_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void nfs_setsecurity ( struct inode * inode , struct nfs_fattr * fattr ) { int error ; if ( fattr -> label == NULL ) { return ; } if ( ( fattr -> valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL ) && inode -> i_security ) { error = security_inode_notifysecctx ( inode , fattr -> label -> label , fattr -> label -> len ) ; if ( error ) { printk ( KERN_ERR \"%s() %s %d \" \"security_inode_notifysecctx() %d\\n\" , __func__ , ( char * ) fattr -> label -> label , fattr -> label -> len , error ) ; } } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "GF_Err gf_sc_set_scene ( GF_Compositor * compositor , GF_SceneGraph * scene_graph ) { u32 width , height ; Bool do_notif ; gf_sc_lock ( compositor , 1 ) ; if ( scene_graph && ! compositor -> scene ) { GF_LOG ( GF_LOG_INFO , GF_LOG_COMPOSE , ( \"[Compositor] Attaching new scene\\n\" ) ) ; } if ( ! scene_graph && compositor -> scene ) { GF_LOG ( GF_LOG_INFO , GF_LOG_COMPOSE , ( \"[Compositor] Detaching scene\\n\" ) ) ; } if ( compositor -> audio_renderer && ( compositor -> scene != scene_graph ) ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_COMPOSE , ( \"[Compositor] resetting audio compositor\\n\" ) ) ; gf_sc_ar_reset ( compositor -> audio_renderer ) ; } GF_LOG ( GF_LOG_DEBUG , GF_LOG_COMPOSE , ( \"[Compositor] resetting event queue\\n\" ) ) ; gf_mx_p ( compositor -> evq_mx ) ; while ( gf_list_count ( compositor -> event_queue ) ) { GF_QueuedEvent * qev = ( GF_QueuedEvent * ) gf_list_get ( compositor -> event_queue , 0 ) ; gf_list_rem ( compositor -> event_queue , 0 ) ; gf_free ( qev ) ; } gf_mx_v ( compositor -> evq_mx ) ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_COMPOSE , ( \"[Compositor] resetting compositor module\\n\" ) ) ; gf_sc_reset ( compositor , scene_graph ?1 : 0 ) ; compositor -> scene = scene_graph ; do_notif = GF_FALSE ; if ( scene_graph ) { GF_Scene * scene_ctx = gf_sg_get_private ( scene_graph ) ; SVG_Length * w , * h ; SVG_ViewBox * vb ; Bool is_svg = GF_FALSE ; u32 tag ; GF_Node * top_node ; Bool had_size_info = compositor -> has_size_info ; compositor -> timed_nodes_valid = GF_TRUE ; if ( scene_ctx && scene_ctx -> is_dynamic_scene ) { compositor -> timed_nodes_valid = GF_FALSE ; } gf_sg_get_scene_size_info ( compositor -> scene , & width , & height ) ; compositor -> has_size_info = ( width && height ) ?1 : 0 ; if ( compositor -> has_size_info != had_size_info ) { compositor -> scene_width = compositor -> scene_height = 0 ; } if ( compositor -> video_memory != 2 ) { compositor -> video_memory = gf_scene_is_dynamic_scene ( scene_graph ) ; } compositor -> visual -> camera . world_bbox . is_set = 0 ; if ( ! ( compositor -> init_flags & GF_VOUT_WINDOWLESS ) ) { if ( compositor -> bc ) { compositor -> back_color = compositor -> bc ; } else { compositor -> back_color = 0xFF000000 ; } } top_node = gf_sg_get_root_node ( compositor -> scene ) ; tag = 0 ; if ( top_node ) { tag = gf_node_get_tag ( top_node ) ; } w = h = NULL ; vb = NULL ; if ( ( tag >= GF_NODE_RANGE_FIRST_SVG ) && ( tag <= GF_NODE_RANGE_LAST_SVG ) ) { GF_FieldInfo info ; is_svg = 1 ; if ( gf_node_get_attribute_by_tag ( top_node , TAG_SVG_ATT_width , 0 , 0 , & info ) == GF_OK ) { w = info . far_ptr ; } if ( gf_node_get_attribute_by_tag ( top_node , TAG_SVG_ATT_height , 0 , 0 , & info ) == GF_OK ) { h = info . far_ptr ; } if ( gf_node_get_attribute_by_tag ( top_node , TAG_SVG_ATT_viewBox , 0 , 0 , & info ) == GF_OK ) { vb = info . far_ptr ; } } if ( is_svg && ! ( compositor -> init_flags & GF_VOUT_WINDOWLESS ) ) { compositor -> back_color = 0xFFFFFFFF ; } if ( ! compositor -> has_size_info && w && h && vb ) { do_notif = 1 ; if ( w -> type != SVG_NUMBER_PERCENTAGE ) { width = FIX2INT ( gf_sc_svg_convert_length_to_display ( compositor , w ) ) ; } if ( ( u32 ) FIX2INT ( vb -> width ) < compositor -> video_out -> max_screen_width ) { width = FIX2INT ( vb -> width ) ; } else { width = SC_DEF_WIDTH ; do_notif = 0 ; } if ( h -> type != SVG_NUMBER_PERCENTAGE ) { height = FIX2INT ( gf_sc_svg_convert_length_to_display ( compositor , h ) ) ; } if ( ( u32 ) FIX2INT ( vb -> height ) < compositor -> video_out -> max_screen_height ) { height = FIX2INT ( vb -> height ) ; } else { height = SC_DEF_HEIGHT ; do_notif = 0 ; } } if ( is_svg ) { compositor -> has_size_info = 0 ; gf_sc_focus_switch_ring ( compositor , 0 , NULL , 0 ) ; } else { GF_Node * keynav = gf_scene_get_keynav ( compositor -> scene , NULL ) ; if ( keynav ) { gf_sc_change_key_navigator ( compositor , keynav ) ; } } if ( compositor -> init_flags & GF_VOUT_WINDOWLESS ) { if ( compositor -> ckey ) { compositor -> back_color = compositor -> ckey ; } } if ( ! width || ( compositor -> scene_width != width ) || ! height || ( compositor -> scene_height != height ) ) { do_notif = do_notif || compositor -> has_size_info || ( ! compositor -> scene_width && ! compositor -> scene_height ) ; gf_sc_set_scene_size ( compositor , width , height , 0 ) ; width = compositor -> scene_width ; height = compositor -> scene_height ; if ( ! compositor -> os_wnd ) { if ( compositor -> video_out -> max_screen_width && ( width > compositor -> video_out -> max_screen_width ) ) { height *= compositor -> video_out -> max_screen_width ; height /= width ; width = compositor -> video_out -> max_screen_width ; } if ( compositor -> video_out -> max_screen_height && ( height > compositor -> video_out -> max_screen_height ) ) { width *= compositor -> video_out -> max_screen_height ; width /= height ; height = compositor -> video_out -> max_screen_height ; } gf_sc_set_size ( compositor , width , height ) ; } } } else { gf_sc_ar_reset ( compositor -> audio_renderer ) ; compositor -> needs_offscreen_gl = GF_FALSE ; } gf_sc_reset_framerate ( compositor ) ; gf_sc_lock ( compositor , 0 ) ; if ( scene_graph ) { gf_sc_next_frame_state ( compositor , GF_SC_DRAW_FRAME ) ; } if ( do_notif ) { GF_Event evt ; evt . type = GF_EVENT_SCENE_SIZE ; evt . size . width = width ; evt . size . height = height ; evt . size . orientation = 0 ; if ( compositor -> scene && gf_sg_get_root_node ( compositor -> scene ) ) { evt . size . window_id = 1 ; } else { evt . size . window_id = 0 ; } gf_sc_send_event ( compositor , & evt ) ; } return GF_OK ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( knav_queue_notify ) ; static irqreturn_t knav_queue_int_handler ( int irq , void * _instdata ) { struct knav_queue_inst * inst = _instdata ; knav_queue_notify ( inst , NULL ) ; return IRQ_HANDLED ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool EBPFBypassCheckHalfFlow ( Flow * f , FlowBypassInfo * fc , EBPFBypassData * eb , void * key , int index ) { int i ; uint64_t pkts_cnt = 0 ; uint64_t bytes_cnt = 0 ; BPF_DECLARE_PERCPU ( pair , values_array , eb -> cpus_count ) ; int res = bpf_map_lookup_elem ( eb -> mapfd , key , values_array ) ; if ( res < 0 ) { SCLogDebug ( \"errno: (%d) %s\" , errno , strerror ( errno ) ) ; return false ; } for ( i = 0 ; i < eb -> cpus_count ; i ++ ) { SCLogDebug ( \"%d: Adding pkts %lu bytes %lu\" , i , BPF_PERCPU ( values_array , i ) . packets , BPF_PERCPU ( values_array , i ) . bytes ) ; pkts_cnt += BPF_PERCPU ( values_array , i ) . packets ; bytes_cnt += BPF_PERCPU ( values_array , i ) . bytes ; } if ( index == 0 ) { if ( pkts_cnt != fc -> todstpktcnt ) { fc -> todstpktcnt = pkts_cnt ; fc -> todstbytecnt = bytes_cnt ; return true ; } } else { if ( pkts_cnt != fc -> tosrcpktcnt ) { fc -> tosrcpktcnt = pkts_cnt ; fc -> tosrcbytecnt = bytes_cnt ; return true ; } } return false ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "errcode_t ext2fs_add_journal_inode2 ( ext2_filsys fs , blk_t num_blocks , blk64_t goal , int flags ) { errcode_t retval ; ext2_ino_t journal_ino ; struct stat st ; char jfile [ 1024 ] ; int mount_flags ; int fd = - 1 ; if ( flags & EXT2_MKJOURNAL_NO_MNT_CHECK ) { mount_flags = 0 ; } if ( ( retval = ext2fs_check_mount_point ( fs -> device_name , & mount_flags , jfile , sizeof ( jfile ) - 10 ) ) ) { return retval ; } if ( mount_flags & EXT2_MF_MOUNTED ) { int f = 0 ; strcat ( jfile , \"/.journal\" ) ; ( void ) chflags ( jfile , 0 ) ; fd = open ( jfile , O_RDONLY ) ; if ( fd >= 0 ) { retval = ioctl ( fd , EXT2_IOC_SETFLAGS , & f ) ; close ( fd , NULL ) ; if ( retval ) { return retval ; } } if ( ( fd = open ( jfile , O_CREAT | O_WRONLY , 0600 ) ) < 0 ) { return errno ; } flags &= ~ EXT2_MKJOURNAL_LAZYINIT ; if ( ( retval = write_journal_file ( fs , jfile , num_blocks , flags ) ) ) { errout } if ( fstat ( fd , & st ) < 0 ) { retval = errno ; errout } retval = fchflags ( fd , UF_NODUMP | UF_IMMUTABLE ) ; if ( ioctl ( fd , EXT2_IOC_GETFLAGS , & f ) < 0 ) { retval = errno ; errout } f |= EXT2_NODUMP_FL | EXT2_IMMUTABLE_FL ; retval = ioctl ( fd , EXT2_IOC_SETFLAGS , & f ) ; if ( retval ) { retval = errno ; errout } if ( close ( fd ) < 0 ) { retval = errno ; fd = - 1 ; errout } journal_ino = st . st_ino ; memset ( fs -> super -> s_jnl_blocks , 0 , sizeof ( fs -> super -> s_jnl_blocks ) ) ; } else { if ( ( mount_flags & EXT2_MF_BUSY ) && ! ( fs -> flags & EXT2_FLAG_EXCLUSIVE ) ) { retval = EBUSY ; errout } journal_ino = EXT2_JOURNAL_INO ; if ( ( retval = write_journal_inode ( fs , journal_ino , num_blocks , goal , flags ) ) ) { return retval ; } } fs -> super -> s_journal_inum = journal_ino ; fs -> super -> s_journal_dev = 0 ; memset ( fs -> super -> s_journal_uuid , 0 , sizeof ( fs -> super -> s_journal_uuid ) ) ; ext2fs_set_feature_journal ( fs -> super ) ; ext2fs_mark_super_dirty ( fs ) ; return 0 ; errout if ( fd >= 0 ) { close ( fd ) ; } return retval ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void mailimap_uidplus_resp_code_apnd_free ( struct mailimap_uidplus_resp_code_apnd * resp_code_apnd ) { if ( resp_code_apnd -> uid_set != NULL ) { mailimap_set_free ( resp_code_apnd -> uid_set ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static size_t rpc_pton4 ( const char * buf , const size_t buflen , struct sockaddr * sap , const size_t salen ) { struct sockaddr_in * sin = ( sockaddr_in * ) sap ; u8 * addr = ( u8 * ) & sin -> sin_addr . s_addr ; if ( buflen > INET_ADDRSTRLEN || salen < sizeof ( sockaddr_in ) ) { return 0 ; } if ( in4_pton ( buf , buflen , addr , '\\0' , NULL ) == 0 ) { return 0 ; } sin -> sin_family = AF_INET ; return sizeof ( sockaddr_in ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static bool check_reloc ( struct host1x_reloc * reloc , struct host1x_bo * cmdbuf , unsigned int offset ) { offset *= sizeof ( u32 ) ; return true ; } host1x_firewall { struct host1x_job * job ; struct device * dev ; unsigned int num_relocs ; struct host1x_reloc * reloc ; struct host1x_bo * cmdbuf ; unsigned int offset ; u32 words ; u32 class u32 reg ; u32 mask ; u32 count ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int lame_init_internal_flags ( lame_internal_flags * gfc ) { if ( NULL == gfc ) { return - 1 ; } gfc -> cfg . vbr_min_bitrate_index = 1 ; gfc -> cfg . vbr_max_bitrate_index = 13 ; gfc -> cfg . decode_on_the_fly = 0 ; gfc -> cfg . findPeakSample = 0 ; gfc -> sv_qnt . OldValue [ 0 ] = 180 ; gfc -> sv_qnt . OldValue [ 1 ] = 180 ; gfc -> sv_qnt . CurrentStep [ 0 ] = 4 ; gfc -> sv_qnt . CurrentStep [ 1 ] = 4 ; gfc -> sv_qnt . masking_lower = 1 ; gfc -> sv_enc . mf_samples_to_encode = ENCDELAY + POSTDELAY ; gfc -> sv_enc . mf_size = ENCDELAY - MDCTDELAY ; gfc -> ov_enc . encoder_padding = 0 ; gfc -> ov_enc . encoder_delay = ENCDELAY ; gfc -> ov_rpg . RadioGain = 0 ; gfc -> ov_rpg . noclipGainChange = 0 ; gfc -> ov_rpg . noclipScale = - 1.0 ; gfc -> ATH = lame_calloc ( ATH_t , 1 ) ; if ( NULL == gfc -> ATH ) { return - 2 ; } gfc -> sv_rpg . rgdata = lame_calloc ( replaygain_t , 1 ) ; if ( NULL == gfc -> sv_rpg . rgdata ) { return - 2 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "( gb_hd_add ) ; void gb_hd_del ( struct gb_host_device * hd ) { trace_gb_hd_del ( hd ) ; gb_svc_del ( hd -> svc , NULL ) ; device_del ( & hd -> dev ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void vips_foreign_load_nsgif_init ( VipsForeignLoadNsgif * gif ) { gif -> anim = g_malloc0 ( gif_animation , 1 ) ; gif_create ( gif -> anim , & vips_foreign_load_nsgif_bitmap_callbacks ) ; gif -> n = 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void radeon_gart_table_vram_free ( struct radeon_device * rdev ) { radeon_bo_unref ( & rdev -> gart . robj ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int hid_open_report ( struct hid_device * device ) { struct hid_parser * parser ; struct hid_item item ; unsigned int size ; __u8 * start ; __u8 * buf ; __u8 * end ; __u8 * next ; int ret ; int i ; static int * dispatch_type [ ] ( struct hid_parser * parser , struct hid_item * item ) { hid_parser_main } ; , hid_parser_global , hid_parser_local , hid_parser_reserved } if ( WARN_ON ( device -> status & HID_STAT_PARSED ) ) { return - EBUSY ; } start = device -> dev_rdesc ; size = device -> dev_rsize ; buf = call_hid_bpf_rdesc_fixup ( device , start , & size ) ; if ( buf == NULL ) { return - ENOMEM ; } if ( device -> driver -> report_fixup ) { start = device -> driver -> report_fixup ( device , buf , & size ) ; } else { start = buf ; } start = kmemdup ( start , size , GFP_KERNEL ) ; kfree ( buf ) ; if ( start == NULL ) { return - ENOMEM ; } device -> rdesc = start ; device -> rsize = size ; parser = vzalloc ( sizeof ( hid_parser ) ) ; if ( ! parser ) { ret = - ENOMEM ; alloc_err } parser -> device = device ; end = start + size ; device -> collection = kcalloc ( HID_DEFAULT_NUM_COLLECTIONS , sizeof ( hid_collection ) , GFP_KERNEL ) ; if ( ! device -> collection ) { ret = - ENOMEM ; err } device -> collection_size = HID_DEFAULT_NUM_COLLECTIONS ; for ( i = 0 ; i < HID_DEFAULT_NUM_COLLECTIONS ; i ++ ) { device -> collection [ i ] . parent_idx = - 1 ; } ret = - EINVAL ; while ( ( next = fetch_item ( start , end , & item ) ) != NULL ) { start = next ; if ( item . format != HID_ITEM_FORMAT_SHORT ) { hid_err ( device , \"unexpected long global item\\n\" ) ; err } if ( dispatch_type [ item . type ] ( parser , & item ) ) { hid_err ( device , \"item %u %u %u %u parsing failed\\n\" , item . format , ( unsigned ) item . size , ( unsigned ) item . type , ( unsigned ) item . tag ) ; err } if ( start == end ) { if ( parser -> collection_stack_ptr ) { hid_err ( device , \"unbalanced collection at end of report description\\n\" ) ; err } if ( parser -> local . delimiter_depth ) { hid_err ( device , \"unbalanced delimiter at end of report description\\n\" ) ; err } hid_setup_resolution_multiplier ( device ) ; kfree ( parser -> collection_stack ) ; vfree ( parser ) ; device -> status |= HID_STAT_PARSED ; return 0 ; } } hid_err ( device , \"item fetching failed at offset %u/%u\\n\" , size - ( unsigned int ) ( end - start ) , size ) ; err kfree ( parser -> collection_stack ) ; alloc_err vfree ( parser ) ; hid_close_report ( device ) ; return ret ; ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static struct usb_wireless_ep_comp_descriptor * rpipe_epc_find ( struct device * dev , struct usb_host_endpoint * ep ) { void * itr ; size_t itr_size ; struct usb_descriptor_header * hdr ; struct usb_wireless_ep_comp_descriptor * epcd ; if ( ep -> desc . bEndpointAddress == 0 ) { epcd = & epc0 ; out } itr = ep -> extra ; itr_size = ep -> extralen ; while ( itr_size > 0 ) { if ( itr_size < sizeof ( * hdr ) ) { dev_err ( dev , \"HW Bug? ep 0x%02x: extra descriptors \" \"at offset %zu: only %zu bytes left\\n\" , ep -> desc . bEndpointAddress , itr - ( void * ) ep -> extra , itr_size ) ; break ; } hdr = itr ; if ( hdr -> bDescriptorType == USB_DT_WIRELESS_ENDPOINT_COMP ) { epcd = itr ; break ; } if ( hdr -> bLength > itr_size ) { dev_err ( dev , \"HW Bug? ep 0x%02x: extra descriptor \" \"at offset %zu (type 0x%02x) \" \"length %d but only %zu bytes left\\n\" , ep -> desc . bEndpointAddress , itr - ( void * ) ep -> extra , hdr -> bDescriptorType , hdr -> bLength , itr_size ) ; break ; } itr += hdr -> bLength ; itr_size -= hdr -> bLength ; } out return epcd ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int devid_get ( int fd , ddi_devid_t * devidp ) { int len = 0 ; dev_t dev ; struct stat statb ; ddi_devid_t mydevid ; if ( fstat ( fd , & statb ) != 0 ) { return ( - 1 ) ; } if ( ! S_ISCHR ( statb . st_mode ) && ! S_ISBLK ( statb . st_mode ) ) { return ( - 1 ) ; } dev = statb . st_rdev ; if ( modctl ( MODSIZEOF_DEVID , dev , & len ) != 0 ) { return ( - 1 ) ; } if ( ( mydevid = ( ddi_devid_t ) malloc ( len ) ) == NULL ) { return ( - 1 ) ; } if ( modctl ( MODGETDEVID , dev , len , mydevid ) != 0 ) { return ( - 1 ) ; } * devidp = mydevid ; return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void acpi_ut_display_init_pathname ( u8 type , struct acpi_namespace_node * obj_handle , const char * path ) { acpi_status status ; struct acpi_buffer buffer ; ACPI_FUNCTION_ENTRY ( ) ; if ( ! ( acpi_dbg_level & ACPI_LV_INIT_NAMES ) ) { return ; } buffer . length = ACPI_ALLOCATE_LOCAL_BUFFER ; status = acpi_ns_handle_to_pathname ( obj_handle , & buffer , TRUE ) ; if ( ACPI_FAILURE ( status ) ) { return ; } switch ( type ) { case ACPI_TYPE_METHOD : acpi_os_printf ( \"Executing  \" ) ; break ; default : acpi_os_printf ( \"Initializing \" ) ; break ; } acpi_os_printf ( \"%-12s %s\" , acpi_ut_get_type_name ( type ) , ( char * ) buffer . pointer ) ; if ( path ) { acpi_os_printf ( \".%s\" , path ) ; } acpi_os_printf ( \"\\n\" ) ; ACPI_FREE ( buffer . pointer , NULL ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int et8ek8_reglist_cmp ( const void * a , const void * b ) { const struct et8ek8_reglist * * list1 = ( const et8ek8_reglist * * ) a , * * list2 = ( const et8ek8_reglist * * ) b ; if ( ( * list1 ) -> type == ET8EK8_REGLIST_MODE && ( * list2 ) -> type != ET8EK8_REGLIST_MODE ) { return - 1 ; } if ( ( * list1 ) -> type != ET8EK8_REGLIST_MODE && ( * list2 ) -> type == ET8EK8_REGLIST_MODE ) { return 1 ; } if ( ( * list1 ) -> mode . window_width < ( * list2 ) -> mode . window_width ) { return 1 ; } if ( ( * list1 ) -> mode . window_height > ( * list2 ) -> mode . window_height ) { return - 1 ; } if ( ( * list1 ) -> mode . window_height < ( * list2 ) -> mode . window_height ) { return 1 ; } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int mdb_ctf_member_info ( mdb_ctf_id_t id , const char * member , ulong_t * offp , mdb_ctf_id_t * typep ) { mbr_info_t mbr ; int rc ; mbr . mbr_member = member ; mbr . mbr_offp = offp ; mbr . mbr_typep = typep ; rc = mdb_ctf_member_iter ( id , member_info_cb , & mbr ) ; if ( rc == - 1 ) { return ( - 1 ) ; } return ( 0 ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void sevseg_disconnect ( struct usb_interface * interface ) { struct usb_sevsegdev * mydev ; mydev = usb_get_intfdata ( interface ) ; usb_set_intfdata ( interface , NULL ) ; usb_put_dev ( mydev -> udev ) ; dev_info ( & interface -> dev , \"USB 7 Segment now disconnected\\n\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static const char * btf_str ( const struct btf * btf , __u32 off ) { return btf__str_by_offset ( btf , off ) ?: \"(invalid)\" ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int check_get_set_i64 ( mp_int * a , int64_t b ) { mp_clear ( a ) ; mp_set_i64 ( a , b ) ; if ( mp_shrink ( a ) != MP_OKAY ) { return EXIT_FAILURE ; } if ( mp_get_i64 ( a ) != b ) { return EXIT_FAILURE ; } if ( mp_get_u64 ( a ) != ( uint64_t ) b ) { return EXIT_FAILURE ; } if ( mp_get_mag_u64 ( a ) != uabs64 ( b ) ) { return EXIT_FAILURE ; } mp_set_u64 ( a , ( uint64_t ) b ) ; if ( mp_get_u64 ( a ) != ( uint64_t ) b ) { return EXIT_FAILURE ; } if ( mp_get_i64 ( a ) != ( int64_t ) ( uint64_t ) b ) { return EXIT_FAILURE ; } return EXIT_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int hal2_playback_prepare ( struct snd_pcm_substream * substream ) { struct snd_hal2 * hal2 = snd_pcm_substream_chip ( substream ) ; struct snd_pcm_runtime * runtime = substream -> runtime ; struct hal2_codec * dac = & hal2 -> dac ; dac -> voices = runtime -> channels ; dac -> sample_rate = hal2_compute_rate ( dac , runtime -> rate ) ; dac -> pcm_indirect . hw_buffer_size = H2_BUF_SIZE ; dac -> pcm_indirect . sw_buffer_size = snd_pcm_lib_buffer_bytes ( substream ) ; dac -> substream = substream ; hal2_setup_dac ( hal2 ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void InitURWTable ( void ) { int i ; memset ( urwtable , - 1 , sizeof ( urwtable ) ) ; for ( i = 0 ; i < 26 ; ++ i ) { urwtable [ i + 101 ] = 'A' + i ; urwtable [ i + 301 ] = 'a' + i ; } urwtable [ 127 ] = 0xc6 ; urwtable [ 128 ] = 0x152 ; urwtable [ 129 ] = 0xd8 ; urwtable [ 200 ] = 0x132 ; urwtable [ 201 ] = 0xc4 ; urwtable [ 202 ] = 0xc1 ; urwtable [ 203 ] = 0xc0 ; urwtable [ 204 ] = 0xc2 ; urwtable [ 205 ] = 0x1cd ; urwtable [ 206 ] = 0x102 ; urwtable [ 207 ] = 0xc3 ; urwtable [ 208 ] = 0xc5 ; urwtable [ 209 ] = 0x104 ; urwtable [ 210 ] = 0xc7 ; urwtable [ 211 ] = 0x106 ; urwtable [ 212 ] = 0x10c ; urwtable [ 213 ] = 0x10a ; urwtable [ 214 ] = 0x10e ; urwtable [ 215 ] = 0x110 ; urwtable [ 216 ] = 0xcb ; urwtable [ 217 ] = 0xc9 ; urwtable [ 218 ] = 0xc8 ; urwtable [ 219 ] = 0xca ; urwtable [ 220 ] = 0x11a ; urwtable [ 221 ] = 0x116 ; urwtable [ 222 ] = 0x118 ; urwtable [ 223 ] = 0x1e6 ; urwtable [ 224 ] = 0x11e ; urwtable [ 225 ] = 0x120 ; urwtable [ 226 ] = 0xcf ; urwtable [ 227 ] = 0xcd ; urwtable [ 228 ] = 0xcc ; urwtable [ 229 ] = 0xce ; urwtable [ 230 ] = 0x130 ; urwtable [ 231 ] = 0x139 ; urwtable [ 233 ] = 0x141 ; urwtable [ 234 ] = 0x143 ; urwtable [ 235 ] = 0x147 ; urwtable [ 236 ] = 0xd1 ; urwtable [ 237 ] = 0xd6 ; urwtable [ 238 ] = 0xd3 ; urwtable [ 239 ] = 0xd2 ; urwtable [ 240 ] = 0xd4 ; urwtable [ 241 ] = 0xd5 ; urwtable [ 242 ] = 0x150 ; urwtable [ 243 ] = 0x154 ; urwtable [ 244 ] = 0x15a ; urwtable [ 246 ] = 0x160 ; urwtable [ 248 ] = 0x15e ; urwtable [ 249 ] = 0x164 ; urwtable [ 251 ] = 0xdc ; urwtable [ 252 ] = 0xda ; urwtable [ 253 ] = 0xd9 ; urwtable [ 254 ] = 0xdb ; urwtable [ 255 ] = 0xdc ; urwtable [ 256 ] = 0x170 ; urwtable [ 257 ] = 0xdd ; urwtable [ 258 ] = 0x179 ; urwtable [ 259 ] = 0x17d ; urwtable [ 260 ] = 0x17b ; urwtable [ 261 ] = 0xde ; urwtable [ 262 ] = 0x100 ; urwtable [ 264 ] = 0x108 ; urwtable [ 265 ] = 0x174 ; urwtable [ 266 ] = 0x1e84 ; urwtable [ 267 ] = 0x176 ; urwtable [ 268 ] = 0x178 ; urwtable [ 269 ] = 0x126 ; urwtable [ 272 ] = 0x112 ; urwtable [ 273 ] = 0x11c ; urwtable [ 274 ] = 0x124 ; urwtable [ 276 ] = 0x12e ; urwtable [ 283 ] = 0x14c ; urwtable [ 286 ] = 0x15c ; urwtable [ 289 ] = 0x1d3 ; urwtable [ 290 ] = 0x16a ; urwtable [ 291 ] = 0x172 ; urwtable [ 296 ] = 0x114 ; urwtable [ 297 ] = 0x1e1e ; urwtable [ 298 ] = 0x1f4 ; urwtable [ 327 ] = 0xe6 ; urwtable [ 328 ] = 0x153 ; urwtable [ 329 ] = 0xf8 ; urwtable [ 330 ] = 0xdf ; urwtable [ 331 ] = 0x131 ; urwtable [ 332 ] = 0x237 ; urwtable [ 333 ] = 0x133 ; urwtable [ 336 ] = 0xfb00 ; urwtable [ 337 ] = 0xfb01 ; urwtable [ 338 ] = 0xfb02 ; urwtable [ 341 ] = 0xfb03 ; urwtable [ 342 ] = 0xfb04 ; urwtable [ 401 ] = 0xe4 ; urwtable [ 402 ] = 0xe1 ; urwtable [ 402 ] = 0xe0 ; urwtable [ 404 ] = 0xe2 ; urwtable [ 405 ] = 0x1ce ; urwtable [ 406 ] = 0x103 ; urwtable [ 407 ] = 0xe3 ; urwtable [ 408 ] = 0xe5 ; urwtable [ 409 ] = 0x105 ; urwtable [ 410 ] = 0x107 ; urwtable [ 411 ] = 0x10d ; urwtable [ 412 ] = 0x10b ; urwtable [ 413 ] = 0xe7 ; urwtable [ 415 ] = 0x111 ; urwtable [ 416 ] = 0xeb ; urwtable [ 417 ] = 0xe9 ; urwtable [ 418 ] = 0xe8 ; urwtable [ 419 ] = 0xea ; urwtable [ 420 ] = 0x119 ; urwtable [ 421 ] = 0x117 ; urwtable [ 423 ] = 0x1e7 ; urwtable [ 424 ] = 0x11f ; urwtable [ 425 ] = 0x121 ; urwtable [ 426 ] = 0xef ; urwtable [ 427 ] = 0xed ; urwtable [ 428 ] = 0xec ; urwtable [ 429 ] = 0xee ; urwtable [ 432 ] = 0x142 ; urwtable [ 433 ] = 0x144 ; urwtable [ 434 ] = 0x148 ; urwtable [ 435 ] = 0xf1 ; urwtable [ 436 ] = 0xf6 ; urwtable [ 437 ] = 0xf3 ; urwtable [ 438 ] = 0xf2 ; urwtable [ 439 ] = 0xf4 ; urwtable [ 440 ] = 0xf5 ; urwtable [ 441 ] = 0x151 ; urwtable [ 444 ] = 0x15b ; urwtable [ 445 ] = 0x15d ; urwtable [ 446 ] = 0x161 ; urwtable [ 449 ] = 0xfc ; urwtable [ 450 ] = 0xfa ; urwtable [ 451 ] = 0xf9 ; urwtable [ 452 ] = 0xfb ; urwtable [ 453 ] = 0x16f ; urwtable [ 454 ] = 0x171 ; urwtable [ 455 ] = 0xfd ; urwtable [ 456 ] = 0x17a ; urwtable [ 457 ] = 0x17e ; urwtable [ 458 ] = 0x17c ; urwtable [ 459 ] = 0xf0 ; urwtable [ 460 ] = 0xfe ; urwtable [ 461 ] = 0xff ; urwtable [ 465 ] = 0x1e85 ; urwtable [ 462 ] = 0x127 ; urwtable [ 464 ] = 0x175 ; urwtable [ 466 ] = 0x101 ; urwtable [ 467 ] = 0x177 ; urwtable [ 469 ] = 0x109 ; urwtable [ 472 ] = 0x113 ; urwtable [ 473 ] = 0x11d ; urwtable [ 480 ] = 0x1e3f ; urwtable [ 482 ] = 0x14d ; urwtable [ 486 ] = 0x16b ; urwtable [ 487 ] = 0x173 ; urwtable [ 489 ] = 0x15f ; for ( i = 1 ; i <= 9 ; ++ i ) { urwtable [ 500 + i ] = '0' + i ; } urwtable [ 510 ] = '0' ; urwtable [ 511 ] = 0xa3 ; urwtable [ 512 ] = '$' ; urwtable [ 513 ] = 0xa2 ; urwtable [ 514 ] = 0x192 ; urwtable [ 516 ] = 0xa5 ; urwtable [ 519 ] = 0x20a4 ; urwtable [ 523 ] = 0x20a7 ; urwtable [ 524 ] = 0x20a3 ; urwtable [ 575 ] = 0xb9 ; urwtable [ 576 ] = 0xb2 ; urwtable [ 577 ] = 0xb3 ; for ( i = 4 ; i <= 9 ; ++ i ) { urwtable [ 574 + i ] = 0x2070 + i ; } urwtable [ 584 ] = 0x2070 ; for ( i = 1 ; i <= 9 ; ++ i ) { urwtable [ 586 + i ] = 0x2080 + i ; } urwtable [ 596 ] = 0x2080 ; urwtable [ 601 ] = '.' ; urwtable [ 602 ] = ':' ; urwtable [ 606 ] = 0x2026 ; urwtable [ 607 ] = ',' ; urwtable [ 608 ] = ';' ; urwtable [ 609 ] = 0x2019 ; urwtable [ 610 ] = 0x2018 ; urwtable [ 611 ] = 0x201d ; urwtable [ 612 ] = 0x201c ; urwtable [ 613 ] = 0x201e ; urwtable [ 614 ] = '!' ; urwtable [ 615 ] = 0xa1 ; urwtable [ 616 ] = '?' ; urwtable [ 617 ] = 0xbf ; urwtable [ 618 ] = 0xbb ; urwtable [ 619 ] = 0xab ; urwtable [ 620 ] = 0x203a ; urwtable [ 621 ] = 0x203a ; urwtable [ 622 ] = '/' ; urwtable [ 623 ] = 0x2010 ; urwtable [ 624 ] = 0x2013 ; urwtable [ 625 ] = 0x2014 ; urwtable [ 626 ] = '(' ; urwtable [ 627 ] = ')' ; urwtable [ 628 ] = '[' ; urwtable [ 629 ] = ']' ; urwtable [ 630 ] = '&' ; urwtable [ 631 ] = 0xa7 ; urwtable [ 632 ] = 0x2020 ; urwtable [ 633 ] = 0x2021 ; urwtable [ 634 ] = '*' ; urwtable [ 635 ] = '\\'' ; urwtable [ 636 ] = '\"' ; urwtable [ 637 ] = '@' ; urwtable [ 638 ] = '#' ; urwtable [ 639 ] = 0xb0 ; urwtable [ 640 ] = '+' ; urwtable [ 641 ] = '-' ; urwtable [ 642 ] = 0xd7 ; urwtable [ 643 ] = 0xf7 ; urwtable [ 644 ] = '=' ; urwtable [ 647 ] = ':' ; urwtable [ 648 ] = 0xa9 ; urwtable [ 649 ] = 0xae ; urwtable [ 650 ] = 0x2122 ; urwtable [ 651 ] = 0xb6 ; urwtable [ 652 ] = 0xa4 ; urwtable [ 655 ] = '{' ; urwtable [ 656 ] = '}' ; urwtable [ 657 ] = 0xaa ; urwtable [ 658 ] = 0xba ; urwtable [ 659 ] = 0xb1 ; urwtable [ 662 ] = 0xbd ; urwtable [ 663 ] = 0x2153 ; urwtable [ 664 ] = 0x2154 ; urwtable [ 665 ] = 0xbc ; urwtable [ 666 ] = 0xbe ; urwtable [ 667 ] = 0x2155 ; for ( i = 0 ; i <= 0x215e - 0x2155 ; ++ i ) { urwtable [ 668 + i ] = 0x215e + i ; } urwtable [ 677 ] = 0x2044 ; urwtable [ 678 ] = '%' ; urwtable [ 679 ] = 0x2030 ; urwtable [ 700 ] = '\\\\' ; urwtable [ 701 ] = 0xa8 ; urwtable [ 702 ] = 0x2d9 ; urwtable [ 703 ] = 0x2da ; urwtable [ 704 ] = 0x2ca ; urwtable [ 705 ] = 0x2cb ; urwtable [ 706 ] = 0x2c6 ; urwtable [ 707 ] = 0x2c7 ; urwtable [ 708 ] = 0x2d8 ; urwtable [ 709 ] = 0x2dc ; urwtable [ 710 ] = 0x2dd ; urwtable [ 711 ] = 0xb8 ; urwtable [ 712 ] = 0x2db ; urwtable [ 713 ] = 0xaf ; urwtable [ 714 ] = 0xaf ; urwtable [ 765 ] = 0x323 ; urwtable [ 766 ] = 0x320 ; urwtable [ 768 ] = 0x326 ; urwtable [ 769 ] = 0x313 ; urwtable [ 854 ] = 0x1ebd3 ; urwtable [ 857 ] = 0x1f5 ; urwtable [ 863 ] = 0x12f ; urwtable [ 866 ] = 0x140 ; urwtable [ 870 ] = 0x1e45 ; urwtable [ 873 ] = 0x1d2 ; urwtable [ 886 ] = 0x16b ; urwtable [ 892 ] = 0x1e8f ; urwtable [ 897 ] = 0x1d4 ; urwtable [ 903 ] = 0x13f ; urwtable [ 905 ] = 0x1e44 ; urwtable [ 908 ] = 0x14e ; urwtable [ 916 ] = 0x16c ; urwtable [ 933 ] = 0x145 ; urwtable [ 934 ] = 0x166 ; urwtable [ 935 ] = 0x146 ; urwtable [ 936 ] = 0x147 ; urwtable [ 937 ] = 0x138 ; urwtable [ 939 ] = 0x168 ; urwtable [ 1003 ] = 0x2665 ; urwtable [ 1004 ] = 0x2666 ; urwtable [ 1005 ] = 0x2663 ; urwtable [ 1006 ] = 0x2660 ; urwtable [ 1011 ] = 0x2642 ; urwtable [ 1012 ] = 0x2640 ; urwtable [ 1016 ] = 0x2022 ; urwtable [ 1036 ] = 0x2192 ; urwtable [ 1037 ] = 0x2190 ; urwtable [ 1038 ] = 0x2194 ; urwtable [ 1039 ] = 0x2191 ; urwtable [ 1040 ] = 0x2193 ; urwtable [ 1041 ] = 0x2195 ; urwtable [ 1049 ] = 0x25ca ; urwtable [ 1085 ] = 0x2206 ; urwtable [ 1101 ] = 0x2260 ; urwtable [ 1103 ] = 0x2261 ; urwtable [ 1104 ] = 0x221a ; urwtable [ 1105 ] = 0x222b ; urwtable [ 1108 ] = 0x223c ; urwtable [ 1109 ] = 0x2248 ; urwtable [ 1111 ] = '<' ; urwtable [ 1112 ] = '>' ; urwtable [ 1113 ] = 0x2264 ; urwtable [ 1114 ] = 0x2265 ; urwtable [ 1117 ] = 0xac ; urwtable [ 1124 ] = 0x221e ; urwtable [ 1133 ] = 0x220f ; urwtable [ 1134 ] = 0x2211 ; urwtable [ 1137 ] = 0x2202 ; urwtable [ 1151 ] = '^' ; urwtable [ 1152 ] = '_' ; urwtable [ 1199 ] = 0x3c0 ; urwtable [ 1337 ] = '~' ; urwtable [ 1342 ] = 0xb5 ; urwtable [ 1376 ] = '|' ; urwtable [ 1412 ] = 0x2126 ; urw_inited = true ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int bio_copy_from_iter ( struct bio * bio , struct iov_iter * iter ) { struct bio_vec * bvec ; struct bvec_iter_all iter_all ; bio_for_each_segment_all ( , , ) { int ret ; ret = copy_page_from_iter ( bvec -> bv_page , bvec -> bv_offset , bvec -> bv_len , iter ) ; if ( ! iov_iter_count ( iter ) ) { break ; } if ( ret < bvec -> bv_len ) { return - EFAULT ; } } return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void print_ascii85 ( struct drm_printer * p , size_t len , u32 * data ) { char out [ ASCII85_BUFSZ ] ; long i , l , datalen = 0 ; for ( i = 0 ; i ( len ) > 2 ; i ++ ) { if ( data [ i ] ) { datalen = ( i + 1 ) << 2 ; } } drm_puts ( p , \"    data: !!ascii85 |\\n\" ) ; drm_puts ( p , \"      \" ) ; l = ascii85_encode_len ( datalen ) ; for ( i = 0 ; i < l ; i ++ ) { drm_puts ( p , ascii85_encode ( data [ i ] , out ) ) ; } drm_puts ( p , \"\\n\" ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "E = 1.41428571428571436819e+00 , F = 1.60714285714285720630e+00 , G = 3.57142857142857150787e-01 ; double cbrtl ( double x ) { long hx ; double r , s , w ; int lt ; unsigned sign ; unsigned unsigned32 __attribute__ mode SI { double t ; unsigned32 pt [ 2 ] ; } , ut , ux int n0 ; ut . t = 1.0 ; n0 = ( ut . pt [ 0 ] == 0 ) ; ut . t = 0.0 ; ux . t = x ; hx = ux . pt [ n0 ] ; sign = hx & 0x80000000 ; hx ^= sign ; if ( hx >= 0x7ff00000 ) { return ( x + x ) ; } if ( ( hx | ux . pt [ 1 - n0 ] ) == 0 ) { return ( ux . t ) ; } ux . pt [ n0 ] = hx ; if ( hx < 0x00100000 ) { ut . pt [ n0 ] = 0x43500000 ; ut . t *= x ; ut . pt [ n0 ] = ut . pt [ n0 ] / 3 + B2 ; } else { ut . pt [ n0 ] = hx / 3 + B1 ; } r = ut . t * ut . t / ux . t ; s = C + r * ut . t ; ut . t *= G + F / ( s + E + D / s ) ; ut . pt [ 1 - n0 ] = 0 ; ut . pt [ n0 ] += 0x00000001 ; s = ut . t * ut . t ; r = ux . t / s ; w = ut . t + ut . t ; r = ( r - ut . t ) / ( w + r ) ; ut . t = ut . t + ut . t * r ; ut . pt [ n0 ] |= sign ; lt = ut . t ; lt -= ( lt - ( x / ( lt * lt ) ) ) * 0.333333333333333333333 ; return lt ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void teardown_donated_memory ( struct kvm_hyp_memcache * mc , void * addr , size_t size ) { size = PAGE_ALIGN ( size ) ; for ( void * start = addr ; start < addr + size ; start += PAGE_SIZE ) { push_hyp_memcache ( mc , start , hyp_virt_to_phys ) ; } unmap_donated_memory_noclear ( addr , size ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int vrc4171_card_setup ( char * options ) { if ( options == NULL || * options == '\\0' ) { return 1 ; } if ( strncmp ( options , \"irq:\" , 4 ) == 0 ) { int irq ; options += 4 ; irq = simple_strtoul ( options , & options , 0 ) ; if ( irq >= 0 && irq < nr_irqs ) { vrc4171_irq = irq ; } if ( * options != ',' ) { return 1 ; } options ++ ; } if ( strncmp ( options , \"slota:\" , 6 ) == 0 ) { options += 6 ; if ( * options != '\\0' ) { if ( strncmp ( options , \"memnoprobe\" , 10 ) == 0 ) { vrc4171_sockets [ CARD_SLOTA ] . slot = SLOT_NOPROBE_MEM ; options += 10 ; } if ( strncmp ( options , \"ionoprobe\" , 9 ) == 0 ) { vrc4171_sockets [ CARD_SLOTA ] . slot = SLOT_NOPROBE_IO ; options += 9 ; } if ( strncmp ( options , \"noprobe\" , 7 ) == 0 ) { vrc4171_sockets [ CARD_SLOTA ] . slot = SLOT_NOPROBE_ALL ; options += 7 ; } if ( * options != ',' ) { return 1 ; } options ++ ; } else { return 1 ; } } if ( strncmp ( options , \"slotb:\" , 6 ) == 0 ) { options += 6 ; if ( * options != '\\0' ) { if ( strncmp ( options , \"pccard\" , 6 ) == 0 ) { vrc4171_slotb = SLOTB_IS_PCCARD ; options += 6 ; } if ( strncmp ( options , \"cf\" , 2 ) == 0 ) { vrc4171_slotb = SLOTB_IS_CF ; options += 2 ; } if ( strncmp ( options , \"flashrom\" , 8 ) == 0 ) { vrc4171_slotb = SLOTB_IS_FLASHROM ; options += 8 ; } if ( strncmp ( options , \"none\" , 4 ) == 0 ) { options += 4 ; } if ( * options != ',' ) { return 1 ; } options ++ ; if ( strncmp ( options , \"memnoprobe\" , 10 ) == 0 ) { vrc4171_sockets [ CARD_SLOTB ] . slot = SLOT_NOPROBE_MEM ; } if ( strncmp ( options , \"ionoprobe\" , 9 ) == 0 ) { vrc4171_sockets [ CARD_SLOTB ] . slot = SLOT_NOPROBE_IO ; } if ( strncmp ( options , \"noprobe\" , 7 ) == 0 ) { vrc4171_sockets [ CARD_SLOTB ] . slot = SLOT_NOPROBE_ALL ; } } } return 1 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int snd_pcm_oss_period_size ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * oss_params , struct snd_pcm_hw_params * slave_params ) { size_t s ; size_t oss_buffer_size , oss_period_size , oss_periods ; size_t min_period_size , max_period_size ; struct snd_pcm_runtime * runtime = substream -> runtime ; size_t oss_frame_size ; oss_frame_size = snd_pcm_format_physical_width ( params_format ( oss_params ) ) * params_channels ( oss_params ) / 8 ; oss_buffer_size = snd_pcm_plug_client_size ( substream , snd_pcm_hw_param_value_max ( slave_params , SNDRV_PCM_HW_PARAM_BUFFER_SIZE , NULL ) ) * oss_frame_size ; oss_buffer_size = rounddown_pow_of_two ( oss_buffer_size ) ; if ( atomic_read ( & substream -> mmap_count ) ) { if ( oss_buffer_size > runtime -> oss . mmap_bytes ) { oss_buffer_size = runtime -> oss . mmap_bytes ; } } if ( substream -> oss . setup . period_size > 16 ) { oss_period_size = substream -> oss . setup . period_size ; } if ( runtime -> oss . fragshift ) { oss_period_size = 1 << runtime -> oss . fragshift ; if ( oss_period_size > oss_buffer_size / 2 ) { oss_period_size = oss_buffer_size / 2 ; } } else { int sd ; size_t bytes_per_sec = params_rate ( oss_params ) * snd_pcm_format_physical_width ( params_format ( oss_params ) ) * params_channels ( oss_params ) / 8 ; oss_period_size = oss_buffer_size ; { oss_period_size /= 2 ; } oss_period_size > bytes_per_sec ; if ( runtime -> oss . subdivision == 0 ) { sd = 4 ; if ( oss_period_size / sd > 4096 ) { sd *= 2 ; } if ( oss_period_size / sd < 4096 ) { sd = 1 ; } } else { sd = runtime -> oss . subdivision ; } oss_period_size /= sd ; if ( oss_period_size < 16 ) { oss_period_size = 16 ; } } min_period_size = snd_pcm_plug_client_size ( substream , snd_pcm_hw_param_value_min ( slave_params , SNDRV_PCM_HW_PARAM_PERIOD_SIZE , NULL ) ) ; min_period_size *= oss_frame_size ; min_period_size = roundup_pow_of_two ( min_period_size ) ; if ( oss_period_size < min_period_size ) { oss_period_size = min_period_size ; } max_period_size = snd_pcm_plug_client_size ( substream , snd_pcm_hw_param_value_max ( slave_params , SNDRV_PCM_HW_PARAM_PERIOD_SIZE , NULL ) ) ; max_period_size *= oss_frame_size ; max_period_size = rounddown_pow_of_two ( max_period_size ) ; if ( oss_period_size > max_period_size ) { oss_period_size = max_period_size ; } oss_periods = oss_buffer_size / oss_period_size ; if ( substream -> oss . setup . periods > 1 ) { oss_periods = substream -> oss . setup . periods ; } s = snd_pcm_hw_param_value_max ( slave_params , SNDRV_PCM_HW_PARAM_PERIODS ) ; if ( runtime -> oss . maxfrags && s > runtime -> oss . maxfrags ) { s = runtime -> oss . maxfrags ; } if ( oss_periods > s ) { oss_periods = s ; } s = snd_pcm_hw_param_value_min ( slave_params , SNDRV_PCM_HW_PARAM_PERIODS , NULL ) ; if ( s < 2 ) { s = 2 ; } if ( oss_periods < s ) { oss_periods = s ; } while ( oss_period_size * oss_periods > oss_buffer_size ) { oss_period_size /= 2 ; } if ( oss_period_size < 16 ) { return - EINVAL ; } runtime -> oss . period_bytes = oss_period_size ; runtime -> oss . period_frames = 1 ; runtime -> oss . periods = oss_periods ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static void ebpf_update_pid_link_list ( ebpf_cgroup_target_t * ect , char * path ) { procfile * ff = procfile_open_no_log ( path , \" \\t:\" , PROCFILE_FLAG_DEFAULT ) ; ff = procfile_readall ( ff ) ; if ( ! ff ) { return ; } size_t lines = procfile_lines ( ff ) , l ; for ( l = 0 ; l < lines ; l ++ ) { int pid = ( int ) str2l ( procfile_lineword ( ff , l , 0 ) ) ; if ( pid ) { struct pid_on_target2 * pt , * prev ; for ( pt = ect -> pids , prev = ect -> pids ; pt ; prev = pt , pt = pt -> next ) { if ( pt -> pid == pid ) { break ; } } if ( ! pt ) { struct pid_on_target2 * w = callocz ( 1 , sizeof ( pid_on_target2 ) ) ; w -> pid = pid ; if ( ! ect -> pids ) { ect -> pids = w ; } else { prev -> next = w ; } } } } procfile_close ( ff ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int korina_remove ( struct platform_device * pdev ) { struct korina_device * bif = platform_get_drvdata ( pdev ) ; struct korina_private * lp = netdev_priv ( bif -> dev ) ; iounmap ( lp -> eth_regs ) ; iounmap ( lp -> rx_dma_regs ) ; iounmap ( lp -> tx_dma_regs ) ; unregister_netdev ( bif -> dev ) ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int ScanKeywordLookup ( const char * str , const ScanKeywordList * keywords ) { size_t len ; int h ; const char * kw ; len = strlen ( str ) ; h = keywords -> hash ( str , len ) ; if ( h < 0 || h >= keywords -> num_keywords ) { return - 1 ; } kw = GetScanKeyword ( h , keywords ) ; while ( * str != '\\0' ) { char ch = * str ++ ; if ( ch >= 'A' && ch <= 'Z' ) { ch += 'a' - 'A' ; } if ( ch != * kw ++ ) { return - 1 ; } } if ( * kw != '\\0' ) { return - 1 ; } return h ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int tegra_i2c_empty_rx_fifo ( struct tegra_i2c_dev * i2c_dev ) { size_t buf_remaining = i2c_dev -> msg_buf_remaining ; unsigned int words_to_transfer , rx_fifo_avail ; u8 * buf = i2c_dev -> msg_buf ; u32 val ; if ( WARN_ON_ONCE ( ! ( i2c_dev -> msg_buf_remaining ) ) ) { return - EINVAL ; } if ( i2c_dev -> hw -> has_mst_fifo ) { val = i2c_readl ( i2c_dev , I2C_MST_FIFO_STATUS ) ; rx_fifo_avail = FIELD_GET ( I2C_MST_FIFO_STATUS_RX , val ) ; } else { val = i2c_readl ( i2c_dev , I2C_FIFO_STATUS ) ; rx_fifo_avail = FIELD_GET ( I2C_FIFO_STATUS_RX , val ) ; } words_to_transfer = buf_remaining / BYTES_PER_FIFO_WORD ; if ( words_to_transfer > rx_fifo_avail ) { words_to_transfer = rx_fifo_avail ; } i2c_readsl ( i2c_dev , buf , I2C_RX_FIFO , words_to_transfer ) ; buf += words_to_transfer * BYTES_PER_FIFO_WORD ; buf_remaining -= words_to_transfer * BYTES_PER_FIFO_WORD ; rx_fifo_avail -= words_to_transfer ; if ( rx_fifo_avail > 0 && buf_remaining > 0 ) { val = i2c_readl ( i2c_dev , I2C_RX_FIFO ) ; val = cpu_to_le32 ( val ) ; memcpy ( buf , & val , buf_remaining ) ; buf_remaining = 0 ; rx_fifo_avail -- ; } i2c_dev -> msg_buf_remaining = buf_remaining ; i2c_dev -> msg_buf = buf ; return 0 ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static ssize_t k5_utf8s_to_ucs2s ( krb5_ucs2 * ucs2str , const char * utf8str , size_t count , int little_endian ) { size_t ucs2len = 0 ; size_t utflen , i ; krb5_ucs2 ch ; if ( utf8str == NULL || * utf8str == '\\0' ) { return 0 ; } while ( * utf8str && ucs2len < count ) { utflen = KRB5_UTF8_CHARLEN2 ( utf8str , utflen ) ; if ( utflen == 0 || utflen > KRB5_MAX_UTF8_LEN ) { return - 1 ; } ch = ( krb5_ucs2 ) ( utf8str [ 0 ] & mask [ utflen ] ) ; for ( i = 1 ; i < utflen ; i ++ ) { if ( ( utf8str [ i ] & 0xc0 ) != 0x80 ) { return - 1 ; } ch <<= 6 ; ch |= ( krb5_ucs2 ) ( utf8str [ i ] & 0x3f ) ; } if ( ucs2str != NULL ) { if ( little_endian ) { ucs2str [ ucs2len ] = SWAP16 ( ch ) ; } else { ucs2str [ ucs2len ] = ch ; } } utf8str += utflen ; ucs2len ++ ; } assert ( ucs2len < count ) ; if ( ucs2str != NULL ) { ucs2str [ ucs2len ] = 0 ; } return ucs2len ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void bfa_hwct_msix_ctrl_install ( struct bfa_s * bfa ) { if ( bfa -> msix . nvecs == 1 ) { bfa -> msix . handler [ BFI_MSIX_LPU_ERR_CT ] = bfa_msix_all ; } else { bfa -> msix . handler [ BFI_MSIX_LPU_ERR_CT ] = bfa_msix_lpu_err ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "ModuleHeader MOD_HEADER = { \"samode\" \"5.0\" \"command /samode\" \"UnrealIRCd Team\" \"unrealircd-6\" } ; MOD_INIT ( ) { CommandAdd ( modinfo -> handle , MSG_SAMODE , cmd_samode , MAXPARA , CMD_USER ) ; MARK_AS_OFFICIAL_MODULE ( modinfo , NULL ) ; return MOD_SUCCESS ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "void test_IsDouble ( void ) { int temp ; temp = is_double ( \"0\" ) ; TEST_ASSERT_TRUE ( temp , NULL ) ; temp = is_double ( \"123\" ) ; TEST_ASSERT_TRUE ( temp ) ; temp = is_double ( \"123.45\" ) ; TEST_ASSERT_TRUE ( temp ) ; temp = is_double ( \"-123.45\" ) ; TEST_ASSERT_TRUE ( temp ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "int dump_vga_bios ( void ) { void * bios ; int fd ; fd = open ( _PATH_MEM , O_RDONLY ) ; if ( fd == - 1 ) { err ( 1 , \"%s\" , _PATH_MEM ) ; } bios = malloc ( VGA_BIOS_LEN ) ; if ( bios == NULL ) { return ( ENOMEM ) ; } if ( pread ( fd , bios , VGA_BIOS_LEN , VGA_BIOS_ADDR ) == - 1 ) { err ( 1 , \"%s\" , _PATH_MEM ) ; } if ( write ( romfd , bios , VGA_BIOS_LEN ) == - 1 ) { return ( errno ) ; } free ( bios ) ; return ( 0 ) ; return ( ENODEV ) ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static unsigned long hym8563_clkout_recalc_rate ( struct clk_hw * hw , unsigned long parent_rate ) { struct hym8563 * hym8563 = clkout_hw_to_hym8563 ( hw ) ; struct i2c_client * client = hym8563 -> client ; int ret = i2c_smbus_read_byte_data ( client , HYM8563_CLKOUT ) ; ret &= HYM8563_CLKOUT_MASK ; return clkout_rates [ ret ] ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int decrypt_rsa ( PGP_PubKey * pk , PullFilter * pkt , PGP_MPI * * m_p ) { int res ; PGP_MPI * c ; if ( pk -> algo != PGP_PUB_RSA_ENCRYPT && pk -> algo != PGP_PUB_RSA_ENCRYPT_SIGN ) { return PXE_PGP_WRONG_KEY ; } res = pgp_mpi_read ( pkt , & c ) ; if ( res < 0 ) { return res ; } res = pgp_rsa_decrypt ( pk , c , m_p ) ; return res ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "struct keynote_session * keynote_sessions [ SESSIONTABLESIZE ] ; struct keynote_session * keynote_current_session = NULL ; int keynote_exceptionflag = 0 ; int keynote_used_variable = 0 ; int keynote_returnvalue = 0 ; int keynote_justrecord = 0 ; int keynote_donteval = 0 ; int keynote_errno = 0 ; static char * keynote_get_action_authorizers ( char * name ) { struct keylist * kl ; size_t cachesize ; int len ; if ( ! strcmp ( name , KEYNOTE_CALLBACK_CLEANUP ) || ! strcmp ( name , KEYNOTE_CALLBACK_INITIALIZE ) ) { free ( keynote_current_session -> ks_authorizers_cache ) ; keynote_current_session -> ks_authorizers_cache = NULL ; return \"\" ; } if ( keynote_current_session -> ks_authorizers_cache != NULL ) { return keynote_current_session -> ks_authorizers_cache ; } for ( cachesize = 0 , kl = keynote_current_session -> ks_action_authorizers ; kl != NULL ; kl = kl -> key_next ) { if ( kl -> key_stringkey != NULL ) { cachesize += strlen ( kl -> key_stringkey ) + 1 ; } } keynote_current_session -> ks_authorizers_cache = calloc ( cachesize , sizeof ( char ) ) ; if ( keynote_current_session -> ks_authorizers_cache == NULL ) { keynote_errno = ERROR_MEMORY ; return NULL ; } for ( len = 0 , kl = keynote_current_session -> ks_action_authorizers ; kl != NULL ; kl = kl -> key_next ) { if ( kl -> key_stringkey != NULL ) { snprintf ( keynote_current_session -> ks_authorizers_cache + len , cachesize - len , \"%s,\" , kl -> key_stringkey ) ; len += strlen ( kl -> key_stringkey ) + 1 ; } } keynote_current_session -> ks_authorizers_cache [ len - 1 ] = '\\0' ; return keynote_current_session -> ks_authorizers_cache ; } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}, {"func": "static int _dep_visit ( Lm_list * lml , int min , Rt_map * clmp , Rt_map * dlmp , uint_t bflags , Sort * sort , int flag ) { int _min ; if ( ( _min = SORTVAL ( dlmp ) ) == - 1 ) { if ( flag & RT_SORT_REV ) { if ( ( FLAGS ( dlmp ) & ( FLG_RT_RELOCED | FLG_RT_INITCLCT ) ) != FLG_RT_RELOCED ) { return ( min ) ; } if ( ( INIT ( dlmp ) == 0 ) && ( INITARRAY ( dlmp ) == 0 ) ) { return ( min ) ; } } else { if ( ( FLAGS ( dlmp ) & ( FLG_RT_INITCLCT | FLG_RT_FINICLCT ) ) != FLG_RT_INITCLCT ) { return ( min ) ; } if ( ( flag & RT_SORT_DELETE ) && ( ( FLAGS ( dlmp ) & FLG_RT_DELETE ) == 0 ) ) { return ( min ) ; } if ( ( FINI ( dlmp ) == 0 ) && ( FINIARRAY ( dlmp ) == 0 ) ) { return ( min ) ; } } if ( ( _min = dep_visit ( lml , clmp , bflags , dlmp , sort , flag ) ) == - 1 ) { return ( - 1 ) ; } } if ( _min < min ) { DBG_CALL ( Dbg_util_edge_out ( clmp , sort -> s_stack [ _min ] ) ) ; return ( _min ) ; } else { return ( min ) ; } } ", "target": 1, "cwe": "known", "project": "vgx", "commit_id": "unknwon", "size": 0, "message": "unknwon", "len_cwe": 0}]